<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/icons/touch-icon-apple.png"><link rel="icon" type="image/png" href="/icons/favicon-32x32.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="mohuishou 的 技术博客, 关注云原生, Go, K8s, Docker, 微服务等技术"><meta name="author" content="Mohuishou"><meta name="keywords" content="Go,Docker,PHP,学习笔记,Go,Go进阶训练营,工程化,Go进阶训练营,Week04: Go 工程化"><title>Go工程化(九) 项目重构实践 - Mohuishou</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main-8c4c5e426918ae095492d8a940e57fef.css"><link rel="stylesheet" href="/assets/css/custom-1f91c11731bc75a5b19468adaa3ab949.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"lailin.xyz",root:"/",version:"1.8.7",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:3},lazyload:{enable:!0,onlypost:!1},web_analytics:{enable:!0,baidu:null,google:"UA-137859264-1",gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}}}</script><script src="/js/utils-5ecdced2f65030c3508cf0b3db78f4ad.js"></script><script src="/js/color-schema-4678c2299d6eeb96e23435ea339c9331.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>mohuishou</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/"><i class="iconfont icon-category-fill"></i> Go 进阶训练营(更新中)</a></li><li class="nav-item"><a class="nav-link" href="/post/go-design-pattern.html"><i class="iconfont icon-notebook"></i> Go 设计模式</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> 更多</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/links/"><i class="iconfont icon-link-fill"></i> 友链 </a><a class="dropdown-item" href="/atom.xml"><i class="iconfont icon-rss"></i> rss </a><a class="dropdown-item" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></div></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Go工程化(九) 项目重构实践">Go工程化(九) 项目重构实践</span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-03-11 13:08" pubdate>2021年3月11日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 6.2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 75 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"><div class="sidebar"><p class="sidebar-header">Go进阶训练营</p><div class="sidebar-body" id="sidebar-body"><ol class="sidebar-list sidebar-list-1"><li class="sidebar-list-item"><a class="sidebar-title" onclick='document.querySelector("#sidebar-ckkm23xho0000m4t51q602czj").classList.toggle("sidebar-is-collapsed")'>Week01: 微服务</a><ol id="sidebar-ckkm23xho0000m4t51q602czj" class="sidebar-list sidebar-list-2 sidebar-is-collapsible"><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-01.html">微服务(一) 微服务概览</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-02.html">微服务(二) 服务发现&amp;多租户</a></li></ol></li><li class="sidebar-list-item"><a class="sidebar-title" onclick='document.querySelector("#sidebar-ckkm23ykh0003m4t53mln1w0n").classList.toggle("sidebar-is-collapsed")'>Week02: Go错误处理</a><ol id="sidebar-ckkm23ykh0003m4t53mln1w0n" class="sidebar-list sidebar-list-2 sidebar-is-collapsible"><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-03.html">Go错误处理最佳实践</a></li></ol></li><li class="sidebar-list-item"><a class="sidebar-title" onclick='document.querySelector("#sidebar-ckkm2667n000pm4t52z016wn0").classList.toggle("sidebar-is-collapsed")'>Week03: Go 并发编程</a><ol id="sidebar-ckkm2667n000pm4t52z016wn0" class="sidebar-list sidebar-list-2 sidebar-is-collapsible"><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-goroutine.html">Go并发编程(一) goroutine</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-go-memory-model.html">Go并发编程(二) Go 内存模型</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-data-race.html">Go并发编程(三) data race</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-sync.html">Go并发编程(四) 深入理解 Mutex</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-atomic.html">Go并发编程(五) 深入理解 sync/atomic</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-waitgroup.html">Go并发编程(六) 深入理解 WaitGroup</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-errgroup.html">Go并发编程(七) 深入理解 errgroup</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-once.html">Go并发编程(八) 深入理解 sync.Once</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-context.html">Go并发编程(九) 深入理解 Context</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-channel.html">Go并发编程(十) 深入理解 Channel</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-sum.html">Go并发编程(十一) 总结</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week5-singleflight.html">Go并发编程(十二) Singleflight</a></li></ol></li><li class="sidebar-list-item"><a class="sidebar-title" onclick='document.querySelector("#sidebar-ckkm23zra000im4t5en8m0qy9").classList.toggle("sidebar-is-collapsed")'>Week04: Go 工程化</a><ol id="sidebar-ckkm23zra000im4t5en8m0qy9" class="sidebar-list sidebar-list-2 sidebar-is-collapsible"><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-clean-arch.html">Go工程化(一) 架构整洁之道阅读笔记</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-project-layout.html">Go工程化(二) 项目目录结构</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-wire.html">Go工程化(三) 依赖注入框架 wire</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-api-design.html">Go工程化(四) API 设计上: 项目结构 &amp; 设计</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-protoc-gen-go-gin.html">Go工程化(五) API 设计下: 基于 protobuf 自动生成 gin 代码</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-config.html">Go工程化(六) 配置管理</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-go-module.html">Go工程化(七) Go Module</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-unit-test.html">Go工程化(八) 单元测试</a></li><li class="sidebar-list-item is-active-li"><a class="sidebar-link sidebar-active-link" href="/post/go-training-week4-practice.html">Go工程化(九) 项目重构实践</a></li></ol></li><li class="sidebar-list-item"><a class="sidebar-title" onclick='document.querySelector("#sidebar-ckmxouk290005tpox6b63ft9x").classList.toggle("sidebar-is-collapsed")'>Week05: 评论系统架构设计</a><ol id="sidebar-ckmxouk290005tpox6b63ft9x" class="sidebar-list sidebar-list-2 sidebar-is-collapsible"><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week5-comment-design-1.html">评论系统架构设计</a></li></ol></li><li class="sidebar-list-item"><a class="sidebar-title" onclick='document.querySelector("#sidebar-ckmxouk2f000ctpox8quy1adz").classList.toggle("sidebar-is-collapsed")'>Week06: 微服务可用性设计</a><ol id="sidebar-ckmxouk2f000ctpox8quy1adz" class="sidebar-list sidebar-list-2 sidebar-is-collapsible"><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week6-usability-1-bulkhe.html">Go可用性(一) 隔离设计</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week6-2-token-bucket-1.html">Go可用性(二) 限流1: 令牌桶原理及使用</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week6-3-token-bucket-2.html">Go可用性(三) 限流2: 令牌桶的实现 rate/limt</a></li></ol></li></ol></div></div></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Go工程化(九) 项目重构实践</h1><div class="markdown-body"><div class="row" style="background:#e8f7ff;padding:10px;border:1px solid #abd2da;border-radius:5px;margin:5px 0"><div class="col-lg-10 col-12">本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a target="_blank" href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go 进阶训练营</a> 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。<br><br>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠，关注公众号 <code>mohuishou</code> 获取专属优惠，比官方优惠更给力哦 <a target="_blank" rel="noopener" href="http://gk.link/a/10plx">前往查看介绍: Go进阶训练营</a><br><br>PS: 博客阅读结合视频观看效果更佳哦</div><div class="col-lg-2 wechat-qr"><img style="width:100%" src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/43_997_077f7799f8d76b357797aff32a04cf64_20b7fcec4c7465d66b253dc18ebde552.png" srcset="/img/loading.gif"></div></div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><strong>3 月进度: 06/15</strong> 3 月开始会尝试爆更模式，争取做到两天更新一篇文章，如果感兴趣可以拉到文章最下方获取关注方式。</p><p>这是《Go 工程化》系列的最后一篇文章了，其实在 Go 并发编程完结的时候我想的工程化这一章节不要写这么多，以听课笔记为主就可以了，但是最后还是展开讲了很多内容，与其说是为了做笔记或者是写文章，不如说是为了整理一下过去几年我的一些微不足道的经验，结合毛老师课上讲的内容与自己的情况重新对已有的知识进行了一遍梳理。</p><p>在前面的八篇文章当中我们讲到了，项目结构、依赖注入，API 设计、配置管理、包管理、单元测试，基本上还是将工程化当中的大部分东西都讲到了，不求尽善尽美，但求对你有所帮助，我们今天就来结合前面文章中提到的各种知识来看一下如何将一个老的项目迁移到新的项目结构当中来，这里面的坑也非常的多。</p><p>这篇文章是从之前重构的一个真实项目映射而来，里面讲到的坑基本上在迁移重构的过程中都趟了不止一次。</p><h2 id="迁移前"><a href="#迁移前" class="headerlink" title="迁移前"></a>迁移前</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── app<br>│   ├── controller<br>│   ├── lib<br>│   ├── middleware<br>│   ├── model<br>│   └── router<br>├── cmd<br>│   ├── cron<br>│   └── server<br>├── config<br>│   └── initializer<br>├── db<br>│   └── migrate<br>│   └── migrate.go<br>├── go.mod<br>├── mock<br>├── <span class="hljs-built_in">test</span><br>└── third_party<br></code></pre></td></tr></table></figure><p>这是我们最开始的目录结构，这个结构是仿照 rails 框架设计而来的，这个结构在很长一段时间都是挺好用的，我先大概解释一下每个目录的含义</p><ul><li>app: 应用逻辑相关的代码都在这里<ul><li>controller: 控制器层，主要负责路由</li><li>lib: 一些工具库函数</li><li>middleware: 路由中间件</li><li>router: 路由注册</li><li>model: 由于我们使用的是充血模型，所以这一层的内容比较多，包含了领域对象，业务逻辑，数据存储等都在这里</li></ul></li><li>cmd: 二进制文件目录<ul><li>cron: 定时任务</li><li>server: http server 服务</li></ul></li><li>db: migration 目录</li><li>mock: gomock 生成的文件</li><li>test: 测试工具库</li><li>third_party: 第三方文件</li></ul><p>调用关系如下图所示<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1615219210365-000fcd85-392a-41da-b7e4-8b4fc583123f.jpeg" srcset="/img/loading.gif" alt="Frame 1 (4).jpg"></p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>其实在报名参加 Go 进阶训练营 之前我就因为在提高这个项目的单元测试覆盖率的时候发现了很多问题，当时我用了各种操作，非常难受的将单元测试覆盖率写到 85% 左右的时候就写不上去了，因为我们的项目的历史包袱太严重了，很多代码写的基本就不可测试，想要提高测试覆盖率也就无从谈起了。</p><ul><li>cmd<ul><li>我们之前在这一层当中最大的问题就是我们手写了大量启动代码，全手动依赖注入，还有一些隐式的依赖，这就导致在项目后期的时候启动的代码已经非常长了，而且很容易遗漏依赖关系的处理，建议如果不是特别小的项目还是使用 wire 比较香。</li></ul></li><li>initializer<ul><li>我们之前所有的初始化都在这个包内完成，这个不是太大的问题，但是要命的是这里面有大量的全局变量，各种各样，过多的全局变量导致我们的单元测试非常难写。</li></ul></li><li>model<ul><li>这一层的事情特别多，业务逻辑，领域对象，持久化存储等都在这一层完成，这就导致了后面我们 model 层的代码特别多，变成了一团乱麻，真的是剪不断理还乱，慢慢的这一层的逻辑我自己都理不清了。</li><li>这一层的代码耦合也很严重，无论是什么定时任务还是消息队列还是 server 的代码都放到了这里，导致出现了很多坑，举个例子，可能我有一个函数是 <code>GetArticles</code> 这个函数最开始是为了 api 接口返回一些简要的列表数据，只需要查询一张表，返回速度非常快，但是我定时任务有一个地方也需要这个函数，然后我一看，真好这里已经有这个函数了我们就直接复用，但是数据内容不满足需求，我们就直接在这个函数当中加逻辑，然后需求满足了，过一段时间我们突然要求所有的接口必须要在 500ms 以内，结果发现坑来了，很多地方依赖这个函数，看 APM，就这一个函数的查询就需要耗费超过 500ms 🤣</li></ul></li><li>controller<ul><li>这一层主要做参数的处理还有部分业务逻辑，我们的 Controller 层和 model 层的界定比较模糊，有的主要业务逻辑放到了 model 有的有部分业务逻辑又放到了 Controller 了，到后面就是一点一点的找问题</li></ul></li><li>错误处理<ul><li>我们之前在项目内统一了错误码，但是存在两个问题</li><li>一个是要么处处 wrap，要么忘记 wrap 没有一个统一准则，这就导致要么错误堆栈长的没法看，要么就没有太多的错误信息没法排查</li><li>另一个是我们之前在 Controller 层跑业务错误代码，这就导致了很多时候想要返回一些细节的错误信息就无能为力，即使在 model 层抛了也会被 Controller 层吞掉</li></ul></li><li>接口文档<ul><li>这也是一个很大的痛点，之前想了很多方式都不能很好的解决，毛老师给出这个方案后，我没多久就用上了非常爽。</li><li>之前我们的文档分布五花八门，最开始使用 gin swagger 通过写注释的方式来生成相关接口文档，说实话可以用但是比较难用，因为这个注释其实和代码逻辑是两套东西，相当于写一遍代码再写一遍注释，慢慢的就没有人写了，或者还有写的是错误的。最麻烦的是在方案设计阶段我们不会直接写代码注释，所以测试同学在写测试方案的时候会比较麻烦，也不符合我们后续技术方案评审的要求所以后面也就废弃了</li><li>后面我们写到内部的文档平台上，还不如之前的 swagger，虽然解决了方案阶段没接口文档的问题，但是接口文档总是在变化当中的，特别是在开发的时候，这就让前后端对接联调，以及测试同学测试的非常难受，特别是经常会出现和前端同学沟通好了但是忘记和测试说的情况。</li></ul></li></ul><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p><em>迁移要三思，处处都是坑, 重构要小心，TDD 大法好</em></p><h3 id="迁移后目录结构"><a href="#迁移后目录结构" class="headerlink" title="迁移后目录结构"></a>迁移后目录结构</h3><p>为了能够更加直观，我们先来复习一下之前提到过的项目目录结构看一下迁移前后有哪些不同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── api<br>│   └── product<br>│       └── app<br>│           ├── errcode<br>│           └── v1<br>│               └── v1.proto<br>├── cmd<br>│   ├── cron<br>│   │   ├── main.go<br>│   │   └── wire.go<br>│   ├── migrate<br>│   └── server<br>├── config<br>├── go.mod<br>├── internal<br>│   ├── cron<br>│   │   ├── repo<br>│   │   ├── service<br>│   │   ├── usecase<br>│   │   └── wire_set.go<br>│   ├── domain<br>│   ├── pkg<br>│   │   ├── copier<br>│   │   ├── mock<br>│   │   └── <span class="hljs-built_in">test</span><br>│   └── server<br>│       ├── repo<br>│       ├── service<br>│       ├── usecase<br>│       └── wire_set.go<br>└── third_party<br></code></pre></td></tr></table></figure><p>具体每个文件夹的含义就不再赘述，如果不太清楚可以查看 <a href="https://lailin.xyz/post/go-training-week4-project-layout.html">Go 工程化(二) 项目目录结构</a><br>我们看一下新的目录结构的调用链路<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1615268889054-251a4e39-c8d9-410f-950c-5262b368ae34.jpeg" srcset="/img/loading.gif" alt="Frame 2 (1).jpg"><br>注意，在这里 service 和 usecase 实际调用的都是 domain 中的接口，只是 usecase 和 repo 实现这些接口而已，所以我们这里用虚线画出来</p><h3 id="迁移重构原则"><a href="#迁移重构原则" class="headerlink" title="迁移重构原则"></a>迁移重构原则</h3><p>接下来我会从各个模块来阐述我在重构这个项目的时候是怎么做的，每个模块都有每个模块自己的坑。开始之前呢我们先来看一下几个总的原则:</p><ul><li>结构简单的应用优先</li><li>有充分的单元测试的应用优先</li><li>先写测试，测试需要在新老代码同时通过</li></ul><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p>api 当中主要写的就是 proto 文件，这个 proto 文件替代了我们在之前的 <code>router</code> 以及部分 <code>controller</code> 中的逻辑，定义了 proto 文件之后，生成的代码当中主要要完成的就是，路由的注册，参数绑定，返回值结构填充。</p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>先补充一下背景，我们之前的项目采用的是 gin 作为路由框架，返回值采用下面这种统一的结构</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;成功&quot;</span>,<br>  <span class="hljs-attr">&quot;data&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 api 层的路由注册，参数绑定，返回值结构填充我们都使用工具进行统一处理，详细介绍可以看之前的文章: <a href="https://lailin.xyz/post/go-training-week4-protoc-gen-go-gin.html">Go 工程化(五) API 设计下: 基于 protobuf 自动生成 gin 代码</a></p><h4 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h4><p>先来看一个基本的例子</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// 这里指定了 proto 文件的版本</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-comment">// package 命名规则: product.application.version</span><br><span class="hljs-keyword">package</span> product.app.v1;<br><br><span class="hljs-comment">// go_package 生成 go 文件当中的包名</span><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;github.com/mohuishou/new-project/api/product/app/v1&quot;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/api/annotations.proto&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">BlogService</span> </span>&#123;<br><br>  <span class="hljs-comment">// 创建文章</span><br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> CreateArticle(CreateArticleReq) <span class="hljs-keyword">returns</span> (CreateArticleResp) </span>&#123;<br>  	<span class="hljs-comment">// option 还是都加上，可以利用插件自动生成 swagger 文档</span><br>    <span class="hljs-keyword">option</span> (google.api.http) = &#123;<br>      post: <span class="hljs-string">&quot;/article&quot;</span><br>      body: <span class="hljs-string">&quot;*&quot;</span><br>    &#125;;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 参数和返回值定义，这里就不详细列了</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">CreateArticleReq</span> </span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">CreateArticleResp</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>成功的例子千篇一律，路上的坑各不相同，我们来看一下几个典型的坑(问题)，以及该如何解决</p><h4 id="Q1-Get-请求参数如何进行绑定，默认无法修改-struct-tag"><a href="#Q1-Get-请求参数如何进行绑定，默认无法修改-struct-tag" class="headerlink" title="Q1: Get 请求参数如何进行绑定，默认无法修改 struct tag"></a>Q1: Get 请求参数如何进行绑定，默认无法修改 struct tag</h4><p>这个稳定同样适用于参数校验，原来 gin 参数校验可以在 struct 上加 tag 解决，这个有两种解决方案，一种是使用 <a target="_blank" rel="noopener" href="https://github.com/favadi/protoc-go-inject-tag">protoc-go-inject-tag</a> 加注释解决，另外一种是使用 <a target="_blank" rel="noopener" href="https://github.com/gogo/protobuf">gogo/protobuf</a> 支持添加 option 的方式来添加 tag，目前我采用的是第一种</p><p>只需要在定义 message 的时候添加注释 <code>// @inject_tag:</code> 后面是具体的 tag</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">GetArticleReq</span> </span>&#123;<br>  <span class="hljs-comment">// @inject_tag: form:&quot;id&quot; binding:&quot;required&quot;</span><br>  <span class="hljs-built_in">int32</span> id = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们在生成好对应的 go 文件之后执行一下 <code>protoc-go-inject-tag -input=filepath</code> 就可以了</p><h4 id="Q2-返回值是一个数组"><a href="#Q2-返回值是一个数组" class="headerlink" title="Q2: 返回值是一个数组"></a>Q2: 返回值是一个数组</h4><p>举个例子，我们之前可能有一个 <code>get: /article/tags</code> 的接口，由于一篇文章当中的标签不会很多，所以我们没有做分页，返回数据的时候直接在 data 里面塞了一个数组，然后我们迁移的时候就麻烦了 o(╥﹏╥)o</p><p>因为在 protobuf 的 rpc 方法定义当中，只能返回一个结构体，无法返回一个数组结构，但是我们做重构的时候又不想有 api 的破坏性变更，因为这项所有的依赖方都需要进行修改成本太大了，那我们如何兼容呢？</p><p>我的解决方案是先生成对应的 go 结构体，然后在同一个包内创建一个 <code>xx_type.pb.go</code> 里面实现 json 的解析接口，让我们虽然定义的是一个结构体，但是返回接口数据的时候返回的是一个数组</p><p>举个例子，下面是我定义的 pb</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">ListArticleTagsResp</span> </span>&#123;<br>  <span class="hljs-keyword">repeated</span> Tag tags = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Tag</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> key = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">string</span> value = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后生成了 <code>v1.pb.go</code> ，我创建了一个 <code>v1_type.pb.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// UnmarshalJSON sets *m to a copy of data.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *ListArticleTagsResp)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>	<span class="hljs-keyword">if</span> m == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;json.RawMessage: UnmarshalJSON on nil pointer&quot;</span>)<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> json.Unmarshal(data, &amp;m.Tags)<br>&#125;<br><br><span class="hljs-comment">// MarshalJSON returns m as the JSON encoding of m.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *ListArticleTagsResp)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<br>	<span class="hljs-keyword">if</span> m == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;null&quot;</span>), <span class="hljs-literal">nil</span><br>	&#125;<br><br>	<span class="hljs-keyword">return</span> json.Marshal(m.Tags)<br>&#125;<br></code></pre></td></tr></table></figure><p>当然后续最好还是修改一下，但是重构的时候还是建议不要做破坏性的变动</p><h4 id="Q3-返回值当中包含时间"><a href="#Q3-返回值当中包含时间" class="headerlink" title="Q3: 返回值当中包含时间"></a>Q3: 返回值当中包含时间</h4><p>除了数组之外，返回值当中包含时间也是挺麻烦的一件事情，首先 pb 的基础类型里面没有时间类型，然后 google 官方的库当中有一个 timestamp 包，可以使用，但是使用的时候就会发现，在 json 序列话的时候不是一个时间字段，而是一个对象值，和我们之前直接使用 <code>time.Time</code> 的行为不一致。</p><p>我的做法是仿照 google 的包自己搞一个然后实现 json 的相关方法，让 json 序列化的时候的行为和 <code>time.Time</code> 保持一致</p><p>首先定义 <code>timestamp.proto</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// 这里指定了 proto 文件的版本</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-comment">// package 命名规则: product.application.version</span><br><span class="hljs-keyword">package</span> product.app.v1;<br><br><span class="hljs-comment">// go_package 生成 go 文件当中的包名</span><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;github.com/mohuishou/new-project/api/product/app/v1&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Timestamp</span> </span>&#123;<br><br>    <span class="hljs-comment">// Represents seconds of UTC time since Unix epoch</span><br>    <span class="hljs-comment">// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to</span><br>    <span class="hljs-comment">// 9999-12-31T23:59:59Z inclusive.</span><br>    <span class="hljs-built_in">int64</span> seconds = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// Non-negative fractions of a second at nanosecond resolution. Negative</span><br>    <span class="hljs-comment">// second values with fractions must still have non-negative nanos values</span><br>    <span class="hljs-comment">// that count forward in time. Must be from 0 to 999,999,999</span><br>    <span class="hljs-comment">// inclusive.</span><br>    <span class="hljs-built_in">int32</span> nanos = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>和上面一样，创建一个 <code>timestamp_type.pb.go</code> ，除了实现 json 的接口以外还实现了两个转换方法，用于 service 层调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewTimestamp NewTimestamp</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTimestamp</span><span class="hljs-params">(t time.Time)</span> *<span class="hljs-title">Timestamp</span></span> &#123;<br>	<span class="hljs-keyword">return</span> &amp;Timestamp&#123;<br>		Seconds: t.Unix(),<br>		Nanos:   <span class="hljs-keyword">int32</span>(t.Nanosecond()),<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// Time 类型转换</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Timestamp)</span> <span class="hljs-title">Time</span><span class="hljs-params">()</span> <span class="hljs-title">time</span>.<span class="hljs-title">Time</span></span> &#123;<br>	<span class="hljs-comment">// Don&#x27;t return the zero value on error, because corresponds to a valid</span><br>	<span class="hljs-comment">// timestamp. Instead return whatever time.Unix gives us.</span><br>	<span class="hljs-keyword">if</span> m == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> time.Unix(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>).UTC() <span class="hljs-comment">// treat nil like the empty Timestamp</span><br>	&#125;<br><br>	<span class="hljs-keyword">return</span> time.Unix(m.Seconds, <span class="hljs-keyword">int64</span>(m.Nanos)).UTC()<br>&#125;<br><br><span class="hljs-comment">// UnmarshalJSON sets *m to a copy of data.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Timestamp)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>	<span class="hljs-keyword">if</span> m == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;json.RawMessage: UnmarshalJSON on nil pointer&quot;</span>)<br>	&#125;<br>	<span class="hljs-keyword">var</span> t time.Time<br>	<span class="hljs-keyword">if</span> err := json.Unmarshal(data, &amp;t); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> err<br>	&#125;<br><br>	*m = *NewTimestamp(t)<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// MarshalJSON returns m as the JSON encoding of m.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Timestamp)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<br>	<span class="hljs-keyword">if</span> m == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;null&quot;</span>), <span class="hljs-literal">nil</span><br>	&#125;<br><br>	<span class="hljs-keyword">return</span> json.Marshal(m.Time())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h3><p>domain 这一层主要是包含 do 对象的定义，以及 usecase 和 repo 层的接口定义，由于我们现在使用的 gorm 所以，也会在这里给 do 对象加上一些 tag 用于标志索引，关联关系等。</p><h4 id="domain-example"><a href="#domain-example" class="headerlink" title="domain example"></a>domain example</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// article.go</span><br><br><span class="hljs-comment">// Article 文章</span><br><span class="hljs-keyword">type</span> Article <span class="hljs-keyword">struct</span> &#123;<br>	Model <span class="hljs-comment">// 基础结构体，包含 id, created_at, deleted_at, updated_at</span><br><br>	Title   <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;title&quot;`</span><br>	Content <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;content&quot;`</span><br>	Tags    []Tag  <span class="hljs-string">`json:&quot;tags&quot; gorm:&quot;many2many:article_tags&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// IArticleUsecase IArticleUsecase</span><br><span class="hljs-keyword">type</span> IArticleUsecase <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-comment">// 获取文章详情</span><br>	GetArticle(ctx context.Context, id <span class="hljs-keyword">int</span>) (*Article, error)<br>	<span class="hljs-comment">// 创建一篇文章</span><br>    CreateArticle(ctx context.Context, article *Article) error<br>&#125;<br><br><span class="hljs-comment">// IArticleRepo IArticleRepo</span><br><span class="hljs-keyword">type</span> IArticleRepo <span class="hljs-keyword">interface</span> &#123;<br>	GetArticle(ctx context.Context, id <span class="hljs-keyword">int</span>) (*Article, error)<br>	CreateArticle(ctx context.Context, article *Article) error<br>&#125;<br><br><span class="hljs-comment">// tag.go</span><br><br><span class="hljs-comment">// Tag 标签数据</span><br><span class="hljs-keyword">type</span> Tag <span class="hljs-keyword">struct</span> &#123;<br>	Model<br><br>	Key   <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;key&quot;`</span><br>	Value <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;value&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这一层的坑稍微少一些，主要是接口定义的相关事情</p><h4 id="小技巧-批量-mock-接口"><a href="#小技巧-批量-mock-接口" class="headerlink" title="小技巧: 批量 mock 接口"></a>小技巧: 批量 mock 接口</h4><p>使用最新的项目结构我们会在 domain 中创建大量接口，之前在 <a href="https://lailin.xyz/post/go-training-week4-unit-test.html">Go 工程化(八) 单元测试</a> 中我们提到了，在每一层的单元测试的时候，我们都会把依赖的接口用 gomock 给 mock 掉，让测试尽量轻量级一些，为了简化 gomock 的创建，我们可以在 <code>makefile</code> 当中写一个 <code>shell</code> 脚本，找出含有 <code>interface</code> 定义的文件，然后我们用 gomock 生成对应的 mock 文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">mockgen:</span><br>	cd ./internal &amp;&amp; for file in `egrep -rnl <span class="hljs-string">&quot;type.*?interface&quot;</span> ./domain | grep -v <span class="hljs-string">&quot;_test&quot;</span> `; do \<br>		echo $$file ; \<br>		cd .. &amp;&amp; mockgen -destination=<span class="hljs-string">&quot;./internal/pkg/mock/$$file&quot;</span> -source=<span class="hljs-string">&quot;./internal/$$file&quot;</span> &amp;&amp; cd ./internal ; \<br>	done<br></code></pre></td></tr></table></figure><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>新的 service 层的主要左右就是 dto 数据和 do 数据的相互转换，它实现了 <code>v1</code> 包中的相关接口，service 的代码比较简单，我们直接看一个例子</p><h4 id="service-example"><a href="#service-example" class="headerlink" title="service example"></a>service example</h4><p>注意，我们在迁移 service、usecase、repo 的时候，都应该先写对应的单元测试，本文当中由于篇幅原因我就没有再列了，感兴趣可以查看上一篇文章 <a href="https://lailin.xyz/post/go-training-week4-unit-test.html">Go 工程化(八) 单元测试</a> 对应章节的内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 确保实现了对应的接口</span><br><span class="hljs-keyword">var</span> _ v1.BlogServiceHTTPServer = &amp;Artcile&#123;&#125;<br><br><span class="hljs-comment">// Artcile Artcile</span><br><span class="hljs-keyword">type</span> Artcile <span class="hljs-keyword">struct</span> &#123;<br>	usecase domain.IArticleUsecase<br>&#125;<br><br><span class="hljs-comment">// NewArticleService 初始化方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewArticleService</span><span class="hljs-params">(usecase domain.IArticleUsecase)</span> *<span class="hljs-title">Artcile</span></span> &#123;<br>	<span class="hljs-keyword">return</span> &amp;Artcile&#123;usecase: usecase&#125;<br>&#125;<br><br><span class="hljs-comment">// CreateArticle 创建一篇文章</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Artcile)</span> <span class="hljs-title">CreateArticle</span><span class="hljs-params">(ctx context.Context, req *v1.CreateArticleReq)</span> <span class="hljs-params">(*v1.CreateArticleResp, error)</span></span> &#123;<br>	article := &amp;domain.Article&#123;<br>		Title:   req.Title,<br>		Content: req.Content,<br>	&#125;<br>	err := a.usecase.CreateArticle(ctx, article)<br>	<span class="hljs-keyword">return</span> &amp;v1.CreateArticleResp&#123;&#125;, err<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小技巧-copier-减少重复的复制粘贴操作"><a href="#小技巧-copier-减少重复的复制粘贴操作" class="headerlink" title="小技巧: copier 减少重复的复制粘贴操作"></a>小技巧: copier 减少重复的复制粘贴操作</h4><p>在上面的例子我们可以看到，我们的数据转换是手动写的，这种方法不是不行，但是示例当中的字段比较少，如果字段多了起来，并且还有各种数组类型的存在的时候，数据转换的这部分代码写的就会比较难受了，如果你的应用和我的一样对性能的要求不是很高的话可以试试下面这种方式。</p><p>我最开始是用了 jinzhu 大佬的 <a target="_blank" rel="noopener" href="https://pkg.go.dev/github.com/jinzhu/copier">copier</a> 包来做的数据转换，但是这个包比较局限，它主要是在两个结构的之间的字段名以及类型相同的时候有用，向出现我们上面在 api 部分讲的那种骚操作就不适用了，并且我还出现过由于两边字段的大小写不一致导致最后有一个字段没有复制成功导致的问题（所以用这个一定要写对应的单元测试）。</p><p>所以结合我们之前的操作，我自己手动写了一个 copier 函数签名一样，实现非常简单，当然性能不太好，但是如果对性能要求不高的话也能用.</p><p>如下所示，就是用 json 来回倒腾两次就行了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Copy 从一个结构体复制到另一个结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Copy</span><span class="hljs-params">(to, from <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<br>	b, err := json.Marshal(from)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;marshal from data err&quot;</span>)<br>	&#125;<br><br>	err = json.Unmarshal(b, to)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;unmarshal to data err&quot;</span>)<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用这个函数的话，我们上面的代码就可以改成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CreateArticle 创建一篇文章</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Artcile)</span> <span class="hljs-title">CreateArticle</span><span class="hljs-params">(ctx context.Context, req *v1.CreateArticleReq)</span> <span class="hljs-params">(*v1.CreateArticleResp, error)</span></span> &#123;<br>	<span class="hljs-keyword">var</span> article domain.Article<br>	err := copier.Copy(&amp;article, req)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br><br>	err = a.usecase.CreateArticle(ctx, &amp;article)<br>	<span class="hljs-keyword">return</span> &amp;v1.CreateArticleResp&#123;&#125;, err<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="usecase"><a href="#usecase" class="headerlink" title="usecase"></a>usecase</h3><p>这一层主要是业务逻辑，业务逻辑相关代码都应该在这一层写，当然有时候我们的代码可能就只是保存一下数据没啥业务逻辑，可能是直接调用一下 repo 的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> article <span class="hljs-keyword">struct</span> &#123;<br>	repo domain.IArticleRepo<br>&#125;<br><br><span class="hljs-comment">// NewArticleUsecase init</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewArticleUsecase</span><span class="hljs-params">(repo domain.IArticleRepo)</span> <span class="hljs-title">domain</span>.<span class="hljs-title">IArticleUsecase</span></span> &#123;<br>	<span class="hljs-keyword">return</span> &amp;article&#123;repo: repo&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *article)</span> <span class="hljs-title">GetArticle</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*domain.Article, error)</span></span> &#123;<br>	<span class="hljs-comment">// 这里可能有其他业务逻辑...</span><br>	<span class="hljs-keyword">return</span> u.repo.GetArticle(ctx, id)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *article)</span> <span class="hljs-title">CreateArticle</span><span class="hljs-params">(ctx context.Context, article *domain.Article)</span> <span class="hljs-title">error</span></span> &#123;<br>	<span class="hljs-keyword">return</span> u.repo.CreateArticle(ctx, article)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="repo"><a href="#repo" class="headerlink" title="repo"></a>repo</h3><p>这一层是数据持久层，像数据库存取，缓存的处理应该都在这一层做掉，还有可能后续我们变成调用一个微服务来实现，那么这个被调用的微服务也应该在这里做。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> article <span class="hljs-keyword">struct</span> &#123;<br>	db *gorm.DB<br>&#125;<br><br><span class="hljs-comment">// NewArticleRepo init</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewArticleRepo</span><span class="hljs-params">(db *gorm.DB)</span> <span class="hljs-title">domain</span>.<span class="hljs-title">IArticleRepo</span></span> &#123;<br>	<span class="hljs-keyword">return</span> &amp;article&#123;db: db&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *article)</span> <span class="hljs-title">GetArticle</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*domain.Article, error)</span></span> &#123;<br>	<span class="hljs-keyword">var</span> a domain.Article<br>	<span class="hljs-keyword">if</span> err := r.db.WithContext(ctx).Find(&amp;a, id); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-comment">// 这里返回业务错误码</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> &amp;a, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *article)</span> <span class="hljs-title">CreateArticle</span><span class="hljs-params">(ctx context.Context, article *domain.Article)</span> <span class="hljs-title">error</span></span> &#123;<br><br>	<span class="hljs-keyword">if</span> err := r.db.WithContext(ctx).Create(article); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-comment">// 这里返回业务错误码</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="wire-set-go"><a href="#wire-set-go" class="headerlink" title="wire_set.go"></a>wire_set.go</h3><p>之前在 <a href="https://lailin.xyz/post/go-training-week4-wire.html">Go 工程化(三) 依赖注入框架 wire</a> 这一节讲到过，我们使用 wire 作为我们的依赖注入框架，由于 wire 不能出现相同的 Provider 所以我们会在 internal 的每个子目录下创建一下 wire_set.go 用于构建 wire.Set 结构，到时我们在 cmd 下直接应用这个文件的内容就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> server<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;github.com/google/wire&quot;</span><br>	<span class="hljs-string">&quot;github.com/mohuishou/new-project/internal/server/repo&quot;</span><br>	<span class="hljs-string">&quot;github.com/mohuishou/new-project/internal/server/service&quot;</span><br>	<span class="hljs-string">&quot;github.com/mohuishou/new-project/internal/server/usecase&quot;</span><br>)<br><br><span class="hljs-comment">// Set for di</span><br><span class="hljs-keyword">var</span> Set = wire.NewSet(<br>	service.NewArticleService,<br>	usecase.NewArticleUsecase,<br>	repo.NewArticleRepo,<br>)<br></code></pre></td></tr></table></figure><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><p>cmd 下的二进制目录，我一般会包含四个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── main.go <span class="hljs-comment"># 包含 main 函数</span><br>├── server.go <span class="hljs-comment"># 包含 wire set 等</span><br>├── wire.go <span class="hljs-comment"># for wire build</span><br>└── wire_gen.go <span class="hljs-comment"># wire 自动生成的</span><br></code></pre></td></tr></table></figure><p><strong>server.go</strong> 在真实的项目当中我们 service 包下面一般会有多个 service 文件，对应不同的结构体，并且除了 internal 中的依赖外我们可能还会有很多公共的依赖，例如配置中心，日志，数据库等，我的习惯是构建一个新的结构，在这个结构当中我们把所有的注册还还有 wire.set 搞好，这样 main 函数就会很清爽，整体上也会比较整洁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> set = wire.NewSet(<br>	<span class="hljs-comment">// domains</span><br>	server.Set,<br><br>	<span class="hljs-comment">// common</span><br>	initializer.Set,<br>)<br><br><span class="hljs-keyword">type</span> services <span class="hljs-keyword">struct</span> &#123;<br>	article *service.Artcile<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *services)</span> <span class="hljs-title">register</span><span class="hljs-params">(r gin.IRouter)</span></span> &#123;<br>	v1.RegisterBlogServiceHTTPServer(r, s.article)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>wire.go</strong> 经过 server.go 封装之后，wire.go 的代码就非常简单了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewServices NewServices</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServices</span><span class="hljs-params">()</span> <span class="hljs-params">(*services, error)</span></span> &#123;<br>	<span class="hljs-built_in">panic</span>(wire.Build(<br>		wire.Struct(<span class="hljs-built_in">new</span>(services), <span class="hljs-string">&quot;*&quot;</span>),<br>		set,<br>	))<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>main.go</strong> 我这里还没有像 <a target="_blank" rel="noopener" href="https://github.com/go-kratos/kratos/blob/main/app.go">kratos</a> 把程序的启动和退出封装起来，如果封装了会更加优雅一点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	s, err := NewServices()<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-built_in">panic</span>(err)<br>	&#125;<br><br>	e := gin.Default()<br>	s.register(e)<br><br>	<span class="hljs-comment">// 这里还有优雅中止的一些代码，就不贴了</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1615219210365-000fcd85-392a-41da-b7e4-8b4fc583123f.jpeg" srcset="/img/loading.gif" alt="Frame 1 (4).jpg"><br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1615268889054-251a4e39-c8d9-410f-950c-5262b368ae34.jpeg" srcset="/img/loading.gif" alt="Frame 2 (1).jpg"><br>我们回过头来看上面这两种结构，可以发现，第一种结构整体上职责相对没有那么清晰，就导致了在团队协作的过程中会出现很多二义性，导致最后越来越混乱，并且由于 model 层就是一个大锅饭，什么都往里面扔所以也就乱的不行了。</p><p>新的结构不仅仅进行了水平拆分还按照功能进行了垂直拆分，将定时任务和 http 服务的代码拆分开来，整体的结构都清晰了很多，并且由于我们大量使用依赖注入，所以代码的可测性非常的好，写单元测试非常容易。<br>但是这里也有一个坑，拆分的时候要注意，我第一次拆分想按照领域进行拆分，并且拆分的非常细，导致出现了很多服务，后面听过毛老师课上的讲解后重新 review 了一下发现其实这些服务边界没有那么清晰，即使我们以后拆微服务，也不会把这些拆成两个不同的微服务，所以后面再改了一次才构成了现在的结构。所以我们在进行垂直拆分的时候一定要多问问自己，或者多和团队的同学讨论一下。</p><p>最后想要业务开发的比较开心愉快，那基础设施的建设非常重要，像本文提到的很多代码只要我们统一了规范和结构都可以通过工具来自动生成。</p><p><strong>我们下一篇文章见，加油打工人 💪（看完别忘了转发，订阅，点赞哦）</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a target="_blank" rel="noopener" href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></li><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Go 工程化(一) 架构整洁之道阅读笔记 - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week4-project-layout.html">Go 工程化(二) 项目目录结构 - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week4-wire.html">Go 工程化(三) 依赖注入框架 wire - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week4-api-design.html">Go 工程化(四) API 设计上: 项目结构 &amp; 设计 - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week4-protoc-gen-go-gin.html">Go 工程化(五) API 设计下: 基于 protobuf 自动生成 gin 代码 - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week4-config.html">Go 工程化(六) 配置管理 - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week4-go-module.html">Go 工程化(七) Go Module - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week4-unit-test.html">Go 工程化(八) 单元测试 - Mohuishou</a></li><li><a target="_blank" rel="noopener" href="https://github.com/favadi/protoc-go-inject-tag">https://github.com/favadi/protoc-go-inject-tag</a></li><li><a target="_blank" rel="noopener" href="https://pkg.go.dev/github.com/jinzhu/copier">https://pkg.go.dev/github.com/jinzhu/copier</a></li><li><a target="_blank" rel="noopener" href="https://github.com/go-kratos/kratos/blob/main/app.go">https://github.com/go-kratos/kratos/blob/main/app.go</a></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week6-3-token-bucket-2.html">Go可用性(三) 限流2: 令牌桶的实现 rate/limt</a></li><li><a href="https://lailin.xyz/post/go-training-week6-2-token-bucket-1.html">Go可用性(二) 限流1: 令牌桶原理及使用</a></li><li><a href="https://lailin.xyz/post/go-training-week6-usability-1-bulkhe.html">Go可用性(一) 隔离设计</a></li></ul></div><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a class="anchorjs-link" aria-label="Anchor" data-anchorjs-icon="" href="#关注我获取更新" style="font:1em/1 anchorjs-icons;padding-left:.375em"></a></h2><div class="row"><div class="col-lg-6"><img style="width:100%" src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png" srcset="/img/loading.gif" alt="wechat"></div><div class="col-lg-2 col-4"><a target="_blank" href="http://s.zhihu.com/B4RT3"><img style="width:100%" src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png" srcset="/img/loading.gif" alt="知乎"></a></div><div class="col-lg-2 col-4"><a target="_blank" href="https://toutiao.io/subjects/387401?f=new"><img style="width:100%" src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png" srcset="/img/loading.gif" alt="开发者头条"></a></div><div class="col-lg-2 col-4"><a target="_blank" href="https://github.com/mohuishou"><img style="width:100%" src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png" srcset="/img/loading.gif" alt="github"></a></div></div></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">Go进阶训练营</a> <a class="hover-with-bg" href="/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week04-Go-%E5%B7%A5%E7%A8%8B%E5%8C%96/">Week04: Go 工程化</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> <a class="hover-with-bg" href="/tags/Go/">Go</a> <a class="hover-with-bg" href="/tags/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">Go进阶训练营</a> <a class="hover-with-bg" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/">工程化</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a>，转载请注明出处，禁止全文转载</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/post/go-training-week5-comment-design-1.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">评论系统架构设计</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/post/go-training-week4-unit-test.html"><span class="hidden-mobile">Go工程化(八) 单元测试</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><script type="text/javascript">Fluid.utils.waitElementVisible("comments",function(){var t="github-light",e="github-dark",s="dark"===(s=document.documentElement.getAttribute("data-user-color-scheme"))?e:t;window.UtterancesThemeLight=t,window.UtterancesThemeDark=e;e=document.createElement("script");e.setAttribute("src","https://utteranc.es/client.js"),e.setAttribute("repo","scuplus/blogComment"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",s),e.setAttribute("crossorigin","anonymous"),document.getElementById("comments").appendChild(e)})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div><div id="bottom"><div id="bottom-drawer" class="bottom-drawer"><div class="sidebar"><p class="sidebar-header">Go进阶训练营</p><div class="sidebar-body" id="sidebar-body"><ol class="sidebar-list sidebar-list-1"><li class="sidebar-list-item"><a class="sidebar-title" onclick='document.querySelector("#sidebar-ckkm23xho0000m4t51q602czj").classList.toggle("sidebar-is-collapsed")'>Week01: 微服务</a><ol id="sidebar-ckkm23xho0000m4t51q602czj" class="sidebar-list sidebar-list-2 sidebar-is-collapsible"><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-01.html">微服务(一) 微服务概览</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-02.html">微服务(二) 服务发现&amp;多租户</a></li></ol></li><li class="sidebar-list-item"><a class="sidebar-title" onclick='document.querySelector("#sidebar-ckkm23ykh0003m4t53mln1w0n").classList.toggle("sidebar-is-collapsed")'>Week02: Go错误处理</a><ol id="sidebar-ckkm23ykh0003m4t53mln1w0n" class="sidebar-list sidebar-list-2 sidebar-is-collapsible"><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-03.html">Go错误处理最佳实践</a></li></ol></li><li class="sidebar-list-item"><a class="sidebar-title" onclick='document.querySelector("#sidebar-ckkm2667n000pm4t52z016wn0").classList.toggle("sidebar-is-collapsed")'>Week03: Go 并发编程</a><ol id="sidebar-ckkm2667n000pm4t52z016wn0" class="sidebar-list sidebar-list-2 sidebar-is-collapsible"><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-goroutine.html">Go并发编程(一) goroutine</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-go-memory-model.html">Go并发编程(二) Go 内存模型</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-data-race.html">Go并发编程(三) data race</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-sync.html">Go并发编程(四) 深入理解 Mutex</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-atomic.html">Go并发编程(五) 深入理解 sync/atomic</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-waitgroup.html">Go并发编程(六) 深入理解 WaitGroup</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-errgroup.html">Go并发编程(七) 深入理解 errgroup</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-once.html">Go并发编程(八) 深入理解 sync.Once</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-context.html">Go并发编程(九) 深入理解 Context</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-channel.html">Go并发编程(十) 深入理解 Channel</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week3-sum.html">Go并发编程(十一) 总结</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week5-singleflight.html">Go并发编程(十二) Singleflight</a></li></ol></li><li class="sidebar-list-item"><a class="sidebar-title" onclick='document.querySelector("#sidebar-ckkm23zra000im4t5en8m0qy9").classList.toggle("sidebar-is-collapsed")'>Week04: Go 工程化</a><ol id="sidebar-ckkm23zra000im4t5en8m0qy9" class="sidebar-list sidebar-list-2 sidebar-is-collapsible"><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-clean-arch.html">Go工程化(一) 架构整洁之道阅读笔记</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-project-layout.html">Go工程化(二) 项目目录结构</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-wire.html">Go工程化(三) 依赖注入框架 wire</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-api-design.html">Go工程化(四) API 设计上: 项目结构 &amp; 设计</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-protoc-gen-go-gin.html">Go工程化(五) API 设计下: 基于 protobuf 自动生成 gin 代码</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-config.html">Go工程化(六) 配置管理</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-go-module.html">Go工程化(七) Go Module</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week4-unit-test.html">Go工程化(八) 单元测试</a></li><li class="sidebar-list-item is-active-li"><a class="sidebar-link sidebar-active-link" href="/post/go-training-week4-practice.html">Go工程化(九) 项目重构实践</a></li></ol></li><li class="sidebar-list-item"><a class="sidebar-title" onclick='document.querySelector("#sidebar-ckmxouk290005tpox6b63ft9x").classList.toggle("sidebar-is-collapsed")'>Week05: 评论系统架构设计</a><ol id="sidebar-ckmxouk290005tpox6b63ft9x" class="sidebar-list sidebar-list-2 sidebar-is-collapsible"><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week5-comment-design-1.html">评论系统架构设计</a></li></ol></li><li class="sidebar-list-item"><a class="sidebar-title" onclick='document.querySelector("#sidebar-ckmxouk2f000ctpox8quy1adz").classList.toggle("sidebar-is-collapsed")'>Week06: 微服务可用性设计</a><ol id="sidebar-ckmxouk2f000ctpox8quy1adz" class="sidebar-list sidebar-list-2 sidebar-is-collapsible"><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week6-usability-1-bulkhe.html">Go可用性(一) 隔离设计</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week6-2-token-bucket-1.html">Go可用性(二) 限流1: 令牌桶原理及使用</a></li><li class="sidebar-list-item"><a class="sidebar-link" href="/post/go-training-week6-3-token-bucket-2.html">Go可用性(三) 限流2: 令牌桶的实现 rate/limt</a></li></ol></li></ol></div></div><div id="toc-mobile"><div class="toc-body" id="toc-body-mobile"></div></div></div><div id="bottom-tab"><a class="sub-menu" onclick='showBottomDrawer(this,"#bottom-drawer .sidebar")'><i class="iconfont"></i> 章节 </a><a class="sub-menu" onclick='showBottomDrawer(this,"#bottom-drawer #toc-mobile")'><i class="iconfont"></i> 目录 </a><a href="#comments" class="sub-menu" onclick='showBottomDrawer(this,"#comments")'><i class="iconfont"></i> 评论</a></div></div><script>function showBottomDrawer(s,t){let e=document.querySelector("#bottom-tab");e.childNodes.forEach(t=>{t!=s&&t.classList&&t.classList.remove("active")}),"#comments"!=t&&s.classList.toggle("active");let o=document.querySelector("#bottom-drawer"),c=document.querySelector(t);o.childNodes.forEach(t=>{t!=c&&t.classList&&t.classList.remove("active")}),c.classList.toggle("active"),"#comments"!=t?(c.classList.contains("active")&&!o.classList.contains("active")&&o.classList.add("active"),!c.classList.contains("active")&&o.classList.contains("active")&&o.classList.remove("active")):o.classList.remove("active")}document.onreadystatechange=function(t){let s=$("#bottom-drawer");s.height()<=0||window.tocbot.init({tocSelector:"#toc-body-mobile",contentSelector:".markdown-body",headingSelector:"h1,h2,h3,h4",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:20})}</script></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><script>!function(e,s,p){var r;void 0===e.webpushr&&(e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)},r=s.getElementsByTagName(p)[0],(p=s.createElement(p)).id="webpushr-jssdk",p.async=1,p.src="https://cdn.webpushr.com/app.min.js",r.parentNode.appendChild(p))}(window,document,"script"),webpushr("setup",{key:"BBkZb7rpvsVqVNkORXD9T9T93MJodtpNJD5c1f2HE_XsED3r94An3CKObdyTJ6ub3ARm9LIdeDCVzKLBsK760NM"})</script></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/debouncer-c523e4d3f8b7b837c19f74984acbabf7.js"></script><script src="/js/events-f495e9aefe2285fc712ba316bdf01b26.js"></script><script src="/js/plugins-93fa930e12b7596433529edc1b5458df.js"></script><script src="/js/lazyload-e96b3165477d429bf8096bdbd068d816.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script src="/js/local-search-c277a106ee2a2e265fcd58887e53c0fb.js"></script><script>document.querySelector("#local-search-input").onclick=function(){searchFunc("/local-search.xml","local-search-input","local-search-result"),this.onclick=null}</script><script defer>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-137859264-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script>let sidebarBody=document.querySelector(".sidebar .sidebar-body"),sidebarActive=document.querySelector(".sidebar .is-active-li"),bc=sidebarBody.getBoundingClientRect(),ac=sidebarActive.getBoundingClientRect(),t=ac.y-bc.y-bc.height/2;0<t&&sidebarBody.scrollTo({top:t,behavior:"smooth"})</script><script src="/js/boot-b4d619350e67f5b3ceeb2164d30268e0.js"></script></body></html>