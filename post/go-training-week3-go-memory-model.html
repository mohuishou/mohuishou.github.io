<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/icons/touch-icon-apple.png"><link rel="icon" type="image/png" href="/icons/favicon-32x32.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content><meta name="author" content="Mohuishou"><meta name="keywords" content="Go, Docker, PHP"><title>Week03: Go并发编程(二) Go 内存模型 - Mohuishou</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/assets/css/custom.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>mohuishou</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item"><a class="nav-link" href="/atom.xml"><i class="iconfont icon-rss"></i> rss</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/img/bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-12-07 13:37" pubdate>2020年12月7日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.8k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 46 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">Week03: Go并发编程(二) Go 内存模型</h1><div class="markdown-body" id="post-body"><blockquote><p>本系列为极客时间 Go 进阶训练营笔记，同步直播更新，预计一周更新 1 ~ 2 篇文章，到 202103 月更新完成</p></blockquote><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在上一篇文章当中我们讲到了使用 goroutine 的一些注意事项，我们先简单回顾一下:</p><ol><li><strong>请将是否异步调用的选择权交给调用者</strong>，不然很有可能大家并不知道你在这个函数里面使用了 goroutine</li><li>如果你要启动一个 goroutine 请对它负责<ol><li><strong>永远不要启动一个你无法控制它退出，或者你无法知道它何时推出的 goroutine</strong></li><li>还有上一篇提到的，启动 goroutine 时请加上 panic recovery 机制，避免服务直接不可用</li><li>造成 goroutine 泄漏的主要原因就是 goroutine 中造成了阻塞，并且没有外部手段控制它退出</li></ol></li><li><strong>尽量避免在请求中直接启动 goroutine 来处理问题</strong>，而应该通过启动 worker 来进行消费，这样可以避免由于请求量过大，而导致大量创建 goroutine 从而导致 oom，当然如果请求量本身非常小，那当我没说</li></ol><p>那我们为什么要这么使用 goroutine 呢？今天我们从原理层面来了解一下 goroutine 的注意事项，本文以 Go 官方博客当中的 <a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a> 为主干穿插讲解，建议阅读本文前先自行看完一遍原文，会有更多的收获</p><h2 id="Go-内存模型"><a href="#Go-内存模型" class="headerlink" title="Go 内存模型"></a>Go 内存模型</h2><p>同样我们先来看一段代码，请问下面的代码可能会输出什么？</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">var</span> a, b <span class="hljs-keyword">int</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;
	a = <span class="hljs-number">1</span>
	b = <span class="hljs-number">2</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-built_in">print</span>(b)
	<span class="hljs-built_in">print</span>(a)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">go</span> f()
	g()
&#125;</code></pre><p>ok，请带着你的答案或者是困惑我们往下走<br><img src="https://lailin.xyz/images/1608363233129-3653a44c-74a9-46dc-94b0-c6151da0c07c.svg" srcset="/img/loading.gif" alt="02_Go进阶03_blog_img.drawio.svg"><br>比较容易想到的结果是:</p><ul><li>执行顺序: 1 - 2 - 3 - 4, f 先执行, g 后执行, 输出 <code>2 1</code></li><li>执行顺序: 3 - 4 - 1 - 2, g 先执行，f 后执行，输出 <code>0 0</code></li></ul><p>就这几种结果么？其实不然，还有可能</p><ul><li>执行顺序: 1 - 3 - 4 - 2, <code>f</code> 先执行一部分, 然后 <code>g</code> 执行, 输出 <code>0 1</code></li></ul><p>那能不能输出 <code>2 0</code> 呢？</p><ul><li>先说答案，是有可能的</li></ul><p>是不是感觉有点反常识？是不是感觉有点飘忽不定？引用参考文章里面曹大的一句话：</p><blockquote><p>软件(<em>编译器</em>)或硬件(<em>CPU</em>)系统可以根据其对代码的分析结果，一定程度上打乱代码的执行顺序，以达到其不可告人的目的(<em>提高 CPU 利用率)</em></p></blockquote><p>所以我们在编写并发程序的时候一定要小心，然后回到我们本次的主题 Go 内存模型，就是要解决两个问题，一个是要了解谁先谁后，有个专有名词叫 <code>Happens Before</code> ，另外一个就是了解可见性的问题，我这次读取能不能看到另外一个线程的写入<br>接下来我们官方的文档<a href="https://golang.org/ref/mem" target="_blank" rel="noopener">《The Go Memory Model》</a>的思路一步一步的了解这些问题，因为官方的文档写的相对比较精炼，所以会比较难懂，我会尝试加入一些我的理解补充说明</p><h3 id="忠告"><a href="#忠告" class="headerlink" title="忠告"></a>忠告</h3><blockquote><p>Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access.<br>To serialize access, protect the data with channel operations or other synchronization primitives such as those in the <a href="https://golang.org/pkg/sync/" target="_blank" rel="noopener"><code>sync</code></a> and <a href="https://golang.org/pkg/sync/atomic/" target="_blank" rel="noopener"><code>sync/atomic</code></a> packages.</p></blockquote><p>这个是说如果你的程序存在多个 goroutine 去访问数据的时候，<strong>必须序列化的访问，</strong>如何保证序列化呢？我们可以采用 channel 或者是 sync 以及 sync/atomic 下面提供的同步语义来保证</p><h3 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens Before"></a>Happens Before</h3><h4 id="序"><a href="#序" class="headerlink" title="序"></a>序</h4><blockquote><p>Within a single goroutine, reads and writes must behave as if they executed in the order specified by the program. That is, compilers and processors may reorder the reads and writes executed within a single goroutine only when the reordering does not change the behavior within that goroutine as defined by the language specification. Because of this reordering, the execution order observed by one goroutine may differ from the order perceived by another. For example, if one goroutine executes a = 1; b = 2;, another might observe the updated value of b before the updated value of a.</p></blockquote><p>这段话就解释了上面我们示例当中为什么会出现 <code>2 0</code> 这种情况。<br>这段话就是说我们在单个 goroutine 当中的编写的代码会总是按照我们编写代码的顺序来执行</p><ul><li>当然这个也是符合我们的习惯的</li><li>当然这并不表示编译器在编译的时候不会对我们的程序进行指令重排</li><li>而是说只会在不影响语言规范对 goroutine 的行为定义的时候，编译器和 CPU 才会对读取和写入的顺序进行重新排序。</li></ul><p>但是正是因为存在这种重排的情况，所以一个 goroutine 监测到的执行顺序和另外一个 goroutine 监测到的有可能不一样。就像我们最上面的这个例子一样，可能我们在 f 执行的顺序是先执行 <code>a = 1</code> 后执行 <code>b = 2</code> 但是在 g 中我们只看到了 b = 2 具体什么情况可能会导致这个呢？不要着急，我们后面还会说到</p><h4 id="编译器重排"><a href="#编译器重排" class="headerlink" title="编译器重排"></a>编译器重排</h4><p>我们来看参考文章中的一个编译器重排例子</p><pre><code class="hljs go">X = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i in <span class="hljs-keyword">range</span>(<span class="hljs-number">100</span>):
    X = <span class="hljs-number">1</span>
    <span class="hljs-built_in">print</span> X</code></pre><p>在这段代码中，X = 1 在 for 循环内部被重复赋值了 100 次，这完全没有必要，于是聪明的编译器就会帮助我们优化成下面的样子</p><pre><code class="hljs go">X = <span class="hljs-number">1</span>
<span class="hljs-keyword">for</span> i in <span class="hljs-keyword">range</span>(<span class="hljs-number">100</span>):
    <span class="hljs-built_in">print</span> X</code></pre><p>完美，在单个 goroutine 中并不会改变程序的执行，这时候同样会输出 100 次 1 ，并且减少了 100 次赋值操作。<br>但是，如果与此同时我们存在一个另外一个 goroutine 干了另外一个事情 X = 0 那么，这个输出就变的不可预知了，就有可能是 1001111101… 这种，所以回到刚开始的忠告：<strong>这个是说如果你的程序存在多个 goroutine 去访问数据的时候，必须序列化的访问</strong></p><h4 id="happens-before-定义"><a href="#happens-before-定义" class="headerlink" title="happens before 定义"></a>happens before 定义</h4><blockquote><p>To specify the requirements of reads and writes, we define happens before, a partial order on the execution of memory operations in a Go program. If event <code>e1</code> happens before event <code>e2</code>, then we say that <code>e2</code> happens after <code>e1</code>. Also, if <code>e1</code> does not happen before <code>e2</code> and does not happen after <code>e2</code>, then we say that <code>e1</code> and <code>e2</code> happen concurrently.</p></blockquote><p>这是 Happens Before 的定义，如果 <code>e1</code> 发生在 <code>e2</code> 之前，那么我们就说 <code>e2</code> 发生在 <code>e1</code> 之后，如果 <code>e1</code> 既不在 <code>e2</code> 前，也不在 <code>e2</code> 之后，那我们就说这俩是并发的</p><blockquote><p>Within a single goroutine, the happens-before order is the order expressed by the program.</p></blockquote><p>这就是我们前面提到的，在单个 goroutine 当中，事件发生的顺序，就是程序所表达的顺序</p><blockquote><p>A read r of a variable <code>v</code> is allowed to observe a write <code>w</code> to <code>v</code> if both of the following hold:</p><ol><li>r does not happen before <code>w</code>.</li><li>There is no other write <code>w&#39;</code> to <code>v</code> that happens after w but before <code>r</code>.</li></ol></blockquote><p>假设我们现在有一个变量 <code>v</code>，然后只要满足下面的两个条件，那么读取操作 <code>r</code> 就可以对这个变量 <code>v</code> 的写入操作 <code>w</code> 进行监测</p><ol><li>读取操作 <code>v</code> 发生在写入操作 <code>w</code> 之后</li><li>并且在 <code>w</code> 之后，<code>r</code> 之前没有其他对 <code>v</code> 的写入操作 <code>w&#39;</code></li></ol><p>注意这里说的只是读取操作 r 可以对 w 进行监测，但是能不能读到呢，可能可以也可能不行</p><blockquote><p>To guarantee that a read <code>r</code> of a variable <code>v</code> observes a particular write <code>w</code> to <code>v</code>, ensure that <code>w</code> is the only write <code>r</code> is allowed to observe. That is, <code>r</code> is guaranteed to observe <code>w</code> if both of the following hold:</p><ol><li><code>w</code> happens before <code>r</code>.</li><li>Any other write to the shared variable <code>v</code> either happens before <code>w</code> or after <code>r</code>.</li></ol></blockquote><p>为确保对变量 <code>v</code> 的读取操作 <code>r</code> 能够监测到特定的对 <code>v</code> 进行写入的操作 <code>w</code>，需确保 <code>w</code> 是唯一允许被 <code>r</code> 监测的写入操作。也就是说，若以下条件均成立，则 <code>r</code> 能保证监测到 <code>w</code>：</p><ol><li><code>w</code> 发生在 <code>r</code> 之前。</li><li>对共享变量 <code>v</code> 的其它任何写入操作都只能发生在 <code>w</code> 之前或 <code>r</code> 之后。</li></ol><p>这对条件的要求比第一个条件更强，它需要确保没有其它写入操作与 <code>w</code> 或 <code>r</code> 并发。<br>在单个 goroutine 当中这两个条件是等价的，因为单个 goroutine 中不存在并发，在多个 goroutine 中就必须使用同步语义来确保顺序，这样才能到保证能够监测到预期的写入<br><strong>单个 goroutine 的情况</strong>：<br>我们可以发现在单个 goroutine 当中，读取操作 r 总是可以读取到上一次 w 写入的值的<br><img src="https://lailin.xyz/images/1608372439492-359ad5bf-1b06-4f4f-ae77-84e96d9f6a7f.png" srcset="/img/loading.gif" alt="image.png"><br><strong>多个 goroutine 的情况</strong>:<br>但是存在多个 goroutine 的时候这个就不一定了，r0 读到的是 哪一次写入的值呢？如果看图的话像是 w4 的，但其实不一定，因为图中的两个 goroutine 所表达的时间维度可能是不一致的，所以 r0 可能读到的是 w0 w3 w4 甚至是 w5 的结果，当然按照我们前面说的理论，读到的不可能是 w1 的结果的<br><img src="https://lailin.xyz/images/1608372753766-f3b66fe5-ac34-4f5e-a1b2-c74e7d3dfbc9.png" srcset="/img/loading.gif" alt="image.png"><br><strong>添加一些同步点</strong><br>如下图所示我们通过 sync 包中的一些同步语义或者是 channel 为多个 goroutine 加入了 同步点，那么这个时候对于 r1 而言，他就是晚于 w4 并且早于 w1 和 w5 执行的，所以它读取到的是写入操作是可以确定的，是 w4<br><img src="https://lailin.xyz/images/1608373281116-271c756e-386e-490b-aa7b-0fb2b741ed40.png" srcset="/img/loading.gif" alt="image.png"></p><blockquote><p>The initialization of variable <code>v</code> with the zero value for <code>v</code>‘s type behaves as a write in the memory model.</p></blockquote><p>以变量 <code>v</code> 所属类型的零值来对 <code>v</code> 进行初始化，其表现如同在内存模型中进行的写入操作。</p><h4 id="机器字"><a href="#机器字" class="headerlink" title="机器字"></a>机器字</h4><blockquote><p>Reads and writes of values larger than a single machine word behave as multiple machine-word-sized operations in an unspecified order.</p></blockquote><p>对大于单个机器字的值进行读取和写入，其表现如同以不确定的顺序对多个机器字大小的值进行操作。要理解这个我们首先要理解什么是机器字。<br>我们现在常见的还有 32 位系统和 64 位的系统，cpu 在执行一条指令的时候对于单个机器字长的的数据的写入可以保证是原子的，对于 32 位的就是 4 个字节，对于 64 位的就是 8 个字节，对于在 32 位情况下去写入一个 8 字节的数据时就需要执行两次写入操作，这两次操作之间就没有原子性，那就可能出现先写入后半部分的数据再写入前半部分，或者是写入了一半数据然后写入失败的情况。<br>也就是说虽然有时候我们看着仅仅只做了一次写入但是还是会有并发问题，因为它本身不是原子的</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><blockquote><p>Program initialization runs in a single goroutine, but that goroutine may create other goroutines, which run concurrently.<br>If a package <code>p</code> imports package <code>q</code>, the completion of <code>q</code>‘s <code>init</code> functions happens before the start of any of <code>p</code>‘s.<br>The start of the function <code>main.main</code> happens after all <code>init</code> functions have finished.</p></blockquote><ul><li>程序的初始化运行在单个 goroutine 中，但该 goroutine 可能会创建其它并发运行的 goroutine</li><li>若包 p 导入了包 q，则 q 的 init 函数会在 p 的任何函数启动前完成。</li><li>函数 main.main 会在所有的 init 函数结束后启动。<div style="background:#fffbe6;padding:10px;border:1px solid #c3c3c3;border-radius:5px;margin-bottom:5px">注意: 在实际的应用代码中不要隐式的依赖这个启动顺序</div></li></ul><h4 id="goroutine-的创建"><a href="#goroutine-的创建" class="headerlink" title="goroutine 的创建"></a>goroutine 的创建</h4><blockquote><p>The <code>go</code> statement that starts a new goroutine happens before the goroutine’s execution begins.</p></blockquote><p><code>go</code> 语句会在当前 goroutine 开始执行前启动新的 goroutine</p><h4 id="goroutine-的销毁"><a href="#goroutine-的销毁" class="headerlink" title="goroutine 的销毁"></a>goroutine 的销毁</h4><blockquote><p>The exit of a goroutine is not guaranteed to happen before any event in the program。</p></blockquote><p>goroutine 无法确保在程序中的任何事件发生之前退出</p><p>注意 <a href="https://golang.org/ref/mem" target="_blank" rel="noopener">《The Go Memory Model》</a>原文中还有关于 channel， 锁相关的阐述，因为篇幅原因在本文中就不多讲了，后面我们还有单独的文章详细讲 channel 和 锁 相关的使用，在强调一遍，原文一定要多看几遍</p><h2 id="内存重排"><a href="#内存重排" class="headerlink" title="内存重排"></a>内存重排</h2><p>在上面我们讲到了编译器重排，以及在最开始的例子中我们提到了可能会存在 <code>2 0</code> 这个答案，接下来我们就来看看为什么。如果大家购买电脑的时候有去对比 cpu 的话应该可以看到，每个 cpu 都会写一下一级缓存，二级缓存，三级缓存的大小，这个缓存就是这里的一个关键点，一般而言，越往下缓存的大小越大速度越慢，这是 cpu 为了提高执行速度做的缓存体系，就像我们平时在应用当中引入 redis 作为缓存类似，都是为了加速。同时这就会带来一些数据不一致的问题。<br><img src="https://lailin.xyz/images/1608385154319-591875fe-fc6f-457f-8fd0-966b8e603310.png" srcset="/img/loading.gif" alt="02_Go进阶03_blog_img.drawio-第 4 页.png"><br><strong>如上图所示：</strong></p><ol><li>C1 执行 a = 1 将 store buffer 中 a 的值写为 1</li><li>C1 执行 b = 2 将 store buffer 中 b 的值写为 2, 然后由于某种原因将 b 的值写入到了内存中</li><li>C2 去读取 b 的值，发现缓存中没有，就去内存中读，这时候 print 出来 2</li><li>C2 去读取 a 的值，发现缓存中没有，就去内存中读，这时候 print 出来 0</li></ol><p>了解到这里之后可能会有一些疑问，既然会存在这种不确定性，我们有没有什么办法去保证一致呢？CPU 的一致性具体又是怎么回事？<br>保证一致从程序上来讲我们必须使用同步语义的工具确保一致，如果深入到底层的话就是使用 cpu 提供的内存屏障命令，保证所有对内存的操作都必须要“扩散”到 memory 之后才能继续执行其他对 memory 的操作。<br>CPU 一致性的原理建议看一下 MSI(E)协议的实现，我在参考文献中列出的最后两篇文章讲的已经比较通俗易懂了，在本文就不再叙述</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>Go 的并发编程非常的简单，只需要使用 go func 就能启动一个新的协程，但是并发编程本身就是很容易出现 bug 的，而且由于并发导致的 bug 还不太容易发现，所以我们在写并发逻辑的时候一定要非常小心，用官方的一句话就是<strong>使用显示的同步</strong></li><li>本文更多是抛砖引玉这里面提到了很多有意思的名词都值得好好研究</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a> 官方文档一定要多读几遍</li><li><a href="https://go-zh.org/ref/mem" target="_blank" rel="noopener">https://go-zh.org/ref/mem</a> 官方文档的中文翻译，英文比较吃力可以看这篇</li><li><a href="https://qcrao.com/2019/06/17/cch-says-memory-reorder/" target="_blank" rel="noopener">https://qcrao.com/2019/06/17/cch-says-memory-reorder/</a></li><li><a href="https://cch123.github.io/ooo/" target="_blank" rel="noopener">https://cch123.github.io/ooo/</a></li><li><a href="https://www.cs.utexas.edu/~bornholt/post/memory-models.html" target="_blank" rel="noopener">https://www.cs.utexas.edu/~bornholt/post/memory-models.html</a></li><li><a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%AD%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%AD%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a>&gt;)</li><li><a href="https://zhuanlan.zhihu.com/p/65245043" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/65245043</a></li><li><a href="https://zhuanlan.zhihu.com/p/94811032" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/94811032</a></li></ul><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新</h2><p>看到这里了还不关注点赞走一波</p><ul><li><a href="https://lailin.xyz">博客</a> 可以订阅 RSS</li><li><a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a> Follow me</li><li><a href="https://www.zhihu.com/people/mo-hui-shou-76" target="_blank" rel="noopener">知乎</a> 关注账号，顺便点个 👍</li><li><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a> 订阅订阅号，顺便点个 👍</li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-sync.html">Week03: Go并发编程(四) 深入理解 Mutex</a></li><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/Go进阶训练营/">Go进阶训练营</a> <a class="hover-with-bg" href="/categories/Go进阶训练营/Go并发编程/">Go并发编程</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/学习笔记/">学习笔记</a> <a class="hover-with-bg" href="/tags/Go/">Go</a> <a class="hover-with-bg" href="/tags/Go进阶训练营/">Go进阶训练营</a> <a class="hover-with-bg" href="/tags/并发/">并发</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/post/go-training-week3-data-race.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Week03: Go并发编程(三) data race</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/post/go-training-week3-goroutine.html"><span class="hidden-mobile">Week03: Go并发编程(一) goroutine</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><script type="text/javascript">function loadUtterances(){var t="github-light",e="github-dark",s=document.documentElement.getAttribute("data-user-color-scheme");s="dark"===s?e:t,window.UtterancesThemeLight=t,window.UtterancesThemeDark=e;var n=document.createElement("script");n.setAttribute("src","https://utteranc.es/client.js"),n.setAttribute("repo","scuplus/blogComment"),n.setAttribute("issue-term","pathname"),n.setAttribute("label","utterances"),n.setAttribute("theme",s),n.setAttribute("crossorigin","anonymous"),document.getElementById("comments").appendChild(n)}waitElementVisible("comments",loadUtterances)</script></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Week03: Go并发编程(二) Go 内存模型&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><script defer>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-137859264-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script></body></html>