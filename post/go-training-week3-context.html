<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/icons/touch-icon-apple.png"><link rel="icon" href="/icons/favicon-32x32.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="
            本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 博客: Go进阶训练营, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。
          


楔子在 Week03: Go 并发编程(六) 深入理解 WaitGroup 、 Week03: Go 并发编程(七) 深入理解 errgroup 中我们提到了等待多个 gorout"><meta name="author" content="Mohuishou"><meta name="keywords" content="Go,Docker,PHP"><meta name="description" content="本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 博客: Go进阶训练营, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。              楔子在 Week03: Go 并发编程(六) 深入理解 WaitGroup 、 Week03: Go 并发编程(七) 深入理解 errgroup 中我们提到了等待多个 gorout"><meta property="og:type" content="article"><meta property="og:title" content="Go并发编程(九) 深入理解 Context"><meta property="og:url" content="https://lailin.xyz/post/go-training-week3-context.html"><meta property="og:site_name" content="Mohuishou"><meta property="og:description" content="本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 博客: Go进阶训练营, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。              楔子在 Week03: Go 并发编程(六) 深入理解 WaitGroup 、 Week03: Go 并发编程(七) 深入理解 errgroup 中我们提到了等待多个 gorout"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.lailin.xyz/image/1610027116078-2e1368bf-015e-4459-8517-73dc858ed083.svg"><meta property="og:image" content="https://img.lailin.xyz/image/1610027303842-4272e9a1-af9c-4804-a779-f72c1f82a1a0.svg"><meta property="og:image" content="https://img.lailin.xyz/image/1610027726018-4ff7389e-ec4a-4107-99ac-493f587f2a88.svg"><meta property="og:image" content="https://img.lailin.xyz/image/1610027762059-43c810a8-619e-4f8d-ad74-7a2767635aa0.svg"><meta property="article:published_time" content="2021-01-08T15:08:51.000Z"><meta property="article:modified_time" content="2021-12-19T16:31:34.984Z"><meta property="article:author" content="Mohuishou"><meta property="article:tag" content="Go"><meta property="article:tag" content="学习笔记"><meta property="article:tag" content="Go进阶训练营"><meta property="article:tag" content="并发"><meta property="article:tag" content="context"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://img.lailin.xyz/image/1610027116078-2e1368bf-015e-4459-8517-73dc858ed083.svg"><title>Go并发编程(九) 深入理解 Context - Mohuishou</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main-c1a2ba48b1cbfbb102870f1f7fdc6af7.css"><link rel="stylesheet" href="/assets/css/custom-20b83bcc6d190c466b14490ddfd6fab4.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"lailin.xyz",root:"/",version:"1.8.12",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:3},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:"UA-137859264-1",gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"}</script><script src="/js/utils-10734676b63578b88b4b8e46ef525a20.js"></script><script src="/js/color-schema-1e146e57667997eb91b1ed8f419f9e22.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>mohuishou</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> Go 系列</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/"><i class="iconfont icon-category-fill"></i> Go 进阶训练营(更新中) </a><a class="dropdown-item" href="/post/list.html"><i class="iconfont icon-notebook"></i> Go 数据结构与算法(更新中) </a><a class="dropdown-item" href="/post/go-design-pattern.html"><i class="iconfont icon-notebook"></i> Go 设计模式</a></div></li><li class="nav-item"><a class="nav-link" href="/post/operator-01-overview.html"><i class="iconfont icon-category-fill"></i> kubernetes 系列</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> 更多</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/links/"><i class="iconfont icon-link-fill"></i> 友链 </a><a class="dropdown-item" href="/atom.xml"><i class="iconfont icon-rss"></i> rss </a><a class="dropdown-item" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></div></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Go并发编程(九) 深入理解 Context">Go并发编程(九) 深入理解 Context</span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-01-08 23:08" pubdate>2021年1月8日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 16k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 133 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2 post-categories"><div class="category-list"><div class="category row"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" id="heading-5635160ef7307ccb3bfb116a87b12b17" role="tab" data-toggle="collapse" href="#collapse-5635160ef7307ccb3bfb116a87b12b17" aria-expanded="true">Go进阶训练营(32) <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-5635160ef7307ccb3bfb116a87b12b17" role="tabpanel" aria-labelledby="heading-5635160ef7307ccb3bfb116a87b12b17"><div class="category-post-list"></div><div class="category-sub row"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" id="heading-a41dee97aac19be1190166bbb774caae" role="tab" data-toggle="collapse" href="#collapse-a41dee97aac19be1190166bbb774caae" aria-expanded="false">Week01: 微服务(2) <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-a41dee97aac19be1190166bbb774caae" role="tabpanel" aria-labelledby="heading-a41dee97aac19be1190166bbb774caae"><div class="category-post-list"><a href="/post/go-training-01.html" class="list-group-item list-group-item-action"><span class="category-post">微服务(一) 微服务概览</span> </a><a href="/post/go-training-02.html" class="list-group-item list-group-item-action"><span class="category-post">微服务(二) 服务发现&amp;多租户</span></a></div></div></div><div class="category-sub row"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" id="heading-d164da313d64fe1286b62ba12ecff46b" role="tab" data-toggle="collapse" href="#collapse-d164da313d64fe1286b62ba12ecff46b" aria-expanded="false">Week02: Go错误处理(1) <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-d164da313d64fe1286b62ba12ecff46b" role="tabpanel" aria-labelledby="heading-d164da313d64fe1286b62ba12ecff46b"><div class="category-post-list"><a href="/post/go-training-03.html" class="list-group-item list-group-item-action"><span class="category-post">Go错误处理最佳实践</span></a></div></div></div><div class="category-sub row"><a class="category-subitem list-group-item category-item-action col-10 col-md-11 col-xm-11" id="heading-f10a23eef212070a176eed5d79b6d6ba" role="tab" data-toggle="collapse" href="#collapse-f10a23eef212070a176eed5d79b6d6ba" aria-expanded="true">Week03: Go 并发编程(12) <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-f10a23eef212070a176eed5d79b6d6ba" role="tabpanel" aria-labelledby="heading-f10a23eef212070a176eed5d79b6d6ba"><div class="category-post-list"><a href="/post/go-training-week3-goroutine.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(一) goroutine</span> </a><a href="/post/go-training-week3-go-memory-model.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(二) Go 内存模型</span> </a><a href="/post/go-training-week3-data-race.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(三) data race</span> </a><a href="/post/go-training-week3-sync.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(四) 深入理解 Mutex</span> </a><a href="/post/go-training-week3-atomic.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(五) 深入理解 sync/atomic</span> </a><a href="/post/go-training-week3-waitgroup.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(六) 深入理解 WaitGroup</span> </a><a href="/post/go-training-week3-errgroup.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(七) 深入理解 errgroup</span> </a><a href="/post/go-training-week3-once.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(八) 深入理解 sync.Once</span> </a><a href="/post/go-training-week3-context.html" class="list-group-item list-group-item-action active"><span class="category-post">Go并发编程(九) 深入理解 Context</span> </a><a href="/post/go-training-week3-channel.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(十) 深入理解 Channel</span> </a><a href="/post/go-training-week3-sum.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(十一) 总结</span> </a><a href="/post/go-training-week5-singleflight.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(十二) Singleflight</span></a></div></div></div><div class="category-sub row"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" id="heading-5f1c09a879adce524fb674e873d85f0d" role="tab" data-toggle="collapse" href="#collapse-5f1c09a879adce524fb674e873d85f0d" aria-expanded="false">Week04: Go 工程化(9) <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-5f1c09a879adce524fb674e873d85f0d" role="tabpanel" aria-labelledby="heading-5f1c09a879adce524fb674e873d85f0d"><div class="category-post-list"><a href="/post/go-training-week4-clean-arch.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(一) 架构整洁之道阅读笔记</span> </a><a href="/post/go-training-week4-project-layout.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(二) 项目目录结构</span> </a><a href="/post/go-training-week4-wire.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(三) 依赖注入框架 wire</span> </a><a href="/post/go-training-week4-api-design.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(四) API 设计上: 项目结构 &amp; 设计</span> </a><a href="/post/go-training-week4-protoc-gen-go-gin.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(五) API 设计下: 基于 protobuf 自动生成 gin 代码</span> </a><a href="/post/go-training-week4-config.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(六) 配置管理</span> </a><a href="/post/go-training-week4-go-module.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(七) Go Module</span> </a><a href="/post/go-training-week4-unit-test.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(八) 单元测试</span> </a><a href="/post/go-training-week4-practice.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(九) 项目重构实践</span></a></div></div></div><div class="category-sub row"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" id="heading-edde40ce71fea3216c3528e70a2f78d3" role="tab" data-toggle="collapse" href="#collapse-edde40ce71fea3216c3528e70a2f78d3" aria-expanded="false">Week05: 评论系统架构设计(1) <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-edde40ce71fea3216c3528e70a2f78d3" role="tabpanel" aria-labelledby="heading-edde40ce71fea3216c3528e70a2f78d3"><div class="category-post-list"><a href="/post/go-training-week5-comment-design-1.html" class="list-group-item list-group-item-action"><span class="category-post">评论系统架构设计</span></a></div></div></div><div class="category-sub row"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" id="heading-9e5f96df977f309449649723b9fb267c" role="tab" data-toggle="collapse" href="#collapse-9e5f96df977f309449649723b9fb267c" aria-expanded="false">Week06: 微服务可用性设计(7) <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-9e5f96df977f309449649723b9fb267c" role="tabpanel" aria-labelledby="heading-9e5f96df977f309449649723b9fb267c"><div class="category-post-list"><a href="/post/go-training-week6-usability-1-bulkhe.html" class="list-group-item list-group-item-action"><span class="category-post">Go可用性(一) 隔离设计</span> </a><a href="/post/go-training-week6-2-token-bucket-1.html" class="list-group-item list-group-item-action"><span class="category-post">Go可用性(二) 令牌桶原理及使用</span> </a><a href="/post/go-training-week6-3-token-bucket-2.html" class="list-group-item list-group-item-action"><span class="category-post">Go可用性(三) 令牌桶的实现 rate/limt</span> </a><a href="/post/go-training-week6-4-leaky-bucket.html" class="list-group-item list-group-item-action"><span class="category-post">Go可用性(四) 漏桶算法</span> </a><a href="/post/go-training-week6-4-auto-limiter.html" class="list-group-item list-group-item-action"><span class="category-post">Go可用性(五) 自适应限流</span> </a><a href="/post/go-training-week6-6-breaker.html" class="list-group-item list-group-item-action"><span class="category-post">Go可用性(六) 熔断</span> </a><a href="/post/go-training-week6-7-summary.html" class="list-group-item list-group-item-action"><span class="category-post">Go可用性(七) 总结: 一张图串联可用性知识点</span></a></div></div></div></div></div></div></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Go并发编程(九) 深入理解 Context</h1><div class="markdown-body"><div class="note note-info"><p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p></div><h2 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h2><p>在 <a href="https://lailin.xyz/post/go-training-week3-waitgroup.html">Week03: Go 并发编程(六) 深入理解 WaitGroup</a> 、 <a href="https://lailin.xyz/post/go-training-week3-errgroup.html">Week03: Go 并发编程(七) 深入理解 errgroup</a> 中我们提到了等待多个 goroutine 协作的方式，但是我们现在想一下这么一个常见的场景。现在有一个 Server 服务在执行，当请求来的时候我们启动一个 goroutine 去处理，然后在这个 goroutine 当中有对下游服务的 rpc 调用，也会去请求数据库获取一些数据，这时候如果下游依赖的服务比较慢，但是又没挂，只是很慢，可能一次调用要 1min 才能返回结果，这个时候我们该如何处理？</p><p>如下图所示，首先假设我们使用 WaitGroup 进行控制，等待所有的 goroutine 处理完成之后返回，可以看到我们实际的耗时远远大于了用户可以容忍的时间。<br><img src="https://img.lailin.xyz/image/1610027116078-2e1368bf-015e-4459-8517-73dc858ed083.svg" srcset="/img/loading.gif" lazyload alt="02_Go进阶03_blog_context.drawio.svg"><br>如下图所示，再考虑一个常见的场景，万一上面的 rpc goroutine 很早就报错了，但是 下面的 db goroutine 又执行了很久，我们最后要返回错误信息，很明显后面 db goroutine 执行的这段时间都是在白白的浪费用户的时间。<br><img src="https://img.lailin.xyz/image/1610027303842-4272e9a1-af9c-4804-a779-f72c1f82a1a0.svg" srcset="/img/loading.gif" lazyload alt="02_Go进阶03_blog_context.drawio.svg"></p><p>这时候就应该请出 context 包了，<strong>context 主要就是用来在多个 goroutine 中设置截止日期、同步信号，传递请求相关值。</strong><br><strong>每一次 context 都会从顶层一层一层的传递到下面一层的 goroutine 当上面的 context 取消的时候，下面所有的 context 也会随之取消。</strong><br>**<br>上面的例子当中，如果引入 context 后就会是这样，如下图所示，context 会类似一个树状结构一样依附在每个 goroutine 上，当上层的 req goroutine 的 context 超时之后就会将取消信号同步到下面的所有 goroutine 上一起返回，从而达到超时控制的作用<br><img src="https://img.lailin.xyz/image/1610027726018-4ff7389e-ec4a-4107-99ac-493f587f2a88.svg" srcset="/img/loading.gif" lazyload alt="02_Go进阶03_blog_context.drawio.svg"><br>如下图所示，当 rpc 调用失败之后，会出发 context 取消，然后这个取消信号就会同步到其他的 goroutine 当中<br><img src="https://img.lailin.xyz/image/1610027762059-43c810a8-619e-4f8d-ad74-7a2767635aa0.svg" srcset="/img/loading.gif" lazyload alt="02_Go进阶03_blog_context.drawio.svg"></p><h2 id="package-context"><a href="#package-context" class="headerlink" title="package context"></a>package context</h2><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>在使用一个新的库的时候，我们一般需要先看它的官方说明，得益于 godoc 的约束，所以标准库和第三方库的文档都可以通过 <a target="_blank" rel="noopener" href="https://pkg.go.dev/">pkg.go.dev</a> 进行搜索查询</p><h4 id="使用准则"><a href="#使用准则" class="headerlink" title="使用准则"></a>使用准则</h4><p>context 包一开始就告诉了我们应该怎么用，不应该怎么用，这是应该被共同遵守的约定。</p><ul><li>对 server 应用而言，传入的请求应该创建一个 context，接受</li><li>通过 <code>WithCancel</code> , <code>WithDeadline</code> , <code>WithTimeout</code>  创建的 Context 会同时返回一个 cancel 方法，这个方法必须要被执行，不然会导致 context 泄漏，这个可以通过执行 <code>go vet</code>  命令进行检查</li><li>应该将 <code>context.Context</code>  作为函数的第一个参数进行传递，参数命名一般为 <code>ctx</code>  不应该将 Context 作为字段放在结构体中。</li><li>不要给 context 传递 nil，如果你不知道应该传什么的时候就传递 <code>context.TODO()</code></li><li>不要将函数的可选参数放在 context 当中，context 中一般只放一些全局通用的 metadata 数据，例如 tracing id 等等</li><li>context 是并发安全的可以在多个 goroutine 中并发调用</li></ul><h4 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h4><p>context 包暴露的方法不多，看下方说明即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个带有新的 Done channel 的 context，并且返回一个取消的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span> <span class="hljs-params">(ctx Context, cancel CancelFunc)</span></span><br><span class="hljs-comment">// 创建一个具有截止时间的 context</span><br><span class="hljs-comment">// 截止时间是 d 和 parent(如果有截止时间的话) 的截止时间中更早的那一个</span><br><span class="hljs-comment">// 当 parent 执行完毕，或 cancel 被调用 或者 截止时间到了的时候，这个 context done 掉</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, d time.Time)</span> <span class="hljs-params">(Context, CancelFunc)</span></span><br><span class="hljs-comment">// 其实就是调用的 WithDeadline</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span> <span class="hljs-params">(Context, CancelFunc)</span></span><br><span class="hljs-keyword">type</span> CancelFunc<br><span class="hljs-keyword">type</span> Context<br>	<span class="hljs-comment">// 一般用于创建 root context，这个 context 永远也不会被取消，或者是 done</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Background</span><span class="hljs-params">()</span> <span class="hljs-title">Context</span></span><br>	<span class="hljs-comment">// 底层和 Background 一致，但是含义不同，当不清楚用什么的时候或者是还没准备好的时候可以用它</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TODO</span><span class="hljs-params">()</span> <span class="hljs-title">Context</span></span><br>	<span class="hljs-comment">// 为 context 附加值</span><br>	<span class="hljs-comment">// key 应该具有可比性，一般不应该是 string int 这种默认类型，应该自己创建一个类型</span><br>	<span class="hljs-comment">// 避免出现冲突，一般 key 不应该导出，如果要导出的话应该是一个接口或者是指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Context</span></span><br></code></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="context-Context-接口"><a href="#context-Context-接口" class="headerlink" title="context.Context 接口"></a>context.Context 接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-comment">// 返回当前 context 的结束时间，如果 ok = false 说明当前 context 没有设置结束时间</span><br>	Deadline() (deadline time.Time, ok <span class="hljs-keyword">bool</span>)<br>    <span class="hljs-comment">// 返回一个 channel，用于判断 context 是否结束，多次调用同一个 context done 方法会返回相同的 channel</span><br>	Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>    <span class="hljs-comment">// 当 context 结束时才会返回错误，有两种情况</span><br>    <span class="hljs-comment">// context 被主动调用 cancel 方法取消：Canceled</span><br>    <span class="hljs-comment">// context 超时取消: DeadlineExceeded</span><br>	Err() error<br>    <span class="hljs-comment">// 用于返回 context 中保存的值, 如何查找，这个后面会讲到</span><br>	Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="默认上下文-context-Backgroud"><a href="#默认上下文-context-Backgroud" class="headerlink" title="默认上下文: context.Backgroud"></a>默认上下文: context.Backgroud</h4><p><strong>Backgroud()，</strong>在前面有讲到，  一般用于创建 root context，这个 context 永远也不会被取消，或超时<br>**TODO()， **底层和 Background 一致，但是含义不同，当不清楚用什么的时候或者是还没准备好的时候可以用它</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>	background = <span class="hljs-built_in">new</span>(emptyCtx)<br>	todo       = <span class="hljs-built_in">new</span>(emptyCtx)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Background</span><span class="hljs-params">()</span> <span class="hljs-title">Context</span></span> &#123;<br>	<span class="hljs-keyword">return</span> background<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TODO</span><span class="hljs-params">()</span> <span class="hljs-title">Context</span></span> &#123;<br>	<span class="hljs-keyword">return</span> todo<br>&#125;<br></code></pre></td></tr></table></figure><p>查看源码我们可以发现，background 和 todo 都是实例化了一个 emptyCtx</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> emptyCtx <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Deadline</span><span class="hljs-params">()</span> <span class="hljs-params">(deadline time.Time, ok <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>	<span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Done</span><span class="hljs-params">()</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">struct</span></span>&#123;&#125; &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Err</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Value</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>emptyCtx 就如同他的名字一样，全都返回空值</p><h4 id="如何取消-context-WithCancel"><a href="#如何取消-context-WithCancel" class="headerlink" title="如何取消 context : WithCancel"></a>如何取消 context : WithCancel</h4><p><strong>WithCancel(),</strong> 方法会创建一个可以取消的 context</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span> <span class="hljs-params">(ctx Context, cancel CancelFunc)</span></span> &#123;<br>	<span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>	&#125;<br>    <span class="hljs-comment">// 包装出新的 cancelContext</span><br>	c := newCancelCtx(parent)<br>    <span class="hljs-comment">// 构建父子上下文的联系，确保当父 Context 取消的时候，子 Context 也会被取消</span><br>	propagateCancel(parent, &amp;c)<br>	<span class="hljs-keyword">return</span> &amp;c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不止 WithCancel 方法，其他的 WithXXX 方法也不允许传入一个 nil 值的父 context<br><code>newCancelCtx</code>  只是一个简单的包装就不展开了， <code>propagateCancel</code>  比较有意思，我们一起来看看</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">propagateCancel</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;<br>	<span class="hljs-comment">// 首先判断 parent 能不能被取消</span><br>    done := parent.Done()<br>	<span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-comment">// parent is never canceled</span><br>	&#125;<br><br>    <span class="hljs-comment">// 如果可以，看一下 parent 是不是已经被取消了，已经被取消的情况下直接取消 子 context</span><br>	<span class="hljs-keyword">select</span> &#123;<br>	<span class="hljs-keyword">case</span> &lt;-done:<br>		<span class="hljs-comment">// parent is already canceled</span><br>		child.cancel(<span class="hljs-literal">false</span>, parent.Err())<br>		<span class="hljs-keyword">return</span><br>	<span class="hljs-keyword">default</span>:<br>	&#125;<br><br>    <span class="hljs-comment">// 这里是向上查找可以被取消的 parent context</span><br>	<span class="hljs-keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;<br>        <span class="hljs-comment">// 如果找到了并且没有被取消的话就把这个子 context 挂载到这个 parent context 上</span><br>        <span class="hljs-comment">// 这样只要 parent context 取消了子 context 也会跟着被取消</span><br>		p.mu.Lock()<br>		<span class="hljs-keyword">if</span> p.err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-comment">// parent has already been canceled</span><br>			child.cancel(<span class="hljs-literal">false</span>, p.err)<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">if</span> p.children == <span class="hljs-literal">nil</span> &#123;<br>				p.children = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125;)<br>			&#125;<br>			p.children[child] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>		&#125;<br>		p.mu.Unlock()<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果没有找到的话就会启动一个 goroutine 去监听 parent context 的取消 channel</span><br>        <span class="hljs-comment">// 收到取消信号之后再去调用 子 context 的 cancel 方法</span><br>		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>			<span class="hljs-keyword">select</span> &#123;<br>			<span class="hljs-keyword">case</span> &lt;-parent.Done():<br>				child.cancel(<span class="hljs-literal">false</span>, parent.Err())<br>			<span class="hljs-keyword">case</span> &lt;-child.Done():<br>			&#125;<br>		&#125;()<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们就看看 cancelCtx 长啥样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> &#123;<br>	Context <span class="hljs-comment">// 这里保存的是父 Context</span><br><br>	mu       sync.Mutex            <span class="hljs-comment">// 互斥锁</span><br>	done     <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;         <span class="hljs-comment">// 关闭信号</span><br>	children <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// 保存所有的子 context，当取消的时候会被设置为 nil</span><br>	err      error<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Done 方法这里采用了 懒汉式加载的方式，第一次调用的时候才会去创建这个 channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span> <span class="hljs-title">Done</span><span class="hljs-params">()</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">struct</span></span>&#123;&#125; &#123;<br>	c.mu.Lock()<br>	<span class="hljs-keyword">if</span> c.done == <span class="hljs-literal">nil</span> &#123;<br>		c.done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>	&#125;<br>	d := c.done<br>	c.mu.Unlock()<br>	<span class="hljs-keyword">return</span> d<br>&#125;<br></code></pre></td></tr></table></figure><p>Value 方法很有意思，这里相当于是内部 <code>cancelCtxKey</code>  这个变量的地址作为了一个特殊的 key，当查询这个 key 的时候就会返回当前 context 如果不是这个 key 就会向上递归的去调用 parent context 的 Value 方法查找有没有对应的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span> <span class="hljs-title">Value</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>	<span class="hljs-keyword">if</span> key == &amp;cancelCtxKey &#123;<br>		<span class="hljs-keyword">return</span> c<br>	&#125;<br>	<span class="hljs-keyword">return</span> c.Context.Value(key)<br>&#125;<br></code></pre></td></tr></table></figure><p>在前面讲到构建父子上下文之间的关系的时候，有一个去查找可以被取消的父 context 的方法 <code>parentCancelCtx</code>  就用到了这个特殊 value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parentCancelCtx</span><span class="hljs-params">(parent Context)</span> <span class="hljs-params">(*cancelCtx, <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 这里先判断传入的 parent 是不是永远不可取消的，如果是就直接返回了</span><br>	done := parent.Done()<br>	<span class="hljs-keyword">if</span> done == closedchan || done == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>	&#125;<br><br>    <span class="hljs-comment">// 这里利用了 context.Value 不断向上查询值的特点，只要出现第一个可以取消的 context 的时候就会返回</span><br>    <span class="hljs-comment">// 如果没有的话，这时候 ok 就会等于 false</span><br>	p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)<br>	<span class="hljs-keyword">if</span> !ok &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>	&#125;<br>    <span class="hljs-comment">// 这里去判断返回的 parent 的 channel 和传入的 parent 是不是同一个，是的话就返回这个 parent</span><br>	p.mu.Lock()<br>	ok = p.done == done<br>	p.mu.Unlock()<br>	<span class="hljs-keyword">if</span> !ok &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> p, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来看最重要的这个 cancel 方法，cancel 接收两个参数，removeFromParent 用于确认是不是把自己从 parent context 中移除，err 是 ctx.Err() 最后返回的错误信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span> <span class="hljs-title">cancel</span><span class="hljs-params">(removeFromParent <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;<br>	<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;context: internal error: missing cancel error&quot;</span>)<br>	&#125;<br>	c.mu.Lock()<br>	<span class="hljs-keyword">if</span> c.err != <span class="hljs-literal">nil</span> &#123;<br>		c.mu.Unlock()<br>		<span class="hljs-keyword">return</span> <span class="hljs-comment">// already canceled</span><br>	&#125;<br>	c.err = err<br>    <span class="hljs-comment">// 由于 cancel context 的 done 是懒加载的，所以有可能存在还没有初始化的情况</span><br>	<span class="hljs-keyword">if</span> c.done == <span class="hljs-literal">nil</span> &#123;<br>		c.done = closedchan<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-built_in">close</span>(c.done)<br>	&#125;<br>    <span class="hljs-comment">// 循环的将所有的子 context 取消掉</span><br>	<span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children &#123;<br>		<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span><br>		child.cancel(<span class="hljs-literal">false</span>, err)<br>	&#125;<br>    <span class="hljs-comment">// 将所有的子 context 和当前 context 关系解除</span><br>	c.children = <span class="hljs-literal">nil</span><br>	c.mu.Unlock()<br><br>    <span class="hljs-comment">// 如果需要将当前 context 从 parent context 移除，就移除掉</span><br>	<span class="hljs-keyword">if</span> removeFromParent &#123;<br>		removeChild(c.Context, c)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="超时自动取消如何实现-WithDeadline-WithTimeout"><a href="#超时自动取消如何实现-WithDeadline-WithTimeout" class="headerlink" title="超时自动取消如何实现: WithDeadline, WithTimeout"></a>超时自动取消如何实现: WithDeadline, WithTimeout</h4><p>我们先看看比较常用的 WithTimeout, 可以发现 WithTimeout 其实就是调用了 WithDeadline 然后再传入的参数上用当前时间加上了 timeout 的时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span> <span class="hljs-params">(Context, CancelFunc)</span></span> &#123;<br>	<span class="hljs-keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))<br>&#125;<br></code></pre></td></tr></table></figure><p>再来看一下实现超时的 timerCtx，WithDeadline 我们放到后面一点点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> timerCtx <span class="hljs-keyword">struct</span> &#123;<br>	cancelCtx <span class="hljs-comment">// 这里复用了 cancelCtx</span><br>	timer *time.Timer <span class="hljs-comment">// Under cancelCtx.mu.</span><br><br>	deadline time.Time <span class="hljs-comment">// 这里保存了快到期的时间</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Deadline()</code>  就是返回了结构体中保存的过期时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span> <span class="hljs-title">Deadline</span><span class="hljs-params">()</span> <span class="hljs-params">(deadline time.Time, ok <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>	<span class="hljs-keyword">return</span> c.deadline, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>cancel</code>  其实就是复用了 cancelCtx 中的取消方法，唯一区别的地方就是在后面加上了对 timer 的判断，如果 timer 没有结束主动结束 timer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span> <span class="hljs-title">cancel</span><span class="hljs-params">(removeFromParent <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;<br>	c.cancelCtx.cancel(<span class="hljs-literal">false</span>, err)<br>	<span class="hljs-keyword">if</span> removeFromParent &#123;<br>		<span class="hljs-comment">// Remove this timerCtx from its parent cancelCtx&#x27;s children.</span><br>		removeChild(c.cancelCtx.Context, c)<br>	&#125;<br>	c.mu.Lock()<br>	<span class="hljs-keyword">if</span> c.timer != <span class="hljs-literal">nil</span> &#123;<br>		c.timer.Stop()<br>		c.timer = <span class="hljs-literal">nil</span><br>	&#125;<br>	c.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p>timerCtx 并没有重新实现 Done() 和 Value 方法，直接复用了 cancelCtx 的相关方法</p><p>最后我们再看看这个最重要的 WithDeadline 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, d time.Time)</span> <span class="hljs-params">(Context, CancelFunc)</span></span> &#123;<br>	<span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>	&#125;<br><br>   	<span class="hljs-comment">// 会先判断 parent context 的过期时间，如果过期时间比当前传入的时间要早的话，就没有必要再设置过期时间了</span><br>    <span class="hljs-comment">// 只需要返回 WithCancel 就可以了，因为在 parent 过期的时候，子 context 也会被取消掉</span><br>	<span class="hljs-keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;<br>		<span class="hljs-comment">// The current deadline is already sooner than the new one.</span><br>		<span class="hljs-keyword">return</span> WithCancel(parent)<br>	&#125;<br><br>    <span class="hljs-comment">// 构造相关结构体</span><br>	c := &amp;timerCtx&#123;<br>		cancelCtx: newCancelCtx(parent),<br>		deadline:  d,<br>	&#125;<br><br>    <span class="hljs-comment">// 和 WithCancel 中的逻辑相同，构建上下文关系</span><br>	propagateCancel(parent, c)<br><br>    <span class="hljs-comment">// 判断传入的时间是不是已经过期，如果已经过期了就 cancel 掉然后再返回</span><br>	dur := time.Until(d)<br>	<span class="hljs-keyword">if</span> dur &lt;= <span class="hljs-number">0</span> &#123;<br>		c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded) <span class="hljs-comment">// deadline has already passed</span><br>		<span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">false</span>, Canceled) &#125;<br>	&#125;<br>	c.mu.Lock()<br>	<span class="hljs-keyword">defer</span> c.mu.Unlock()<br><br>    <span class="hljs-comment">// 这里是超时取消的逻辑，启动 timer 时间到了之后就会调用取消方法</span><br>	<span class="hljs-keyword">if</span> c.err == <span class="hljs-literal">nil</span> &#123;<br>		c.timer = time.AfterFunc(dur, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>			c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded)<br>		&#125;)<br>	&#125;<br>	<span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现超时控制其实就是在复用 cancelCtx 的基础上加上了一个 timer 来做定时取消</p><h4 id="如何为-Context-附加一些值-WithValue"><a href="#如何为-Context-附加一些值-WithValue" class="headerlink" title="如何为 Context 附加一些值: WithValue"></a>如何为 Context 附加一些值: WithValue</h4><p>WithValue 相对简单一点，主要就是校验了一下 Key 是不是可比较的，然后构造出一个 valueCtx 的结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Context</span></span> &#123;<br>	<span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>	&#125;<br>	<span class="hljs-keyword">if</span> key == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil key&quot;</span>)<br>	&#125;<br>	<span class="hljs-keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;key is not comparable&quot;</span>)<br>	&#125;<br>	<span class="hljs-keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>valueCtx 主要就是嵌入了 parent context 然后附加了一个 key val</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span> &#123;<br>	Context<br>	key, val <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Value 的查找和之前 cancelCtx 类似，都是先判断当前有没有，没有就向上递归，只是在 cancelCtx 当中 key 是一个固定的 key 而已</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span> <span class="hljs-title">Value</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>	<span class="hljs-keyword">if</span> c.key == key &#123;<br>		<span class="hljs-keyword">return</span> c.val<br>	&#125;<br>	<span class="hljs-keyword">return</span> c.Context.Value(key)<br>&#125;<br></code></pre></td></tr></table></figure><p>Value 就没有实现 Context 接口的其他方法了，其他的方法全都是复用的 parent context 的方法</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h4><p>这就是文章开始时候第一个场景下的一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;context&quot;</span><br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 模拟一个耗时的操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rpc</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br>	time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;rpc done&quot;</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;<br>	data <span class="hljs-keyword">string</span><br>	err  error<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handle</span><span class="hljs-params">(ctx context.Context, ms <span class="hljs-keyword">int</span>)</span></span> &#123;<br>	ctx, cancel := context.WithTimeout(ctx, time.Duration(ms)*time.Millisecond)<br>	<span class="hljs-keyword">defer</span> cancel()<br><br>	r := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> result)<br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		data, err := rpc()<br>		r &lt;- result&#123;data: data, err: err&#125;<br>	&#125;()<br><br>	<span class="hljs-keyword">select</span> &#123;<br>	<span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>		fmt.Printf(<span class="hljs-string">&quot;timeout: %d ms, context exit: %+v\n&quot;</span>, ms, ctx.Err())<br>	<span class="hljs-keyword">case</span> res := &lt;-r:<br>		fmt.Printf(<span class="hljs-string">&quot;result: %s, err: %+v\n&quot;</span>, res.data, res.err)<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// 这里模拟接受请求，启动一个协程去发起请求</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>		time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>		<span class="hljs-keyword">go</span> handle(context.Background(), i*<span class="hljs-number">50</span>)<br>	&#125;<br><br>	<span class="hljs-comment">// for test, hang</span><br>	time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">▶ <span class="hljs-keyword">go</span> run *.<span class="hljs-keyword">go</span><br>timeout: <span class="hljs-number">50</span> ms, context exit: context deadline exceeded<br>result: rpc done, err: &lt;<span class="hljs-literal">nil</span>&gt;<br>result: rpc done, err: &lt;<span class="hljs-literal">nil</span>&gt;<br>result: rpc done, err: &lt;<span class="hljs-literal">nil</span>&gt;<br></code></pre></td></tr></table></figure><p>我们可以发现在第一次执行的时候传入的超时时间 50ms 程序超时直接退出了，但是后面超过 50ms 的时候均返回了结果。</p><h4 id="错误取消"><a href="#错误取消" class="headerlink" title="错误取消"></a>错误取消</h4><p>这是第二个场景的一个例子，假设我们在 main 中并发调用了 <code>f1</code>  <code>f2</code>  两个函数，但是 <code>f1</code>  很快就返回了，但是 <code>f2</code>  还在阻塞</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;context&quot;</span><br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;sync&quot;</span><br>	<span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">(ctx context.Context)</span> <span class="hljs-title">error</span></span> &#123;<br>	<span class="hljs-keyword">select</span> &#123;<br>	<span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;f1: %w&quot;</span>, ctx.Err())<br>	<span class="hljs-keyword">case</span> &lt;-time.After(time.Millisecond): <span class="hljs-comment">// 模拟短时间报错</span><br>		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;f1 err in 1ms&quot;</span>)<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(ctx context.Context)</span> <span class="hljs-title">error</span></span> &#123;<br>	<span class="hljs-keyword">select</span> &#123;<br>	<span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;f2: %w&quot;</span>, ctx.Err())<br>	<span class="hljs-keyword">case</span> &lt;-time.After(time.Hour): <span class="hljs-comment">// 模拟一个耗时操作</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	ctx, cancel := context.WithTimeout(context.Background(), time.Second)<br>	<span class="hljs-keyword">defer</span> cancel()<br><br>	<span class="hljs-keyword">var</span> wg sync.WaitGroup<br>	wg.Add(<span class="hljs-number">2</span>)<br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">defer</span> wg.Done()<br>		<span class="hljs-keyword">if</span> err := f1(ctx); err != <span class="hljs-literal">nil</span> &#123;<br>			fmt.Println(err)<br>			cancel()<br>		&#125;<br>	&#125;()<br><br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">defer</span> wg.Done()<br>		<span class="hljs-keyword">if</span> err := f2(ctx); err != <span class="hljs-literal">nil</span> &#123;<br>			fmt.Println(err)<br>			cancel()<br>		&#125;<br>	&#125;()<br><br>	wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果，可以看到 f1 返回之后 f2 立即就返回了，并且报错 context 被取消</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">▶ <span class="hljs-keyword">go</span> run *.<span class="hljs-keyword">go</span><br>f1 err in <span class="hljs-number">1</span>ms<br>f2: context canceled<br></code></pre></td></tr></table></figure><p>细心的同学可能发现了，这个例子不就是 errgroup 的逻辑么，是的它就是类似 errgroup 的简单逻辑，这时候再反过来去看一下 《<a href="https://lailin.xyz/post/go-training-week3-errgroup.html">Week03: Go 并发编程(七) 深入理解 errgroup - Mohuishou</a>》这篇文章可能会有不一样的体会</p><h4 id="传递共享数据"><a href="#传递共享数据" class="headerlink" title="传递共享数据"></a>传递共享数据</h4><p>一般会用来传递 tracing id, request id 这种数据，不要用来传递可选参数，这里借用一下饶大的一个例子，在实际的生产案例中我们代码也是这样大同小异</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> requestIDKey <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithRequestID</span><span class="hljs-params">(next http.Handler)</span> <span class="hljs-title">http</span>.<span class="hljs-title">Handler</span></span> &#123;<br>	<span class="hljs-keyword">return</span> http.HandlerFunc(<br>		<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;<br>			<span class="hljs-comment">// 从 header 中提取 request-id</span><br>			reqID := req.Header.Get(<span class="hljs-string">&quot;X-Request-ID&quot;</span>)<br>			<span class="hljs-comment">// 创建 valueCtx。使用自定义的类型，不容易冲突</span><br>			ctx := context.WithValue(<br>				req.Context(), requestIDKey, reqID)<br><br>			<span class="hljs-comment">// 创建新的请求</span><br>			req = req.WithContext(ctx)<br><br>			<span class="hljs-comment">// 调用 HTTP 处理函数</span><br>			next.ServeHTTP(rw, req)<br>		&#125;<br>	)<br>&#125;<br><br><span class="hljs-comment">// 获取 request-id</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetRequestID</span><span class="hljs-params">(ctx context.Context)</span> <span class="hljs-title">string</span></span> &#123;<br>	ctx.Value(requestIDKey).(<span class="hljs-keyword">string</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handle</span><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;<br>	<span class="hljs-comment">// 拿到 reqId，后面可以记录日志等等</span><br>	reqID := GetRequestID(req.Context())<br>	...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	handler := WithRequestID(http.HandlerFunc(Handle))<br>	http.ListenAndServe(<span class="hljs-string">&quot;/&quot;</span>, handler)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="在某些情况下可以用来防止-goroutine-泄漏"><a href="#在某些情况下可以用来防止-goroutine-泄漏" class="headerlink" title="在某些情况下可以用来防止 goroutine 泄漏"></a>在某些情况下可以用来防止 goroutine 泄漏</h4><p>我们看一下官方文档的这个例子, 这里面 gen 这个函数中如果不使用 context done 来控制的话就会导致 goroutine 泄漏，因为这里面的 for 是一个死循环，没有 ctx 就没有相关的退出机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// gen generates integers in a separate goroutine and</span><br>	<span class="hljs-comment">// sends them to the returned channel.</span><br>	<span class="hljs-comment">// The callers of gen need to cancel the context once</span><br>	<span class="hljs-comment">// they are done consuming generated integers not to leak</span><br>	<span class="hljs-comment">// the internal goroutine started by gen.</span><br>	gen := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">int</span></span> &#123;<br>		dst := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>		n := <span class="hljs-number">1</span><br>		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>			<span class="hljs-keyword">for</span> &#123;<br>				<span class="hljs-keyword">select</span> &#123;<br>				<span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>					<span class="hljs-keyword">return</span> <span class="hljs-comment">// returning not to leak the goroutine</span><br>				<span class="hljs-keyword">case</span> dst &lt;- n:<br>					n++<br>				&#125;<br>			&#125;<br>		&#125;()<br>		<span class="hljs-keyword">return</span> dst<br>	&#125;<br><br>	ctx, cancel := context.WithCancel(context.Background())<br>	<span class="hljs-keyword">defer</span> cancel() <span class="hljs-comment">// cancel when we are finished consuming integers</span><br><br>	<span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> gen(ctx) &#123;<br>		fmt.Println(n)<br>		<span class="hljs-keyword">if</span> n == <span class="hljs-number">5</span> &#123;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="使用准则-1"><a href="#使用准则-1" class="headerlink" title="使用准则"></a>使用准则</h3><p>context 包一开始就告诉了我们应该怎么用，不应该怎么用，这是应该被共同遵守的约定。</p><ul><li>对 server 应用而言，传入的请求应该创建一个 context，接受</li><li>通过 <code>WithCancel</code> , <code>WithDeadline</code> , <code>WithTimeout</code> 创建的 Context 会同时返回一个 cancel 方法，这个方法必须要被执行，不然会导致 context 泄漏，这个可以通过执行 <code>go vet</code> 命令进行检查</li><li>应该将 <code>context.Context</code> 作为函数的第一个参数进行传递，参数命名一般为 <code>ctx</code> 不应该将 Context 作为字段放在结构体中。</li><li>不要给 context 传递 nil，如果你不知道应该传什么的时候就传递 <code>context.TODO()</code></li><li>不要将函数的可选参数放在 context 当中，context 中一般只放一些全局通用的 metadata 数据，例如 tracing id 等等</li><li>context 是并发安全的可以在多个 goroutine 中并发调用</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>超时控制</li><li>错误取消</li><li>跨 goroutine 数据同步</li><li>防止 goroutine 泄漏</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>最显著的一个就是 context 引入需要修改函数签名，并且会病毒的式的扩散到每个函数上面，不过这个见仁见智，我看着其实还好</li><li>某些情况下虽然是可以做到超时返回提高用户体验，但是实际上是不会退出相关 goroutine 的，这时候可能会导致 goroutine 的泄漏，针对这个我们来看一个例子</li></ul><p>我们使用标准库的 timeout handler 来实现超时控制，底层是通过 context 来实现的。我们设置了超时时间为 1ms 并且在 handler 中模拟阻塞 1000s 不断的请求，然后看 pprof 的 goroutine 数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;net/http&quot;</span><br>	_ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br>	<span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	mux := http.NewServeMux()<br>	mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;<br>		<span class="hljs-comment">// 这里阻塞住，goroutine 不会释放的</span><br>		time.Sleep(<span class="hljs-number">1000</span> * time.Second)<br>		rw.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>))<br>	&#125;)<br>	handler := http.TimeoutHandler(mux, time.Millisecond, <span class="hljs-string">&quot;xxx&quot;</span>)<br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8066&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-built_in">panic</span>(err)<br>		&#125;<br>	&#125;()<br>	http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, handler)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>查看数据我们可以发现请求返回后， goroutine 其实并未回收，但是如果不阻塞的话是会立即回收的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">goroutine profile: total <span class="hljs-number">29</span><br><span class="hljs-number">24</span> @ <span class="hljs-number">0x103b125</span> <span class="hljs-number">0x106cc9f</span> <span class="hljs-number">0x1374110</span> <span class="hljs-number">0x12b9584</span> <span class="hljs-number">0x12bb4ad</span> <span class="hljs-number">0x12c7fbf</span> <span class="hljs-number">0x106fd01</span><br></code></pre></td></tr></table></figure><p>我们来看看它的源码，超时控制主要在 ServeHTTP 中实现，我删掉了部分不关键的数据， 我们可以看到函数内部启动了一个 goroutine 去处理请求逻辑，然后再外面等待，但是这里的问题是，当 context 超时之后 ServeHTTP 这个函数就直接返回了，在这里面启动的这个 goroutine 就没人管了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *timeoutHandler)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w ResponseWriter, r *Request)</span></span> &#123;<br>	ctx := h.testContext<br>	<span class="hljs-keyword">if</span> ctx == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">var</span> cancelCtx context.CancelFunc<br>		ctx, cancelCtx = context.WithTimeout(r.Context(), h.dt)<br>		<span class="hljs-keyword">defer</span> cancelCtx()<br>	&#125;<br>	r = r.WithContext(ctx)<br>	done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>	tw := &amp;timeoutWriter&#123;<br>		w:   w,<br>		h:   <span class="hljs-built_in">make</span>(Header),<br>		req: r,<br>	&#125;<br>	panicChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">1</span>)<br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>			<span class="hljs-keyword">if</span> p := <span class="hljs-built_in">recover</span>(); p != <span class="hljs-literal">nil</span> &#123;<br>				panicChan &lt;- p<br>			&#125;<br>		&#125;()<br>		h.handler.ServeHTTP(tw, r)<br>		<span class="hljs-built_in">close</span>(done)<br>	&#125;()<br>	<span class="hljs-keyword">select</span> &#123;<br>	<span class="hljs-keyword">case</span> p := &lt;-panicChan:<br>		<span class="hljs-built_in">panic</span>(p)<br>	<span class="hljs-keyword">case</span> &lt;-done:<br>		<span class="hljs-comment">// ...</span><br>	<span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>		<span class="hljs-comment">// ...</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>context 是一个优缺点都十分明显的包，这个包目前基本上已经成为了在 go 中做超时控制错误取消的标准做法，但是为了添加超时取消我们需要去修改所有的函数签名，对代码的侵入性比较大，如果之前一直都没有使用后续再添加的话还是会有一些改造成本</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a target="_blank" rel="noopener" href="https://pkg.go.dev/context">context · pkg.go.dev</a></li><li><a target="_blank" rel="noopener" href="https://www.flysnow.org/2017/05/12/go-in-action-go-context.html#%E5%88%9D%E8%AF%86context">Go 语言实战笔记（二十）| Go Context</a></li><li><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">Go 语言并发编程与 Context | Go 语言设计与实现</a></li><li><a target="_blank" rel="noopener" href="https://qcrao.com/2019/06/12/dive-into-go-context/">深度解密 Go 语言之 context | qcrao</a></li><li><a target="_blank" rel="noopener" href="https://blog.golang.org/context">Go Concurrency Patterns: Context - The Go Blog</a></li><li><a target="_blank" rel="noopener" href="https://blog.golang.org/pipelines">Go Concurrency Patterns: Pipelines and cancellation - The Go Blog</a></li></ol><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a class="anchorjs-link" aria-label="Anchor" data-anchorjs-icon="" href="#关注我获取更新" style="font:1em/1 anchorjs-icons;padding-left:.375em"></a></h2><div class="row"><div class="col-lg-6"><img style="width:100%" src="https://img.lailin.xyz/custom/wechat_white.png" srcset="/img/loading.gif" lazyload alt="wechat"></div><div class="col-lg-2 col-4"><a target="_blank" href="http://s.zhihu.com/B4RT3"><img style="width:100%" src="https://img.lailin.xyz/custom/zhihu.png" srcset="/img/loading.gif" lazyload alt="知乎"></a></div><div class="col-lg-2 col-4"><a target="_blank" href="https://github.com/mohuishou"><img style="width:100%" src="https://img.lailin.xyz/custom/github.png" srcset="/img/loading.gif" lazyload alt="github"></a></div></div><script>document.addEventListener("DOMContentLoaded",t=>{let e=$("#toc");if(!(e.height()<1)){let t=`
  <a
    class="fancybox fancybox.image"
    target="_blank" href="https://img.lailin.xyz/custom/wechat_white.png"
    itemscope=""
    itemtype="http://schema.org/ImageObject"
    itemprop="url"
    data-fancybox="default"
    rel="default noopener"
    title="wechat"
    data-caption="wechat"
    ><img
      style="width: 80%; margin-left: 1rem;"
      src="https://img.lailin.xyz/custom/wechat_white.png" srcset="/img/loading.gif" lazyload
      srcset="https://img.lailin.xyz/custom/wechat_white.png"
      alt="wechat"
    />
    </a>
  `;e.append(t.replace(/srcset.*?"/,""))}})</script><h2 id="猜你喜欢">猜你喜欢</h2><ul><li><a href="/post/go-training-week3-atomic.html" rel="recommend">Go并发编程(五) 深入理解 sync/atomic</a> <span></span></li><li><a href="/post/go-training-week3-errgroup.html" rel="recommend">Go并发编程(七) 深入理解 errgroup</a> <span></span></li><li><a href="/post/go-training-week3-channel.html" rel="recommend">Go并发编程(十) 深入理解 Channel</a> <span></span></li><li><a href="/post/go-training-week3-data-race.html" rel="recommend">Go并发编程(三) data race</a> <span></span></li><li><a href="/post/go-training-week3-go-memory-model.html" rel="recommend">Go并发编程(二) Go 内存模型</a> <span></span></li></ul></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">Go进阶训练营</a> <a class="hover-with-bg" href="/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week03-Go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Week03: Go 并发编程</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Go/">Go</a> <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> <a class="hover-with-bg" href="/tags/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">Go进阶训练营</a> <a class="hover-with-bg" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a> <a class="hover-with-bg" href="/tags/context/">context</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a>，转载请注明出处，禁止全文转载</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/post/go-training-week3-channel.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Go并发编程(十) 深入理解 Channel</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/post/go-training-week3-once.html"><span class="hidden-mobile">Go并发编程(八) 深入理解 sync.Once</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){var t="github-light",e="github-dark",s="dark"===(s=document.documentElement.getAttribute("data-user-color-scheme"))?e:t;window.UtterancesThemeLight=t,window.UtterancesThemeDark=e;e=document.createElement("script");e.setAttribute("src","https://utteranc.es/client.js"),e.setAttribute("repo","scuplus/blogComment"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",s),e.setAttribute("crossorigin","anonymous"),document.getElementById("comments").appendChild(e)})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div><div id="bottom"><div id="bottom-drawer" class="bottom-drawer"><div class="category-list"><div class="category row"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" id="heading-5635160ef7307ccb3bfb116a87b12b17" role="tab" data-toggle="collapse" href="#collapse-5635160ef7307ccb3bfb116a87b12b17" aria-expanded="true">Go进阶训练营(32) <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-5635160ef7307ccb3bfb116a87b12b17" role="tabpanel" aria-labelledby="heading-5635160ef7307ccb3bfb116a87b12b17"><div class="category-post-list"></div><div class="category-sub row"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" id="heading-a41dee97aac19be1190166bbb774caae" role="tab" data-toggle="collapse" href="#collapse-a41dee97aac19be1190166bbb774caae" aria-expanded="false">Week01: 微服务(2) <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-a41dee97aac19be1190166bbb774caae" role="tabpanel" aria-labelledby="heading-a41dee97aac19be1190166bbb774caae"><div class="category-post-list"><a href="/post/go-training-01.html" class="list-group-item list-group-item-action"><span class="category-post">微服务(一) 微服务概览</span> </a><a href="/post/go-training-02.html" class="list-group-item list-group-item-action"><span class="category-post">微服务(二) 服务发现&amp;多租户</span></a></div></div></div><div class="category-sub row"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" id="heading-d164da313d64fe1286b62ba12ecff46b" role="tab" data-toggle="collapse" href="#collapse-d164da313d64fe1286b62ba12ecff46b" aria-expanded="false">Week02: Go错误处理(1) <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-d164da313d64fe1286b62ba12ecff46b" role="tabpanel" aria-labelledby="heading-d164da313d64fe1286b62ba12ecff46b"><div class="category-post-list"><a href="/post/go-training-03.html" class="list-group-item list-group-item-action"><span class="category-post">Go错误处理最佳实践</span></a></div></div></div><div class="category-sub row"><a class="category-subitem list-group-item category-item-action col-10 col-md-11 col-xm-11" id="heading-f10a23eef212070a176eed5d79b6d6ba" role="tab" data-toggle="collapse" href="#collapse-f10a23eef212070a176eed5d79b6d6ba" aria-expanded="true">Week03: Go 并发编程(12) <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-f10a23eef212070a176eed5d79b6d6ba" role="tabpanel" aria-labelledby="heading-f10a23eef212070a176eed5d79b6d6ba"><div class="category-post-list"><a href="/post/go-training-week3-goroutine.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(一) goroutine</span> </a><a href="/post/go-training-week3-go-memory-model.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(二) Go 内存模型</span> </a><a href="/post/go-training-week3-data-race.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(三) data race</span> </a><a href="/post/go-training-week3-sync.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(四) 深入理解 Mutex</span> </a><a href="/post/go-training-week3-atomic.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(五) 深入理解 sync/atomic</span> </a><a href="/post/go-training-week3-waitgroup.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(六) 深入理解 WaitGroup</span> </a><a href="/post/go-training-week3-errgroup.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(七) 深入理解 errgroup</span> </a><a href="/post/go-training-week3-once.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(八) 深入理解 sync.Once</span> </a><a href="/post/go-training-week3-context.html" class="list-group-item list-group-item-action active"><span class="category-post">Go并发编程(九) 深入理解 Context</span> </a><a href="/post/go-training-week3-channel.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(十) 深入理解 Channel</span> </a><a href="/post/go-training-week3-sum.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(十一) 总结</span> </a><a href="/post/go-training-week5-singleflight.html" class="list-group-item list-group-item-action"><span class="category-post">Go并发编程(十二) Singleflight</span></a></div></div></div><div class="category-sub row"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" id="heading-5f1c09a879adce524fb674e873d85f0d" role="tab" data-toggle="collapse" href="#collapse-5f1c09a879adce524fb674e873d85f0d" aria-expanded="false">Week04: Go 工程化(9) <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-5f1c09a879adce524fb674e873d85f0d" role="tabpanel" aria-labelledby="heading-5f1c09a879adce524fb674e873d85f0d"><div class="category-post-list"><a href="/post/go-training-week4-clean-arch.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(一) 架构整洁之道阅读笔记</span> </a><a href="/post/go-training-week4-project-layout.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(二) 项目目录结构</span> </a><a href="/post/go-training-week4-wire.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(三) 依赖注入框架 wire</span> </a><a href="/post/go-training-week4-api-design.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(四) API 设计上: 项目结构 &amp; 设计</span> </a><a href="/post/go-training-week4-protoc-gen-go-gin.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(五) API 设计下: 基于 protobuf 自动生成 gin 代码</span> </a><a href="/post/go-training-week4-config.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(六) 配置管理</span> </a><a href="/post/go-training-week4-go-module.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(七) Go Module</span> </a><a href="/post/go-training-week4-unit-test.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(八) 单元测试</span> </a><a href="/post/go-training-week4-practice.html" class="list-group-item list-group-item-action"><span class="category-post">Go工程化(九) 项目重构实践</span></a></div></div></div><div class="category-sub row"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" id="heading-edde40ce71fea3216c3528e70a2f78d3" role="tab" data-toggle="collapse" href="#collapse-edde40ce71fea3216c3528e70a2f78d3" aria-expanded="false">Week05: 评论系统架构设计(1) <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-edde40ce71fea3216c3528e70a2f78d3" role="tabpanel" aria-labelledby="heading-edde40ce71fea3216c3528e70a2f78d3"><div class="category-post-list"><a href="/post/go-training-week5-comment-design-1.html" class="list-group-item list-group-item-action"><span class="category-post">评论系统架构设计</span></a></div></div></div><div class="category-sub row"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" id="heading-9e5f96df977f309449649723b9fb267c" role="tab" data-toggle="collapse" href="#collapse-9e5f96df977f309449649723b9fb267c" aria-expanded="false">Week06: 微服务可用性设计(7) <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-9e5f96df977f309449649723b9fb267c" role="tabpanel" aria-labelledby="heading-9e5f96df977f309449649723b9fb267c"><div class="category-post-list"><a href="/post/go-training-week6-usability-1-bulkhe.html" class="list-group-item list-group-item-action"><span class="category-post">Go可用性(一) 隔离设计</span> </a><a href="/post/go-training-week6-2-token-bucket-1.html" class="list-group-item list-group-item-action"><span class="category-post">Go可用性(二) 令牌桶原理及使用</span> </a><a href="/post/go-training-week6-3-token-bucket-2.html" class="list-group-item list-group-item-action"><span class="category-post">Go可用性(三) 令牌桶的实现 rate/limt</span> </a><a href="/post/go-training-week6-4-leaky-bucket.html" class="list-group-item list-group-item-action"><span class="category-post">Go可用性(四) 漏桶算法</span> </a><a href="/post/go-training-week6-4-auto-limiter.html" class="list-group-item list-group-item-action"><span class="category-post">Go可用性(五) 自适应限流</span> </a><a href="/post/go-training-week6-6-breaker.html" class="list-group-item list-group-item-action"><span class="category-post">Go可用性(六) 熔断</span> </a><a href="/post/go-training-week6-7-summary.html" class="list-group-item list-group-item-action"><span class="category-post">Go可用性(七) 总结: 一张图串联可用性知识点</span></a></div></div></div></div></div></div><div id="toc-mobile"><div class="toc-body" id="toc-body-mobile"></div></div></div><div id="bottom-tab"><a class="sub-menu" onclick='showBottomDrawer(this,"#bottom-drawer .category-list")'><i class="iconfont"></i> 章节 </a><a class="sub-menu" onclick='showBottomDrawer(this,"#bottom-drawer #toc-mobile")'><i class="iconfont"></i> 目录 </a><a href="#comments" class="sub-menu" onclick='showBottomDrawer(this,"#comments")'><i class="iconfont"></i> 评论</a></div></div><script>function showBottomDrawer(s,t){let e=document.querySelector("#bottom-tab");e.childNodes.forEach(t=>{t!=s&&t.classList&&t.classList.remove("active")}),"#comments"!=t&&s.classList.toggle("active");let o=document.querySelector("#bottom-drawer"),c=document.querySelector(t);o.childNodes.forEach(t=>{t!=c&&t.classList&&t.classList.remove("active")}),c.classList.toggle("active"),"#comments"!=t?(c.classList.contains("active")&&!o.classList.contains("active")&&o.classList.add("active"),!c.classList.contains("active")&&o.classList.contains("active")&&o.classList.remove("active")):o.classList.remove("active")}document.onreadystatechange=function(t){let s=$("#bottom-drawer");s.height()<=0||window.tocbot.init({tocSelector:"#toc-body-mobile",contentSelector:".markdown-body",headingSelector:"h1,h2,h3,h4",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:20})}</script></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><script>!function(e,s,p){var r;void 0===e.webpushr&&(e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)},r=s.getElementsByTagName(p)[0],(p=s.createElement(p)).id="webpushr-jssdk",p.async=1,p.src="https://cdn.webpushr.com/app.min.js",r.parentNode.appendChild(p))}(window,document,"script"),webpushr("setup",{key:"BBkZb7rpvsVqVNkORXD9T9T93MJodtpNJD5c1f2HE_XsED3r94An3CKObdyTJ6ub3ARm9LIdeDCVzKLBsK760NM"})</script></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">蜀ICP备15014307号-3</a></span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events-33e028d78bd6a0739c153c52ae09fc4b.js"></script><script src="/js/plugins-0fbde8af13687afd5119855d6d8cc6c0.js"></script><script src="/js/local-search-336cd0153d3a0c907001488f0c1acbb3.js"></script><script src="/js/img-lazyload-906050e291c80575119e9a45011fed62.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script defer>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-137859264-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script src="/js/boot-e2e7defad6d45a0409b0143389c87de0.js"></script></body></html>