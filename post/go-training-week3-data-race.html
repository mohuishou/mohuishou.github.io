<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/icons/touch-icon-apple.png"><link rel="icon" type="image/png" href="/icons/favicon-32x32.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content><meta name="author" content="Mohuishou"><meta name="keywords" content="Go, Docker, PHP"><title>Week03: Go并发编程(三) data race - Mohuishou</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/assets/css/custom.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>mohuishou</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item"><a class="nav-link" href="/atom.xml"><i class="iconfont icon-rss"></i> rss</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/img/bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-12-07 13:38" pubdate>2020年12月7日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 47 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">Week03: Go并发编程(三) data race</h1><div class="markdown-body" id="post-body"><blockquote><p>本系列为极客时间 Go 进阶训练营笔记，同步直播更新，预计一周更新 1 ~ 2 篇文章，到 202103 月更新完成</p></blockquote><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在前两篇文章当中我们反复提到了虽然在 go 中，并发编程十分简单，我们只需要使用 <code>go func()</code> 就能启动一个 goroutine 去做一些事情，但是正是由于这种简单我们要十分当心，不然很容易出现一些莫名其妙的 bug 或者是你的服务由于不知名的原因就重启了。</p><h2 id="数据竞争-data-race"><a href="#数据竞争-data-race" class="headerlink" title="数据竞争(data race)"></a>数据竞争(data race)</h2><p>之前我们提到了很多次在多个 goroutine 对同一个变量的数据进行修改的时候会出现很多奇奇怪怪的问题，那我们有没有什么办法检测它呢，除了通过我们聪明的脑袋？</p><p>答案就是 data race tag，go 官方早在 1.1 版本就引入了数据竞争的检测工具，我们只需要在执行测试或者是编译的时候加上 <code>-race</code> 的 flag 就可以开启数据竞争的检测</p><pre><code class="hljs go"><span class="hljs-keyword">go</span> test -race ./...
<span class="hljs-keyword">go</span> build -race</code></pre><div style="background:#fffbe6;padding:10px;border:1px solid #c3c3c3;border-radius:5px;margin-bottom:5px">不建议在生产环境 build 的时候开启数据竞争检测，因为这会带来一定的性能损失(一般内存5-10倍，执行时间2-20倍)，当然 必须要 debug 的时候除外。<br>建议在执行单元测试时始终开启数据竞争的检测。</div><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p>我们来直接看一下下面的这个例子，这是来自课上的一个例子，但是我稍稍做了一些改造，源代码没有跑 10w 次这个操作，会导致看起来每次跑的结果都是差不多的，我们只需要把这个次数放大就可以发现每次结果都会不一样</p><h4 id="正常执行"><a href="#正常执行" class="headerlink" title="正常执行"></a>正常执行</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"sync"</span>
)

<span class="hljs-keyword">var</span> wg sync.WaitGroup
<span class="hljs-keyword">var</span> counter <span class="hljs-keyword">int</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">// 多跑几次来看结果</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++ &#123;
		run()
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; i++ &#123;
		wg.Add(<span class="hljs-number">1</span>)
		<span class="hljs-keyword">go</span> routine(i)
	&#125;
	wg.Wait()
	fmt.Printf(<span class="hljs-string">"Final Counter: %d\n"</span>, counter)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">routine</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span></span> &#123;
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;
		value := counter
		value++
		counter = value
	&#125;
	wg.Done()
&#125;</code></pre><p>我执行了三次每次的结果都不一致，分别是:</p><pre><code class="hljs go">Final Counter: <span class="hljs-number">399996</span>
Final Counter: <span class="hljs-number">399989</span>
Final Counter: <span class="hljs-number">399988</span></code></pre><p>为什么会导致这样的结果呢，是因为每一次执行的时候，我们都使用 <code>go routine(i)</code> 启动了两个 goroutine，但是我们并没有控制它的执行顺序，那就有好几种可能了，我这里描述两种情况</p><ol><li>执行一次 <code>run()</code> , <code>counter + 4</code> 这种情况下，第二个 goroutine 开始执行时，拿到了第一个 goroutine 的执行结果，也就是 <code>value := counter</code> 这一步时，value = 2</li><li>执行一次 <code>run()</code> , <code>counter + 2</code> 这种情况下，第二个 goroutine 开始执行时，没有拿到了第一个 goroutine 的执行结果，也就是 <code>value := counter</code> 这一步时，counter 还是零值，这时候 value = 0</li></ol><p>当然由于种种不确定性，所有肯定不止这两种情况，但是这个不是本文讨论的重点，具体的原因可以结合上一篇文章 <a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go 并发编程(二) Go 内存模型</a> 进行思考</p><h4 id="data-race-执行"><a href="#data-race-执行" class="headerlink" title="data race 执行"></a>data race 执行</h4><p>可以发现，写出这种代码时上线后如果出现 bug 会非常难定位，因为你不知道到底是哪里出现了问题，所以我们就要在测试阶段就结合 data race 工具提前发现问题。<br>我们执行以下命令</p><pre><code class="hljs go"><span class="hljs-keyword">go</span> run -race ./main.<span class="hljs-keyword">go</span></code></pre><p>会发现结果会所有的都输出， <code>data race</code> 的报错信息，我们已经看不到了，因为终端的打印的太长了，可以发现的是，最后打印出发现了一处 data race 并且推出码为 <code>66</code></p><pre><code class="hljs go">Final Counter: <span class="hljs-number">399956</span>
Final Counter: <span class="hljs-number">399960</span>
Found <span class="hljs-number">1</span> data race(s)
exit status <span class="hljs-number">66</span></code></pre><h4 id="data-race-配置"><a href="#data-race-配置" class="headerlink" title="data race 配置"></a>data race 配置</h4><p>问题来了，我们有没有什么办法可以立即知道 data race 的报错呢？<br>答案就在官方的文档当中，我们可以通过设置 <code>GORACE</code> 环境变量，来控制 data race 的行为， 格式如下:</p><pre><code class="hljs go">GORACE=<span class="hljs-string">"option1=val1 option2=val2"</span></code></pre><p>可选配置:</p><table><thead><tr><th><strong>配置</strong></th><th><strong>默认值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>log_path</td><td>stderr</td><td>日志文件的路径，除了文件路径外支持 stderr, stdout 这两个特殊值</td></tr><tr><td>exitcode</td><td>66</td><td>退出码</td></tr><tr><td>strip_path_prefix</td><td>“”</td><td>从日志中的文件信息里面去除相关的前缀，可以去除本地信息，同时会更好看</td></tr><tr><td>history_size</td><td>1</td><td>per-goroutine 内存访问历史记录为 32K * 2 ** history_size，增加这个可以避免出现堆栈还原失败的错误，但是增加这个会导致使用的内存也跟着增加</td></tr><tr><td>halt_on_error</td><td>0</td><td>用来控制第一个数据竞争错误出现后是否立即退出</td></tr><tr><td>atexit_sleep_ms</td><td>100</td><td>用来控制 main 退出之前 sleep 的时间</td></tr></tbody></table><p>有了这个背景知识后就很简单了，在我们这个场景我们可以控制发现数据竞争后直接退出</p><pre><code class="hljs go">GORACE=<span class="hljs-string">"halt_on_error=1 strip_path_prefix=/home/ll/project/Go-000/Week03/blog/03_sync/01_data_race"</span> <span class="hljs-keyword">go</span> run -race ./main.<span class="hljs-keyword">go</span></code></pre><p>重新执行后我们的结果</p><pre><code class="hljs go">==================
WARNING: DATA RACE
Read at <span class="hljs-number">0x00000064a9c0</span> by goroutine <span class="hljs-number">7</span>:
  main.routine()
      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">29</span> +<span class="hljs-number">0x47</span>

Previous write at <span class="hljs-number">0x00000064a9c0</span> by goroutine <span class="hljs-number">8</span>:
  main.routine()
      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">31</span> +<span class="hljs-number">0x64</span>

Goroutine <span class="hljs-number">7</span> (running) created at:
  main.run()
      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">21</span> +<span class="hljs-number">0x75</span>
  main.main()
      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span> +<span class="hljs-number">0x38</span>

Goroutine <span class="hljs-number">8</span> (finished) created at:
  main.run()
      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">21</span> +<span class="hljs-number">0x75</span>
  main.main()
      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span> +<span class="hljs-number">0x38</span>
==================
exit status <span class="hljs-number">66</span></code></pre><p>这个结果非常清晰的告诉了我们在 29 行这个地方我们有一个 goroutine 在读取数据，但是呢，在 31 行这个地方又有一个 goroutine 在写入，所以产生了数据竞争。<br>然后下面分别说明这两个 goroutine 是什么时候创建的，已经当前是否在运行当中。</p><h3 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h3><p>接来下我们再来看一些典型案例，这些案例都来自 go 官方的文档 <a href="https://golang.org/doc/articles/race_detector.html" target="_blank" rel="noopener">Data Race Detector</a>，这些也是初学者很容易犯的错误</p><h4 id="案例二-在循环中启动-goroutine-引用临时变量"><a href="#案例二-在循环中启动-goroutine-引用临时变量" class="headerlink" title="案例二 在循环中启动 goroutine 引用临时变量"></a>案例二 在循环中启动 goroutine 引用临时变量</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> wg sync.WaitGroup
	wg.Add(<span class="hljs-number">5</span>)
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			fmt.Println(i) <span class="hljs-comment">// Not the 'i' you are looking for.</span>
			wg.Done()
		&#125;()
	&#125;
	wg.Wait()
&#125;</code></pre><p>如果你去找一些 go 的面试题，肯定能找到类似的例子，然后会问你这里会输出什么？<br>常见的答案就是会输出 5 个 5，因为在 for 循环的 i++ 会执行的快一些，所以在最后打印的结果都是 5<br>这个答案不能说不对，因为真的执行的话大概率也是这个结果，但是不全<br>因为这里本质上是有数据竞争，在新启动的 goroutine 当中读取 i 的值，在 main 中写入，导致出现了 data race，这个结果应该是不可预知的，因为我们不能假定 goroutine 中 print 就一定比外面的 i++ 慢，习惯性的做这种假设在并发编程中是很有可能会出问题的</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> wg sync.WaitGroup
	wg.Add(<span class="hljs-number">5</span>)
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;
			fmt.Println(i)
			wg.Done()
		&#125;(i)
	&#125;
	wg.Wait()
&#125;</code></pre><p>这个要修改也很简单，只需要将 i 作为参数传入即可，这样每个 goroutine 拿到的都是拷贝后的数据</p><h4 id="案例三-一不小心就把变量共享了"><a href="#案例三-一不小心就把变量共享了" class="headerlink" title="案例三 一不小心就把变量共享了"></a>案例三 一不小心就把变量共享了</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">"os"</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	ParallelWrite([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">"xxx"</span>))
&#125;

<span class="hljs-comment">// ParallelWrite writes data to file1 and file2, returns the errors.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParallelWrite</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">chan</span> <span class="hljs-title">error</span></span> &#123;
	res := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> error, <span class="hljs-number">2</span>)
	f1, err := os.Create(<span class="hljs-string">"/tmp/file1"</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		res &lt;- err
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			<span class="hljs-comment">// This err is shared with the main goroutine,</span>
			<span class="hljs-comment">// so the write races with the write below.</span>
			_, err = f1.Write(data)
			res &lt;- err
			f1.Close()
		&#125;()
	&#125;
	f2, err := os.Create(<span class="hljs-string">"/tmp/file2"</span>) <span class="hljs-comment">// The second conflicting write to err.</span>
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		res &lt;- err
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			_, err = f2.Write(data)
			res &lt;- err
			f2.Close()
		&#125;()
	&#125;
	<span class="hljs-keyword">return</span> res
&#125;</code></pre><p>我们使用 <code>go run -race main.go</code> 执行，可以发现这里报错的地方是，19 行和 24 行，有 data race，这里主要是因为共享了 err 这个变量</p><pre><code class="hljs go">==================
WARNING: DATA RACE
Write at <span class="hljs-number">0x00c0000a01a0</span> by goroutine <span class="hljs-number">7</span>:
  main.ParallelWrite.func1()
      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">19</span> +<span class="hljs-number">0x94</span>

Previous write at <span class="hljs-number">0x00c0000a01a0</span> by main goroutine:
  main.ParallelWrite()
      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">24</span> +<span class="hljs-number">0x1dd</span>
  main.main()
      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">6</span> +<span class="hljs-number">0x84</span>

Goroutine <span class="hljs-number">7</span> (running) created at:
  main.ParallelWrite()
      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">16</span> +<span class="hljs-number">0x336</span>
  main.main()
      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">6</span> +<span class="hljs-number">0x84</span>
==================
Found <span class="hljs-number">1</span> data race(s)
exit status <span class="hljs-number">66</span></code></pre><p>修改的话只需要在两个 goroutine 中使用新的临时变量就行了</p><pre><code class="hljs go">...
_, err := f1.Write(data)
...
_, err := f2.Write(data)
...</code></pre><p>细心的同学可能会有这个疑问，在 24 行不也是重新赋值了么，为什么在这里会和 19 行产生 data race 呢？<br>这是由于 go 的语法规则导致的，我们在初始化变量的时候如果在同一个作用域下，如下方代码，这里使用的 err 其实是同一个变量，只是 f1 f2 不同，具体可以看 <a href="https://golang.org/doc/effective_go.html#redeclaration" target="_blank" rel="noopener">effective go 当中 Redeclaration and reassignment</a> 的内容</p><pre><code class="hljs go">f1, err := os.Create(<span class="hljs-string">"a"</span>)
f2, err := os.Create(<span class="hljs-string">"b"</span>)</code></pre><h4 id="案例四-不受保护的全局变量"><a href="#案例四-不受保护的全局变量" class="headerlink" title="案例四 不受保护的全局变量"></a>案例四 不受保护的全局变量</h4><pre><code class="hljs go"><span class="hljs-keyword">var</span> service = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;&#125;

<span class="hljs-comment">// RegisterService RegisterService</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterService</span><span class="hljs-params">(name, addr <span class="hljs-keyword">string</span>)</span></span> &#123;
	service[name] = addr
&#125;

<span class="hljs-comment">// LookupService LookupService</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LookupService</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> service[name]
&#125;</code></pre><p>这个也是很容易犯的一个错，在之前写 Go 设计模式这个系列文章的时候，应该有提到过我们要写出可测性比较高的代码就要少用或者是尽量避免用全局变量，使用 map 作为全局变量比较常见的一种情况就是配置信息。关于全局变量的话一般的做法就是加锁，就本文这个问题也可以使用 sync.Map 这个下一篇文章会讲，这里篇幅有限就不多讲了</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> (
	service   <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>
	serviceMu sync.Mutex
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterService</span><span class="hljs-params">(name, addr <span class="hljs-keyword">string</span>)</span></span> &#123;
	serviceMu.Lock()
	<span class="hljs-keyword">defer</span> serviceMu.Unlock()
	service[name] = addr
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LookupService</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;
	serviceMu.Lock()
	<span class="hljs-keyword">defer</span> serviceMu.Unlock()
	<span class="hljs-keyword">return</span> service[name]
&#125;</code></pre><h4 id="案例五-未受保护的成员变量"><a href="#案例五-未受保护的成员变量" class="headerlink" title="案例五 未受保护的成员变量"></a>案例五 未受保护的成员变量</h4><pre><code class="hljs go"><span class="hljs-keyword">type</span> Watchdog <span class="hljs-keyword">struct</span>&#123; last <span class="hljs-keyword">int64</span> &#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Watchdog)</span> <span class="hljs-title">KeepAlive</span><span class="hljs-params">()</span></span> &#123;
	w.last = time.Now().UnixNano() <span class="hljs-comment">// First conflicting access.</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Watchdog)</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		<span class="hljs-keyword">for</span> &#123;
			time.Sleep(time.Second)
			<span class="hljs-comment">// Second conflicting access.</span>
			<span class="hljs-keyword">if</span> w.last &lt; time.Now().Add(<span class="hljs-number">-10</span>*time.Second).UnixNano() &#123;
				fmt.Println(<span class="hljs-string">"No keepalives for 10 seconds. Dying."</span>)
				os.Exit(<span class="hljs-number">1</span>)
			&#125;
		&#125;
	&#125;()
&#125;</code></pre><p>同样成员变量也会有这个问题，这里可以用 <code>atomic</code> 包来解决，同样这个我们下篇文章会细讲</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Watchdog <span class="hljs-keyword">struct</span>&#123; last <span class="hljs-keyword">int64</span> &#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Watchdog)</span> <span class="hljs-title">KeepAlive</span><span class="hljs-params">()</span></span> &#123;
	atomic.StoreInt64(&amp;w.last, time.Now().UnixNano())
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Watchdog)</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		<span class="hljs-keyword">for</span> &#123;
			time.Sleep(time.Second)
			<span class="hljs-keyword">if</span> atomic.LoadInt64(&amp;w.last) &lt; time.Now().Add(<span class="hljs-number">-10</span>*time.Second).UnixNano() &#123;
				fmt.Println(<span class="hljs-string">"No keepalives for 10 seconds. Dying."</span>)
				os.Exit(<span class="hljs-number">1</span>)
			&#125;
		&#125;
	&#125;()
&#125;</code></pre><h3 id="案例六-一个有趣的例子"><a href="#案例六-一个有趣的例子" class="headerlink" title="案例六 一个有趣的例子"></a>案例六 一个有趣的例子</h3><p>dava 在博客中提到过一个很有趣的例子的 <a href="https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races" target="_blank" rel="noopener">Ice cream makers and data races</a></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>

<span class="hljs-keyword">type</span> IceCreamMaker <span class="hljs-keyword">interface</span> &#123;
	<span class="hljs-comment">// Great a customer.</span>
	Hello()
&#125;

<span class="hljs-keyword">type</span> Ben <span class="hljs-keyword">struct</span> &#123;
	name <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Ben)</span> <span class="hljs-title">Hello</span><span class="hljs-params">()</span></span> &#123;
	fmt.Printf(<span class="hljs-string">"Ben says, \"Hello my name is %s\"\n"</span>, b.name)
&#125;

<span class="hljs-keyword">type</span> Jerry <span class="hljs-keyword">struct</span> &#123;
	name <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j *Jerry)</span> <span class="hljs-title">Hello</span><span class="hljs-params">()</span></span> &#123;
	fmt.Printf(<span class="hljs-string">"Jerry says, \"Hello my name is %s\"\n"</span>, j.name)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> ben = &amp;Ben&#123;name: <span class="hljs-string">"Ben"</span>&#125;
	<span class="hljs-keyword">var</span> jerry = &amp;Jerry&#123;<span class="hljs-string">"Jerry"</span>&#125;
	<span class="hljs-keyword">var</span> maker IceCreamMaker = ben

	<span class="hljs-keyword">var</span> loop0, loop1 <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>

	loop0 = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		maker = ben
		<span class="hljs-keyword">go</span> loop1()
	&#125;

	loop1 = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		maker = jerry
		<span class="hljs-keyword">go</span> loop0()
	&#125;

	<span class="hljs-keyword">go</span> loop0()

	<span class="hljs-keyword">for</span> &#123;
		maker.Hello()
	&#125;
&#125;</code></pre><p>这个例子有趣的点在于，最后输出的结果会有这种例子</p><pre><code class="hljs go">Ben says, <span class="hljs-string">"Hello my name is Jerry"</span>
Ben says, <span class="hljs-string">"Hello my name is Jerry"</span></code></pre><p>这是因为我们在 <code>maker = jerry</code> 这种赋值操作的时候并不是原子的，在上一篇文章中我们讲到过，只有对 single machine word 进行赋值的时候才是原子的，虽然这个看上去只有一行，但是 interface 在 go 中其实是一个结构体，它包含了 type 和 data 两个部分，所以它的复制也不是原子的，会出现问题</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-keyword">interface</span> <span class="hljs-keyword">struct</span> &#123;
       Type <span class="hljs-keyword">uintptr</span>     <span class="hljs-comment">// points to the type of the interface implementation</span>
       Data <span class="hljs-keyword">uintptr</span>     <span class="hljs-comment">// holds the data for the interface's receiver</span>
&#125;</code></pre><p>这个案例有趣的点还在于，这个案例的两个结构体的内存布局一模一样所以出现错误也不会 panic 退出，如果在里面再加入一个 string 的字段，去读取就会导致 panic，但是这也恰恰说明这个案例很可怕，这种错误在线上实在太难发现了，而且很有可能会很致命。<br>这个案例还有一个衍生案例，大家有兴趣可以点开查看一下，并不是说要看起来一样才不会 panic <a href="https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾一下，这篇文章通过一个案例讲解了 data race 的使用方法:</p><pre><code class="hljs go"><span class="hljs-keyword">go</span> build -race main.<span class="hljs-keyword">go</span>
<span class="hljs-keyword">go</span> test -race ./...</code></pre><p>然后讲述了 data race 如何通过 GORACE 环境变量进行配置<br>最后讲解了几个典型案例，看完这篇相信你对 data race 已经有了一个基本的了解，希望可以在接下来的工作学习当中对你有有所启发<br>最后在重申一下关键点：</p><ul><li>善用 data race 这个工具帮助我们提前发现并发错误</li><li>不要对未定义的行为做任何假设，虽然有时候我们写的只是一行代码，但是 go 编译器可能后面坐了很多事情，并不是说一行写完就一定是原子的</li><li>即使是原子的出现了 data race 也不能保证安全，因为我们还有可见性的问题，上篇我们讲到了现代的 cpu 基本上都会有一些缓存的操作。</li><li>所有出现了 data race 的地方都需要进行处理</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races" target="_blank" rel="noopener">https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races</a></li><li><a href="https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html</a></li><li><a href="http://blog.golang.org/race-detector" target="_blank" rel="noopener">http://blog.golang.org/race-detector</a></li><li><a href="https://golang.org/doc/articles/race_detector.html" target="_blank" rel="noopener">https://golang.org/doc/articles/race_detector.html</a></li><li><a href="https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package" target="_blank" rel="noopener">https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package</a> 除了考虑原子性之外，还要考虑可见性，并不是说赋值原子了，并发操作就没有问题了</li><li><a href="https://golang.org/doc/effective_go.html#redeclaration" target="_blank" rel="noopener">https://golang.org/doc/effective_go.html#redeclaration</a></li></ul><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新</h2><p>看到这里了还不关注点赞走一波</p><ul><li><a href="https://lailin.xyz">博客</a> 可以订阅 RSS</li><li><a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a> Follow me</li><li><a href="https://www.zhihu.com/people/mo-hui-shou-76" target="_blank" rel="noopener">知乎</a> 关注账号，顺便点个 👍</li><li><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a> 订阅订阅号，顺便点个 👍</li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-waitgroup.html">Week03: Go并发编程(六) 深入理解 WaitGroup</a></li><li><a href="https://lailin.xyz/post/go-training-week3-atomic.html">Week03: Go并发编程(五) 深入理解 sync/atomic</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sync.html">Week03: Go并发编程(四) 深入理解 Mutex</a></li></ul></div></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/Go进阶训练营/">Go进阶训练营</a> <a class="hover-with-bg" href="/categories/Go进阶训练营/Go并发编程/">Go并发编程</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/学习笔记/">学习笔记</a> <a class="hover-with-bg" href="/tags/Go/">Go</a> <a class="hover-with-bg" href="/tags/Go进阶训练营/">Go进阶训练营</a> <a class="hover-with-bg" href="/tags/并发/">并发</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/post/go-training-week3-sync.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Week03: Go并发编程(四) 深入理解 Mutex</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/post/go-training-week3-go-memory-model.html"><span class="hidden-mobile">Week03: Go并发编程(二) Go 内存模型</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><script type="text/javascript">function loadUtterances(){var t="github-light",e="github-dark",s=document.documentElement.getAttribute("data-user-color-scheme");s="dark"===s?e:t,window.UtterancesThemeLight=t,window.UtterancesThemeDark=e;var n=document.createElement("script");n.setAttribute("src","https://utteranc.es/client.js"),n.setAttribute("repo","scuplus/blogComment"),n.setAttribute("issue-term","pathname"),n.setAttribute("label","utterances"),n.setAttribute("theme",s),n.setAttribute("crossorigin","anonymous"),document.getElementById("comments").appendChild(n)}waitElementVisible("comments",loadUtterances)</script></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Week03: Go并发编程(三) data race&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><script defer>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-137859264-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script></body></html>