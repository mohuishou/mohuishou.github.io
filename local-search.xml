<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go可用性(五) 限流4: 自适应限流</title>
    <link href="/post/go-training-week6-4-auto-limiter.html"/>
    <url>/post/go-training-week6-4-auto-limiter.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>在前面限流的三篇文章，我们学习了令牌桶、漏桶算法的原理、实现以及使用方式，不知道你有没有觉得这两种算法存在着一些问题。</p><ul><li><a href="https://lailin.xyz/post/go-training-week6-2-token-bucket-1.html">Go 可用性(二) 限流 1: 令牌桶原理及使用</a></li><li><a href="https://lailin.xyz/post/go-training-week6-3-token-bucket-2.html">Go 可用性(三) 限流 2: 令牌桶的实现 rate/limt</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go 可用性(四) 限流 3: 漏桶算法</a></li></ul><p>这两种算法最大的一个问题就是他们都属于需要提前设置阈值的算法，基于 QPS 进行限流的时候最麻烦的就是这个阈值应该怎么设定。一般来说我们可以通过压测来决定这个阈值。</p><ul><li>但是如果每个系统上线前都要经过很严格的压测，那么成本相对来说会比较大</li><li>并且我们很多时候压测都会在测试环境进行压测，测试环境一般来说和生产环境会有一定的差异，即使我们在生产环境做了压测，现在我们的应用都是以容器的形式跑在不同的宿主机上的，每台宿主机上的差异，以及不同的负载都会导致这个压测时的结果不一定就一定是正确的</li><li>当我们的机器型号、数量等发生改变时，之前压测的指标能不能用其实是一个问题，这些数据对于系统负载的影响其实不是线性的，举个例子之前一台机器，后面再加一台，负载就一定能到 2 倍么？其实是不一定的</li><li>如果需要修改限流的值，虽然之前我们将令牌桶的限流是可以动态调整，但是靠人去调整，如果真出现问题然后再叫运维或者是开发同学去调整可能黄花菜都凉了</li></ul><p>既然这种方式有这么多的缺点，那有没有办法解决呢？答案就是今天讲到的 <strong>自适应限流</strong></p><h2 id="自适应限流"><a href="#自适应限流" class="headerlink" title="自适应限流"></a>自适应限流</h2><h3 id="自适应限流怎么做"><a href="#自适应限流怎么做" class="headerlink" title="自适应限流怎么做"></a>自适应限流怎么做</h3><p>前面我们遇到的主要问题就是每个服务实例的限流阈值实际应该是动态变化的，我们应该根据系统能够承载的最大吞吐量，来进行限流，当当前的流量大于最大吞吐的时候就限制流量进入，反之则允许通过。那现在的问题就是</p><ul><li><strong>系统的吞吐量该如何计算？</strong></li><li><strong>什么时候系统的吞吐量就是最大的吞吐量了？</strong></li></ul><p>**</p><h4 id="计算吞吐量：利特尔法则-L-λ-W"><a href="#计算吞吐量：利特尔法则-L-λ-W" class="headerlink" title="计算吞吐量：利特尔法则 L = λ * W"></a>计算吞吐量：利特尔法则 L = λ * W</h4><blockquote><p>利特尔法则由麻省理工大学斯隆商学院（MIT Sloan School of Management）的教授 John Little﹐于 1961 年所提出与证明。它是一个有关提前期与在制品关系的简单数学公式，这一法则为精益生产的改善方向指明了道路。 —- <a href="https://wiki.mbalib.com/wiki/%E5%88%A9%E7%89%B9%E5%B0%94%E6%B3%95%E5%88%99">MBA 智库百科 (mbalib.com)</a></p></blockquote><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1618149289604-8e317c82-9a06-4369-99ca-61f138515439.png" alt="image.png"><br>如上图所示，如果我们开一个小店，平均每分钟进店 2 个客人(λ)，每位客人从等待到完成交易需要 4 分钟(W)，那我们店里能承载的客人数量就是 2 * 4 = 8 个人</p><p>同理，我们可以将 <code>λ</code>  当做 QPS， <code>W</code>  呢是每个请求需要花费的时间，那我们的系统的吞吐就是 <code>L = λ * W</code> ，所以我们可以使用利特尔法则来计算系统的吞吐量。</p><h4 id="什么时候系统的吞吐量就是最大的吞吐量？"><a href="#什么时候系统的吞吐量就是最大的吞吐量？" class="headerlink" title="什么时候系统的吞吐量就是最大的吞吐量？"></a>什么时候系统的吞吐量就是最大的吞吐量？</h4><p>首先我们可以通过统计过去一段时间的数据，获取到平均每秒的请求量，也就是 QPS，以及请求的耗时时间，为了避免出现前面 900ms 一个请求都没有最后 100ms 请求特别多的情况，我们可以使用滑动窗口算法来进行统计。</p><p>最容易想到的就是我们从系统启动开始，就把这些值给保存下来，然后计算一个吞吐的最大值，用这个来表示我们的最大吞吐量就可以了。但是这样存在一个问题是，我们很多系统其实都不是独占一台机器的，一个物理机上面往往有很多服务，并且一般还存在一些超卖，所以可能第一个小时最大处理能力是 100，但是这台节点上其他服务实例同时都在抢占资源的时候，这个处理能力最多就只能到 80 了</p><p>所以我们需要一个数据来做启发阈值，只要这个指标达到了阈值那我们就进入流控当中。常见的选择一般是 CPU、Memory、System Load，这里我们以 CPU 为例</p><p>只要我们的 CPU 负载超过 80% 的时候，获取过去 5s 的最大吞吐数据，然后再统计当前系统中的请求数量，只要当前系统中的请求数大于最大吞吐那么我们就丢弃这个请求。</p><h3 id="kratos-自适应限流分析"><a href="#kratos-自适应限流分析" class="headerlink" title="kratos 自适应限流分析"></a>kratos 自适应限流分析</h3><h3 id="限流公式"><a href="#限流公式" class="headerlink" title="限流公式"></a>限流公式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PS: 官方文档这里写的是 cpu &gt; 800 AND (Now - PrevDrop) &lt; 1s</span><br><span class="hljs-comment">// 应该是写错了，等下看源码就知道了</span><br>(cpu &gt; <span class="hljs-number">800</span> OR (Now - PrevDrop) &lt; <span class="hljs-number">1</span>s) AND (MaxPass * MinRt * windows / <span class="hljs-number">1000</span>) &lt; InFlight<br></code></pre></td></tr></table></figure><ul><li><code>cpu &gt; 800</code>  表示 CPU 负载大于 80% 进入限流</li><li><code>(Now - PrevDrop) &lt; 1s</code>  这个表示只要触发过 1 次限流，那么 1s 内都会去做限流的判定，这是为了避免反复出现限流恢复导致请求时间和系统负载产生大量毛刺</li><li><code>(MaxPass * MinRt * windows / 1000) &lt; InFlight</code>  判断当前负载是否大于最大负载<ul><li><code>InFlight</code>  表示当前系统中有多少请求</li><li><code>(MaxPass * MinRt * windows / 1000)</code>  表示过去一段时间的最大负载</li><li><code>MaxPass</code>  表示最近 5s 内，单个采样窗口中最大的请求数</li><li><code>MinRt</code>  表示最近 5s 内，单个采样窗口中最小的响应时间</li><li><code>windows</code>  表示一秒内采样窗口的数量，默认配置中是 5s 50 个采样，那么 windows 的值为 10。</li></ul></li></ul><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="BBR-结构体"><a href="#BBR-结构体" class="headerlink" title="BBR 结构体"></a>BBR 结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> BBR <span class="hljs-keyword">struct</span> &#123;<br>cpu             cpuGetter<br>    <span class="hljs-comment">// 请求数，和响应时间的采样数据，使用滑动窗口进行统计</span><br>passStat        metric.RollingCounter<br>rtStat          metric.RollingCounter<br><br>    <span class="hljs-comment">// 当前系统中的请求数</span><br>inFlight        <span class="hljs-keyword">int64</span><br><span class="hljs-comment">// 每秒钟内的采样数量，默认是10</span><br>    winBucketPerSec <span class="hljs-keyword">int64</span><br>    <span class="hljs-comment">// 单个 bucket 的时间</span><br>bucketDuration  time.Duration<br><span class="hljs-comment">// 窗口数量</span><br>    winSize         <span class="hljs-keyword">int</span><br><span class="hljs-comment">// 配置</span><br>    conf            *Config<br>prevDrop        atomic.Value<br>    <span class="hljs-comment">// 表示最近 5s 内，单个采样窗口中最大的请求数的缓存数据</span><br>maxPASSCache    atomic.Value<br>    <span class="hljs-comment">// 表示最近 5s 内，单个采样窗口中最小的响应时间的缓存数据</span><br>minRtCache      atomic.Value<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Allow-判断请求是否允许通过"><a href="#Allow-判断请求是否允许通过" class="headerlink" title="Allow: 判断请求是否允许通过"></a>Allow: 判断请求是否允许通过</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *BBR)</span> <span class="hljs-title">Allow</span><span class="hljs-params">(ctx context.Context, opts ...limit.AllowOption)</span> <span class="hljs-params">(<span class="hljs-keyword">func</span>(info limit.DoneInfo)</span>, <span class="hljs-title">error</span>)</span> &#123;<br><span class="hljs-comment">// ... 省略配置修改代码</span><br><br>    <span class="hljs-keyword">if</span> l.shouldDrop() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ecode.LimitExceed<br>&#125;<br><br>atomic.AddInt64(&amp;l.inFlight, <span class="hljs-number">1</span>)<br>stime := time.Since(initTime)<br><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(do limit.DoneInfo)</span></span> &#123;<br>rt := <span class="hljs-keyword">int64</span>((time.Since(initTime) - stime) / time.Millisecond)<br>l.rtStat.Add(rt)<br>atomic.AddInt64(&amp;l.inFlight, <span class="hljs-number">-1</span>)<br><span class="hljs-keyword">switch</span> do.Op &#123;<br><span class="hljs-keyword">case</span> limit.Success:<br>l.passStat.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法主要是给中间件使用的</p><ul><li>首先使用 <code>shouldDrop</code>  方法判断这个请求是否应该丢弃</li><li>如果成功放行，那么当前系统中的请求数就 +1</li><li>然后返回一个 <code>function</code>  用于请求结束之后<ul><li>统计请求的响应时间</li><li>如果请求成功了，给成功的请求数 +1</li><li>并且当前系统中的请求数量 <code>Inflight</code>  -1</li></ul></li></ul><h4 id="shouldDrop-判断请求是否应该被丢弃"><a href="#shouldDrop-判断请求是否应该被丢弃" class="headerlink" title="shouldDrop: 判断请求是否应该被丢弃"></a>shouldDrop: 判断请求是否应该被丢弃</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *BBR)</span> <span class="hljs-title">shouldDrop</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> l.cpu() &lt; l.conf.CPUThreshold &#123;<br>prevDrop, _ := l.prevDrop.Load().(time.Duration)<br><span class="hljs-keyword">if</span> prevDrop == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> time.Since(initTime)-prevDrop &lt;= time.Second &#123;<br>inFlight := atomic.LoadInt64(&amp;l.inFlight)<br><span class="hljs-keyword">return</span> inFlight &gt; <span class="hljs-number">1</span> &amp;&amp; inFlight &gt; l.maxFlight()<br>&#125;<br>l.prevDrop.Store(time.Duration(<span class="hljs-number">0</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>inFlight := atomic.LoadInt64(&amp;l.inFlight)<br>drop := inFlight &gt; <span class="hljs-number">1</span> &amp;&amp; inFlight &gt; l.maxFlight()<br><span class="hljs-keyword">if</span> drop &#123;<br>prevDrop, _ := l.prevDrop.Load().(time.Duration)<br><span class="hljs-keyword">if</span> prevDrop != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> drop<br>&#125;<br>l.prevDrop.Store(time.Since(initTime))<br>&#125;<br><span class="hljs-keyword">return</span> drop<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法其实就是开头讲到的限流公式了，逻辑如下图所示<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1618158541909-f94f46a3-fad8-47d3-a389-395a57116c55.png" alt="Go可用性 限流-分布式限流-kratos 限流策略.png"></p><ul><li>首先看 CPU 的使用率是否达到了阈值</li><li>如果没到，则回去判断一下上次触发限流到现在是否在一秒以内<ul><li>如果在一秒内，就判断当前负载是否超过限制，如果超过了就需要丢弃</li><li>如果不在 1s 内或者是请求数量已经降下来了，那么就吧 <code>prevDrop</code>  清零然后返回 false</li></ul></li><li>如果到了，则判断一下当前负载是否超过限制<ul><li>如果超过了，则设置丢弃时间 <code>prevDrop</code>，返回 true 需要丢弃请求</li><li>如果没超过直接返回 false</li></ul></li></ul><h4 id="maxFlight-系统的最大负载"><a href="#maxFlight-系统的最大负载" class="headerlink" title="maxFlight: 系统的最大负载"></a>maxFlight: 系统的最大负载</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *BBR)</span> <span class="hljs-title">maxFlight</span><span class="hljs-params">()</span> <span class="hljs-title">int64</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">int64</span>(math.Floor(<span class="hljs-keyword">float64</span>(l.maxPASS()*l.minRT()*l.winBucketPerSec)/<span class="hljs-number">1000.0</span> + <span class="hljs-number">0.5</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>这个就是计算过去一段时间系统的最大负载是多少</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章我们讲了一下为什么需要自适应限流，令牌桶和漏桶这类需要手动设置 rps 算法的问题所在，了解了自适应限流的实现原理，最后看了一下 kratos 当中是如何实现自适应限流的。但是由于篇幅关系，CPU 的数据如何进行统计，文章中提到了很多次的滑动窗口是个什么原理这些知识点大家可以自行查看 kratos 中的源码，或者去看极客时间的 Go 进阶训练营都有讲到。</p><p>kratos 中的限流算法其实灵感源于 Google SRE，实现上参考了 sentinel，其中一个有意思的点是 sentinel 默认使用 load 作为启发阈值，而 kratos 使用了 cpu，kratos 为什么要使用 cpu 呢？这个大家可以自己想想（答案可以自行观看极客时间的 Go 进阶训练营）</p><p>而 sentinel 的实现其实是参考了 TCP 中的 BBR 算法，在 BBR 的基础上加上了 load 作为启发阈值的判断，所以多了解一下基础知识总是没错的，指不定当下遇到的场景就能解决。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></li><li><a href="https://kunzhao.org/docs/cloud-plus-bbs/bilibili-high-availability/">B 站高可用架构实践 | 赵坤的个人网站 (kunzhao.org)</a></li><li><a href="https://wiki.mbalib.com/wiki/%E5%88%A9%E7%89%B9%E5%B0%94%E6%B3%95%E5%88%99">利特尔法则 - MBA 智库百科 (mbalib.com)</a></li><li><a href="https://aws.amazon.com/cn/blogs/china/talking-about-network-optimization-from-the-flow-control-algorithm/">从流量控制算法谈网络优化 – 从 CUBIC 到 BBRv2 算法 | 亚马逊 AWS 官方博客 (amazon.com)</a></li><li><a href="https://github.com/go-kratos/kratos/blob/v1.0.x/docs/ratelimit.md">kratos/ratelimit.md at v1.0.x · go-kratos/kratos (github.com)</a></li><li><a href="https://my.oschina.net/u/3162806/blog/4525952">限流器系列(3)–自适应限流 - 郝洪范的个人空间 - OSCHINA - 中文开源技术交流社区</a></li><li><a href="https://en.wikipedia.org/wiki/TCP_congestion_control#TCP_BBR">TCP congestion control - Wikipedia</a></li><li><a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">系统自适应限流 · alibaba/Sentinel Wiki · GitHub</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li><li><a href="https://lailin.xyz/post/go-training-week6-3-token-bucket-2.html">Go可用性(三) 限流2: 令牌桶的实现 rate/limt</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week06: 微服务可用性设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>微服务</tag>
      
      <tag>可用性</tag>
      
      <tag>过载保护</tag>
      
      <tag>限流</tag>
      
      <tag>令牌桶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go可用性(四) 限流3: 漏桶算法</title>
    <link href="/post/go-training-week6-4-leaky-bucket.html"/>
    <url>/post/go-training-week6-4-leaky-bucket.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>在前面两篇文章当中我们学习了令牌桶算法的使用和实现，今天我们就一起来看一看另外一种常见的限流算法，漏桶算法</p><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>漏桶算法(Leaky Bucket) 是网络世界中流量整形（Traffic Shaping）或速率限制（Rate Limiting）时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。 — <a href="https://baike.baidu.com/item/%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95">百度百科</a></p></blockquote><p>漏桶算法其实非常形象，如下图所示可以理解为一个漏水的桶，当有突发流量来临的时候，会先到桶里面，桶下有一个洞，可以以固定的速率向外流水，如果水的从桶中外溢了出来，那么这个请求就会被拒绝掉。具体的表现就会向下图右侧的图表一样，突发流量就被整形成了一个平滑的流量。<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1617718978961-0a125409-6fbb-4ca9-b335-5bef61cd44a8.png" alt="image.png"></p><p>漏桶算法的主要作用就是避免出现有的时候流量很高，有的时候又很低，导致系统出现旱的旱死，涝的涝死的这种情况。</p><p>Go 中比较常用的漏桶算法的实现就是来自 uber 的 <a href="https://pkg.go.dev/go.uber.org/ratelimit">ratelimit</a>，下面我们就会看一下这个库的使用方式和源码</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Clock<br><span class="hljs-keyword">type</span> Limiter<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(rate <span class="hljs-keyword">int</span>, opts ...Option)</span> <span class="hljs-title">Limiter</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUnlimited</span><span class="hljs-params">()</span> <span class="hljs-title">Limiter</span></span><br><span class="hljs-keyword">type</span> Option<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Per</span><span class="hljs-params">(per time.Duration)</span> <span class="hljs-title">Option</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithClock</span><span class="hljs-params">(clock Clock)</span> <span class="hljs-title">Option</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithSlack</span><span class="hljs-params">(slack <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">Option</span></span><br></code></pre></td></tr></table></figure><p><code>Clock</code>  是一个接口，计时器的最小实现，有两个方法，分别是当前的时间和睡眠</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Clock <span class="hljs-keyword">interface</span> &#123;<br>Now() time.Time<br>Sleep(time.Duration)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Limiter</code>  也是一个接口，只有一个 <code>Take</code>  方法，执行这个方法的时候如果触发了 rps 限制则会阻塞住</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Limiter <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Take should block to make sure that the RPS is met.</span><br>Take() time.Time<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NewLimter</code>  和 <code>NewUnlimited</code>  会分别初始化一个无锁的限速器和没有任何限制的限速器</p><p><code>Option</code>  是在初始化的时候的额外参数，这种使用姿势在之前 Go 工程化的文章<a href="https://lailin.xyz/post/go-training-week4-config.html">《Go 工程化(六) 配置管理》</a>当中有讲到，这里我们就不再赘述了</p><p><code>Option</code>  有三个方法</p><ul><li><code>Per</code>  可以修改时间单位，默认是秒所以我们默认限制的是 rps，如果改成分钟那么就是 rpm 了</li><li><code>WithClock</code>  可以修改时钟，这个用于在测试的时候可以 mock 掉不使用真实的时间</li><li><code>WithSlack</code>  用于修改松弛时间，也就是可以允许的突发流量的大小，默认是 <code>Pre / 10</code> ，这个后面会讲到</li></ul><h3 id="案例-10-行代码实现一个基于漏桶算法的-ip-限流中间件"><a href="#案例-10-行代码实现一个基于漏桶算法的-ip-限流中间件" class="headerlink" title="案例: 10 行代码实现一个基于漏桶算法的 ip 限流中间件"></a>案例: 10 行代码实现一个基于漏桶算法的 ip 限流中间件</h3><p>案例我们使用和令牌桶类似的案例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLimiter</span><span class="hljs-params">(rps <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">gin</span>.<span class="hljs-title">HandlerFunc</span></span> &#123;<br>limiters := &amp;sync.Map&#123;&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 获取限速器</span><br><span class="hljs-comment">// key 除了 ip 之外也可以是其他的，例如 header，user name 等</span><br>key := c.ClientIP()<br>l, _ := limiters.LoadOrStore(key, ratelimit.New(rps))<br>now := l.(ratelimit.Limiter).Take()<br>fmt.Printf(<span class="hljs-string">&quot;now: %s\n&quot;</span>, now)<br>c.Next()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用上也是比较简单的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>e := gin.Default()<br><span class="hljs-comment">// 新建一个限速器，允许突发 3 个并发</span><br>e.Use(NewLimiter(<span class="hljs-number">3</span>))<br>e.GET(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.String(http.StatusOK, <span class="hljs-string">&quot;pong&quot;</span>)<br>&#125;)<br>e.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们用 <code>go-stress-testing</code>  进行压测</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>-stress-testing-linux -c <span class="hljs-number">100</span> -u http:<span class="hljs-comment">//localhost:8080/ping</span><br><br>─────┬───────┬───────┬───────┬────────┬────────┬────────┬────────┬────────┬────────┬────────<br> 耗时 │ 并发数│  成功数│ 失败数 │   qps  │最长耗时│最短耗时 │平均耗时 │下载字节 │字节每秒 │ 错误码<br>─────┼───────┼───────┼───────┼────────┼────────┼────────┼────────┼────────┼────────┼────────<br>   <span class="hljs-number">1</span>s│     <span class="hljs-number">13</span>│     <span class="hljs-number">13</span>│      <span class="hljs-number">0</span>│  <span class="hljs-number">233.55</span>│  <span class="hljs-number">676.10</span>│    <span class="hljs-number">5.82</span>│   <span class="hljs-number">85.64</span>│      <span class="hljs-number">52</span>│      <span class="hljs-number">51</span>│<span class="hljs-number">200</span>:<span class="hljs-number">13</span><br>   <span class="hljs-number">2</span>s│     <span class="hljs-number">16</span>│     <span class="hljs-number">16</span>│      <span class="hljs-number">0</span>│   <span class="hljs-number">62.25</span>│ <span class="hljs-number">1675.17</span>│    <span class="hljs-number">5.82</span>│  <span class="hljs-number">321.30</span>│      <span class="hljs-number">64</span>│      <span class="hljs-number">31</span>│<span class="hljs-number">200</span>:<span class="hljs-number">16</span><br>   <span class="hljs-number">3</span>s│     <span class="hljs-number">19</span>│     <span class="hljs-number">19</span>│      <span class="hljs-number">0</span>│   <span class="hljs-number">31.24</span>│ <span class="hljs-number">2673.94</span>│    <span class="hljs-number">5.82</span>│  <span class="hljs-number">640.20</span>│      <span class="hljs-number">76</span>│      <span class="hljs-number">25</span>│<span class="hljs-number">200</span>:<span class="hljs-number">19</span><br>   <span class="hljs-number">3</span>s│     <span class="hljs-number">20</span>│     <span class="hljs-number">20</span>│      <span class="hljs-number">0</span>│   <span class="hljs-number">26.37</span>│ <span class="hljs-number">3006.49</span>│    <span class="hljs-number">5.82</span>│  <span class="hljs-number">758.51</span>│      <span class="hljs-number">80</span>│      <span class="hljs-number">26</span>│<span class="hljs-number">200</span>:<span class="hljs-number">20</span><br><br><br>*************************  结果 stat  ****************************<br>处理协程数量: <span class="hljs-number">20</span><br>请求总数（并发数*请求数 -c * -n）: <span class="hljs-number">20</span> 总请求时间: <span class="hljs-number">3.011</span> 秒 successNum: <span class="hljs-number">20</span> failureNum: <span class="hljs-number">0</span><br>*************************  结果 end   ****************************<br></code></pre></td></tr></table></figure><p>查看结果发现为什么第一秒的时候完成了 13 个请求，不是限制的 3rps 么？不要慌，我们看看它的实现就知道了</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>这个库有基于互斥锁的实现和基于 CAS 的无锁实现，默认使用的是无锁实现版本，所以我们主要看无锁实现的源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> state <span class="hljs-keyword">struct</span> &#123;<br>last     time.Time<br>sleepFor time.Duration<br>&#125;<br><br><span class="hljs-keyword">type</span> atomicLimiter <span class="hljs-keyword">struct</span> &#123;<br>state unsafe.Pointer<br><span class="hljs-comment">//lint:ignore U1000 Padding is unused but it is crucial to maintain performance</span><br><span class="hljs-comment">// of this rate limiter in case of collocation with other frequently accessed memory.</span><br>padding [<span class="hljs-number">56</span>]<span class="hljs-keyword">byte</span> <span class="hljs-comment">// cache line size - state pointer size = 64 - 8; created to avoid false sharing.</span><br><br>perRequest time.Duration<br>maxSlack   time.Duration<br>clock      Clock<br>&#125;<br></code></pre></td></tr></table></figure><p><code>atomicLimiter</code>  结构体</p><ul><li><code>state</code>  是一个状态的指针，用于存储上一次的执行的时间，以及需要 <code>sleep</code>  的时间</li><li><code>padding</code>  是一个无意义的填充数据，为了提高性能，避免 cpu 缓存的 false sharing<ul><li>之前在讲 <a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Go 并发编程(二) Go 内存模型</a> 的时候有讲到，为了能够最大限度的利用 CPU 的能力，会做很多丧心病狂的优化，其中一种就是 cpu cache</li><li>cpu cache 一般是以 cache line 为单位的，在 64 位的机器上一般是 64 字节</li><li>所以如果我们高频并发访问的数据小于 64 字节的时候就可能会和其他数据一起缓存，其他数据如果出现改变就会导致 cpu 认为缓存失效，这就是 false sharing</li><li>所以在这里为了尽可能提高性能，填充了 56 字节的无意义数据，因为 state 是一个指针占用了 8 个字节，所以 <code>64 - 8 = 56</code></li></ul></li><li>剩下三个字段和 <code>Option</code>  中的三个方法意义对应<ul><li><code>perRequest</code>  就是单位，默认是秒</li><li><code>maxSlack</code>  松弛时间，也就是可以允许的突发流量的大小，默认是 <code>Pre / 10</code> ，这个后面会讲到</li><li><code>clock</code>  时钟，这个用于在测试的时候可以 mock 掉不使用真实的时间</li></ul></li></ul><p>接下来看看最主要的 <code>Take</code>  方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *atomicLimiter)</span> <span class="hljs-title">Take</span><span class="hljs-params">()</span> <span class="hljs-title">time</span>.<span class="hljs-title">Time</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>        <span class="hljs-comment">// 状态</span><br>newState state<br>        <span class="hljs-comment">// 用于表示原子操作是否成功</span><br>taken    <span class="hljs-keyword">bool</span><br>        <span class="hljs-comment">// 需要 sleep 的时间</span><br>interval time.Duration<br>)<br><br>    <span class="hljs-comment">// 如果 CAS 操作不成功就一直尝试</span><br><span class="hljs-keyword">for</span> !taken &#123;<br>        <span class="hljs-comment">// 获取当前的时间</span><br>now := t.clock.Now()<br><br>        <span class="hljs-comment">// load 出上一次调用的时间</span><br>previousStatePointer := atomic.LoadPointer(&amp;t.state)<br>oldState := (*state)(previousStatePointer)<br><br>newState = state&#123;<br>last:     now,<br>sleepFor: oldState.sleepFor,<br>&#125;<br><br><span class="hljs-comment">// 如果 last 是零值的话，表示之前就没用过，直接保存返回即可</span><br><span class="hljs-keyword">if</span> oldState.last.IsZero() &#123;<br>taken = atomic.CompareAndSwapPointer(&amp;t.state, previousStatePointer, unsafe.Pointer(&amp;newState))<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// sleepFor 是需要睡眠的时间，由于引入了松弛时间，所以 sleepFor 可能是一个</span><br>        <span class="hljs-comment">// maxSlack ~ 0 之间的一个值，所以这里需要将现在的需要 sleep 的时间和上一次</span><br>        <span class="hljs-comment">// sleepFor 的值相加</span><br>newState.sleepFor += t.perRequest - now.Sub(oldState.last)<br><br>        <span class="hljs-comment">// 如果距离上一次调用已经很久了，sleepFor 可能会是一个很小的值</span><br>        <span class="hljs-comment">// 最小值只能是 maxSlack 的大小</span><br><span class="hljs-keyword">if</span> newState.sleepFor &lt; t.maxSlack &#123;<br>newState.sleepFor = t.maxSlack<br>&#125;<br><br>        <span class="hljs-comment">// 如果 sleepFor 大于 0  的话，计算出需要 sleep 的时间</span><br>        <span class="hljs-comment">// 然后将 state.sleepFor 置零</span><br><span class="hljs-keyword">if</span> newState.sleepFor &gt; <span class="hljs-number">0</span> &#123;<br>newState.last = newState.last.Add(newState.sleepFor)<br>interval, newState.sleepFor = newState.sleepFor, <span class="hljs-number">0</span><br>&#125;<br><br>        <span class="hljs-comment">// 保存状态</span><br>taken = atomic.CompareAndSwapPointer(&amp;t.state, previousStatePointer, unsafe.Pointer(&amp;newState))<br>&#125;<br><br>    <span class="hljs-comment">// sleep interval</span><br>t.clock.Sleep(interval)<br><span class="hljs-keyword">return</span> newState.last<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天学习了漏桶的实现原理以及使用方式，漏桶和令牌桶的最大的区别就是，令牌桶是支持突发流量的，但是漏桶是不支持的。但是 uber 的这个库通过引入弹性时间的方式也让漏桶算法有了类似令牌桶能够应对部分突发流量的能力，并且实现上还非常的简单，值得学习。</p><p>多看看好的轮子的实现总会学到一些新姿势，今天就学到了使用 padding 填充来避免 false sharing 提高性能的操作</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></li><li><a href="https://eddycjy.com/posts/microservice/leaky-token-buckets/">“带你快速了解：限流中的漏桶和令牌桶算法”</a></li><li><a href="https://pkg.go.dev/go.uber.org/ratelimit">ratelimit · pkg.go.dev</a></li><li><a href="https://github.com/uber-go/ratelimit/blob/main/limiter_atomic.go">ratelimit/limiter_atomic.go at main · uber-go/ratelimit (github.com)</a></li><li><a href="https://baike.baidu.com/item/%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95">漏桶算法_百度百科 (baidu.com)</a></li><li><a href="https://pengrl.com/p/9125/">利用 CPU cache 特性优化 Go 程序</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-3-token-bucket-2.html">Go可用性(三) 限流2: 令牌桶的实现 rate/limt</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week06: 微服务可用性设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>微服务</tag>
      
      <tag>可用性</tag>
      
      <tag>过载保护</tag>
      
      <tag>限流</tag>
      
      <tag>令牌桶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go可用性(三) 限流2: 令牌桶的实现 rate/limt</title>
    <link href="/post/go-training-week6-3-token-bucket-2.html"/>
    <url>/post/go-training-week6-3-token-bucket-2.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>在上一篇文章 <a href="https://lailin.xyz/post/go-training-week6-2-token-bucket-1.html">Go 可用性(二) 限流 1: 令牌桶原理及使用</a> 当中我们简单的介绍了令牌桶实现的原理，然后利用 <a href="https://pkg.go.dev/golang.org/x/time/rate">/x/time/rate</a> 这个库 10 行代码写了一个基于 ip 的 gin 限流中间件，那这个功能是怎么实现的呢？接下来我们就从源码层面来了解一下这个库的实现。这个实现很有意思，并没有真正的使用一个定时器不断的生成令牌，而是靠计算的方式来完成</p><h2 id="rate-limt"><a href="#rate-limt" class="headerlink" title="rate/limt"></a>rate/limt</h2><blockquote><p>本文源码基于 <a href="https://pkg.go.dev/golang.org/x/time@v0.0.0-20210220033141-f8bda1e9f3ba/rate">https://pkg.go.dev/golang.org/x/time@v0.0.0-20210220033141-f8bda1e9f3ba/rate</a></p></blockquote><p>上回我们讲到，使用限速器的时候我们需要调用 <code>NewLimiter</code>  方法，然后 <code>Limiter</code>  提供了三组限速的方法，这三组方法其实都是通过调用 <code>reserveN</code>  实现的 <code>reserveN</code>  返回一个 <code>*Reservation</code>  指针，我们先来看一下这两个结构体吧。</p><p><strong>Limiter</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Limiter <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// 互斥锁</span><br>mu     sync.Mutex<br><br>    <span class="hljs-comment">// 每秒产生 token 的速度, 其实是 float64 的一个别名</span><br>limit  Limit<br><br>    <span class="hljs-comment">// 桶的大小</span><br>burst  <span class="hljs-keyword">int</span><br><br>    <span class="hljs-comment">// 当前时间节点拥有的 tokens 数量</span><br>tokens <span class="hljs-keyword">float64</span><br><br><span class="hljs-comment">// 上次更新 token 的时间</span><br>last time.Time<br><br><span class="hljs-comment">// 上次限速的时间，这个时间可能是过去的某个时间也可能是将来的某个时间</span><br>lastEvent time.Time<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Reservation</strong><br>这个结构体挺有意思的，表示预约某个时间的 token</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reservation <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// 是否能预约上</span><br>ok        <span class="hljs-keyword">bool</span><br>    <span class="hljs-comment">// limter</span><br>lim       *Limiter<br>    <span class="hljs-comment">// 预约的 token 数量</span><br>tokens    <span class="hljs-keyword">int</span><br>    <span class="hljs-comment">// token 实际使用的时间</span><br>timeToAct time.Time<br><span class="hljs-comment">// 保存一下速率，因为 lim 的速率是可以被动态调整的，所以不能直接用</span><br>limit Limit<br>&#125;<br></code></pre></td></tr></table></figure><p>这个库并没有使用定时器来发放 token 而是用了 lazyload 的方式，等需要消费 token 的时候才通过时间去计算然后更新 token 的数量，下面我们先通过一个例子来看一下这个流程是怎么跑的<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1617121384819-00164807-a2c9-4976-a7ab-4169a45a7d0d.png" alt="blog.png"><br>如上图所示，假设我们有一个限速器，它的 token 生成速度为 1，也就是一秒一个，桶的大小为 10，每个格子表示一秒的时间间隔</p><ul><li><code>last</code>  表示上一次更新 token 时还有 2 个 token。</li><li>现在我有一个请求进来，我总共需要 7 个 token 才能完成这个请求</li><li><code>now</code>  表示我现在进来的时间，距离 last 已经过去了 2s，那么现在就有 4 个 token</li><li>所以我如果需要 7 个 token 那么也就还需要等待 3s 中才真的有 7 个，所以这就是 <code>timeToAct</code>  所在的时间节点</li><li>预约成功之后更新 <code>last = now</code> 、<code>token = -3</code>  因为 token 已经被预约出去了所以现在剩下的就是负数了</li></ul><h3 id="消费-token"><a href="#消费-token" class="headerlink" title="消费 token"></a>消费 token</h3><p>总共有三组消费 token 的方法 <code></code>AllowN, ReserveN, and WaitN<code>最终都是调用的</code>reserveN`  这个方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// now: 需要消费 token 的时间点</span><br><span class="hljs-comment">// n: 需要多少个 token</span><br><span class="hljs-comment">// maxFutureReserve: 能够等待的最长时间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">reserveN</span><span class="hljs-params">(now time.Time, n <span class="hljs-keyword">int</span>, maxFutureReserve time.Duration)</span> <span class="hljs-title">Reservation</span></span> &#123;<br>lim.mu.Lock()<br><br>    <span class="hljs-comment">// 如果发放令牌的速度无穷大的话，那么直接返回就行了，要多少可以给多少</span><br><span class="hljs-keyword">if</span> lim.limit == Inf &#123;<br>lim.mu.Unlock()<br><span class="hljs-keyword">return</span> Reservation&#123;<br>ok:        <span class="hljs-literal">true</span>,<br>lim:       lim,<br>tokens:    n,<br>timeToAct: now,<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// advance 方法会去计算当前有多少个 token</span><br>    <span class="hljs-comment">// 后面会讲到，now 其实就是传入的时间，但是 last 可能会变</span><br>now, last, tokens := lim.advance(now)<br><br><span class="hljs-comment">// 发放 token 之后还剩多少</span><br>tokens -= <span class="hljs-keyword">float64</span>(n)<br><br><span class="hljs-comment">// 根据 token 数量计算需要等待的时间</span><br><span class="hljs-keyword">var</span> waitDuration time.Duration<br><span class="hljs-keyword">if</span> tokens &lt; <span class="hljs-number">0</span> &#123;<br>waitDuration = lim.limit.durationFromTokens(-tokens)<br>&#125;<br><br><span class="hljs-comment">// 计算是否可以发放，如果需要的量比桶的容量还大肯定是不行的</span><br>    <span class="hljs-comment">// 然后就是看需要能否容忍需要等待的时间</span><br>ok := n &lt;= lim.burst &amp;&amp; waitDuration &lt;= maxFutureReserve<br><br><span class="hljs-comment">// Prepare reservation</span><br>r := Reservation&#123;<br>ok:    ok,<br>lim:   lim,<br>limit: lim.limit,<br>&#125;<br>    <span class="hljs-comment">// 如果可以的话，就把 token 分配给预约者</span><br><span class="hljs-keyword">if</span> ok &#123;<br>r.tokens = n<br>r.timeToAct = now.Add(waitDuration)<br>&#125;<br><br><span class="hljs-comment">// 更新各个字段的状态</span><br><span class="hljs-keyword">if</span> ok &#123;<br>lim.last = now<br>lim.tokens = tokens<br>lim.lastEvent = r.timeToAct<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 为什么不 ok 也要更新 last 呢？因为 last 可能会改变</span><br>lim.last = last<br>&#125;<br><br>lim.mu.Unlock()<br><span class="hljs-keyword">return</span> r<br>&#125;<br></code></pre></td></tr></table></figure><p><code>advance</code>  方法用于计算 token 的数量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// now 是传入的当前的时间点，返回的 newNow 其实就是传入的参数，没有任何改变</span><br><span class="hljs-comment">// newLast 是更新 token 的时间</span><br><span class="hljs-comment">// newTokens 是 token 的数量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">advance</span><span class="hljs-params">(now time.Time)</span> <span class="hljs-params">(newNow time.Time, newLast time.Time, newTokens <span class="hljs-keyword">float64</span>)</span></span> &#123;<br><span class="hljs-comment">// 如果当前时间比上次更新 token 的时间还要早，那么就重置一下 last</span><br>    last := lim.last<br><span class="hljs-keyword">if</span> now.Before(last) &#123;<br>last = now<br>&#125;<br><br><span class="hljs-comment">// 这里为了防止溢出，先计算了将桶填满需要花费的最大时间</span><br>maxElapsed := lim.limit.durationFromTokens(<span class="hljs-keyword">float64</span>(lim.burst) - lim.tokens)<br>    <span class="hljs-comment">// 计算时间差，如果大于最大时间的话，就取最大值</span><br>elapsed := now.Sub(last)<br><span class="hljs-keyword">if</span> elapsed &gt; maxElapsed &#123;<br>elapsed = maxElapsed<br>&#125;<br><br><span class="hljs-comment">// 计算这段时间生成的 token 数量，如果大于桶的容量，就取桶的容量</span><br>delta := lim.limit.tokensFromDuration(elapsed)<br>tokens := lim.tokens + delta<br><span class="hljs-keyword">if</span> burst := <span class="hljs-keyword">float64</span>(lim.burst); tokens &gt; burst &#123;<br>tokens = burst<br>&#125;<br><br><span class="hljs-keyword">return</span> now, last, tokens<br>&#125;<br></code></pre></td></tr></table></figure><p>这个比较有意思的是先去计算了时间的最大值，因为初始化的时候没为 <code>last</code>  赋值，所以 <code>now.Before(last)</code>  出来的结果可能是一个很大的值，再去计算 tokens 数量很可能溢出</p><p><strong>durationFromTokens</strong> 根据 tokens 的数量计算需要花费的时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(limit Limit)</span> <span class="hljs-title">durationFromTokens</span><span class="hljs-params">(tokens <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">time</span>.<span class="hljs-title">Duration</span></span> &#123;<br>seconds := tokens / <span class="hljs-keyword">float64</span>(limit)<br><span class="hljs-keyword">return</span> time.Nanosecond * time.Duration(<span class="hljs-number">1e9</span>*seconds)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>tokensFromDuration</strong> 根据时间计算 tokens 的数量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(limit Limit)</span> <span class="hljs-title">tokensFromDuration</span><span class="hljs-params">(d time.Duration)</span> <span class="hljs-title">float64</span></span> &#123;<br><span class="hljs-comment">// 这里通过拆分整数和小数部分可以减少时间上的误差</span><br>sec := <span class="hljs-keyword">float64</span>(d/time.Second) * <span class="hljs-keyword">float64</span>(limit)<br>nsec := <span class="hljs-keyword">float64</span>(d%time.Second) * <span class="hljs-keyword">float64</span>(limit)<br><span class="hljs-keyword">return</span> sec + nsec/<span class="hljs-number">1e9</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消费-token-总结"><a href="#消费-token-总结" class="headerlink" title="消费 token 总结"></a>消费 token 总结</h3><p>消费 token 的逻辑就讲完了，我们大概总结一下</p><ul><li>需要消费的时候，先去计算一下，从过去到现在可以生成多少个 token</li><li>然后我们通过需要的 token 减去现在拥有的 token 数量，就得到了需要预约的 token 数量</li><li>再通过 token 数量转换成时间，就可以得到需要等待的时间长度，以及是否可以消费</li><li>然后再通过不同的消费方法进行消费</li></ul><h3 id="WaitN"><a href="#WaitN" class="headerlink" title="WaitN"></a>WaitN</h3><p>其他两类消费方法都很简单，调用 <code>Reservation</code>  进行返回， <code>WaitN</code>  还有一点逻辑，所以我们一起来看一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ctx 用于控制超时, n 是需要消费的 token 数量，如果 context 的 Deadline 早于要等待的时间就会直接返回失败</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">WaitN</span><span class="hljs-params">(ctx context.Context, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(err error)</span></span> &#123;<br>lim.mu.Lock()<br>burst := lim.burst<br>limit := lim.limit<br>lim.mu.Unlock()<br><br>    <span class="hljs-comment">// 先看一下是不是已经超出消费极限了</span><br><span class="hljs-keyword">if</span> n &gt; burst &amp;&amp; limit != Inf &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;rate: Wait(n=%d) exceeds limiter&#x27;s burst %d&quot;</span>, n, burst)<br>&#125;<br><br>    <span class="hljs-comment">// 如果 ctx 已经结束了也不用等了</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-keyword">return</span> ctx.Err()<br><span class="hljs-keyword">default</span>:<br>&#125;<br><br><span class="hljs-comment">// 计算一下可以等待的时间</span><br>now := time.Now()<br>waitLimit := InfDuration<br><span class="hljs-keyword">if</span> deadline, ok := ctx.Deadline(); ok &#123;<br>waitLimit = deadline.Sub(now)<br>&#125;<br><br><span class="hljs-comment">// 调用 reserveN 得到预约数据</span><br>r := lim.reserveN(now, n, waitLimit)<br><br>    <span class="hljs-comment">// 如果不 ok 说明预约不到</span><br><span class="hljs-keyword">if</span> !r.ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;rate: Wait(n=%d) would exceed context deadline&quot;</span>, n)<br>&#125;<br><br><span class="hljs-comment">// 如果可以预约到，计算一下需要等多久</span><br>delay := r.DelayFrom(now)<br><span class="hljs-keyword">if</span> delay == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>    <span class="hljs-comment">// 启动一个 timer 进行定时</span><br>t := time.NewTimer(delay)<br><span class="hljs-keyword">defer</span> t.Stop()<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-t.C:<br><span class="hljs-comment">// We can proceed.</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-comment">// 如果 context 主动取消了，那么值钱预约的 token 数量需要归还</span><br>r.Cancel()<br><span class="hljs-keyword">return</span> ctx.Err()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="取消消费"><a href="#取消消费" class="headerlink" title="取消消费"></a>取消消费</h3><p><code>WaitN</code>  当中如果预约上了，但是 <code>Context</code>  取消了，会调用 <code>CancelAt</code>  归还 tokens 我们来一起看一下是怎么实现的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reservation)</span> <span class="hljs-title">CancelAt</span><span class="hljs-params">(now time.Time)</span></span> &#123;<br>    <span class="hljs-comment">// 不 ok 说明没有预约上，直接返回就行了</span><br><span class="hljs-keyword">if</span> !r.ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>r.lim.mu.Lock()<br><span class="hljs-keyword">defer</span> r.lim.mu.Unlock()<br><br>    <span class="hljs-comment">// 如果没有速率限制，或者没有消费 token 或 token 已经被消费了，都不用还了</span><br><span class="hljs-keyword">if</span> r.lim.limit == Inf || r.tokens == <span class="hljs-number">0</span> || r.timeToAct.Before(now) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 计算需要还的 token 数量</span><br>    <span class="hljs-comment">// 这里说是需要减去已经预支的 token 数量，但是我发现应该是个 bug，感觉这里减重复了</span><br>restoreTokens := <span class="hljs-keyword">float64</span>(r.tokens) - r.limit.tokensFromDuration(r.lim.lastEvent.Sub(r.timeToAct))<br><span class="hljs-keyword">if</span> restoreTokens &lt;= <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>    <span class="hljs-comment">// 计算当前拥有的 tokens 数量</span><br>now, _, tokens := r.lim.advance(now)<br><br><span class="hljs-comment">// 当前拥有的加上需要归还的就是现有的，但是不能大于桶的容量</span><br>tokens += restoreTokens<br><span class="hljs-keyword">if</span> burst := <span class="hljs-keyword">float64</span>(r.lim.burst); tokens &gt; burst &#123;<br>tokens = burst<br>&#125;<br><br><span class="hljs-comment">// 更新 tokens 数量</span><br>r.lim.last = now<br>r.lim.tokens = tokens<br><br>    <span class="hljs-comment">// 如果相等说明后面没有新的 token 消费，所以将状态重置到上一次</span><br><span class="hljs-keyword">if</span> r.timeToAct == r.lim.lastEvent &#123;<br>prevEvent := r.timeToAct.Add(r.limit.durationFromTokens(<span class="hljs-keyword">float64</span>(-r.tokens)))<br><span class="hljs-keyword">if</span> !prevEvent.Before(now) &#123;<br>r.lim.lastEvent = prevEvent<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>除了上面提到的感觉 cancelAt 可能有一个 bug 外，云神的博客还提到了一个问题，就是如果我们 cancel 了的话，后面已经在等待的任务是不会重新调整的，举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span></span> &#123;<br>l := rate.NewLimiter(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br>t := time.Now()<br>l.ReserveN(t, <span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br>ctx, cancel := context.WithTimeout(context.TODO(), time.Hour)<br><span class="hljs-keyword">defer</span> cancel()<br><br>    <span class="hljs-comment">// 注释掉下面这段就不会提前 cancel</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-comment">// 模拟出现问题, 200ms就取消了</span><br>time.Sleep(<span class="hljs-number">200</span> * time.Millisecond)<br>cancel()<br>&#125;()<br><br>wg.Add(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-comment">// 如果要等，这个要等 1s 才能执行，但是我们的 ctx 200ms 就会取消</span><br>l.WaitN(ctx, <span class="hljs-number">10</span>)<br>fmt.Printf(<span class="hljs-string">&quot;[1] cost: %s\n&quot;</span>, time.Since(t))<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-comment">// 正常情况下，这个要等 1.2 s 才能执行，但是我们前面都取消了</span><br><span class="hljs-comment">// 这个是不是应该就只需要等 200ms 就执行了</span><br>ctx, cancel := context.WithTimeout(context.Background(), time.Hour)<br><span class="hljs-keyword">defer</span> cancel()<br>l.WaitN(ctx, <span class="hljs-number">2</span>)<br>fmt.Printf(<span class="hljs-string">&quot;[2] cost: %s\n&quot;</span>, time.Since(t))<br>&#125;()<br><br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先看一下不提前 cancel 的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[1] cost: 1.0002113s<br>[2] cost: 1.2007347s<br></code></pre></td></tr></table></figure><p>再看看提前 cancel 的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[1] cost: 200.8268ms<br>[2] cost: 1.201066s<br></code></pre></td></tr></table></figure><p>可以看到就是 1 有变化，从 1s -&gt; 200ms 但是 2 一直都要等 1.2s</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>仔细看了一下令牌桶的实现，但是也留下了一个疑问，如果哪位童鞋知道希望可以留言告诉我，在取消的时候，会减掉一个预约的时间，但是我发现这里其实应该是重复减了一次</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">restoreTokens := <span class="hljs-keyword">float64</span>(r.tokens) - r.limit.tokensFromDuration(r.lim.lastEvent.Sub(r.timeToAct))<br></code></pre></td></tr></table></figure><p>下面是测试代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t0 := time.Now()<br>t1 := time.Now().Add(<span class="hljs-number">100</span> * time.Millisecond)<br>t2 := time.Now().Add(<span class="hljs-number">200</span> * time.Millisecond)<br>t3 := time.Now().Add(<span class="hljs-number">300</span> * time.Millisecond)<br><br>l := rate.NewLimiter(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>l.ReserveN(t0, <span class="hljs-number">15</span>) <span class="hljs-comment">// 桶里还剩 5 个 token</span><br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, l)<br><br>r := l.ReserveN(t1, <span class="hljs-number">10</span>) <span class="hljs-comment">// 桶还有 -4 个，</span><br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, l)<br><br><span class="hljs-comment">// 注释掉下面两行，最后结果还剩 8 个 token</span><br>l.ReserveN(t2, <span class="hljs-number">2</span>) <span class="hljs-comment">// 桶里还有 -5 个</span><br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, l)<br><br>r.CancelAt(t3)<br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, l)<br><span class="hljs-comment">// 归还之前借的，运行结果 桶里还有 4 个</span><br><span class="hljs-comment">// 但是这里不应该剩下 6 个么，本来有 5 个，300ms 生成了 3 个，后面又预支出去 2 个</span><br><span class="hljs-comment">// 而且我发现如果我注释掉预支两个的代码，结果和我预期的一致，剩余 8 个token</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Token_bucket">Token bucket - Wikipedia</a></p></li><li><a href="https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95">令牌桶算法_百度百科 (baidu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/158948815">限流的概念，算法，分布式限流以及微服务架构下限流的难点 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/164503398">令牌桶工作原理 - 知乎 (zhihu.com)</a></li><li><a href="https://pkg.go.dev/golang.org/x/time/rate">/x/time/rate</a></li><li><a href="https://pandaychen.github.io/2020/04/05/GOLANG-X-RATELIMIT-ANALYSIS/">开源限流组件分析（二）：Golang-time/rate 限速算法实现分析 - 熊喵君的博客 | PANDAYCHEN</a></li><li><a href="http://xiaorui.cc/archives/5930">Golang rate 无法延迟重排的 BUG – 峰云就她了 (xiaorui.cc)</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week06: 微服务可用性设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>微服务</tag>
      
      <tag>可用性</tag>
      
      <tag>过载保护</tag>
      
      <tag>限流</tag>
      
      <tag>令牌桶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go可用性(二) 限流1: 令牌桶原理及使用</title>
    <link href="/post/go-training-week6-2-token-bucket-1.html"/>
    <url>/post/go-training-week6-2-token-bucket-1.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><strong>3 月进度: 10/15</strong>，终于完成了 2/3 了，后续文章会在长度上做一些调整，之前的文章长度有的实在是比较长，这样会导致不太便于阅读，特别是现在很多都是使用手机进行查看，所以后面每天文章的长度会尽量控制在 2k - 3k 这个长度，太短了没啥内容，太长了阅读上会有一些疲劳</p><p>从这篇文章开始会开始讲一讲限流该如何做，会结合 Go 进阶训练营 中的内容、网上查阅的一些资料以及个人一些微小的经验进行总结，这一部分预计总共会有 7 篇文章，今天我们来开始第一篇，令牌桶的原理及使用。</p><h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1616948682303-85f82a16-c93e-4a35-a9f0-0b480480b374.jpg" alt=""><br>如上图[<a href="https://zhuanlan.zhihu.com/p/164503398">5</a>] 所示，令牌桶的大概原理是：</p><ol><li>我们以 <code>r/s</code>  的速度向桶内放置令牌，桶的容量为 <code>b</code> , 如果桶满了令牌将会丢弃</li><li>当请求到达时，我们向桶内获取令牌，如果令牌足够，我们就通过转发请求</li><li>如果桶内的令牌数量不够，那么这个请求会被缓存等待令牌足够时转发，或者是被直接丢弃掉</li></ol><p><strong>由于桶的存在，所以令牌桶算法不仅可以限流还可以应对突发流量的情况</strong></p><p>举个例子：假设我们桶的容量是 100，速度是 10 rps，那么在我们桶满的情况下，如果突然来 100 个请求是可以满足的，但是后续的请求就会被限制到 10 rps</p><p><strong>存在下面两种特殊情况</strong></p><ul><li>如果桶的容量为 0，那么相当于禁止请求，因为所有的令牌都被丢弃了</li><li>如果令牌放置速率为无穷大，那么相当于没有限制</li></ul><p>令牌桶最常见的实现就是 Go 官方的 <a href="https://pkg.go.dev/golang.org/x/time/rate">golang.org/x/time/rate</a>，接下来我们就看看这个库如何使用吧</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="方法一览"><a href="#方法一览" class="headerlink" title="方法一览"></a>方法一览</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 限流器结构体</span><br><span class="hljs-keyword">type</span> Limiter<br><span class="hljs-comment">// 构建一个限流器，r 是每秒放入的令牌数量，b 是桶的大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLimiter</span><span class="hljs-params">(r Limit, b <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Limiter</span></span><br><br><span class="hljs-comment">// 分别返回 b 和 r 的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">Burst</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">Limit</span><span class="hljs-params">()</span> <span class="hljs-title">Limit</span></span><br><br><span class="hljs-comment">// token 消费方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">Allow</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">AllowN</span><span class="hljs-params">(now time.Time, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">Reserve</span><span class="hljs-params">()</span> *<span class="hljs-title">Reservation</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">ReserveN</span><span class="hljs-params">(now time.Time, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Reservation</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">Wait</span><span class="hljs-params">(ctx context.Context)</span> <span class="hljs-params">(err error)</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">WaitN</span><span class="hljs-params">(ctx context.Context, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(err error)</span></span><br><br><span class="hljs-comment">// 动态流控</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">SetBurst</span><span class="hljs-params">(newBurst <span class="hljs-keyword">int</span>)</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">SetBurstAt</span><span class="hljs-params">(now time.Time, newBurst <span class="hljs-keyword">int</span>)</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">SetLimit</span><span class="hljs-params">(newLimit Limit)</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">SetLimitAt</span><span class="hljs-params">(now time.Time, newLimit Limit)</span></span><br></code></pre></td></tr></table></figure><h4 id="初始化令牌桶"><a href="#初始化令牌桶" class="headerlink" title="初始化令牌桶"></a>初始化令牌桶</h4><p>直接调用 <code>NewLimiter(r Limit, b int)</code>  即可， <code>r</code>  表示每秒产生 token 的速度， <code>b</code>  表示桶的大小</p><h4 id="Token-消费"><a href="#Token-消费" class="headerlink" title="Token 消费"></a>Token 消费</h4><p>总共有三种 token 消费的方式，最常用的是使用 <code>Wait</code>  阻塞等待<br>**<br><strong>Allow</strong></p><p><code>Allow</code>  就是 <code>AllowN(now,1)</code>  的别名， <code>AllowN</code>  表示截止到 <code>now</code>  这个时间点，是否存在 <code>n</code>  个 token，如果存在那么就返回 true 反之返回 false，如果我们限流比较严格，没有资源就直接丢弃可以使用这个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">Allow</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">AllowN</span><span class="hljs-params">(now time.Time, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span><br></code></pre></td></tr></table></figure><p>**<br><strong>Reserve</strong></p><p>同理 <code>Reserve</code>  也是 <code>ReserveN(now, 1)</code>  的别名， <code>ReserveN</code>  其实和 <code>AllowN</code>  类似，表示截止到 <code>now</code>  这个时间点，是否存在 <code>n</code>  个 token，只是 <code>AllowN</code>  直接返回 true or false，但是 <code>ReserveN</code>  返回一个 <code>Reservation</code>  对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">Reserve</span><span class="hljs-params">()</span> *<span class="hljs-title">Reservation</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">ReserveN</span><span class="hljs-params">(now time.Time, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Reservation</span></span><br></code></pre></td></tr></table></figure><p><code>Reservation</code>  有 5 个方法，通过调用 <code>OK</code>  我们可以知道是否通过等待可以获取到 N 个 token，如果可以通过 <code>Delay</code>  方法我们可以得知需要等待的时间，如果我们不想等了可以调用 <code>Cancel</code>  方法归还 token</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reservation<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reservation)</span> <span class="hljs-title">Cancel</span><span class="hljs-params">()</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reservation)</span> <span class="hljs-title">CancelAt</span><span class="hljs-params">(now time.Time)</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reservation)</span> <span class="hljs-title">Delay</span><span class="hljs-params">()</span> <span class="hljs-title">time</span>.<span class="hljs-title">Duration</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reservation)</span> <span class="hljs-title">DelayFrom</span><span class="hljs-params">(now time.Time)</span> <span class="hljs-title">time</span>.<span class="hljs-title">Duration</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reservation)</span> <span class="hljs-title">OK</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span><br></code></pre></td></tr></table></figure><p>**<br><strong>Wait</strong></p><p><code>Wait</code>  是最常用的， <code>Wait</code>  是 <code>WaitN(ctx, 1)</code>  的别名， <code>WaitN(ctx, n)</code>  表示如果存在 <code>n</code>  个令牌就直接转发，不存在我们就等，等待存在为止，传入的 <code>ctx</code>  的 <code>Deadline</code>  就是等待的 Deadline</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">Wait</span><span class="hljs-params">(ctx context.Context)</span> <span class="hljs-params">(err error)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">WaitN</span><span class="hljs-params">(ctx context.Context, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(err error)</span></span><br></code></pre></td></tr></table></figure><h4 id="动态流控"><a href="#动态流控" class="headerlink" title="动态流控"></a>动态流控</h4><p>通过调用 <code>SetBurst</code>  和 <code>SetLimit</code>  可以动态的设置桶的大小和 token 生产速率，其中 <code>SetBurstAt</code>  和 <code>SetLimitAt</code>  会将传入的时间 <code>now</code>  设置为流控最后的更新时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">SetBurst</span><span class="hljs-params">(newBurst <span class="hljs-keyword">int</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">SetBurstAt</span><span class="hljs-params">(now time.Time, newBurst <span class="hljs-keyword">int</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">SetLimit</span><span class="hljs-params">(newLimit Limit)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span> <span class="hljs-title">SetLimitAt</span><span class="hljs-params">(now time.Time, newLimit Limit)</span></span><br></code></pre></td></tr></table></figure><h3 id="案例-10-行代码实现-基于-ip-的-gin-限流中间件"><a href="#案例-10-行代码实现-基于-ip-的-gin-限流中间件" class="headerlink" title="案例: 10 行代码实现 基于 ip 的 gin 限流中间件"></a>案例: 10 行代码实现 基于 ip 的 gin 限流中间件</h3><p>正好上周我们有个类似的需求，我们就来简单实现一下，其实主要就是使用了 <code>sync.map</code>  来为每一个 ip 创建一个 limiter，当然这个 key 也可以是其他的值，例如用户名等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLimiter</span><span class="hljs-params">(r rate.Limit, b <span class="hljs-keyword">int</span>, t time.Duration)</span> <span class="hljs-title">gin</span>.<span class="hljs-title">HandlerFunc</span></span> &#123;<br>limiters := &amp;sync.Map&#123;&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 获取限速器</span><br><span class="hljs-comment">// key 除了 ip 之外也可以是其他的，例如 header，user name 等</span><br>key := c.ClientIP()<br>l, _ := limiters.LoadOrStore(key, rate.NewLimiter(r, b))<br><br><span class="hljs-comment">// 这里注意不要直接使用 gin 的 context 默认是没有超时时间的</span><br>ctx, cancel := context.WithTimeout(c, t)<br><span class="hljs-keyword">defer</span> cancel()<br><br><span class="hljs-keyword">if</span> err := l.(*rate.Limiter).Wait(ctx); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 这里先不处理日志了，如果返回错误就直接 429</span><br>c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err&#125;)<br>&#125;<br>c.Next()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的时候只需要 use 一下中间件就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>e := gin.Default()<br><span class="hljs-comment">// 新建一个限速器，允许突发 10 个并发，限速 3rps，超过 500ms 就不再等待</span><br>e.Use(NewLimiter(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">500</span>*time.Millisecond))<br>e.GET(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.String(http.StatusOK, <span class="hljs-string">&quot;pong&quot;</span>)<br>&#125;)<br>e.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用 <code>go-stress-testing</code>  来压测一下，20 个并发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"> ~/gopath/bin/go-stress-testing-mac -c 20 -n 1 -u http://127.0.0.1:8080/ping<br><br>开始启动  并发数:20 请求数:1 请求参数:<br><br>─────┬───────┬───────┬───────┬────────┬────────┬────────┬────────┬────────┬────────┬────────<br>  耗时│  并发数│  成功数│  失败数│   qps  │ 最长耗时│  最短耗时│ 平均耗时│  下载字节│ 字节每秒│ 错误码<br>─────┼───────┼───────┼───────┼────────┼────────┼────────┼────────┼────────┼────────┼────────<br>   1s│     20│     11│      9│   63.79│  438.48│   45.37│  313.53│     152│     259│200:11;429:9<br><br><br>*************************  结果 <span class="hljs-built_in">stat</span>  ****************************<br>处理协程数量: 20<br>请求总数（并发数*请求数 -c * -n）: 20 总请求时间: 0.586 秒 successNum: 11 failureNum: 9<br>*************************  结果 end   ****************************<br></code></pre></td></tr></table></figure><p>可以发现总共成功了 11 个请求，失败了 9 个，这是因为我们桶的大小是 10 所以前 10 个请求都很快就结束了，第 11 个请求等待 333.3 ms 就可以完成，小于超时时间 500ms，所以可以放行，但是后面的请求确是等不了了，所以就都失败了，并且可以看到最后一个成功的请求的耗时为 <code>336.83591ms</code>  而其他的请求耗时都很短</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">[GIN-debug] Listening and serving HTTP on :8080<br>[GIN] 2021/03/29 - 13:15:55 | 200 |     1.48104ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 429 |    1.107689ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 429 |    1.746222ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 429 |      866.35µs |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 429 |    1.870403ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 429 |    2.231912ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 429 |    1.832506ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 429 |     613.741µs |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 200 |    1.454753ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 200 |     1.37802ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 200 |    1.428062ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 200 |      40.782µs |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 200 |    1.046146ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 429 |      1.7624ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 429 |    1.803124ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 200 |       41.67µs |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 200 |     1.42315ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 200 |    1.371483ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 200 |     731.091µs |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br>[GIN] 2021/03/29 - 13:15:55 | 200 |   336.83591ms |       127.0.0.1 | GET      <span class="hljs-string">&quot;/ping&quot;</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇主要介绍了一下令牌桶的实现原理，以及 Go 官方实现如何使用，最后讲了一个使用案例，下一篇我们再来学习一下源码是怎么实现的</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></li><li><a href="https://en.wikipedia.org/wiki/Token_bucket">Token bucket - Wikipedia</a></li><li><a href="https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95">令牌桶算法_百度百科 (baidu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/158948815">限流的概念，算法，分布式限流以及微服务架构下限流的难点 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/164503398">令牌桶工作原理 - 知乎 (zhihu.com)</a></li><li><a href="https://pkg.go.dev/golang.org/x/time/rate">golang.org/x/time/rate</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week06: 微服务可用性设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>微服务</tag>
      
      <tag>可用性</tag>
      
      <tag>过载保护</tag>
      
      <tag>限流</tag>
      
      <tag>令牌桶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go可用性(一) 隔离设计</title>
    <link href="/post/go-training-week6-usability-1-bulkhe.html"/>
    <url>/post/go-training-week6-usability-1-bulkhe.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><strong>3 月进度: 09/15</strong></p><p>隔离设计源于船舶行业，一般而言无论大船还是小船，都会有一些隔板，将船分为不同的空间，这样如果有船舱漏水一般只会影响这一小块空间，不至于把整个船都给搞沉了。</p><p>同样我们的软件服务也是一个道理，我们要尽量避免出现一个问题就把这个业务给搞挂的情况出现。</p><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1616682187683-fee45154-b69e-438c-8c09-53dfe5f32916.png" alt=""><br>一般而言类似的文章都会告诉大家服务隔离应该分为哪里类型，或者那些级别，然后一般分别怎么做，今天我们换一个套路，我们从一个服务演进的角度来看，我们服务隔离是怎么做的</p><h2 id="服务的演进"><a href="#服务的演进" class="headerlink" title="服务的演进"></a>服务的演进</h2><p>PS: 接下来的部分架构纯属瞎扯，但是道理是差不多的，辛苦各位凑合看一下了</p><p>如下图，今天天气不错，我们开始创业（天气和创业有啥关系？？？），搞了一个电商网站，由于前期人手不足技术也不够，就一个服务和一个数据库就开始对外提供服务了<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1616682861837-8c345d62-e181-478e-b51f-81a46bf33aee.jpeg" alt="v1.jpg"><br>随着货物的不断上架，我们发现产品相关介绍的图片、视频等信息占用了我们服务的大部分带宽，并且也不太好管理，用户访问呢也比较慢，影响了剁手的体验，这时候我们做了一波优化，把静态资源的数据使用云服务商提供的对象存储给保存了起来，然后在前面接入了一个 CDN 给用户提供更好的体验。</p><p><strong>这就是第一次隔离，动静隔离，我们使用对象存储和 CDN 将静态资源和动态 API 进行了隔离</strong><br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1616682867673-bcc803dd-6d8a-4868-a4bb-c26401d21951.jpeg" alt="v2.jpg"><br>然后突然有一天我们发现，用户大量投诉说什么垃圾网站，突然访问这么慢，进过紧锣密鼓的排查发现，原来是我们的运营同学在后台进行数据统计准备出报告的时候影响了生产的数据库，导致影响了我们的用户。</p><p>这怎么能行呢，怎么可以影响我们的衣食父母，所以我们有进行了一波优化，我们对数据库进行了主从分离，然后将运营后台和我们的商城主服务做了拆分，后续所有的统计查询请求我们都从从库查询，其他请求才会去修改主库。</p><p><strong>是滴，我们又做了一次隔离，一个是将数据库做了主从隔离，另外一个按照不同的用户属性，做了用户隔离。当然这是比较宏观的在这过程中我们肯定也会对数据中的表进行一些拆分设计，例如将经常变化的数据和不太经常变化的数据分配到两张表等。</strong><br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1616682875486-e25112ea-7339-4f10-b899-73bcda442ee5.jpeg" alt="v3.jpg"></p><p>不知道是随着一些爆款活动的退出，以及不知名大 V 的推广使得我们的业务欣欣向上，还是我们新来的技术总监为了 KPI 我们进行了轰轰烈烈的微服务改造的活动，最后经过长达一年多的改造，我们的服务架构改造成了下面这个模样。</p><p>我们的请求才访问之前都会先经过 WAF 防火墙，然后在到对应的 CDN 节点然后经过我们的 API 网关到 BFF 层。然后 BFF 层再去调用各种服务聚合成业务数据并且返回。</p><p><strong>我们其实又做了一层按照服务的隔离，我们将一个单体服务拆分成了一个个的小服务，就不会出现评论挂掉了导致整个服务挂掉无法下单的情况。</strong><br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1616683768644-9612104e-32b1-4dbd-a560-66624867c1f1.png" alt="v4.png"><br>微服务改造完成之后我们发现，的确整体的服务质量都好了很多，但是突如其来的一个 bug 导致我们的监控大量告警，这是为什么呢，原来是我们的推荐服务出现了一个内存泄漏的问题，然后我们的服务限制做的不够好根本没有设置任何限制，这就导致它占用了资源池中的大量资源，让我们的其他服务资源紧缺。</p><p>然后我们就又做了一个改造，我们把支付和商城这种最重要的业务单独放在了一个池子里面，对于像评论推荐这种没有那么重要的业务放在共享的资源池当中。</p><p><strong>所以这一次我们按照服务的优先级进行了隔离</strong><br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1616684093160-fc520e2b-60c0-4c79-be59-a424c2dca9fa.png" alt="v5.png"><br>然后突然有一天，我们的一个商品成为了爆款，大量用户涌入访问，成功将我们的 cache 打挂，后续我们做了什么改动呢，我们将 remote cache 提升为了 local cache，在 sdk 当中自动识别出热点流量，然后将其缓存，大大减少了 redis 的压力</p><p><strong>这一次我们就将热点数据进行了隔离</strong><br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1616685784499-6e9c1df5-44e1-437b-a400-099b1fcbeee6.png" alt="V6.png"><br>好啦，瞎扯结束总结一下吧</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面纯属虚构的面向事故驱动的例子，我们可以发现，我们隔离设计一般分为以下几种：</p><ul><li>服务隔离<ul><li>动静隔离：例如上面讲到的 CDN</li><li>读写隔离：例如上面讲到的主从，除此之外还有常见的 CQRS 模式，分库分表等</li></ul></li><li>轻重隔离<ul><li>核心隔离：例如上面讲到将核心业务独立部署，非核心业务共享资源</li><li>热点隔离：例如上面讲到的 remote cache 到 local cache</li><li>用户隔离：不同的用户可能有不同的级别，例如上面讲到的外部用户和管理员</li></ul></li><li>物理隔离<ul><li>线程：常见的例子就是线程池，这个在 Golang 中一般不用过多考虑，runtime 已经帮我们管理好了（后续有一个系列讲这个）</li><li>进程：我们现在一般使用容器化服务，跑在 k8s 上这就是一种进程级别的隔离</li><li>机房：我们目前在 K8s 的基础上做一些开发，常见的一种做法就是将我们的服务的不同副本尽量的分配在不同的可用区，实际上就是云厂商的不同机房，避免机房停电或者着火之类的影响</li><li>集群：非常重要的服务我们可以部署多套，在物理上进行隔离，常见的有异地部署，也可能就部署在同一个区域</li></ul></li></ul><p>今天的内容就到这里，画图真的好费时间，下篇文章讲一讲过载保护-令牌桶，敬请期待</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></li><li><a href="https://zhuanlan.zhihu.com/p/40475855">架构设计之「服务隔离」</a></li><li><a href="https://time.geekbang.org/column/article/3917">42 | 弹力设计篇之“隔离设计”-极客时间</a></li><li><a href="https://time.geekbang.org/column/article/3912">41 | 弹力设计篇之“认识故障和弹力设计”-极客时间</a></li><li><a href="https://developer.aliyun.com/article/712982">如何设计高可用系统之故障隔离-阿里云开发者社区</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week06: 微服务可用性设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>微服务</tag>
      
      <tag>可用性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程(十二) Singleflight</title>
    <link href="/post/go-training-week5-singleflight.html"/>
    <url>/post/go-training-week5-singleflight.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><strong>3 月进度: 08/15</strong> （月初定的目标感觉快完不成了）</p><p>这一篇文章的内容是在 <a href="https://lailin.xyz/post/go-training-week5-comment-design-1.html">Week05: 评论系统架构设计</a> 当中的可用性设计当中提到的，但是这个属于 Go 官方扩展同步包 (<a href="https://pkg.go.dev/golang.org/x/sync/singleflight">golang.org/x/sync/singleflight</a>) 的一个库，为了让内容统一就放到这里了。</p><p>废话到此结束，正式进入今天的内容</p><h2 id="SingleFlight"><a href="#SingleFlight" class="headerlink" title="SingleFlight"></a>SingleFlight</h2><h3 id="为什么我们需要-SingleFlight（使用场景）？"><a href="#为什么我们需要-SingleFlight（使用场景）？" class="headerlink" title="为什么我们需要 SingleFlight（使用场景）？"></a>为什么我们需要 SingleFlight（使用场景）？</h3><p>一般情况下我们在写一写对外的服务的时候都会有一层 cache 作为缓存，用来减少底层数据库的压力，但是在遇到例如 redis 抖动或者其他情况可能会导致大量的 cache miss 出现。</p><p>如下图所示，可能存在来自桌面端和移动端的用户有 1000 的并发请求，他们都访问的获取文章列表的接口，获取前 20 条信息，如果这个时候我们服务直接去访问 redis 出现 cache miss 那么我们就会去请求 1000 次数据库，这时可能会给数据库带来较大的压力（这里的 1000 只是一个例子，实际上可能远大于这个值）导致我们的服务异常或者超时。<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1616344003127-d6a6a921-8913-4dd0-aa1e-cdd032cd6df5.jpeg" alt="Frame 1.jpg"><br>这时候就可以使用 singleflight 库了，直译过来就是单飞，这个库的主要作用就是将一组相同的请求合并成一个请求，实际上只会去请求一次，然后对所有的请求返回相同的结果。<br>如下图所示，使用 singleflight 之后，我们在一个请求的时间周期内实际上只会向底层的数据库发起一次请求大大减少对数据库的压力。<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1616344014634-6cd2cdbf-2eaf-450d-836d-083b1d2fc35e.jpeg" alt="Frame 2.jpg"></p><h3 id="SingleFlight-包怎么用（使用教程）？"><a href="#SingleFlight-包怎么用（使用教程）？" class="headerlink" title="SingleFlight 包怎么用（使用教程）？"></a>SingleFlight 包怎么用（使用教程）？</h3><h4 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h4><p>主要是一个 <code>Group</code>  结构体，三个方法，具体信息看下方注释</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Group<br>    <span class="hljs-comment">// Do 执行函数, 对同一个 key 多次调用的时候，在第一次调用没有执行完的时候</span><br><span class="hljs-comment">// 只会执行一次 fn 其他的调用会阻塞住等待这次调用返回</span><br><span class="hljs-comment">// v, err 是传入的 fn 的返回值</span><br><span class="hljs-comment">// shared 表示是否真正执行了 fn 返回的结果，还是返回的共享的结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span> <span class="hljs-title">Do</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>, fn <span class="hljs-keyword">func</span>()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span>) <span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;, err error, shared <span class="hljs-keyword">bool</span>)</span></span><br><br><span class="hljs-comment">// DoChan 和 Do 类似，只是 DoChan 返回一个 channel，也就是同步与异步的区别</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span> <span class="hljs-title">DoChan</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>, fn <span class="hljs-keyword">func</span>()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span>) &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">Result</span></span><br><br>    <span class="hljs-comment">// Forget 用于通知 Group 删除某个 key 这样后面继续这个 key 的调用的时候就不会在阻塞等待了</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span> <span class="hljs-title">Forget</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span></span><br></code></pre></td></tr></table></figure><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>接下来我们看看实际上我们是怎么使用的，先使用一个普通的例子，这时一个获取文章详情的函数，我们在函数里面使用一个 count 模拟不同并发下的耗时的不同，并发越多请求耗时越多</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getArticle</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(article <span class="hljs-keyword">string</span>, err error)</span></span> &#123;<br><span class="hljs-comment">// 假设这里会对数据库进行调用, 模拟不同并发下耗时不同</span><br>atomic.AddInt32(&amp;count, <span class="hljs-number">1</span>)<br>time.Sleep(time.Duration(count) * time.Millisecond)<br><br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;article: %d&quot;</span>, id), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用 singleflight 的时候就只需要 <code>new(singleflight.Group)</code>  然后调用一下相对应的 Do 方法就可了，是不是很简单</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleflightGetArticle</span><span class="hljs-params">(sg *singleflight.Group, id <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br>v, err, _ := sg.Do(fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, id), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<br><span class="hljs-keyword">return</span> getArticle(id)<br>&#125;)<br><br><span class="hljs-keyword">return</span> v.(<span class="hljs-keyword">string</span>), err<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="效果测试"><a href="#效果测试" class="headerlink" title="效果测试"></a>效果测试</h4><p>光说不练假把式，写一个简单的测试代码，下面我们启动 1000 个 Goroutine 去并发调用这两个方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> count <span class="hljs-keyword">int32</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>time.AfterFunc(<span class="hljs-number">1</span>*time.Second, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>atomic.AddInt32(&amp;count, -count)<br>&#125;)<br><br><span class="hljs-keyword">var</span> (<br>wg  sync.WaitGroup<br>now = time.Now()<br>n   = <span class="hljs-number">1000</span><br>sg  = &amp;singleflight.Group&#123;&#125;<br>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// res, _ := singleflightGetArticle(sg, 1)</span><br>res, _ := getArticle(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;article: 1&quot;</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;err&quot;</span>)<br>&#125;<br>wg.Done()<br>&#125;()<br>&#125;<br><br>wg.Wait()<br>fmt.Printf(<span class="hljs-string">&quot;同时发起 %d 次请求，耗时: %s&quot;</span>, n, time.Since(now))<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个是调用 <code>getArticle</code>  方法的耗时，花费了 1s 多</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 直接调用的请求耗时</span><br>❯ go run ./1.go<br>同时发起 1000 次请求，耗时: 1.0022831s<br></code></pre></td></tr></table></figure><p>而使用 singleflight 的方法，花费了不到 3ms</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 singleflight 的请求耗时</span><br>❯ go run ./1.go<br>同时发起 1000 次请求，耗时: 2.5119ms<br></code></pre></td></tr></table></figure><p>当然每个库都有自己的使用场景，软件领域里面没有银弹，如果我们用的不太好的话甚至可能会得到适得其反的效果，而多看源码不仅能够帮助我们进行学习，也可以尽量少踩坑</p><h3 id="它是如何实现的（源码分析）？"><a href="#它是如何实现的（源码分析）？" class="headerlink" title="它是如何实现的（源码分析）？"></a>它是如何实现的（源码分析）？</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">本文基于 <a href="https://pkg.go.dev/golang.org/x/sync@v0.0.0-20210220032951-036812b2e83c/singleflight">https://pkg.go.dev/golang.org/x/sync@v0.0.0-20210220032951-036812b2e83c/singleflight</a> 进行分析，这个库的实现很简单，但是功能很强大，还有一些小技巧，非常值得学习</div><h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> &#123;<br>mu sync.Mutex       <span class="hljs-comment">// protects m</span><br>m  <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*call <span class="hljs-comment">// lazily initialized</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Group 结构体由一个互斥锁和一个 map 组成，可以看到注释 map 是懒加载的，所以 Group 只要声明就可以使用，不用进行额外的初始化零值就可以直接使用。call 保存了当前调用对应的信息，map 的键就是我们调用 <code>Do</code>  方法传入的 key</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> call <span class="hljs-keyword">struct</span> &#123;<br>wg sync.WaitGroup<br><br><span class="hljs-comment">// 函数的返回值，在 wg 返回前只会写入一次</span><br>val <span class="hljs-keyword">interface</span>&#123;&#125;<br>err error<br><br><span class="hljs-comment">// 使用调用了 Forgot 方法</span><br>forgotten <span class="hljs-keyword">bool</span><br><br>    <span class="hljs-comment">// 统计调用次数以及返回的 channel</span><br>dups  <span class="hljs-keyword">int</span><br>chans []<span class="hljs-keyword">chan</span>&lt;- Result<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Do"><a href="#Do" class="headerlink" title="Do"></a>Do</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span> <span class="hljs-title">Do</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>, fn <span class="hljs-keyword">func</span>()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span>) <span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;, err error, shared <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>g.mu.Lock()<br><br>    <span class="hljs-comment">// 前面提到的懒加载</span><br>    <span class="hljs-keyword">if</span> g.m == <span class="hljs-literal">nil</span> &#123;<br>g.m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*call)<br>&#125;<br><br>    <span class="hljs-comment">// 会先去看 key 是否已经存在</span><br><span class="hljs-keyword">if</span> c, ok := g.m[key]; ok &#123;<br>       <span class="hljs-comment">// 如果存在就会解锁</span><br>c.dups++<br>g.mu.Unlock()<br><br>        <span class="hljs-comment">// 然后等待 WaitGroup 执行完毕，只要一执行完，所有的 wait 都会被唤醒</span><br>c.wg.Wait()<br><br>        <span class="hljs-comment">// 这里区分 panic 错误和 runtime 的错误，避免出现死锁，后面可以看到为什么这么做</span><br><span class="hljs-keyword">if</span> e, ok := c.err.(*panicError); ok &#123;<br><span class="hljs-built_in">panic</span>(e)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c.err == errGoexit &#123;<br>runtime.Goexit()<br>&#125;<br><span class="hljs-keyword">return</span> c.val, c.err, <span class="hljs-literal">true</span><br>&#125;<br><br>    <span class="hljs-comment">// 如果我们没有找到这个 key 就 new call</span><br>c := <span class="hljs-built_in">new</span>(call)<br><br>    <span class="hljs-comment">// 然后调用 waitgroup 这里只有第一次调用会 add 1，其他的都会调用 wait 阻塞掉</span><br>    <span class="hljs-comment">// 所以这要这次调用返回，所有阻塞的调用都会被唤醒</span><br>c.wg.Add(<span class="hljs-number">1</span>)<br>g.m[key] = c<br>g.mu.Unlock()<br><br>    <span class="hljs-comment">// 然后我们调用 doCall 去执行</span><br>g.doCall(c, key, fn)<br><span class="hljs-keyword">return</span> c.val, c.err, c.dups &gt; <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="doCall"><a href="#doCall" class="headerlink" title="doCall"></a>doCall</h4><p>这个方法的实现有点意思，使用了两个 defer 巧妙的将 runtime 的错误和我们传入 function 的 panic 区别开来避免了由于传入的 function panic 导致的死锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span> <span class="hljs-title">doCall</span><span class="hljs-params">(c *call, key <span class="hljs-keyword">string</span>, fn <span class="hljs-keyword">func</span>()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span>)</span> &#123;<br>normalReturn := <span class="hljs-literal">false</span><br>recovered := <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">// 第一个 defer 检查 runtime 错误</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;()<br><br>    <span class="hljs-comment">// 使用一个匿名函数来执行</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> !normalReturn &#123;<br>                <span class="hljs-comment">// 如果 panic 了我们就 recover 掉，然后 new 一个 panic 的错误</span><br>                <span class="hljs-comment">// 后面在上层重新 panic</span><br><span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>c.err = newPanicError(r)<br>&#125;<br>&#125;<br>&#125;()<br><br>c.val, c.err = fn()<br><br>        <span class="hljs-comment">// 如果 fn 没有 panic 就会执行到这一步，如果 panic 了就不会执行到这一步</span><br>        <span class="hljs-comment">// 所以可以通过这个变量来判断是否 panic 了</span><br>normalReturn = <span class="hljs-literal">true</span><br>&#125;()<br><br>    <span class="hljs-comment">// 如果 normalReturn 为 false 就表示，我们的 fn panic 了</span><br>    <span class="hljs-comment">// 如果执行到了这一步，也说明我们的 fn  recover 住了，不是直接 runtime exit</span><br><span class="hljs-keyword">if</span> !normalReturn &#123;<br>recovered = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再来看看第一个 defer 中的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 如果既没有正常执行完毕，又没有 recover 那就说明需要直接退出了</span><br><span class="hljs-keyword">if</span> !normalReturn &amp;&amp; !recovered &#123;<br>c.err = errGoexit<br>&#125;<br><br>c.wg.Done()<br>g.mu.Lock()<br><span class="hljs-keyword">defer</span> g.mu.Unlock()<br><br>       <span class="hljs-comment">// 如果已经 forgot 过了，就不要重复删除这个 key 了</span><br><span class="hljs-keyword">if</span> !c.forgotten &#123;<br><span class="hljs-built_in">delete</span>(g.m, key)<br>&#125;<br><br><span class="hljs-keyword">if</span> e, ok := c.err.(*panicError); ok &#123;<br><span class="hljs-comment">// 如果返回的是 panic 错误，为了避免 channel 死锁，我们需要确保这个 panic 无法被恢复</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.chans) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-built_in">panic</span>(e)<br><span class="hljs-keyword">select</span> &#123;&#125; <span class="hljs-comment">// Keep this goroutine around so that it will appear in the crash dump.</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">panic</span>(e)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c.err == errGoexit &#123;<br><span class="hljs-comment">// 已经准备退出了，也就不用做其他操作了</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 正常情况下向 channel 写入数据</span><br><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> c.chans &#123;<br>ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="hljs-number">0</span>&#125;<br>&#125;<br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure><h4 id="DoChan"><a href="#DoChan" class="headerlink" title="DoChan"></a>DoChan</h4><p>Do chan 和 Do 类似，其实就是一个是同步等待，一个是异步返回，主要实现上就是，如果调用 DoChan 会给 call.chans 添加一个 channel 这样等第一次调用执行完毕之后就会循环向这些 channel 写入数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span> <span class="hljs-title">DoChan</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>, fn <span class="hljs-keyword">func</span>()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span>) &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">Result</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Result, <span class="hljs-number">1</span>)<br>g.mu.Lock()<br><span class="hljs-keyword">if</span> g.m == <span class="hljs-literal">nil</span> &#123;<br>g.m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*call)<br>&#125;<br><span class="hljs-keyword">if</span> c, ok := g.m[key]; ok &#123;<br>c.dups++<br>c.chans = <span class="hljs-built_in">append</span>(c.chans, ch)<br>g.mu.Unlock()<br><span class="hljs-keyword">return</span> ch<br>&#125;<br>c := &amp;call&#123;chans: []<span class="hljs-keyword">chan</span>&lt;- Result&#123;ch&#125;&#125;<br>c.wg.Add(<span class="hljs-number">1</span>)<br>g.m[key] = c<br>g.mu.Unlock()<br><br><span class="hljs-keyword">go</span> g.doCall(c, key, fn)<br><br><span class="hljs-keyword">return</span> ch<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Forget"><a href="#Forget" class="headerlink" title="Forget"></a>Forget</h4><p>forget 用于手动释放某个 key 下次调用就不会阻塞等待了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span> <span class="hljs-title">Forget</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span></span> &#123;<br>g.mu.Lock()<br><span class="hljs-keyword">if</span> c, ok := g.m[key]; ok &#123;<br>c.forgotten = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-built_in">delete</span>(g.m, key)<br>g.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有哪些注意事项（避坑指南）？"><a href="#有哪些注意事项（避坑指南）？" class="headerlink" title="有哪些注意事项（避坑指南）？"></a>有哪些注意事项（避坑指南）？</h3><p>单飞虽好但也不要滥用哦，还是存在一些坑的</p><h3 id="1-一个阻塞，全员等待"><a href="#1-一个阻塞，全员等待" class="headerlink" title="1. 一个阻塞，全员等待"></a>1. 一个阻塞，全员等待</h3><p>使用 singleflight 我们比较常见的是直接使用 Do 方法，但是这个极端情况下会导致整个程序 hang 住，如果我们的代码出点问题，有一个调用 hang 住了，那么会导致所有的请求都 hang 住</p><p>还是之前的例子，我们加一个 select 模拟阻塞</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleflightGetArticle</span><span class="hljs-params">(sg *singleflight.Group, id <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br>v, err, _ := sg.Do(fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, id), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<br><span class="hljs-comment">// 模拟出现问题，hang 住</span><br><span class="hljs-keyword">select</span> &#123;&#125;<br><span class="hljs-keyword">return</span> getArticle(id)<br>&#125;)<br><br><span class="hljs-keyword">return</span> v.(<span class="hljs-keyword">string</span>), err<br>&#125;<br></code></pre></td></tr></table></figure><p>执行就会发现死锁了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">fatal error: all goroutines are asleep - deadlock!<br><br>goroutine <span class="hljs-number">1</span> [<span class="hljs-keyword">select</span> (no cases)]:<br></code></pre></td></tr></table></figure><p>这时候我们可以使用 DoChan 结合 select 做超时控制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleflightGetArticle</span><span class="hljs-params">(ctx context.Context, sg *singleflight.Group, id <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br>result := sg.DoChan(fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, id), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<br><span class="hljs-comment">// 模拟出现问题，hang 住</span><br><span class="hljs-keyword">select</span> &#123;&#125;<br><span class="hljs-keyword">return</span> getArticle(id)<br>&#125;)<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> r := &lt;-result:<br><span class="hljs-keyword">return</span> r.Val.(<span class="hljs-keyword">string</span>), r.Err<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, ctx.Err()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用的时候传入一个含 超时的 context 即可，执行时就会返回超时错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">❯ <span class="hljs-keyword">go</span> run ./<span class="hljs-number">1.</span><span class="hljs-keyword">go</span><br><span class="hljs-built_in">panic</span>: context deadline exceeded<br></code></pre></td></tr></table></figure><h3 id="2-一个出错，全部出错"><a href="#2-一个出错，全部出错" class="headerlink" title="2. 一个出错，全部出错"></a>2. 一个出错，全部出错</h3><p>这个本身不是什么问题，因为 singleflight 就是这么设计的，但是实际使用的时候 如果我们一次调用要 1s，我们的数据库请求或者是 下游服务可以支撑 10rps 的请求的时候这会导致我们的错误阈提高，因为实际上我们可以一秒内尝试 10 次，但是用了 singleflight 之后只能尝试一次，只要出错这段时间内的所有请求都会受影响</p><p>这种情况我们可以启动一个 Goroutine 定时 forget 一下，相当于将 rps 从 1rps 提高到了 10rps</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>       time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br>       <span class="hljs-comment">// logging</span><br>       g.Forget(key)<br>   &#125;()<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章从使用场景，到使用方法，再到源码分析和可能存在的坑给大家介绍了 singleflight，希望你能有所收获，没事看看官方的代码还是很有收获的，这次又学到了一个骚操作，用双重 defer 来避免死锁，你学废了么？</p><p>我们下一篇会开启一个新的系列，Go 可用性，敬请期待！</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://pkg.go.dev/golang.org/x/sync/singleflight">golang.org/x/sync/singleflight</a></li><li><a href="https://www.cyningsun.com/01-11-2021/golang-concurrency-singleflight.html">sync.singleflight 到底怎么用才对？</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#singleflight">Go 语言并发编程、同步原语与锁 | Go 语言设计与实现</a></li><li><a href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></li><li><a href="https://github.com/golang/go/issues/33519">x/sync/singleflight: panic in Do fn results in deadlock · Issue #33519 · golang/go · GitHub</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week03: Go 并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>评论系统架构设计</title>
    <link href="/post/go-training-week5-comment-design-1.html"/>
    <url>/post/go-training-week5-comment-design-1.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><strong>3 月进度: 07/15</strong> 3 月开始会尝试爆更模式，争取做到两天更新一篇文章，如果感兴趣可以拉到文章最下方获取关注方式。</p><p>时间兜兜转转终于复习到 Week05 了，训练营第 0 期也结束了，第一期也马上开始了，个人感觉整体来看还是比较值的，因为在这里我们不仅能学到 Go 的知识其实也有很多架构设计，学习方法论，以及一些职场的话题。接下来我们就来到本次课程的第一个完整案例，评论系统架构设计，据 “某公司” 技术总监毛老师说这套架构设计支撑了 “某公司” 上亿 DAU 的评论系统。</p><div class="note note-warning">            <p>本文涉及部分为收费内容，为保护毛老师的成果，详细内容经沟通后删除，强烈推荐大家购买专栏，并且为大家申请到了读者专属福利，购买前加我微信（lailin306755605）还可获得更多优惠(读者专属福利，比官方优惠更大哦)</p>          </div><p>以下为大纲：</p><ul><li>功能模块设计</li><li>架构设计</li><li>存储设计</li><li>可用性设计</li></ul><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week05: 评论系统架构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>架构设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go工程化(九) 项目重构实践</title>
    <link href="/post/go-training-week4-practice.html"/>
    <url>/post/go-training-week4-practice.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><strong>3 月进度: 06/15</strong> 3 月开始会尝试爆更模式，争取做到两天更新一篇文章，如果感兴趣可以拉到文章最下方获取关注方式。</p><p>这是《Go 工程化》系列的最后一篇文章了，其实在 Go 并发编程完结的时候我想的工程化这一章节不要写这么多，以听课笔记为主就可以了，但是最后还是展开讲了很多内容，与其说是为了做笔记或者是写文章，不如说是为了整理一下过去几年我的一些微不足道的经验，结合毛老师课上讲的内容与自己的情况重新对已有的知识进行了一遍梳理。</p><p>在前面的八篇文章当中我们讲到了，项目结构、依赖注入，API 设计、配置管理、包管理、单元测试，基本上还是将工程化当中的大部分东西都讲到了，不求尽善尽美，但求对你有所帮助，我们今天就来结合前面文章中提到的各种知识来看一下如何将一个老的项目迁移到新的项目结构当中来，这里面的坑也非常的多。</p><p>这篇文章是从之前重构的一个真实项目映射而来，里面讲到的坑基本上在迁移重构的过程中都趟了不止一次。</p><h2 id="迁移前"><a href="#迁移前" class="headerlink" title="迁移前"></a>迁移前</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── app<br>│   ├── controller<br>│   ├── lib<br>│   ├── middleware<br>│   ├── model<br>│   └── router<br>├── cmd<br>│   ├── cron<br>│   └── server<br>├── config<br>│   └── initializer<br>├── db<br>│   └── migrate<br>│   └── migrate.go<br>├── go.mod<br>├── mock<br>├── <span class="hljs-built_in">test</span><br>└── third_party<br></code></pre></td></tr></table></figure><p>这是我们最开始的目录结构，这个结构是仿照 rails 框架设计而来的，这个结构在很长一段时间都是挺好用的，我先大概解释一下每个目录的含义</p><ul><li>app: 应用逻辑相关的代码都在这里<ul><li>controller: 控制器层，主要负责路由</li><li>lib: 一些工具库函数</li><li>middleware: 路由中间件</li><li>router: 路由注册</li><li>model: 由于我们使用的是充血模型，所以这一层的内容比较多，包含了领域对象，业务逻辑，数据存储等都在这里</li></ul></li><li>cmd: 二进制文件目录<ul><li>cron: 定时任务</li><li>server: http server 服务</li></ul></li><li>db: migration 目录</li><li>mock: gomock 生成的文件</li><li>test: 测试工具库</li><li>third_party: 第三方文件</li></ul><p>调用关系如下图所示<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1615219210365-000fcd85-392a-41da-b7e4-8b4fc583123f.jpeg" alt="Frame 1 (4).jpg"></p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>其实在报名参加 Go 进阶训练营 之前我就因为在提高这个项目的单元测试覆盖率的时候发现了很多问题，当时我用了各种操作，非常难受的将单元测试覆盖率写到 85% 左右的时候就写不上去了，因为我们的项目的历史包袱太严重了，很多代码写的基本就不可测试，想要提高测试覆盖率也就无从谈起了。</p><ul><li>cmd<ul><li>我们之前在这一层当中最大的问题就是我们手写了大量启动代码，全手动依赖注入，还有一些隐式的依赖，这就导致在项目后期的时候启动的代码已经非常长了，而且很容易遗漏依赖关系的处理，建议如果不是特别小的项目还是使用 wire 比较香。</li></ul></li><li>initializer<ul><li>我们之前所有的初始化都在这个包内完成，这个不是太大的问题，但是要命的是这里面有大量的全局变量，各种各样，过多的全局变量导致我们的单元测试非常难写。</li></ul></li><li>model<ul><li>这一层的事情特别多，业务逻辑，领域对象，持久化存储等都在这一层完成，这就导致了后面我们 model 层的代码特别多，变成了一团乱麻，真的是剪不断理还乱，慢慢的这一层的逻辑我自己都理不清了。</li><li>这一层的代码耦合也很严重，无论是什么定时任务还是消息队列还是 server 的代码都放到了这里，导致出现了很多坑，举个例子，可能我有一个函数是 <code>GetArticles</code>  这个函数最开始是为了 api 接口返回一些简要的列表数据，只需要查询一张表，返回速度非常快，但是我定时任务有一个地方也需要这个函数，然后我一看，真好这里已经有这个函数了我们就直接复用，但是数据内容不满足需求，我们就直接在这个函数当中加逻辑，然后需求满足了，过一段时间我们突然要求所有的接口必须要在 500ms 以内，结果发现坑来了，很多地方依赖这个函数，看 APM，就这一个函数的查询就需要耗费超过 500ms 🤣</li></ul></li><li>controller<ul><li>这一层主要做参数的处理还有部分业务逻辑，我们的 Controller 层和 model 层的界定比较模糊，有的主要业务逻辑放到了 model 有的有部分业务逻辑又放到了 Controller 了，到后面就是一点一点的找问题</li></ul></li><li>错误处理<ul><li>我们之前在项目内统一了错误码，但是存在两个问题</li><li>一个是要么处处 wrap，要么忘记 wrap 没有一个统一准则，这就导致要么错误堆栈长的没法看，要么就没有太多的错误信息没法排查</li><li>另一个是我们之前在 Controller 层跑业务错误代码，这就导致了很多时候想要返回一些细节的错误信息就无能为力，即使在 model 层抛了也会被 Controller 层吞掉</li></ul></li><li>接口文档<ul><li>这也是一个很大的痛点，之前想了很多方式都不能很好的解决，毛老师给出这个方案后，我没多久就用上了非常爽。</li><li>之前我们的文档分布五花八门，最开始使用 gin swagger 通过写注释的方式来生成相关接口文档，说实话可以用但是比较难用，因为这个注释其实和代码逻辑是两套东西，相当于写一遍代码再写一遍注释，慢慢的就没有人写了，或者还有写的是错误的。最麻烦的是在方案设计阶段我们不会直接写代码注释，所以测试同学在写测试方案的时候会比较麻烦，也不符合我们后续技术方案评审的要求所以后面也就废弃了</li><li>后面我们写到内部的文档平台上，还不如之前的 swagger，虽然解决了方案阶段没接口文档的问题，但是接口文档总是在变化当中的，特别是在开发的时候，这就让前后端对接联调，以及测试同学测试的非常难受，特别是经常会出现和前端同学沟通好了但是忘记和测试说的情况。</li></ul></li></ul><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p><em>迁移要三思，处处都是坑, 重构要小心，TDD 大法好</em></p><h3 id="迁移后目录结构"><a href="#迁移后目录结构" class="headerlink" title="迁移后目录结构"></a>迁移后目录结构</h3><p>为了能够更加直观，我们先来复习一下之前提到过的项目目录结构看一下迁移前后有哪些不同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── api<br>│   └── product<br>│       └── app<br>│           ├── errcode<br>│           └── v1<br>│               └── v1.proto<br>├── cmd<br>│   ├── cron<br>│   │   ├── main.go<br>│   │   └── wire.go<br>│   ├── migrate<br>│   └── server<br>├── config<br>├── go.mod<br>├── internal<br>│   ├── cron<br>│   │   ├── repo<br>│   │   ├── service<br>│   │   ├── usecase<br>│   │   └── wire_set.go<br>│   ├── domain<br>│   ├── pkg<br>│   │   ├── copier<br>│   │   ├── mock<br>│   │   └── <span class="hljs-built_in">test</span><br>│   └── server<br>│       ├── repo<br>│       ├── service<br>│       ├── usecase<br>│       └── wire_set.go<br>└── third_party<br></code></pre></td></tr></table></figure><p>具体每个文件夹的含义就不再赘述，如果不太清楚可以查看 <a href="https://lailin.xyz/post/go-training-week4-project-layout.html">Go 工程化(二) 项目目录结构</a><br>我们看一下新的目录结构的调用链路<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1615268889054-251a4e39-c8d9-410f-950c-5262b368ae34.jpeg" alt="Frame 2 (1).jpg"><br>注意，在这里 service 和 usecase 实际调用的都是 domain 中的接口，只是 usecase 和 repo 实现这些接口而已，所以我们这里用虚线画出来</p><h3 id="迁移重构原则"><a href="#迁移重构原则" class="headerlink" title="迁移重构原则"></a>迁移重构原则</h3><p>接下来我会从各个模块来阐述我在重构这个项目的时候是怎么做的，每个模块都有每个模块自己的坑。开始之前呢我们先来看一下几个总的原则:</p><ul><li>结构简单的应用优先</li><li>有充分的单元测试的应用优先</li><li>先写测试，测试需要在新老代码同时通过</li></ul><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p>api 当中主要写的就是 proto 文件，这个 proto 文件替代了我们在之前的 <code>router</code>  以及部分 <code>controller</code>  中的逻辑，定义了 proto 文件之后，生成的代码当中主要要完成的就是，路由的注册，参数绑定，返回值结构填充。</p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>先补充一下背景，我们之前的项目采用的是 gin 作为路由框架，返回值采用下面这种统一的结构</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;成功&quot;</span>,<br>  <span class="hljs-attr">&quot;data&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 api 层的路由注册，参数绑定，返回值结构填充我们都使用工具进行统一处理，详细介绍可以看之前的文章: <a href="https://lailin.xyz/post/go-training-week4-protoc-gen-go-gin.html">Go 工程化(五) API 设计下: 基于 protobuf 自动生成 gin 代码</a></p><h4 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h4><p>先来看一个基本的例子</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// 这里指定了 proto 文件的版本</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-comment">// package 命名规则: product.application.version</span><br><span class="hljs-keyword">package</span> product.app.v1;<br><br><span class="hljs-comment">// go_package 生成 go 文件当中的包名</span><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;github.com/mohuishou/new-project/api/product/app/v1&quot;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/api/annotations.proto&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">BlogService</span> </span>&#123;<br><br>  <span class="hljs-comment">// 创建文章</span><br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> CreateArticle(CreateArticleReq) <span class="hljs-keyword">returns</span> (CreateArticleResp) </span>&#123;<br>  <span class="hljs-comment">// option 还是都加上，可以利用插件自动生成 swagger 文档</span><br>    <span class="hljs-keyword">option</span> (google.api.http) = &#123;<br>      post: <span class="hljs-string">&quot;/article&quot;</span><br>      body: <span class="hljs-string">&quot;*&quot;</span><br>    &#125;;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 参数和返回值定义，这里就不详细列了</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">CreateArticleReq</span> </span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">CreateArticleResp</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>成功的例子千篇一律，路上的坑各不相同，我们来看一下几个典型的坑(问题)，以及该如何解决</p><h4 id="Q1-Get-请求参数如何进行绑定，默认无法修改-struct-tag"><a href="#Q1-Get-请求参数如何进行绑定，默认无法修改-struct-tag" class="headerlink" title="Q1: Get 请求参数如何进行绑定，默认无法修改 struct tag"></a>Q1: Get 请求参数如何进行绑定，默认无法修改 struct tag</h4><p>这个稳定同样适用于参数校验，原来 gin 参数校验可以在 struct 上加 tag 解决，这个有两种解决方案，一种是使用 <a href="https://github.com/favadi/protoc-go-inject-tag">protoc-go-inject-tag</a> 加注释解决，另外一种是使用 <a href="https://github.com/gogo/protobuf">gogo/protobuf</a> 支持添加 option 的方式来添加 tag，目前我采用的是第一种</p><p>只需要在定义 message 的时候添加注释 <code>// @inject_tag:</code>  后面是具体的 tag</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">GetArticleReq</span> </span>&#123;<br>  <span class="hljs-comment">// @inject_tag: form:&quot;id&quot; binding:&quot;required&quot;</span><br>  <span class="hljs-built_in">int32</span> id = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们在生成好对应的 go 文件之后执行一下 <code>protoc-go-inject-tag -input=filepath</code>  就可以了</p><h4 id="Q2-返回值是一个数组"><a href="#Q2-返回值是一个数组" class="headerlink" title="Q2: 返回值是一个数组"></a>Q2: 返回值是一个数组</h4><p>举个例子，我们之前可能有一个 <code>get: /article/tags</code>  的接口，由于一篇文章当中的标签不会很多，所以我们没有做分页，返回数据的时候直接在 data 里面塞了一个数组，然后我们迁移的时候就麻烦了 o(╥﹏╥)o</p><p>因为在 protobuf 的 rpc 方法定义当中，只能返回一个结构体，无法返回一个数组结构，但是我们做重构的时候又不想有 api 的破坏性变更，因为这项所有的依赖方都需要进行修改成本太大了，那我们如何兼容呢？</p><p>我的解决方案是先生成对应的 go 结构体，然后在同一个包内创建一个 <code>xx_type.pb.go</code>  里面实现 json 的解析接口，让我们虽然定义的是一个结构体，但是返回接口数据的时候返回的是一个数组</p><p>举个例子，下面是我定义的 pb</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">ListArticleTagsResp</span> </span>&#123;<br>  <span class="hljs-keyword">repeated</span> Tag tags = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Tag</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> key = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">string</span> value = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后生成了 <code>v1.pb.go</code> ，我创建了一个 <code>v1_type.pb.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// UnmarshalJSON sets *m to a copy of data.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *ListArticleTagsResp)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">if</span> m == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;json.RawMessage: UnmarshalJSON on nil pointer&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">return</span> json.Unmarshal(data, &amp;m.Tags)<br>&#125;<br><br><span class="hljs-comment">// MarshalJSON returns m as the JSON encoding of m.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *ListArticleTagsResp)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<br><span class="hljs-keyword">if</span> m == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;null&quot;</span>), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">return</span> json.Marshal(m.Tags)<br>&#125;<br></code></pre></td></tr></table></figure><p>当然后续最好还是修改一下，但是重构的时候还是建议不要做破坏性的变动</p><h4 id="Q3-返回值当中包含时间"><a href="#Q3-返回值当中包含时间" class="headerlink" title="Q3: 返回值当中包含时间"></a>Q3: 返回值当中包含时间</h4><p>除了数组之外，返回值当中包含时间也是挺麻烦的一件事情，首先 pb 的基础类型里面没有时间类型，然后 google 官方的库当中有一个 timestamp 包，可以使用，但是使用的时候就会发现，在 json 序列话的时候不是一个时间字段，而是一个对象值，和我们之前直接使用 <code>time.Time</code>  的行为不一致。</p><p>我的做法是仿照 google 的包自己搞一个然后实现 json 的相关方法，让 json 序列化的时候的行为和 <code>time.Time</code>  保持一致</p><p>首先定义 <code>timestamp.proto</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// 这里指定了 proto 文件的版本</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-comment">// package 命名规则: product.application.version</span><br><span class="hljs-keyword">package</span> product.app.v1;<br><br><span class="hljs-comment">// go_package 生成 go 文件当中的包名</span><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;github.com/mohuishou/new-project/api/product/app/v1&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Timestamp</span> </span>&#123;<br><br>    <span class="hljs-comment">// Represents seconds of UTC time since Unix epoch</span><br>    <span class="hljs-comment">// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to</span><br>    <span class="hljs-comment">// 9999-12-31T23:59:59Z inclusive.</span><br>    <span class="hljs-built_in">int64</span> seconds = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// Non-negative fractions of a second at nanosecond resolution. Negative</span><br>    <span class="hljs-comment">// second values with fractions must still have non-negative nanos values</span><br>    <span class="hljs-comment">// that count forward in time. Must be from 0 to 999,999,999</span><br>    <span class="hljs-comment">// inclusive.</span><br>    <span class="hljs-built_in">int32</span> nanos = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>和上面一样，创建一个 <code>timestamp_type.pb.go</code> ，除了实现 json 的接口以外还实现了两个转换方法，用于 service 层调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewTimestamp NewTimestamp</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTimestamp</span><span class="hljs-params">(t time.Time)</span> *<span class="hljs-title">Timestamp</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;Timestamp&#123;<br>Seconds: t.Unix(),<br>Nanos:   <span class="hljs-keyword">int32</span>(t.Nanosecond()),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Time 类型转换</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Timestamp)</span> <span class="hljs-title">Time</span><span class="hljs-params">()</span> <span class="hljs-title">time</span>.<span class="hljs-title">Time</span></span> &#123;<br><span class="hljs-comment">// Don&#x27;t return the zero value on error, because corresponds to a valid</span><br><span class="hljs-comment">// timestamp. Instead return whatever time.Unix gives us.</span><br><span class="hljs-keyword">if</span> m == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> time.Unix(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>).UTC() <span class="hljs-comment">// treat nil like the empty Timestamp</span><br>&#125;<br><br><span class="hljs-keyword">return</span> time.Unix(m.Seconds, <span class="hljs-keyword">int64</span>(m.Nanos)).UTC()<br>&#125;<br><br><span class="hljs-comment">// UnmarshalJSON sets *m to a copy of data.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Timestamp)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">if</span> m == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;json.RawMessage: UnmarshalJSON on nil pointer&quot;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> t time.Time<br><span class="hljs-keyword">if</span> err := json.Unmarshal(data, &amp;t); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>*m = *NewTimestamp(t)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// MarshalJSON returns m as the JSON encoding of m.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Timestamp)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<br><span class="hljs-keyword">if</span> m == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;null&quot;</span>), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">return</span> json.Marshal(m.Time())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h3><p>domain 这一层主要是包含 do 对象的定义，以及 usecase 和 repo 层的接口定义，由于我们现在使用的 gorm 所以，也会在这里给 do 对象加上一些 tag 用于标志索引，关联关系等。</p><h4 id="domain-example"><a href="#domain-example" class="headerlink" title="domain example"></a>domain example</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// article.go</span><br><br><span class="hljs-comment">// Article 文章</span><br><span class="hljs-keyword">type</span> Article <span class="hljs-keyword">struct</span> &#123;<br>Model <span class="hljs-comment">// 基础结构体，包含 id, created_at, deleted_at, updated_at</span><br><br>Title   <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;title&quot;`</span><br>Content <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;content&quot;`</span><br>Tags    []Tag  <span class="hljs-string">`json:&quot;tags&quot; gorm:&quot;many2many:article_tags&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// IArticleUsecase IArticleUsecase</span><br><span class="hljs-keyword">type</span> IArticleUsecase <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-comment">// 获取文章详情</span><br>GetArticle(ctx context.Context, id <span class="hljs-keyword">int</span>) (*Article, error)<br><span class="hljs-comment">// 创建一篇文章</span><br>    CreateArticle(ctx context.Context, article *Article) error<br>&#125;<br><br><span class="hljs-comment">// IArticleRepo IArticleRepo</span><br><span class="hljs-keyword">type</span> IArticleRepo <span class="hljs-keyword">interface</span> &#123;<br>GetArticle(ctx context.Context, id <span class="hljs-keyword">int</span>) (*Article, error)<br>CreateArticle(ctx context.Context, article *Article) error<br>&#125;<br><br><span class="hljs-comment">// tag.go</span><br><br><span class="hljs-comment">// Tag 标签数据</span><br><span class="hljs-keyword">type</span> Tag <span class="hljs-keyword">struct</span> &#123;<br>Model<br><br>Key   <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;key&quot;`</span><br>Value <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;value&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这一层的坑稍微少一些，主要是接口定义的相关事情</p><h4 id="小技巧-批量-mock-接口"><a href="#小技巧-批量-mock-接口" class="headerlink" title="小技巧: 批量 mock 接口"></a>小技巧: 批量 mock 接口</h4><p>使用最新的项目结构我们会在 domain 中创建大量接口，之前在 <a href="https://lailin.xyz/post/go-training-week4-unit-test.html">Go 工程化(八) 单元测试</a> 中我们提到了，在每一层的单元测试的时候，我们都会把依赖的接口用 gomock 给 mock 掉，让测试尽量轻量级一些，为了简化 gomock 的创建，我们可以在 <code>makefile</code>  当中写一个 <code>shell</code>  脚本，找出含有 <code>interface</code>  定义的文件，然后我们用 gomock 生成对应的 mock 文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">mockgen:</span><br>cd ./internal &amp;&amp; for file in `egrep -rnl <span class="hljs-string">&quot;type.*?interface&quot;</span> ./domain | grep -v <span class="hljs-string">&quot;_test&quot;</span> `; do \<br>echo $$file ; \<br>cd .. &amp;&amp; mockgen -destination=<span class="hljs-string">&quot;./internal/pkg/mock/$$file&quot;</span> -source=<span class="hljs-string">&quot;./internal/$$file&quot;</span> &amp;&amp; cd ./internal ; \<br>done<br></code></pre></td></tr></table></figure><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>新的 service 层的主要左右就是 dto 数据和 do 数据的相互转换，它实现了 <code>v1</code>  包中的相关接口，service 的代码比较简单，我们直接看一个例子</p><h4 id="service-example"><a href="#service-example" class="headerlink" title="service example"></a>service example</h4><p>注意，我们在迁移 service、usecase、repo 的时候，都应该先写对应的单元测试，本文当中由于篇幅原因我就没有再列了，感兴趣可以查看上一篇文章 <a href="https://lailin.xyz/post/go-training-week4-unit-test.html">Go 工程化(八) 单元测试</a> 对应章节的内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 确保实现了对应的接口</span><br><span class="hljs-keyword">var</span> _ v1.BlogServiceHTTPServer = &amp;Artcile&#123;&#125;<br><br><span class="hljs-comment">// Artcile Artcile</span><br><span class="hljs-keyword">type</span> Artcile <span class="hljs-keyword">struct</span> &#123;<br>usecase domain.IArticleUsecase<br>&#125;<br><br><span class="hljs-comment">// NewArticleService 初始化方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewArticleService</span><span class="hljs-params">(usecase domain.IArticleUsecase)</span> *<span class="hljs-title">Artcile</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;Artcile&#123;usecase: usecase&#125;<br>&#125;<br><br><span class="hljs-comment">// CreateArticle 创建一篇文章</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Artcile)</span> <span class="hljs-title">CreateArticle</span><span class="hljs-params">(ctx context.Context, req *v1.CreateArticleReq)</span> <span class="hljs-params">(*v1.CreateArticleResp, error)</span></span> &#123;<br>article := &amp;domain.Article&#123;<br>Title:   req.Title,<br>Content: req.Content,<br>&#125;<br>err := a.usecase.CreateArticle(ctx, article)<br><span class="hljs-keyword">return</span> &amp;v1.CreateArticleResp&#123;&#125;, err<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小技巧-copier-减少重复的复制粘贴操作"><a href="#小技巧-copier-减少重复的复制粘贴操作" class="headerlink" title="小技巧: copier 减少重复的复制粘贴操作"></a>小技巧: copier 减少重复的复制粘贴操作</h4><p>在上面的例子我们可以看到，我们的数据转换是手动写的，这种方法不是不行，但是示例当中的字段比较少，如果字段多了起来，并且还有各种数组类型的存在的时候，数据转换的这部分代码写的就会比较难受了，如果你的应用和我的一样对性能的要求不是很高的话可以试试下面这种方式。</p><p>我最开始是用了 jinzhu 大佬的 <a href="https://pkg.go.dev/github.com/jinzhu/copier">copier</a> 包来做的数据转换，但是这个包比较局限，它主要是在两个结构的之间的字段名以及类型相同的时候有用，向出现我们上面在 api 部分讲的那种骚操作就不适用了，并且我还出现过由于两边字段的大小写不一致导致最后有一个字段没有复制成功导致的问题（所以用这个一定要写对应的单元测试）。</p><p>所以结合我们之前的操作，我自己手动写了一个 copier 函数签名一样，实现非常简单，当然性能不太好，但是如果对性能要求不高的话也能用.</p><p>如下所示，就是用 json 来回倒腾两次就行了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Copy 从一个结构体复制到另一个结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Copy</span><span class="hljs-params">(to, from <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<br>b, err := json.Marshal(from)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;marshal from data err&quot;</span>)<br>&#125;<br><br>err = json.Unmarshal(b, to)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;unmarshal to data err&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用这个函数的话，我们上面的代码就可以改成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CreateArticle 创建一篇文章</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Artcile)</span> <span class="hljs-title">CreateArticle</span><span class="hljs-params">(ctx context.Context, req *v1.CreateArticleReq)</span> <span class="hljs-params">(*v1.CreateArticleResp, error)</span></span> &#123;<br><span class="hljs-keyword">var</span> article domain.Article<br>err := copier.Copy(&amp;article, req)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>err = a.usecase.CreateArticle(ctx, &amp;article)<br><span class="hljs-keyword">return</span> &amp;v1.CreateArticleResp&#123;&#125;, err<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="usecase"><a href="#usecase" class="headerlink" title="usecase"></a>usecase</h3><p>这一层主要是业务逻辑，业务逻辑相关代码都应该在这一层写，当然有时候我们的代码可能就只是保存一下数据没啥业务逻辑，可能是直接调用一下 repo 的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> article <span class="hljs-keyword">struct</span> &#123;<br>repo domain.IArticleRepo<br>&#125;<br><br><span class="hljs-comment">// NewArticleUsecase init</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewArticleUsecase</span><span class="hljs-params">(repo domain.IArticleRepo)</span> <span class="hljs-title">domain</span>.<span class="hljs-title">IArticleUsecase</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;article&#123;repo: repo&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *article)</span> <span class="hljs-title">GetArticle</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*domain.Article, error)</span></span> &#123;<br><span class="hljs-comment">// 这里可能有其他业务逻辑...</span><br><span class="hljs-keyword">return</span> u.repo.GetArticle(ctx, id)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *article)</span> <span class="hljs-title">CreateArticle</span><span class="hljs-params">(ctx context.Context, article *domain.Article)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> u.repo.CreateArticle(ctx, article)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="repo"><a href="#repo" class="headerlink" title="repo"></a>repo</h3><p>这一层是数据持久层，像数据库存取，缓存的处理应该都在这一层做掉，还有可能后续我们变成调用一个微服务来实现，那么这个被调用的微服务也应该在这里做。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> article <span class="hljs-keyword">struct</span> &#123;<br>db *gorm.DB<br>&#125;<br><br><span class="hljs-comment">// NewArticleRepo init</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewArticleRepo</span><span class="hljs-params">(db *gorm.DB)</span> <span class="hljs-title">domain</span>.<span class="hljs-title">IArticleRepo</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;article&#123;db: db&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *article)</span> <span class="hljs-title">GetArticle</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*domain.Article, error)</span></span> &#123;<br><span class="hljs-keyword">var</span> a domain.Article<br><span class="hljs-keyword">if</span> err := r.db.WithContext(ctx).Find(&amp;a, id); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 这里返回业务错误码</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;a, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *article)</span> <span class="hljs-title">CreateArticle</span><span class="hljs-params">(ctx context.Context, article *domain.Article)</span> <span class="hljs-title">error</span></span> &#123;<br><br><span class="hljs-keyword">if</span> err := r.db.WithContext(ctx).Create(article); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 这里返回业务错误码</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="wire-set-go"><a href="#wire-set-go" class="headerlink" title="wire_set.go"></a>wire_set.go</h3><p>之前在 <a href="https://lailin.xyz/post/go-training-week4-wire.html">Go 工程化(三) 依赖注入框架 wire</a> 这一节讲到过，我们使用 wire 作为我们的依赖注入框架，由于 wire 不能出现相同的 Provider 所以我们会在 internal 的每个子目录下创建一下 wire_set.go 用于构建 wire.Set 结构，到时我们在 cmd 下直接应用这个文件的内容就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> server<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/google/wire&quot;</span><br><span class="hljs-string">&quot;github.com/mohuishou/new-project/internal/server/repo&quot;</span><br><span class="hljs-string">&quot;github.com/mohuishou/new-project/internal/server/service&quot;</span><br><span class="hljs-string">&quot;github.com/mohuishou/new-project/internal/server/usecase&quot;</span><br>)<br><br><span class="hljs-comment">// Set for di</span><br><span class="hljs-keyword">var</span> Set = wire.NewSet(<br>service.NewArticleService,<br>usecase.NewArticleUsecase,<br>repo.NewArticleRepo,<br>)<br></code></pre></td></tr></table></figure><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><p>cmd 下的二进制目录，我一般会包含四个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── main.go <span class="hljs-comment"># 包含 main 函数</span><br>├── server.go <span class="hljs-comment"># 包含 wire set 等</span><br>├── wire.go <span class="hljs-comment"># for wire build</span><br>└── wire_gen.go <span class="hljs-comment"># wire 自动生成的</span><br></code></pre></td></tr></table></figure><p><strong>server.go</strong> 在真实的项目当中我们 service 包下面一般会有多个 service 文件，对应不同的结构体，并且除了 internal 中的依赖外我们可能还会有很多公共的依赖，例如配置中心，日志，数据库等，我的习惯是构建一个新的结构，在这个结构当中我们把所有的注册还还有 wire.set 搞好，这样 main 函数就会很清爽，整体上也会比较整洁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> set = wire.NewSet(<br><span class="hljs-comment">// domains</span><br>server.Set,<br><br><span class="hljs-comment">// common</span><br>initializer.Set,<br>)<br><br><span class="hljs-keyword">type</span> services <span class="hljs-keyword">struct</span> &#123;<br>article *service.Artcile<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *services)</span> <span class="hljs-title">register</span><span class="hljs-params">(r gin.IRouter)</span></span> &#123;<br>v1.RegisterBlogServiceHTTPServer(r, s.article)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>wire.go</strong> 经过 server.go 封装之后，wire.go 的代码就非常简单了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewServices NewServices</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServices</span><span class="hljs-params">()</span> <span class="hljs-params">(*services, error)</span></span> &#123;<br><span class="hljs-built_in">panic</span>(wire.Build(<br>wire.Struct(<span class="hljs-built_in">new</span>(services), <span class="hljs-string">&quot;*&quot;</span>),<br>set,<br>))<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>main.go</strong> 我这里还没有像 <a href="https://github.com/go-kratos/kratos/blob/main/app.go">kratos</a> 把程序的启动和退出封装起来，如果封装了会更加优雅一点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s, err := NewServices()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>e := gin.Default()<br>s.register(e)<br><br><span class="hljs-comment">// 这里还有优雅中止的一些代码，就不贴了</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1615219210365-000fcd85-392a-41da-b7e4-8b4fc583123f.jpeg" alt="Frame 1 (4).jpg"><br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1615268889054-251a4e39-c8d9-410f-950c-5262b368ae34.jpeg" alt="Frame 2 (1).jpg"><br>我们回过头来看上面这两种结构，可以发现，第一种结构整体上职责相对没有那么清晰，就导致了在团队协作的过程中会出现很多二义性，导致最后越来越混乱，并且由于 model 层就是一个大锅饭，什么都往里面扔所以也就乱的不行了。</p><p>新的结构不仅仅进行了水平拆分还按照功能进行了垂直拆分，将定时任务和 http 服务的代码拆分开来，整体的结构都清晰了很多，并且由于我们大量使用依赖注入，所以代码的可测性非常的好，写单元测试非常容易。<br>但是这里也有一个坑，拆分的时候要注意，我第一次拆分想按照领域进行拆分，并且拆分的非常细，导致出现了很多服务，后面听过毛老师课上的讲解后重新 review 了一下发现其实这些服务边界没有那么清晰，即使我们以后拆微服务，也不会把这些拆成两个不同的微服务，所以后面再改了一次才构成了现在的结构。所以我们在进行垂直拆分的时候一定要多问问自己，或者多和团队的同学讨论一下。</p><p>最后想要业务开发的比较开心愉快，那基础设施的建设非常重要，像本文提到的很多代码只要我们统一了规范和结构都可以通过工具来自动生成。</p><p><strong>我们下一篇文章见，加油打工人 💪（看完别忘了转发，订阅，点赞哦）</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></li><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Go 工程化(一) 架构整洁之道阅读笔记 - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week4-project-layout.html">Go 工程化(二) 项目目录结构 - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week4-wire.html">Go 工程化(三) 依赖注入框架 wire - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week4-api-design.html">Go 工程化(四) API 设计上: 项目结构 &amp; 设计 - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week4-protoc-gen-go-gin.html">Go 工程化(五) API 设计下: 基于 protobuf 自动生成 gin 代码 - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week4-config.html">Go 工程化(六) 配置管理 - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week4-go-module.html">Go 工程化(七) Go Module - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week4-unit-test.html">Go 工程化(八) 单元测试 - Mohuishou</a></li><li><a href="https://github.com/favadi/protoc-go-inject-tag">https://github.com/favadi/protoc-go-inject-tag</a></li><li><a href="https://pkg.go.dev/github.com/jinzhu/copier">https://pkg.go.dev/github.com/jinzhu/copier</a></li><li><a href="https://github.com/go-kratos/kratos/blob/main/app.go">https://github.com/go-kratos/kratos/blob/main/app.go</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week04: Go 工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go工程化(八) 单元测试</title>
    <link href="/post/go-training-week4-unit-test.html"/>
    <url>/post/go-training-week4-unit-test.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><strong>3 月进度: 05/15</strong> 3 月开始会尝试爆更模式，争取做到两天更新一篇文章，如果感兴趣可以拉到文章最下方获取关注方式。</p><p>从我们开始开发以来，应该很多人都提到过测试的重要性，而在所有的测试类型当中，以单元测试为代表的单元测试无疑是成本最小，性价比最高的一种，而且有的公司为了保证质量会要求单元测试覆盖率的指标（包括我们）</p><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1614514088908-363f1894-098c-47e5-8289-0e223adda8a6.png" alt="image.png"><br>所以希望看完这篇文章，希望大家可以很快的在我们之前提出的项目结构上进行单元测试的编写，可以做到又快又好。<br>本文分为两部分，前半段会简单介绍一下 go 的单元测试怎么写，不会有很复杂的技巧，如果已经比较了解可以跳过，后半段会介绍一下我们在项目当中该如何写 “单元测试”</p><h2 id="单元测试简明教程"><a href="#单元测试简明教程" class="headerlink" title="单元测试简明教程"></a>单元测试简明教程</h2><h3 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a>go test</h3><h4 id="一个简单的-🌰"><a href="#一个简单的-🌰" class="headerlink" title="一个简单的 🌰"></a>一个简单的 🌰</h4><p>项目结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── max.go<br>└── max_test.go<br></code></pre></td></tr></table></figure><p>max.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> max<br><br><span class="hljs-comment">// Int get the max</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Int</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>max_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> max<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestInt</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> got := Int(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); got != <span class="hljs-number">2</span> &#123;<br>t.Errorf(<span class="hljs-string">&quot;exp: %d, got: %d&quot;</span>, <span class="hljs-number">2</span>, got)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">▶ go <span class="hljs-built_in">test</span><br>PASS<br>ok      code/max        0.006s<br></code></pre></td></tr></table></figure><p><strong>单元测试文件说明</strong></p><ul><li>文件名必须是<code>_test.go</code>结尾的，这样在执行<code>go test</code>的时候才会执行到相应的代码。</li><li>你必须<code>import testing</code>这个包。</li><li>所有的测试用例函数必须是<code>Test</code>开头。</li><li>测试用例会按照源代码中写的顺序依次执行。</li><li>测试函数<code>TestX()</code>的参数是<code>testing.T</code>，我们可以使用该类型来记录错误或者是测试状态。</li><li>测试格式：<code>func TestXxx (t *testing.T)</code>,<code>Xxx</code>部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如<code>Testintdiv</code>是错误的函数名。</li><li>函数中通过调用<code>testing.T</code>的<code>Error</code>, <code>Errorf</code>, <code>FailNow</code>, <code>Fatal</code>, <code>FatalIf</code>方法，说明测试不通过，调用<code>Log</code>方法用来记录测试的信息。</li></ul><h4 id="表驱动测试"><a href="#表驱动测试" class="headerlink" title="表驱动测试"></a>表驱动测试</h4><p>在实际编写单元测试的时候，我们往往需要执行多个测试用例，期望达到更全面的覆盖效果，这时候就需要使用表驱动测试了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestInt_Table</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>a    <span class="hljs-keyword">int</span><br>b    <span class="hljs-keyword">int</span><br>want <span class="hljs-keyword">int</span><br>&#125;&#123;<br>&#123;name: <span class="hljs-string">&quot;a&gt;b&quot;</span>, a: <span class="hljs-number">10</span>, b: <span class="hljs-number">2</span>, want: <span class="hljs-number">10</span>&#125;,<br>&#123;name: <span class="hljs-string">&quot;a&lt;b&quot;</span>, a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>, want: <span class="hljs-number">2</span>&#125;,<br>&#125;<br><br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> got := Int(tt.a, tt.b); got != tt.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;exp: %d, got: %d&quot;</span>, tt.want, got)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">▶ <span class="hljs-keyword">go</span> test -v<br>=== RUN   TestInt<br>--- PASS: TestInt (<span class="hljs-number">0.00</span>s)<br>=== RUN   TestInt_Table<br>=== RUN   TestInt_Table/a&gt;b<br>=== RUN   TestInt_Table/a&lt;b<br>--- PASS: TestInt_Table (<span class="hljs-number">0.00</span>s)<br>    --- PASS: TestInt_Table/a&gt;b (<span class="hljs-number">0.00</span>s)<br>    --- PASS: TestInt_Table/a&lt;b (<span class="hljs-number">0.00</span>s)<br>PASS<br></code></pre></td></tr></table></figure><p><strong>随机执行</strong><br>上面的例子是按照顺序执行的，单元测试大多随机执行更能够发现一些没有注意到的错误, 如下面的这个例子，利用 <code>map</code> 的特性我们很容易将上面这个例子改造为随机执行的单元测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestInt_RandTable</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">struct</span> &#123;<br>a    <span class="hljs-keyword">int</span><br>b    <span class="hljs-keyword">int</span><br>want <span class="hljs-keyword">int</span><br>&#125;&#123;<br><span class="hljs-string">&quot;a&gt;b&quot;</span>: &#123;a: <span class="hljs-number">10</span>, b: <span class="hljs-number">2</span>, want: <span class="hljs-number">10</span>&#125;,<br><span class="hljs-string">&quot;a&lt;b&quot;</span>: &#123;a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>, want: <span class="hljs-number">2</span>&#125;,<br>&#125;<br><br><span class="hljs-keyword">for</span> name, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> got := Int(tt.a, tt.b); got != tt.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;exp: %d, got: %d&quot;</span>, tt.want, got)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="testfiy"><a href="#testfiy" class="headerlink" title="testfiy"></a>testfiy</h3><p>标准库为我们提供了一个还不错的测试框架，但是没有提供断言的功能，<code>testify</code> 包含了 断言、mock、suite 三个功能，mock 推荐使用官方的 <code>gomock</code></p><p><code>testify/assert</code> 提供了非常多的方法，这里为大家介绍最为常用的一些，所有的方法可以访问 <a href="https://godoc.org/github.com/stretchr/testify/assert">https://godoc.org/github.com/stretchr/testify/assert</a> 查看</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 判断两个值是否相等</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Equal</span><span class="hljs-params">(t TestingT, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 判断两个值不相等</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotEqual</span><span class="hljs-params">(t TestingT, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 测试失败，测试中断</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FailNow</span><span class="hljs-params">(t TestingT, failureMessage <span class="hljs-keyword">string</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 判断值是否为nil，常用于 error 的判断</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Nil</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 判断值是否不为nil，常用于 error 的判断</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotNil</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br></code></pre></td></tr></table></figure><p>我们可以发现，断言方法都会返回一个 <code>bool</code> 值，我们可以通过这个返回值判断断言成功/失败，从而做一些处理</p><p>一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestInt_assert_fail</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>got := Int(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>assert.Equal(t, <span class="hljs-number">1</span>, got)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果, 可以看到输出十分的清晰</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">=== RUN   TestInt_assert_fail<br>--- FAIL: TestInt_assert_fail (0.00s)<br>    max_test.go:62:<br>                Error Trace:    max_test.go:62<br>                Error:          Not equal:<br>                                expected: 1<br>                                actual  : 2<br>                Test:           TestInt_assert_fail<br>FAIL<br>FAIL    code/max        0.017s<br></code></pre></td></tr></table></figure><h3 id="gomock"><a href="#gomock" class="headerlink" title="gomock"></a>gomock</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><strong>注意: 请在非项目文件夹执行下面这条命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GO111MODULE=on GOPROXY=https://goproxy.cn go get github.com/golang/mock/mockgen<br></code></pre></td></tr></table></figure><p><code>mockgen</code> 是一个代码生成工具，可以对包或者源代码文件生成指定<strong>接口</strong>的 Mock 代码</p><h4 id="生成-Mock-代码"><a href="#生成-Mock-代码" class="headerlink" title="生成 Mock 代码"></a>生成 Mock 代码</h4><p>指定源文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mockgen -<span class="hljs-built_in">source</span>=./.go  -destination=./a_mock.go  INeedMockInterface<br><br>mockgen -<span class="hljs-built_in">source</span>=源文件路径  -destination=写入文件的路径(没有这个参数输出到终端) 需要mock的接口名(多个接口逗号间隔)<br></code></pre></td></tr></table></figure><p>指定包路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mockgen  -destination=写入文件的路径(没有这个参数输出到终端) 包路径 需要mock的接口名(多个接口逗号间隔)<br></code></pre></td></tr></table></figure><h4 id="一个简单的-gomock-🌰"><a href="#一个简单的-gomock-🌰" class="headerlink" title="一个简单的 gomock 🌰"></a>一个简单的 gomock 🌰</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// UserAge 获取用户年龄</span><br><span class="hljs-keyword">type</span> UserAge <span class="hljs-keyword">interface</span> &#123;<br>GetAge(user <span class="hljs-keyword">string</span>) <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// Simple 一个简单的例子</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Simple</span><span class="hljs-params">(user <span class="hljs-keyword">string</span>, age UserAge)</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s age is: %d&quot;</span>, user, age.GetAge(user))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSimple</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-comment">// 新建一个mock对象</span><br>ctrl := gomock.NewController(t)<br>age := mock_mock.NewMockUserAge(ctrl)<br><br>  <span class="hljs-comment">// mock 返回值</span><br>age.EXPECT().GetAge(gomock.Any()).Return(<span class="hljs-number">1</span>).AnyTimes()<br><br>assert.Equal(t, <span class="hljs-string">&quot;a age is: 1&quot;</span>, Simple(<span class="hljs-string">&quot;a&quot;</span>, age))<br>&#125;<br></code></pre></td></tr></table></figure><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">本文只是简单介绍用法，详细使用及 API 说明可以查看官方仓库，<a href="https://github.com/golang/mock">https://github.com/golang/mock</a></div><h2 id="项目-“单元测试”"><a href="#项目-“单元测试”" class="headerlink" title="项目 “单元测试”"></a>项目 “单元测试”</h2><p>接下来就是本文的重点，在我们之前提到的 <a href="https://lailin.xyz/post/go-training-week4-project-layout.html">Go 工程化(二) 项目目录结构</a> 当中，如何编写单元测试。虽然这里说的是单元测试，其实后面讲的其实很多不是单元测试，像 repo 层，如果涉及到数据库后面就会讲到我们一般会启动一个真实的数据库来测试，这其实已经算是集成测试了，但是它仍然是轻量级的。</p><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>这一层主要处理的 dto 和 do 数据之间的相互转换，本身是不含什么业务逻辑的，目前我们使用的是 http，所以在这一层的测试一般会使用 httptest 来模拟实际请求的测试。然后在对 usecase 层的调用上，我们使用 gomock mock 掉相关的接口，简化我们的测试。如果你不想写的那么麻烦，也可以不用启用 httptest 来测试，直接测试 service 层的代码也是可以的，不过这样的话，service 层的代码测试的内容就没有多少了，也就是看转换数据的时候符不符合预期。</p><p>这一层主要完成的测试是</p><ul><li>参数的校验是否符合预期</li><li>数据的转换是否符合预期，如果你像我一样偷懒使用了类似 <a href="https://pkg.go.dev/github.com/jinzhu/copier">copier</a> 的工具的话一定要写这部分的单元测试，不然还是很容易出错，容易字段名不一致导致 copier 的工作不正常</li></ul><p>当然如果时间有限的话，这一层的测试也不是必须的，因为接入层相对来说变化也比较快一点，这是说写了单元测试，基本上在测试阶段很少会出现由于参数的问题提交过来的 bug</p><p>同样我们直接看一个例子, 首先是 service 层的代码，可以看到逻辑很简单，就是调用了一下，usecase 层的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> _ v1.BlogServiceHTTPServer = &amp;PostService&#123;&#125;<br><br><span class="hljs-comment">// PostService PostService</span><br><span class="hljs-keyword">type</span> PostService <span class="hljs-keyword">struct</span> &#123;<br>Usecase domain.IPostUsecase<br>&#125;<br><br><span class="hljs-comment">// CreateArticle 创建文章</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *PostService)</span> <span class="hljs-title">CreateArticle</span><span class="hljs-params">(ctx context.Context, req *v1.Article)</span> <span class="hljs-params">(*v1.Article, error)</span></span> &#123;<br>article, err := p.Usecase.CreateArticle(ctx, domain.Article&#123;<br>Title:    req.Title,<br>Content:  req.Content,<br>AuthorID: req.AuthorId,<br>&#125;)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">var</span> resp v1.Article<br>err = copier.Copy(&amp;resp, &amp;article)<br><span class="hljs-keyword">return</span> &amp;resp, err<br>&#125;<br></code></pre></td></tr></table></figure><p>再看看单元测试<br>首先是初始化，之前我们讲到初始化的时候我们一般在 cmd 当中使用 wire 自动生成，但是在单元测试中 wire 并不好用，并且由于单元测试的时候我们的依赖项其实没有真实的依赖项那么复杂我们只需要关心当前这一层的依赖即可，所以一般在单元测试的时候我都是手写初始化<br>一般会向下面这样，使用一个 struct 包装起来，因为在后面像是 mock 的 usecase 还需要调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> testPostService <span class="hljs-keyword">struct</span> &#123;<br>post    *PostService<br>usecase *mock_domain.MockIPostUsecase<br>handler *gin.Engine<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initPostService</span><span class="hljs-params">(t *testing.T)</span> *<span class="hljs-title">testPostService</span></span> &#123;<br>ctrl := gomock.NewController(t)<br>usecase := mock_domain.NewMockIPostUsecase(ctrl)<br>service := &amp;PostService&#123;Usecase: usecase&#125;<br><br>handler := gin.New()<br>v1.RegisterBlogServiceHTTPServer(handler, service)<br><br><span class="hljs-keyword">return</span> &amp;testPostService&#123;<br>post:    service,<br>usecase: usecase,<br>handler: handler,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际的测试，这一块主要是为了展示一个完整的单元测试所以贴的代码稍微长了一些，后面的两层具体的单元测试代码都大同小异，我就不再贴了，主要的思路就是把依赖的接口都用 gomock mock 掉，这样实际写单元测试代码的时候就会比较简单。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPostService_CreateArticle</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>s := initPostService(t)<br>s.usecase.EXPECT().<br>CreateArticle(gomock.Any(), gomock.Eq(domain.Article&#123;Title: <span class="hljs-string">&quot;err&quot;</span>, AuthorID: <span class="hljs-number">1</span>&#125;)).<br>Return(domain.Article&#123;&#125;, fmt.Errorf(<span class="hljs-string">&quot;err&quot;</span>))<br>s.usecase.EXPECT().<br>CreateArticle(gomock.Any(), gomock.Eq(domain.Article&#123;Title: <span class="hljs-string">&quot;success&quot;</span>, AuthorID: <span class="hljs-number">2</span>&#125;)).<br>Return(domain.Article&#123;Title: <span class="hljs-string">&quot;success&quot;</span>&#125;, <span class="hljs-literal">nil</span>)<br><br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name       <span class="hljs-keyword">string</span><br>params     *v1.Article<br>want       *v1.Article<br>wantStatus <span class="hljs-keyword">int</span><br>wantCode   <span class="hljs-keyword">int</span><br>wantErr    <span class="hljs-keyword">string</span><br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;参数错误 author_id 必须&quot;</span>,<br>params: &amp;v1.Article&#123;<br>Title:    <span class="hljs-string">&quot;1&quot;</span>,<br>Content:  <span class="hljs-string">&quot;2&quot;</span>,<br>AuthorId: <span class="hljs-number">0</span>,<br>&#125;,<br>want:       <span class="hljs-literal">nil</span>,<br>wantStatus: <span class="hljs-number">400</span>,<br>wantCode:   <span class="hljs-number">400</span>,<br>&#125;,<br>&#123;<br>name: <span class="hljs-string">&quot;失败&quot;</span>,<br>params: &amp;v1.Article&#123;<br>Title:    <span class="hljs-string">&quot;err&quot;</span>,<br>AuthorId: <span class="hljs-number">1</span>,<br>&#125;,<br>want:       <span class="hljs-literal">nil</span>,<br>wantStatus: <span class="hljs-number">500</span>,<br>wantCode:   <span class="hljs-number">-1</span>,<br>&#125;,<br>&#123;<br>name: <span class="hljs-string">&quot;成功&quot;</span>,<br>params: &amp;v1.Article&#123;<br>Title:    <span class="hljs-string">&quot;success&quot;</span>,<br>AuthorId: <span class="hljs-number">2</span>,<br>&#125;,<br>want: &amp;v1.Article&#123;<br>Title: <span class="hljs-string">&quot;success&quot;</span>,<br>&#125;,<br>wantStatus: <span class="hljs-number">200</span>,<br>wantCode:   <span class="hljs-number">0</span>,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-comment">// 下面这些一般都会封装在一起，这里是为了演示</span><br><br><span class="hljs-comment">// 初始化请求</span><br>b, err := json.Marshal(tt.params)<br>require.NoError(t, err)<br>uri := fmt.Sprintf(<span class="hljs-string">&quot;/v1/author/%d/articles&quot;</span>, tt.params.AuthorId)<br>req := httptest.NewRequest(http.MethodPost, uri, bytes.NewReader(b))<br><br><span class="hljs-comment">// 初始化响应</span><br>w := httptest.NewRecorder()<br><br><span class="hljs-comment">// 调用相应的handler接口</span><br>s.handler.ServeHTTP(w, req)<br><br><span class="hljs-comment">// 提取响应</span><br>resp := w.Result()<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br>require.Equal(t, tt.wantStatus, resp.StatusCode)<br><br><span class="hljs-comment">// 读取响应body</span><br>respBody, _ := ioutil.ReadAll(resp.Body)<br>r := <span class="hljs-keyword">struct</span> &#123;<br>Code <span class="hljs-keyword">int</span>         <span class="hljs-string">`json:&quot;code&quot;`</span><br>Msg  <span class="hljs-keyword">string</span>      <span class="hljs-string">`json:&quot;msg&quot;`</span><br>Data *v1.Article <span class="hljs-string">`json:&quot;data&quot;`</span><br>&#125;&#123;&#125;<br>require.NoError(t, json.Unmarshal(respBody, &amp;r))<br><br>assert.Equal(t, tt.wantCode, r.Code)<br>assert.Equal(t, tt.want, r.Data)<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="usecase"><a href="#usecase" class="headerlink" title="usecase"></a>usecase</h3><p>usecase 是主要的业务逻辑，所以一般写单元测试的时候都应该先写这一层的单远测试，而且这一层我们没有任何依赖，只需要把 repo 层的接口直接 mock 掉就可以了，是非常纯净的一层，其实也就这一层的单元测试才是真正的单元测试</p><h3 id="repo"><a href="#repo" class="headerlink" title="repo"></a>repo</h3><p>repo 层我们一般依赖 mysql 或者是 redis 等数据库，在测试的时候我们可以直接启动一个全新的数据库用于测试即可。</p><h4 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h4><p>直接使用 docker run 对应的数据库就可以了</p><h4 id="ci-cd"><a href="#ci-cd" class="headerlink" title="ci/cd"></a>ci/cd</h4><p>我们的 ci cd 是使用的 gitlab，gitlab 有一个比较好用的功能是指定 service，只需要指定对应的数据库镜像我们就可以在测试容器启动的时候自动启动对应的测试数据库容器，并且每一次都是全新的空数据库。我们只需要每次跑单元测试的时候先跑一下数据库的 migration 就可以了。</p><p>下面给出一个配置示例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">test:</span><br>  <span class="hljs-attr">stage:</span> <span class="hljs-string">test</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">golang:1.15-alpine-test</span><br>  <span class="hljs-attr">services:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">redis:v4.0.11</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">postgres:10-alpine</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker:19-dind</span><br>  <span class="hljs-attr">variables:</span><br>    <span class="hljs-attr">POSTGRES_DB:</span> <span class="hljs-string">test_db</span><br>    <span class="hljs-attr">POSTGRES_USER:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">POSTGRES_PASSWORD:</span> <span class="hljs-number">1234567</span><br>    <span class="hljs-attr">GOPROXY:</span> <span class="hljs-string">&quot;这里设置 proxy 地址&quot;</span><br>    <span class="hljs-attr">CGO_ENABLED:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">script:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">go</span> <span class="hljs-string">mod</span> <span class="hljs-string">download</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">go</span> <span class="hljs-string">run</span> <span class="hljs-string">db/*.go</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">mkdir</span> <span class="hljs-string">artifacts</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">gotestsum</span> <span class="hljs-string">--</span> <span class="hljs-string">-p</span> <span class="hljs-number">1</span> <span class="hljs-string">-v</span> <span class="hljs-string">-coverprofile=./artifacts/coverage.out</span> <span class="hljs-string">-coverpkg=./...</span> <span class="hljs-string">./...</span><br>    <span class="hljs-comment"># 单元测试统计去除一些不需要测试的代码</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">|</span><br>      <span class="hljs-string">cat</span> <span class="hljs-string">./artifacts/coverage.out</span> <span class="hljs-string">|</span> <span class="hljs-string">\</span><br>      <span class="hljs-string">grep</span> <span class="hljs-string">-v</span> <span class="hljs-string">&quot;/mock/&quot;</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span> <span class="hljs-string">-v</span> <span class="hljs-string">&quot;/db/&quot;</span> <span class="hljs-string">|</span>  <span class="hljs-string">grep</span> <span class="hljs-string">-v</span> <span class="hljs-string">&quot;pb.go&quot;</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">./artifacts/coverage.out2</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">go</span> <span class="hljs-string">tool</span> <span class="hljs-string">cover</span> <span class="hljs-string">-func=./artifacts/coverage.out2</span><br>  <span class="hljs-comment"># 捕获单元测试覆盖率在 gitlab job 上显示</span><br>  <span class="hljs-attr">coverage:</span> <span class="hljs-string">&#x27;/total:\s+.*\s+\d+\.\d+%/&#x27;</span><br>  <span class="hljs-attr">artifacts:</span><br>    <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">artifacts/coverage.out</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单元测试的介绍就到这里了，这篇文章从单元测试的基本写法，再到我们在项目当中如何写单元测试都简单介绍了一下，希望你看了这篇文章能有所收获。</p><p>同时我们 Go 工程化 这一章节的内容也接近尾声了，整理的材料也挺多的，下一篇就是这一节的最后一篇文章，讲一讲我在真实改造一个项目的时候遇到的一些问题和解决方案。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></li><li><a href="https://github.com/stretchr/testify">https://github.com/stretchr/testify</a></li><li><a href="https://github.com/golang/mock">https://github.com/golang/mock</a></li><li><a href="https://pkg.go.dev/github.com/jinzhu/copier">https://pkg.go.dev/github.com/jinzhu/copier</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week04: Go 工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>工程化</tag>
      
      <tag>单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go工程化(七) Go Module</title>
    <link href="/post/go-training-week4-go-module.html"/>
    <url>/post/go-training-week4-go-module.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><strong>3 月进度: 04/15</strong> 3 月开始会尝试爆更模式，争取做到两天更新一篇文章，如果感兴趣可以拉到文章最下方获取关注方式。</p><p>本文将会分为两部分，第一部分会简单介绍一下 go module 的使用，算是一个简明教程，第二部分会重点介绍一下使用 go module 使用过程当中会遇到的一些坑的解决办法。</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">PS: Go 的版本管理一直是一个槽点，虽然 go module 已经解决了很多问题，但是槽点还是比较多，本文会介绍一些常见的坑，如果遇到了其他的坑也不要慌，Google 可以帮助你</div><h2 id="Go-Module-简明教程"><a href="#Go-Module-简明教程" class="headerlink" title="Go Module 简明教程"></a>Go Module 简明教程</h2><p>从 go 1.11 的初步支持，到 1.16 后的默认开启，go module 已经经历了 5 个版本，已然成为了创建 go 项目的首选包管理方式，这一趴我们就先看一下 go module 的基本使用。</p><h3 id="使用-Go-Module"><a href="#使用-Go-Module" class="headerlink" title="使用 Go Module"></a>使用 Go Module</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># go mod init [包路径]</span><br>go mod init github.com/mohuishou/go-mod-example<br></code></pre></td></tr></table></figure><p>执行上述命令会在当前目录下生成一个 <code>go.mod</code>  文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">module github.com/mohuishou/<span class="hljs-keyword">go</span>-mod-example<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.16</span><br></code></pre></td></tr></table></figure><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>执行 go get 包 添加添加对应库到 go mod 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/sirupsen/logrus<br></code></pre></td></tr></table></figure><p>这时候会在 go mod 中添加如下信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">module github.com/mohuishou/<span class="hljs-keyword">go</span>-mod-example<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.16</span><br><br>require github.com/sirupsen/logrus v1<span class="hljs-number">.8</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span><br></code></pre></td></tr></table></figure><ul><li>在 go get 的时候如果不手动指定版本信息，会自动拉取最新的版本的包</li><li>如果想要拉取指定版本可以通过 <code>go get github.com/sirupsen/logrus@v1.7.0</code>  的方式，支持<ul><li><code>@版本号</code> 例如 <a href="mailto:`@v1.7.0">`@v1.7.0</a>`</li><li><code>@分支名</code>  例如 <code>@master</code></li><li><code>@commit tag</code>  例如 <code>@6cff360233dc4457f1536e4f3df4e4e740fd3410</code></li></ul></li><li><code>// indirect</code>  表示，我们在代码中没有直接应用这个包</li></ul><p>执行完 go get 命令之后还会在目录下生成一个 <code>go.sum</code>  文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">......<br><br>github.com/pmezard/<span class="hljs-keyword">go</span>-difflib v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span> h1:<span class="hljs-number">4</span>DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=<br>github.com/pmezard/<span class="hljs-keyword">go</span>-difflib v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-keyword">go</span>.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/<span class="hljs-number">4</span>=<br>github.com/sirupsen/logrus v1<span class="hljs-number">.8</span><span class="hljs-number">.0</span> h1:nfhvjKcUMhBMVqbKHJlk5RPrrfYr/NMo3692g0dwfWU=<br>github.com/sirupsen/logrus v1<span class="hljs-number">.8</span><span class="hljs-number">.0</span>/<span class="hljs-keyword">go</span>.mod h1:<span class="hljs-number">4</span>GuYW9TZmE769R5STWrRakJc4UqQ3+QQ95fyz7ENv1A=<br><br>......<br></code></pre></td></tr></table></figure><p>这个文件主要包含当前依赖的所有的包，像 <code>go-difflib</code>  我们没有直接依赖，但是我们依赖的 <code>logrus</code>  有依赖它，所以会列在这里</p><p><code>h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=</code>  这一串是一个加密的哈希数据，用来保证这个版本一定是一致的，避免包的发布者删除了这个版本之后，修改代码重复发布</p><p>现在我们在代码中使用这个包试试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/sirupsen/logrus&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>logrus.Info(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="清理依赖"><a href="#清理依赖" class="headerlink" title="清理依赖"></a>清理依赖</h4><p>随着我们开发，可能会有一些包，之前依赖但是后面就不再依赖了，这个时候我们如果要清理哪些不再需要的依赖可以执行下面的命令来进行清理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> mod tidy<br></code></pre></td></tr></table></figure><h3 id="发布-Go-Module"><a href="#发布-Go-Module" class="headerlink" title="发布 Go Module"></a>发布 Go Module</h3><h4 id="Go-版本号"><a href="#Go-版本号" class="headerlink" title="Go 版本号"></a>Go 版本号</h4><p>go 默认使用语义化的版本来表示版本号，基本的方式</p><ul><li><code>vMAJOR.MINOR.PATCH</code><ul><li>有破坏性变更的时候需要增加主版本号，也就是 <code>MAJOR</code> ，例如 <code>v1.0.0</code> -&gt; <code>v2.0.0</code></li><li>当有新增的函数或者是 API 时，我们增加 <code>MINOR</code>  版本号，例如 <code>v1.1.0</code> -&gt; <code>v1.2.0</code></li><li>当没有新的 feature 的时候，例如 bug 修复时，我们增加 <code>PATCH</code>  版本号，例如 <code>v1.1.1</code> -&gt; <code>v1.1.2</code></li></ul></li><li>除此之外我们还可以在版本号后面使用 <code>-</code>  表示一些特殊的预发布版本例如 alpha beta 版本等<ul><li><code>v1.1.1-alpha</code></li><li><code>v1.1.1-beta.2</code></li><li>上面这种特殊的版本只会在手动指定的版本号的时候才会去获取它，默认情况或者是在更新版本的时候不会获取这些版本</li></ul></li><li>为了兼容在 Go Module 出现之前的一些版本，你可能会看到还有一种比较特殊的版本号<ul><li><code>v0.0.0-20170915032832-14c0d48ead0c</code></li><li>如果依赖的仓库从来没有发布过版本，就会以这种方式存在</li></ul></li></ul><h4 id="v1-及之前版本的发布"><a href="#v1-及之前版本的发布" class="headerlink" title="v1 及之前版本的发布"></a>v1 及之前版本的发布</h4><p>1.0 之前的版本发布非常简单，只需要做两件事情</p><ul><li>添加一个 LICENSE 文件（非必须）</li><li>使用 <code>git tag v1.0.0</code>  加一个版本 tag 即可</li></ul><h4 id="v2-及之后版本的发布"><a href="#v2-及之后版本的发布" class="headerlink" title="v2 及之后版本的发布"></a>v2 及之后版本的发布</h4><p>2.0 之后的版本发布就麻烦一些了，因为 Go Module 的限制，v2 之后的版本需要在 <code>go.mod</code>  中显示的指定 <code>/v2</code>  主版本好标识，用户在使用导入包的时候也必须加上这个版本标志，这个好处就是可以同时同时导入不同版本的包，但是在升级的时候就比较蛋疼了，必须要将所有文件的导入路径都修改一下</p><p>那么该如何发布新版本的包呢？官方推荐的操作是</p><ul><li>我们先在当前目录下创建一个 <code>v2</code>  文件夹，应为这样可以兼容那些还在使用 <code>GOPATH</code>  的用户，当然这不是必须的</li><li>然后我们再修改一下 <code>go.mod</code>  文件, 在包名后加上主版本号，例如<ul><li><code>module github.com/mohuishou/go-mod-example/v2</code></li></ul></li><li>最后我们再使用 <code>git tag v2.0.0</code>  打一个版本并发布即可</li></ul><h2 id="Go-Module-避坑指南"><a href="#Go-Module-避坑指南" class="headerlink" title="Go Module 避坑指南"></a>Go Module 避坑指南</h2><h3 id="1-拉取依赖很慢，有的包还拉取不到"><a href="#1-拉取依赖很慢，有的包还拉取不到" class="headerlink" title="1. 拉取依赖很慢，有的包还拉取不到"></a>1. 拉取依赖很慢，有的包还拉取不到</h3><p>Go 默认的 GOPROXY 配置是 <code>proxy.golang.org</code> , 默认国内无法访问，我们可以配置国内镜像，推荐 <code>goproxy.cn</code>  或者 <code>goproxy.io</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> env -w GOPROXY=https:<span class="hljs-comment">//goproxy.cn,direct</span><br></code></pre></td></tr></table></figure><p>1.16 之前 Go Module 并未默认开启还需要配置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> env -w GO111MODULE=on<br></code></pre></td></tr></table></figure><h3 id="2-公司私有仓库包如何获取"><a href="#2-公司私有仓库包如何获取" class="headerlink" title="2. 公司私有仓库包如何获取"></a>2. 公司私有仓库包如何获取</h3><p>Go 获取包的时候默认会走 PROXY，这个只要你们的库没有对公网发布，那就获取不到，可以通过设置环境变量解决</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> env -w GOPRIVATE=gitlab.com/xxx<br></code></pre></td></tr></table></figure><h3 id="3-依赖的包被自动升级"><a href="#3-依赖的包被自动升级" class="headerlink" title="3. 依赖的包被自动升级"></a>3. 依赖的包被自动升级</h3><p>在 1.16 后, go build, go test, go get 等命令已经不会自动升级我们依赖的包了，但是在 1.16 之前，这个操作很难受。</p><p>首先，这个操作非常的反直觉，其次还有可能会导致非预期的 bug，虽然在 Go Module 的设计当中，主版本不变的情况下都应该保持向前兼容，但是很多知名的第三库都做不到这个，包括 Google 自己开发的 grpc，我们之前就出现过由于 grpc 版本自动升级导致的程序连接错误，必须要回退版本才行。</p><p>三个解决办法都可以解决：</p><ul><li>升级 Go 版本到 1.16</li><li>使用 <code>-mod=readonly</code> ，例如 <code>go build -mod=readonly</code></li><li>在 <code>go.mod</code>  文件中使用 <code>replace</code>  指令指定版本</li></ul><h3 id="4-包的源代码仓库删库了怎么办？"><a href="#4-包的源代码仓库删库了怎么办？" class="headerlink" title="4. 包的源代码仓库删库了怎么办？"></a>4. 包的源代码仓库删库了怎么办？</h3><p>这个其实在 Go Module 上还好一些，因为 Go Module 默认使用 Go Proxy 只要你使用的库的 LICENSE 和 GOPROXY 没有问题，一般都会有缓存</p><ul><li>建议公司需要搭建一套自己的 GOPROXY</li><li>建议使用官方的 GOPROXY 或者是 goproxy.cn</li></ul><h3 id="5-logrus-包名问题"><a href="#5-logrus-包名问题" class="headerlink" title="5. logrus 包名问题"></a>5. logrus 包名问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>: downloading github.com/Sirupsen/logrus v1<span class="hljs-number">.4</span><span class="hljs-number">.1</span><br><span class="hljs-keyword">go</span> get: github.com/Sirupsen/logrus@v1<span class="hljs-number">.0</span><span class="hljs-number">.6</span> updating to<br>        github.com/Sirupsen/logrus@v1<span class="hljs-number">.4</span><span class="hljs-number">.1</span>: parsing <span class="hljs-keyword">go</span>.mod:<br>        module declares its path as: github.com/sirupsen/logrus<br>                but was required as: github.com/Sirupsen/logrus<br></code></pre></td></tr></table></figure><p>现在这个错误应该比较少了，但是我们碰到过很多次了，主要的原因就是 logrus 的作者改了 github 名字，从 <code>Sirupsen</code>  -&gt; <code>sirupsen</code>  就导致了大量依赖 logrus 库的第三方库报错冲突，这个的解决方案也是使用 replace</p><p>在 <code>go.mod</code>  的最后加上这么一句就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">replace (<br>    github.com/Sirupsen/logrus v1<span class="hljs-number">.4</span><span class="hljs-number">.1</span> =&gt; github.com/sirupsen/logrus v1<span class="hljs-number">.4</span><span class="hljs-number">.1</span><br>)<br></code></pre></td></tr></table></figure><h3 id="6-go-sum-git-merge-冲突"><a href="#6-go-sum-git-merge-冲突" class="headerlink" title="6. go.sum git merge 冲突"></a>6. go.sum git merge 冲突</h3><p>其实很多包管理都有类似的问题，解决方法一般情况下 git merge 合并后再重新执行 go mod tidy 清理一下即可</p><h3 id="7-Go-版本升级无法使用新特性"><a href="#7-Go-版本升级无法使用新特性" class="headerlink" title="7. Go 版本升级无法使用新特性"></a>7. Go 版本升级无法使用新特性</h3><p>举个例子，我从 go 1.15 升级到 1.16 想使用 embed，也就是静态文件打包的特性，但是我们发现升级 Go 之后执行还是会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ go run ./main.go<br><span class="hljs-comment"># command-line-arguments</span><br>./main.go:9:3: go:embed requires go1.16 or later (-lang was <span class="hljs-built_in">set</span> to go1.15; check go.mod)<br></code></pre></td></tr></table></figure><p>这种情况修改一下 <code>go.mod</code>  文件中 <code>go 1.15</code>  到 <code>go 1.16</code>  即可</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于 Go Module 的介绍就到这里了，说实话 Go 的包管理一直以来都是社区的痛点，从 GOPATH 到 Go Vendor 再到 <code>dep</code> 、 <code>glide</code>  等社区工具再到现在的 go mod 整体来说还是变得越来越好，特别是最新的 go 1.16 版本，如果没有其他问题的话还是建议升级的，仅默认 <code>readonly</code>  模式这一项就可以少很多事情</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></li><li><a href="https://blog.golang.org/modules2019">https://blog.golang.org/modules2019</a></li><li><a href="https://blog.golang.org/using-go-modules">https://blog.golang.org/using-go-modules</a></li><li><a href="https://blog.golang.org/migrating-to-go-modules">https://blog.golang.org/migrating-to-go-modules</a></li><li><a href="https://blog.golang.org/module-mirror-launch">https://blog.golang.org/module-mirror-launch</a></li><li><a href="https://blog.golang.org/publishing-go-modules">https://blog.golang.org/publishing-go-modules</a></li><li><a href="https://blog.golang.org/v2-go-modules">https://blog.golang.org/v2-go-modules</a></li><li><a href="https://blog.golang.org/module-compatibility">https://blog.golang.org/module-compatibility</a></li><li><a href="https://mp.weixin.qq.com/s/CBiebXjBcik2pHQnbnB51A">Go mod 七宗罪</a></li><li><a href="https://jaycechant.info/2019/golang-1-13-from-dep-to-mod/">golang 1.13 - 依赖管理从 dep 到 mod 踩坑 | 存档 Save&amp;Load</a></li><li><a href="https://sulin.me/2019/1Z78YAK.html">Go 填坑之将 Private 仓库用作 module 依赖 | 小木屋</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week04: Go 工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go工程化(六) 配置管理</title>
    <link href="/post/go-training-week4-config.html"/>
    <url>/post/go-training-week4-config.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><strong>3 月进度: 03/15</strong> 3 月开始会尝试爆更模式，争取做到两天更新一篇文章，如果感兴趣可以拉到文章最下方获取关注方式。</p><p>应用的配置大概可以分为以下几种</p><ul><li>环境配置<ul><li>环境配置，应该是应用部署时就已经确定好的信息，这些信息不应该写在我们的配置文件或者是放到配置中心，而是应该由我们的部署平台，例如 K8s 直接在容器启动时候就注入好</li><li>region: 区域信息</li><li>env: 环境信息，例如 prod, test</li><li>zone: 可用区</li><li>host: 机器名</li><li>appid: 应用 id</li><li>color: 流量染色信息，用来做流量分发的</li></ul></li><li>静态配置<ul><li>资源需要初始化的配置信息，比如 http/gRPC server、redis、mysql 等</li><li>这类资源在线变更配置的风险非常大，尽量不要在线动态变更，很可能会导致业务出现不可预期的事故</li><li>变更静态配置和发布 bianry app 没有区别，应该走一次迭代发布的流程。</li></ul></li><li>动态配置<ul><li>应用程序可能需要一些在线的开关，来控制业务的一些简单策略，会频繁的调整和使用，我们把这类是基础类型(int, bool)等配置，用于可以动态变更业务流的收归一起，</li><li>不过业务配置最好做到管理后台，因为配置中心运营同学一般没有权限，并且很多配置中心的校验做的不够好，不熟悉的人进行变更很容易出问题</li></ul></li><li>全局配置<ul><li>我们依赖的各类组件、中间件都有大量的默认配置或者指定配置，在各个项目里大量拷贝复制，容易出现意外，所以我们使用全局配置模板来定制化常用的组件，然后再特化的应用里进行局部替换。</li></ul></li></ul><h2 id="函数参数配置"><a href="#函数参数配置" class="headerlink" title="函数参数配置"></a>函数参数配置</h2><p>下面这个是 redis 初始化的例子，一般在我们刚刚开始写代码的时候，我们都会向下面这么写，把需要的参数放到函数的入参就行了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(Conn, error)</span></span><br></code></pre></td></tr></table></figure><p>这个有什么问题呢？如果这个函数只是你自己用也没有什么毛病，但是如果是一个公共的库或者是中间件就会发现，用户的诉求是多种多样，灵活多变的。就会听见</p><ul><li>我要自定义超时时间</li><li>我要自定义 database</li></ul><p>等等一系列的需求和各种各样的声音。<br>这时候为了满足大家的需求，最简单，最直接的做法就是，为不同的需求添加不同的初始化函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DialTimeout</span><span class="hljs-params">(network, address <span class="hljs-keyword">string</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 connectTimeout, readTimeout, writeTimeout time.Duration)</span> <span class="hljs-params">(Conn, error)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DialDatabase</span><span class="hljs-params">(network, address <span class="hljs-keyword">string</span>, database <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(Conn, error)</span></span><br></code></pre></td></tr></table></figure><p>但这样毕竟不是一个办法，因为用户的需求是满足不完的，作为公共库，不可能为每个用户的需求都单独来搞个函数签名，那这样函数签名也太多了。而且还有一个问题是参数列表会很长，例如上面的 <code>DialTimeout</code> , 可读性也不好。<br>当然这也和 Go 的函数不能重载有关系，如果可以重载的话，每种需求来一个可能也还行，但是其实也不够优雅。</p><p>这时候我们比较容易想到的办法是什么呢？既然参数比较长，配置变化又想要灵活，那么我们就直接传入一个对象就好了，让每个用户自己构造去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>  *pool.Config<br>  Addr <span class="hljs-keyword">string</span><br>  Auth <span class="hljs-keyword">string</span><br>  DialTimeout time.Duration<br>  ReadTimeout time.Duration<br>  WriteTimeout time.Duration<br>&#125;<br><br><span class="hljs-comment">// NewConn new a redis conn.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewConn</span><span class="hljs-params">(c *Config)</span> <span class="hljs-params">(cn Conn, err error)</span></span><br></code></pre></td></tr></table></figure><p>这种方式有什么问题呢？</p><ul><li>可以看到 <code>NewConn</code>  传递的是一个指针，那么这个只能就能够被外面修改，只要外面修改那就麻烦了，因为不知道会发生什么，这是一个未定义的行为。</li><li>还有就是我们没有办法指定必填参数，这样传递相当于每一项都是可选的</li></ul><p>既然指针可能会导致未定义的行为，那我们就换个方式, 不传指针传结构体不就行了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewConn</span><span class="hljs-params">(c Config)</span> <span class="hljs-params">(cn Conn, err error)</span></span><br></code></pre></td></tr></table></figure><p>但是这又带来了一些新的问题</p><ul><li>首先，必填参数的问题还是没有解决的</li><li>其次，这么传参我们是没有办法区分默认值的，通过指针我们可以通过判断是否等于 nil 来区分，因为大部分的场景下其实用默认值就可以了，这样做反而降低了使用体验</li></ul><p>所以，有一段时间毛老师他们都是使用上面传指针的这种方式，当然这种方式我们也用过，虽然可以用，但是就是有点不爽</p><blockquote><p>“I believe that we, as Go programmers, should work hard to ensure that nil is never a parameter that needs to be passed to any public function.” – Dave Cheney</p></blockquote><p>dava 大神也提到过，我们应该将 nil 作为一个函数的参数值进行传递，那我们该如何修改呢？<br>如果去看一些知名的开源库或者是标准库的一些初始化代码，我们可以看到这种姿势</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> DialOption <span class="hljs-keyword">struct</span> &#123;<br>  f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*dialOptions)</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-keyword">string</span>, options ...DialOption)</span> <span class="hljs-params">(Conn, error)</span></span> &#123;<br>  do := dialOptions&#123;<br>    dial: net.Dial,<br>  &#125;<br>  <span class="hljs-keyword">for</span> _, option := <span class="hljs-keyword">range</span> options &#123;<br>    option.f(&amp;do)<br>  &#125; <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// DialReadTimeout specifies the timeout for reading a single command reply.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DialReadTimeout</span><span class="hljs-params">(d time.Duration)</span> <span class="hljs-title">DialOption</span></span> &#123;<br><span class="hljs-keyword">return</span> DialOption&#123;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(do *dialOptions)</span></span> &#123;<br>do.readTimeout = d<br>&#125;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种操作的核心在于，我们可以定义一个未导出的 option struct 用于存放配置，然后到处一个函数指针，然后我们在初始化的时候，使用可变参数进行传递，然后再初始化函数内部通过 for 循环调用修改相关的配置。</p><ul><li>这样我们就可以把必填参数放在前面几位，保证参数必填，一眼就能看出来，减少沟通成本</li><li>然后默认参数，我们可以在函数内部先初始化一个 defaultOption 然后用后面配置的函数进行修改即可</li></ul><p>我们可以在包里面直接定义一些函数例如上面的 <code>DialReadTimeout</code>  来返回一个函数，然后进行配置修改</p><p>但是这样就可以了么？这种使用方式</p><ul><li>首先，函数指针没有必要搞那么麻烦，其实直接顶一个函数类型就可以了 <code>type DialOption func(*dialOptions)</code></li><li>其次，这种做法还是只能在包内部进行定义，用户是没有办法自定义一些配置的，但是其实也够用了</li></ul><p>如果想要用户可以自定义一些配置，我们可以看看 grpc 的配置定义，主要的思路就是把 option 从函数修改接口，然后定义了一个 <code>EmptyCallOption</code>  实现这个接口，因为这个接口包含的函数是未导出的，所以我们只要在需要做配置的 struct 当中包含这个 <code>EmptyCallOption</code>  就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> GreeterClient <span class="hljs-keyword">interface</span> &#123;<br>  SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption)     (*HelloReply, error)<br>&#125;<br><br><span class="hljs-keyword">type</span> CallOption <span class="hljs-keyword">interface</span> &#123;<br>  before(*callInfo) error<br>  after(*callInfo)<br>&#125;<br><span class="hljs-comment">// EmptyCallOption does not alter the Call configuration.</span><br><span class="hljs-keyword">type</span> EmptyCallOption <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// TimeoutCallOption timeout option.</span><br><span class="hljs-keyword">type</span> TimeoutCallOption <span class="hljs-keyword">struct</span> &#123;<br>  grpc.EmptyCallOption<br>  Timeout time.Duration<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>到这里函数的配置就解决了，但是我们怎么和配置文件进行结合呢？现在的这种做法隐藏了结构，没有办法直接使用 <code>json.Unmarshal</code> 这种方法直接反序列化回来。</p><p>比较常见的办法就是我们设定两个函数如果需要配置文件反序列化的就用不带 Option 的，反之用带 Option 的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-keyword">string</span>, options ...DialOption)</span> <span class="hljs-params">(Conn, error)</span></span><br><br><span class="hljs-comment">// NewConn new a redis conn.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewConn</span><span class="hljs-params">(c *Config)</span> <span class="hljs-params">(cn Conn, err error)</span></span><br></code></pre></td></tr></table></figure><p>这么做比较大的问题就是，把 config 给暴露了出来，并且有两种初始化方式，使用配置文件就没有办法得到使用 Option 的好处了</p><p>课上提供了一种解决思路就是把这两步进行分离，首先我们使用 protobuf 文件定义好配置的结构，这样可以加上一些验证条件</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/duration.proto&quot;</span>;<br><span class="hljs-keyword">package</span> config.redis.v1;<br><span class="hljs-comment">// redis config.</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">redis</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> network = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">string</span> address = <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">int32</span> database = <span class="hljs-number">3</span>;<br>  <span class="hljs-built_in">string</span> password = <span class="hljs-number">4</span>;<br>  google.protobuf.Duration read_timeout = <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义好之后使用 yaml 来修改配置，然后使用 <code>Options</code>  方法，将 protobuf 生成的 <code>Config</code>  替换为 redis.Options</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ApplyYAML</span><span class="hljs-params">(s *redis.Config, yml <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>  js, err := yaml.YAMLToJSON([]<span class="hljs-keyword">byte</span>(yml))<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br>  <span class="hljs-keyword">return</span> ApplyJSON(s, <span class="hljs-keyword">string</span>(js))<br>&#125;<br><span class="hljs-comment">// Options apply config to options.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Options</span><span class="hljs-params">(c *redis.Config)</span> []<span class="hljs-title">redis</span>.<span class="hljs-title">Options</span></span> &#123;<br>  <span class="hljs-keyword">return</span> []redis.Options&#123;<br>    redis.DialDatabase(c.Database),<br>    redis.DialPassword(c.Password),<br>    redis.DialReadTimeout(c.ReadTimeout),<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式除了定义起来比较麻烦，使用上还是很简单的，使用只需要像下面这样就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// load config file from yaml.</span><br>  c := <span class="hljs-built_in">new</span>(redis.Config)<br>  _ = ApplyYAML(c, loadConfig())<br>  r, _ := redis.Dial(c.Network, c.Address, Options(c)...)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们现在使用的没有那么复杂，统一接入了配置中心，所以我现在的做法是定义一个 <code>WithConfigCenter</code>  的方法就行了，调用的时候其实还要简单一点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithConfigCenter</span><span class="hljs-params">(config ConfigCenter, key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">Option</span></span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>修改配置其实是一件比较危险的事情，很多时候我们缺乏足够的敬畏，因为现在在线的配置中心越来方便，所以修改的成本越来越低，大家就越来越随意，所以我们需要对配置的修改慎重一些。配置的目标：</p><ul><li>避免复杂</li><li>多样的配置</li><li>简单化努力</li><li>以基础设施 -&gt; 面向用户进行转变</li><li>配置的必选项和可选项</li><li>配置的防御编程</li><li>权限和变更跟踪</li><li>配置的版本和应用对齐，这个很多都没做到，经常应用回滚了配置没回滚，就出事故了</li><li>安全的配置变更：逐步部署、回滚更改、自动回滚</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></li><li><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">command center: Self-referential functions and the design of options</a></li><li><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">Functional options for friendly APIs – The acme of foolishness</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week04: Go 工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go工程化(五) API 设计下: 基于 protobuf 自动生成 gin 代码</title>
    <link href="/post/go-training-week4-protoc-gen-go-gin.html"/>
    <url>/post/go-training-week4-protoc-gen-go-gin.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><strong>3 月进度: 02/15</strong> 3 月开始会尝试爆更模式，争取做到两天更新一篇文章，如果感兴趣可以拉到文章最下方获取关注方式。</p><p>在官方的提供的 protobuf 代码生成器当中仅支持生成 grpc 的代码，但是我们团队现状是大部分的项目都是使用 http1 类似 restful 的方式进行通信的，目前公司内部 gRPC 相关基础设施建设的还不完全，例如跨区域路由，服务注册等等原因导致我们没有办法向 gRPC 进行迁移，但是我们又想要有前面提到的各种好处，考虑到后面还是会进行 RPC 的迁移，又不想在代码里面写两套相同逻辑 service 层代码那该怎么办？</p><p>毛老师在课程上介绍了 kratos v2 的方法，自己写一个 protoc 插件，在代码生成的时候生成相关代码，只要我们生成的 server 接口和 gRPC 保持一致，或者接入其他的 RPC 服务，只需要接口保持一致那么我们的 service 层代码无需修改任何代码，就可以支持多种协议，做到了“框架只是细节”。</p><p>虽然框架只是细节，但是我们之前一直使用的 gin 作为 web 框架，kratos 使用的是 mux 作为路由框架，所以我们如果直接使用 kratos 的插件会导致很多中间件都需要做重构，这样影响比较大，并且也算是为了积累一些经验，因为除了生成 server 的代码，我们还需要同时配合公司内部的网关生成 client 端的代码，解决之前每个项目都需要自己手写 sdk 的问题。</p><p>接下来我们就一起来从借鉴开始实现一个生成 gin 的 http server 代码。</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">注: 本文代码可以在 <a href="https://github.com/mohuishou/protoc-gen-go-gin">mohuishou/protoc-gen-go-gin</a> 中找到，如果你有类似的需求可以直接使用</div><h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><p>开始开发之前我们先看一下 gin 的路由是怎么注册的，以及 grpc 生成的接口格式是什么样的</p><h4 id="gin-example"><a href="#gin-example" class="headerlink" title="gin example"></a>gin example</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// get params</span><br>params := <span class="hljs-keyword">struct</span> &#123;<br>Msg <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;msg&quot;`</span><br>&#125;&#123;&#125;<br>ctx.BindQuery(&amp;params)<br><br><span class="hljs-comment">// 业务逻辑</span><br><br><span class="hljs-comment">// 返回数据</span><br>ctx.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;message&quot;</span>: params.Msg,<br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, handler)<br>r.Run() <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个简单的示例，可以发现 gin 注册路由需要一个 <code>func (ctx *gin.Context)</code> 签名的函数，这个函数一般做三件事，获取参数，调用业务逻辑，调用 gin 的方法返回 http response</p><h4 id="grpc-server-interface"><a href="#grpc-server-interface" class="headerlink" title="grpc server interface"></a>grpc server interface</h4><p>先看一下 proto 文件中的 rpc 定义，一般就是包含一个参数和一个返回值的函数</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// The greeting service definition.</span><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">Greeter</span> </span>&#123;<br>  <span class="hljs-comment">// Sends a greeting</span><br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello (HelloRequest) <span class="hljs-keyword">returns</span> (HelloReply) </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后看 grpc 生成的接口，其实和 proto 文件一一对应，只是多了一个 context 和 error</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> GreeterServer <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Sends a greeting</span><br>SayHello(context.Context, *HelloRequest) (*HelloReply, error)<br>mustEmbedUnimplementedGreeterServer()<br>&#125;<br></code></pre></td></tr></table></figure><p>所以问题来了，我们让 service 层实现类似 <code>GreeterServer</code> 接口就行了，那我们代码生成器要怎么写才能够应用到 http 上呢？</p><h4 id="概要方案"><a href="#概要方案" class="headerlink" title="概要方案"></a>概要方案</h4><ol><li>我们需要从 proto 文件中得知 http method，http path 的信息，这样我们才知道要注册到哪个路由上<ol><li>这个可以通过 <code>google/api/annotations.proto</code> 为 rpc 方法添加 Option 实现</li><li>或者是通过函数签名来约定，我们约定方法名使用驼峰方式命名，首个单词是 http method 或者是 http method 的映射，如果都不是默认采用 post<ol><li><code>&quot;GET&quot;, &quot;FIND&quot;, &quot;QUERY&quot;, &quot;LIST&quot;, &quot;SEARCH&quot;</code>  –&gt; <code>GET</code></li><li><code>&quot;POST&quot;, &quot;CREATE&quot;</code>  –&gt; <code>POST</code></li><li><code>&quot;PUT&quot;, &quot;UPDATE&quot;</code>  –&gt; <code>PUT</code></li><li><code>&quot;DELETE&quot;</code>  –&gt; <code>DELETE</code></li></ol></li></ol></li><li>我们需要构建 <code>func handler(ctx *gin.Context)</code> 函数用于注册路由<ol><li>函数内需要处理参数，用于调用 service 层的代码</li><li>调用 service 层的代码结束之后，将返回值调用 gin 相关方法返回</li></ol></li></ol><p>所以我们最后生成的代码大概应该是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> GreeterService <span class="hljs-keyword">struct</span> &#123;<br>server GreeterHTTPServer<br>router gin.IRouter<br>&#125;<br><br><span class="hljs-comment">// 生成的 gin.HandlerFunc</span><br><span class="hljs-comment">// 由于 HandlerFunc 签名的限制，不能从参数传递 service 接口进来</span><br><span class="hljs-comment">// 所以我们使用一个 Struct 托管 service 数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *GreeterService)</span> <span class="hljs-title">SayHello</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> in HelloRequest<br><br><span class="hljs-keyword">if</span> err := ctx.ShouldBindJSON(∈); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 返回参数错误</span><br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 调用业务逻辑</span><br>out, err := s.server.(GreeterHTTPServer).SayHello(ctx, ∈)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 返回错误结果</span><br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 返回成功结果</span><br>ctx.JSON(<span class="hljs-number">200</span>, out)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 路由注册，首先需要 gin.IRouter 接口用于注册</span><br><span class="hljs-comment">// 其次需要获取到 SayHello 方法对应的 http method 和 path</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *GreeterService)</span> <span class="hljs-title">RegisterService</span><span class="hljs-params">()</span></span> &#123;<br>s.router.Handle(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/hello&quot;</span>, s.SayHello)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>理论可行，开始干活，代码从 kratos v2 相关代码修改而来，文章篇幅有限，这里只贴关键代码，完整可执行代码请访问 <a href="https://github.com/mohuishou/protoc-gen-go-gin">mohuishou/protoc-gen-go-gin</a></p><p><strong><em>如果对实现不感兴趣可以直接跳到最后一个部分查看使用示例，看最终的效果</em></strong></p><p>大致流程: 获取所有的 proto 文件 –&gt; 获取 proto 文件中的所有 service 信息 –&gt; 获取 service 中的所有 method 信息</p><h3 id="proto-文件"><a href="#proto-文件" class="headerlink" title="proto 文件"></a>proto 文件</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;github.com/mohuishou/protoc-gen-go-gin/example/testproto;testproto&quot;</span>;<br><br><span class="hljs-keyword">package</span> testproto;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/api/annotations.proto&quot;</span>;<br><br><span class="hljs-comment">// blog service is a blog demo</span><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">BlogService</span> </span>&#123;<br><span class="hljs-comment">// 方法名 action+resource</span><br><span class="hljs-function"><span class="hljs-keyword">rpc</span> GetArticles(GetArticlesReq) <span class="hljs-keyword">returns</span> (GetArticlesResp) </span>&#123;<br>  <span class="hljs-comment">// 添加 option 用于指定 http 的路由和方法</span><br><span class="hljs-keyword">option</span> (google.api.http) = &#123;<br>get: <span class="hljs-string">&quot;/v1/articles&quot;</span><br><br>      <span class="hljs-comment">// 可以通过添加 additional_bindings 一个 rpc method 对应多个 http 路由</span><br>additional_bindings &#123;<br>get: <span class="hljs-string">&quot;/v1/author/&#123;author_id&#125;/articles&quot;</span><br>&#125;<br>&#125;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="需要获取的信息"><a href="#需要获取的信息" class="headerlink" title="需要获取的信息"></a>需要获取的信息</h4><p><strong>service info</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> service <span class="hljs-keyword">struct</span> &#123;<br>Name     <span class="hljs-keyword">string</span> <span class="hljs-comment">// Greeter</span><br>FullName <span class="hljs-keyword">string</span> <span class="hljs-comment">// helloworld.Greeter</span><br>FilePath <span class="hljs-keyword">string</span> <span class="hljs-comment">// api/helloworld/helloworld.proto</span><br><br>Methods   []*method<br>MethodSet <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*method<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么需要 Methods 和 MethodSet，因为可能存在多个 HTTP 请求对应一个 RPC Method，这也是下面的 method 结构中包含了一个 num 字段的原因</p><p><strong>method info</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> method <span class="hljs-keyword">struct</span> &#123;<br>Name    <span class="hljs-keyword">string</span> <span class="hljs-comment">// SayHello</span><br>Num     <span class="hljs-keyword">int</span>    <span class="hljs-comment">// 一个 rpc 方法可以对应多个 http 请求</span><br>Request <span class="hljs-keyword">string</span> <span class="hljs-comment">// SayHelloReq</span><br>Reply   <span class="hljs-keyword">string</span> <span class="hljs-comment">// SayHelloResp</span><br><span class="hljs-comment">// http_rule</span><br>Path         <span class="hljs-keyword">string</span> <span class="hljs-comment">// 路由</span><br>Method       <span class="hljs-keyword">string</span> <span class="hljs-comment">// HTTP Method</span><br>Body         <span class="hljs-keyword">string</span><br>ResponseBody <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取所有的-proto-文件"><a href="#获取所有的-proto-文件" class="headerlink" title="获取所有的 proto 文件"></a>获取所有的 proto 文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// ...</span><br><br>options := protogen.Options&#123;<br>ParamFunc: flags.Set,<br>&#125;<br><br>options.Run(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(gen *protogen.Plugin)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> gen.Files &#123;<br><span class="hljs-keyword">if</span> !f.Generate &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>generateFile(gen, f)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生成单个-proto-文件中的内容"><a href="#生成单个-proto-文件中的内容" class="headerlink" title="生成单个 proto 文件中的内容"></a>生成单个 proto 文件中的内容</h4><p>这一部分的逻辑主要是生成文件的包名，以及将需要导入的第三方库，例如 gin 之类的导入到其中<br>然后循环调用 genService 方法生成相关代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 后面都是 gin.go 的内容</span><br><br><span class="hljs-comment">// generateFile generates a _gin.pb.go file.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateFile</span><span class="hljs-params">(gen *protogen.Plugin, file *protogen.File)</span> *<span class="hljs-title">protogen</span>.<span class="hljs-title">GeneratedFile</span></span> &#123;<br><span class="hljs-comment">// 如果不存在 service 就直接跳过了，我们主要生成 service 的接口</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(file.Services) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>filename := file.GeneratedFilenamePrefix + <span class="hljs-string">&quot;_gin.pb.go&quot;</span><br>g := gen.NewGeneratedFile(filename, file.GoImportPath)<br>g.P(<span class="hljs-string">&quot;// Code generated by github.com/mohuishou/protoc-gen-go-gin. DO NOT EDIT.&quot;</span>)<br>g.P()<br>g.P(<span class="hljs-string">&quot;package &quot;</span>, file.GoPackageName)<br>g.P()<br>g.P(<span class="hljs-string">&quot;// This is a compile-time assertion to ensure that this generated file&quot;</span>)<br>g.P(<span class="hljs-string">&quot;// is compatible with the mohuishou/protoc-gen-go-gin package it is being compiled against.&quot;</span>)<br>g.P(<span class="hljs-string">&quot;// &quot;</span>, contextPkg.Ident(<span class="hljs-string">&quot;&quot;</span>), metadataPkg.Ident(<span class="hljs-string">&quot;&quot;</span>))<br>g.P(<span class="hljs-string">&quot;//&quot;</span>, ginPkg.Ident(<span class="hljs-string">&quot;&quot;</span>), errPkg.Ident(<span class="hljs-string">&quot;&quot;</span>))<br>g.P()<br><br><span class="hljs-keyword">for</span> _, service := <span class="hljs-keyword">range</span> file.Services &#123;<br>genService(gen, file, g, service)<br>&#125;<br><span class="hljs-keyword">return</span> g<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取-service-相关信息"><a href="#获取-service-相关信息" class="headerlink" title="获取 service 相关信息"></a>获取 service 相关信息</h4><p>这一部分主要是利用 protogen.Service 的信息构建 service 结构，然后循环调用 genMethod 方法生成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">genService</span><span class="hljs-params">(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, s *protogen.Service)</span></span> &#123;<br><span class="hljs-keyword">if</span> s.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() &#123;<br>g.P(<span class="hljs-string">&quot;//&quot;</span>)<br>g.P(deprecationComment)<br>&#125;<br><span class="hljs-comment">// HTTP Server.</span><br>sd := &amp;service&#123;<br>Name:     s.GoName,<br>FullName: <span class="hljs-keyword">string</span>(s.Desc.FullName()),<br>FilePath: file.Desc.Path(),<br>&#125;<br><br><span class="hljs-keyword">for</span> _, method := <span class="hljs-keyword">range</span> s.Methods &#123;<br>sd.Methods = <span class="hljs-built_in">append</span>(sd.Methods, genMethod(method)...)<br>&#125;<br>g.P(sd.execute())<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取-rpc-方法的相关信息"><a href="#获取-rpc-方法的相关信息" class="headerlink" title="获取 rpc 方法的相关信息"></a>获取 rpc 方法的相关信息</h4><p>我们通过 proto.GetExtension 获取之前在 rpc method 设置的 option 信息，如果存在那么就从 option 获取路由和 method 的信息，如果没有就根据方法名生成默认的路由</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">genMethod</span><span class="hljs-params">(m *protogen.Method)</span> []*<span class="hljs-title">method</span></span> &#123;<br><span class="hljs-keyword">var</span> methods []*method<br><br><span class="hljs-comment">// 存在 http rule 配置</span><br>rule, ok := proto.GetExtension(m.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)<br><span class="hljs-keyword">if</span> rule != <span class="hljs-literal">nil</span> &amp;&amp; ok &#123;<br><span class="hljs-keyword">for</span> _, bind := <span class="hljs-keyword">range</span> rule.AdditionalBindings &#123;<br>methods = <span class="hljs-built_in">append</span>(methods, buildHTTPRule(m, bind))<br>&#125;<br>methods = <span class="hljs-built_in">append</span>(methods, buildHTTPRule(m, rule))<br><span class="hljs-keyword">return</span> methods<br>&#125;<br><br><span class="hljs-comment">// 不存在走默认流程</span><br>methods = <span class="hljs-built_in">append</span>(methods, defaultMethod(m))<br><span class="hljs-keyword">return</span> methods<br>&#125;<br></code></pre></td></tr></table></figure><p>从 option 中生成路由</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildHTTPRule</span><span class="hljs-params">(m *protogen.Method, rule *annotations.HttpRule)</span> *<span class="hljs-title">method</span></span> &#123;<br><span class="hljs-comment">// ....</span><br><br><span class="hljs-keyword">switch</span> pattern := rule.Pattern.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *annotations.HttpRule_Get:<br>path = pattern.Get<br>method = <span class="hljs-string">&quot;GET&quot;</span><br><span class="hljs-comment">// ... 其他映射</span><br>&#125;<br>md := buildMethodDesc(m, method, path)<br><span class="hljs-keyword">return</span> md<br>&#125;<br></code></pre></td></tr></table></figure><p>生成默认的路由</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defaultMethod</span><span class="hljs-params">(m *protogen.Method)</span> *<span class="hljs-title">method</span></span> &#123;<br>    <span class="hljs-comment">// 分割方法名</span><br>names := strings.Split(toSnakeCase(m.GoName), <span class="hljs-string">&quot;_&quot;</span>)<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 如果 http method 映射成功，那么路由就是 names[1:]</span><br>    <span class="hljs-comment">// 如果没有映射成功路由就是 names</span><br><span class="hljs-keyword">switch</span> strings.ToUpper(names[<span class="hljs-number">0</span>]) &#123;<br><span class="hljs-keyword">case</span> http.MethodGet, <span class="hljs-string">&quot;FIND&quot;</span>, <span class="hljs-string">&quot;QUERY&quot;</span>, <span class="hljs-string">&quot;LIST&quot;</span>, <span class="hljs-string">&quot;SEARCH&quot;</span>:<br>httpMethod = http.MethodGet<br><span class="hljs-comment">// ...  其他方法映射</span><br><span class="hljs-keyword">default</span>:<br>httpMethod = <span class="hljs-string">&quot;POST&quot;</span><br>paths = names<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><br>md := buildMethodDesc(m, httpMethod, path)<br><span class="hljs-keyword">return</span> md<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们在使用 go template 生成最开始方案中文件即可，代码有点多了这里就不贴了，可以在 <a href="https://github.com/mohuishou/protoc-gen-go-gin">https://github.com/mohuishou/protoc-gen-go-gin</a> 中找到</p><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">案例完整源代码可以在 <a href="https://github.com/mohuishou/protoc-gen-go-gin">https://github.com/mohuishou/protoc-gen-go-gin</a> 中找到</div><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;github.com/mohuishou/protoc-gen-go-gin/example/api/product/app/v1&quot;</span>;<br><br><span class="hljs-keyword">package</span> product.app.v1;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/api/annotations.proto&quot;</span>;<br><br><span class="hljs-comment">// blog service is a blog demo</span><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">BlogService</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">rpc</span> GetArticles(GetArticlesReq) <span class="hljs-keyword">returns</span> (GetArticlesResp) </span>&#123;<br><span class="hljs-keyword">option</span> (google.api.http) = &#123;<br>get: <span class="hljs-string">&quot;/v1/articles&quot;</span><br>additional_bindings &#123;<br>get: <span class="hljs-string">&quot;/v1/author/&#123;author_id&#125;/articles&quot;</span><br>&#125;<br>&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">rpc</span> CreateArticle(Article) <span class="hljs-keyword">returns</span> (Article) </span>&#123;<br><span class="hljs-keyword">option</span> (google.api.http) = &#123;<br>post: <span class="hljs-string">&quot;/v1/author/&#123;author_id&#125;/articles&quot;</span><br>&#125;;<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">GetArticlesReq</span> </span>&#123;<br><span class="hljs-comment">// @inject_tag: form:&quot;title&quot;</span><br><span class="hljs-built_in">string</span> title = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// @inject_tag: form:&quot;page&quot;</span><br><span class="hljs-built_in">int32</span> page = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// @inject_tag: form:&quot;page_size&quot;</span><br><span class="hljs-built_in">int32</span> page_size = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// @inject_tag: form:&quot;author_id&quot; uri:&quot;author_id&quot;</span><br><span class="hljs-built_in">int32</span> author_id = <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">GetArticlesResp</span> </span>&#123;<br><span class="hljs-built_in">int64</span> total = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">repeated</span> Article articles = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Article</span> </span>&#123;<br><span class="hljs-built_in">string</span> title  = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">string</span> content = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// @inject_tag: form:&quot;author_id&quot; uri:&quot;author_id&quot;</span><br><span class="hljs-built_in">int32</span> author_id = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意 @inject_tag: 的注释是使用了 protoc-go-inject-tag 插件用来附加额外的 Struct tags，protoc-gen-go 目前暂时不支持添加 tag</p><p>定义好 proto 文件之后我们只需要执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">protoc -I ./example/api \<br> <span class="hljs-comment"># 这个是用来生成 swagger json 文件的，我们很多系统支持导入 swagger 的定义，生成这个方便导入</span><br>--openapiv2_out ./example/api --openapiv2_opt logtostderr=<span class="hljs-literal">true</span> --openapiv2_opt json_names_for_fields=<span class="hljs-literal">false</span> \<br> <span class="hljs-comment"># 生成对应的 go 文件</span><br>--go_out ./example/api --go_opt=paths=source_relative \<br> <span class="hljs-comment"># 生成本文插件中的 gin 文件</span><br>--go-gin_out ./example/api --go-gin_opt=paths=source_relative \<br>example/api/product/app/v1/v1.proto<br>protoc-go-inject-tag -input=./example/api/product/app/v1/v1.pb.go<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>api 设计这部分就先到这里了，下一篇文章我们一起看看配置管理</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></li><li><a href="https://lailin.xyz/post/go-training-week4-project-layout.html">Go 工程化(二) 项目目录结构</a></li><li><a href="https://github.com/go-kratos/kratos">https://github.com/go-kratos/kratos</a></li><li><a href="https://github.com/golang/protobuf/blob/master/protoc-gen-go/main.go">https://github.com/golang/protobuf/blob/master/protoc-gen-go/main.go</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week04: Go 工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go工程化(四) API 设计上: 项目结构 &amp; 设计</title>
    <link href="/post/go-training-week4-api-design.html"/>
    <url>/post/go-training-week4-api-design.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>3 月开始会尝试爆更模式，争取做到两天更新一篇文章，如果感兴趣可以拉到文章最下方获取关注方式。<strong>3 月进度: 01/15</strong></p><p>在 <a href="https://lailin.xyz/post/go-training-week4-project-layout.html">Go 工程化(二) 项目目录结构</a> 中我们大概讲了一下 api 目录，但是并没有详细的说明，留在这这篇文章一起讲。</p><p>API 设计将分为四个部分:</p><ul><li>首先会讲一下 API 的项目目录结构，在项目中 api 该如何组织，以及 api 依赖该如何处理</li><li>第二个部分会讲一下 API 该如何设计，包括错误码的设计</li><li>第三个部分会讲一下如何构造一个 protobuf 的代码生成器，自动生成 gin 相关代码，这个是因为我们目前主要是 http 的服务，grpc 相关基础设施建设不完全，所以依赖现有的基础设施得到更好的体验。并且做到在 service 层的代码支持 grpc 和 http 多种方式，使后续架构变化更加灵活。</li><li>第四个部分会给出一个 demo，辅助大家更好的理解</li></ul><p>由于篇幅原因拆分成了两篇文章，本文涉及到一二部分，下一篇文章为讲解三四部分</p><h2 id="API-项目结构与管理"><a href="#API-项目结构与管理" class="headerlink" title="API 项目结构与管理"></a>API 项目结构与管理</h2><h3 id="API-定义方式"><a href="#API-定义方式" class="headerlink" title="API 定义方式"></a>API 定义方式</h3><p>b 站内部主要使用 grpc 作为内部通信的方式，因为他使用 protobuf 文件定义可以支持对语言代码生成，同时还避免了手写文档导致的文档错误过时等情况，具体的原因其实在第一课的笔记当中就有提到，如果感兴趣可以查看 <a href="https://lailin.xyz/post/go-training-02.html#%E6%9C%8D%E5%8A%A1%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F-gRPC">微服务(二) 服务发现&amp;多租户#gRPC</a></p><p>我们目前使用类似 http restful 的方式进行对外对内提供服务，但是我们之前的 API 管理其实是比较混乱的，分为以下几种情况:</p><ol><li>暴露给 web 的 api：有使用 swagger 的，有在文档平台上写文档的，还有没有写文档的</li><li>暴露给其他服务调用的 api: 有注册到内部的接口网关的，但是内部的接口网关上有的有参数，有的没有，没有返回值定义</li></ol><p>所以就存在很多问题:</p><ol><li>想要接口不知道从哪儿找，只能到处问人</li><li>有时候从内部网关平台上找到接口但是不知道怎么调用，没有写任何参数，有的写了还有可能是错的</li><li>有的压根没有接口文档，对接的同学也没有时间写，然后让你直接看代码</li><li>有的对接同学扔给你一个接口文档，然后试了半天发现，有问题，沟通排查之后发现文档很久没有更新了 o(╥﹏╥)o</li></ol><p>所以课程上毛老师提到的利用 protobuf 来定义接口的方式非常令人心动，因为 protobuf 当中包含了接口的函数签名，入参和返回值同时还支持注释，就是一份天然的文档，同时也不用担心出现代码更新了但是文档没有更新的情况，因为它既是文档也是代码，服务端也需要使用，所以代码更新之后文档也一定会更新。自然而然的就少了很多沟通的成本。<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1614415342256-f3677521-4990-4a9b-9136-ea2b1f4b75d8.jpeg" alt="api 定义方式 (1).jpg"><br>如上图所示于此同时我们还可以利用 protobuf 文件生成对应语言的客户端代码，就不用每个项目都去维护一套 sdk 了，同时我们使用接口生成代码，在 go 当中可以使用 gomock 非常方便的对代码进行 mock。</p><h3 id="API-Project"><a href="#API-Project" class="headerlink" title="API Project"></a>API Project</h3><p>使用 protobuf 定义接口可以解决我们找到 api 文档之后，文档不准确，缺失的问题，但是我们应该如何找到我们的 api 呢？我们生成出的 api 文件调用方应该如何引用呢？难道我们给每个调用方都去开一个项目的权限么？那明显是不太行的，接下来我们就看看我们 api 该如何管理和组织。</p><p>毛老师他们仿照 <a href="https://github.com/googleapis/googleapis">googleapis/googleapis</a>，<a href="https://github.com/istio/api">istio/api</a> 等知名项目在 b 站内部搞了一个 bapis 的仓库用于同一存放 api 定义文档，然后通过 ci/cd 生成对应的客户端代码放到各个语言的子仓库当中<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1614414445467-d7fb88d2-732d-4ef7-8535-cc645a5b9184.jpeg" alt="Frame 1 (1).jpg"><br>工作流程如上图所示</p><ul><li>开发同学修改了 proto 文件定义之后 push 到对应的业务应用仓库当中</li><li>然后触发 cicd 流程将 proto 文件复制到 api project 当中<ul><li>首先会对 proto 文件进行静态代码分析，查看是否符合规范</li><li>然后 clone api project 创建一个新的分支</li><li>然后 push 代码，创建一个 merge request 请求</li></ul></li><li>然后我们对应负责的同学收到 code review 的通知之后进行 code review，没有问题就会合并到 api project 的主分支当中了</li><li>然后就会触发 cicd 生成对应语言的客户端代码，push 到对应的各个子仓库当中了</li></ul><h3 id="API-Project-Layout"><a href="#API-Project-Layout" class="headerlink" title="API Project Layout"></a>API Project Layout</h3><p>我们的 api 项目是如何定义的呢？看下图<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1614417503897-60326cce-3788-4727-a182-659252fdd231.jpeg" alt="Frame 1 (2).jpg"></p><ul><li>首先是在业务项目当中，我们顶层会有一个 api 目录<ul><li>在 api 目录当中我们会按照 product name/app name/版本号/app.proto 的方式进行组织</li><li>具体怎么组织可能每个公司都不太一样，但是总的来说就是应用的 唯一名称+版本号 来进行一个区分</li></ul></li><li>在 api project 当中和业务应用类似，也有一个 api 目录，通过上图的两个框就可以发现这是一模一样的<ul><li>除此之外 api project 还有用于注解的 annotations 文件夹</li><li>有一些第三方的引用，例如 googleapis 当中的一些 proto 文件</li></ul></li></ul><h2 id="API-设计"><a href="#API-设计" class="headerlink" title="API 设计"></a>API 设计</h2><h3 id="API-兼容性设计"><a href="#API-兼容性设计" class="headerlink" title="API 兼容性设计"></a>API 兼容性设计</h3><p>随着应用的不断开发，业务的不断发展我们的 api 肯定会不断的进行修改，在修改 api 的时候考虑 api 的兼容性就会很重要了，如果我们做了一些破坏性的变更就有可能会导致依赖我们的服务或者是客户端报错，这样就会带来事故。</p><h4 id="向下兼容的变更"><a href="#向下兼容的变更" class="headerlink" title="向下兼容的变更"></a>向下兼容的变更</h4><ul><li>新增接口</li><li>新增参数字段</li><li>新增返回字段<ul><li>在不改变其他响应字段的行为的前提下，非资源（例如，ListBooksResponse）的响应消息可以扩展而不必破坏客户端的兼容性。即使会引入冗余，先前在响应中填充的任何字段应继续使用相同的语义填充。</li></ul></li></ul><p>一般而言新增都是相对安全的，但是我们要注意的是新增字段不能改变我们原本的逻辑，如果改变了 api 的逻辑，那就不一定安全了</p><h4 id="向下不兼容的变更（破坏性变更）"><a href="#向下不兼容的变更（破坏性变更）" class="headerlink" title="向下不兼容的变更（破坏性变更）"></a>向下不兼容的变更（破坏性变更）</h4><ul><li>删除或重命名服务，字段，方法或枚举值<ul><li>在做这种修改的时候需要修改我们 api 的版本号，常见有两种方式</li><li>如果只有很少的 api 变动可以创建一个 XXXV2 的方法</li><li>如果变动的 api 比较多，可以直接新启一个 v2 的包</li></ul></li><li>修改字段的类型<ul><li>严禁修改字段的类型，修改字段的类型可能会导致客户端崩溃</li></ul></li><li>修改现有请求的可见行为</li><li>给资源消息添加 读取/写入 字段</li></ul><h3 id="API-命名规范"><a href="#API-命名规范" class="headerlink" title="API 命名规范"></a>API 命名规范</h3><h4 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h4><table><thead><tr><th>产品名</th><th>product</th></tr></thead><tbody><tr><td>应用名</td><td>app</td></tr><tr><td>版本号</td><td>v1</td></tr><tr><td>包名</td><td>product.app.v1</td></tr><tr><td>目录结构</td><td>api/product/app/v1/xx.proto</td></tr></tbody></table><h4 id="API-定义"><a href="#API-定义" class="headerlink" title="API 定义"></a>API 定义</h4><ul><li>命名规则：方法 + 资源</li><li>标准方法：参考 Google API 设计指南</li></ul><table><thead><tr><th><strong>标准方法</strong></th><th><strong>HTTP 映射</strong></th></tr></thead><tbody><tr><td>List</td><td>GET</td></tr><tr><td>Get</td><td>GET</td></tr><tr><td>Update</td><td>PUT 或者 PATCH</td></tr><tr><td>Create</td><td>POST</td></tr><tr><td>Delete</td><td>DELETE</td></tr></tbody></table><p>除了标准的也有一些非标准的，例如同步数据可能会用 <code>Sync</code>  等，不过大部分的 api 应该都是标准的</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// api/product/app/v1/blog.proto</span><br><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">package</span> product.app.v1;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/api/annotations.proto&quot;</span>;<br><br><span class="hljs-comment">// blog service is a blog demo</span><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">BlogService</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">rpc</span> GetArticles(GetArticlesReq) <span class="hljs-keyword">returns</span> (GetArticlesResp) </span>&#123;<br><span class="hljs-keyword">option</span> (google.api.http) = &#123;<br>get: <span class="hljs-string">&quot;/v1/articles&quot;</span><br>additional_bindings &#123;<br>get: <span class="hljs-string">&quot;/v1/author/&#123;author_id&#125;/articles&quot;</span><br>&#125;<br>&#125;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，一般而言我们应该为每个接口都创建一个自定义的 message，为了后面扩展，如果我们用 Empty 的话后续就没有办法新增字段了</p><h3 id="API-Error"><a href="#API-Error" class="headerlink" title="API Error"></a>API Error</h3><h3 id="错误定义"><a href="#错误定义" class="headerlink" title="错误定义"></a>错误定义</h3><p>先说我们当前的问题，我们一直用的 http 然后我们返回是使用的下面这种格式，然后 http code 统一返回 200</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>,<br>  <span class="hljs-attr">&quot;data&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种做法就存在一个比较大的问题，做监控的时候不太好做，很多现成的东西没有办法直接使用，因为我们都返回的成功。<br>参照 google 的错误定义，将 http code 和 grpc 错误码进行映射，返回对应的错误信息<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1614421247833-c0467849-823e-4a22-b53f-95b2705f8c39.png" alt="image.png"><br>但是这样还是不行，因为这样很多业务错误信息无法区分，毛老师他们的 kratos v2 的做法是做了两层，使用下面的方式进行定义</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Status</span> </span>&#123;<br>  <span class="hljs-comment">// 错误码，跟 grpc-status 一致，并且在HTTP中可映射成 http-status</span><br>  <span class="hljs-built_in">int32</span> code = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 错误原因，定义为业务判定错误码</span><br>  <span class="hljs-built_in">string</span> reason = <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// 错误信息，为用户可读的信息，可作为用户提示内容</span><br>  <span class="hljs-built_in">string</span> <span class="hljs-class"><span class="hljs-keyword">message</span> = 3;</span><br><span class="hljs-class">  // 错误详细信息，可以附加自定义的信息列表</span><br><span class="hljs-class">  <span class="hljs-title">repeated</span> google.protobuf.Any details = 4;</span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure><p>和我们当前的方式差不太多，但是我们是在原来的基础上返回了 http code，剩下的字段还是和原来保持一致</p><h3 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h3><p>这一点我们之前做的还行，错误传播这一部分很容易出的问题就是，当前服务直接把上游服务的错误给返回了，这样会导致一些问题：</p><ul><li>如果我调用了多个上游服务都报错了，我应该返回哪一个错误</li><li>直接返回导致必须要有一个全局错误码，不然的话就会冲突，但是全局错误码是很难定义的</li></ul><p>正确的做法应该是把上游错误信息吞掉，返回当前服务自己定义的错误信息就可以了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>毛老师课上讲的 api 设计思路用起来还是挺爽的，我们已经在一个项目当中进行了试点，cicd 的流程也跑了起来，最爽的一点就是终于不用找接口文档了，然后还节省了一些代码量，我们之前的接口调用方式都是十分原始的，每个项目都自己去封装相关的 sdk 然后我们对单元测试还有要求，http 接口的 mock 是挺麻烦的事情，通过 protobuf 定义接口之后我写了一个结合内部网关的 sdk 代码生成器，直接生成相关接口代码，go interface 的 mock 实现也在 ci 流程中生产好了，调用方只需要调用不同的实现就行了。<br>下一篇我们就通过写一个 从 proto 生成 gin 代码的生成器来看看这个代码生成器改如何实现。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></li><li><a href="https://github.com/istio/api">GitHub - istio/api: API definitions for the Istio project</a></li><li><a href="https://github.com/envoyproxy/data-plane-api">GitHub - envoyproxy/data-plane-api: [READ ONLY MIRROR] Envoy REST/proto API definitions and documentation.</a></li><li><a href="https://github.com/googleapis/googleapis">GitHub - googleapis/googleapis: Public interface definitions of Google APIs.</a></li><li><a href="https://cloud.google.com/apis/design?hl=zh-cn">API 设计指南  |  Google Cloud</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week04: Go 工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go工程化(三) 依赖注入框架 wire</title>
    <link href="/post/go-training-week4-wire.html"/>
    <url>/post/go-training-week4-wire.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>在上一篇文章当中我们讲到了项目的目录结构，大体上水平切分为了四层，然后再根据需要进行垂直切分，然后由于我们大量的使用到了接口和依赖注入的手段，所以在项目初始化的时候如果手动进行依赖关系的初始化会比较麻烦，这时候就需要用到依赖注入的框架了。</p><p>在刚开始接触 go 的那一段时间，我是比较排斥使用太多框架的，觉得保持简单更加重要，这种想法在很长一段时间（大概两年左右）都没有问题，直到正式工作一段时间之后发现，随着开发合作的同学的增多以及部门的要求增加，项目启动时的依赖越来越多，依赖之间还有先后顺序，有一些甚至是隐式的顺序，到时 main 函数的代码膨胀的非常迅速并且慢慢的变的不可维护了，这种情况下引入依赖注入框架其实可以省心很多。</p><p>Golang 的依赖注入框架有两类，一类是通过反射在运行时进行依赖注入，典型代表是 uber 开源的 dig，另外一类是通过 generate 进行代码生成，典型代表是 Google 开源的 wire。使用 dig 功能会强大一些，但是缺点就是错误只能在运行时才能发现，这样如果不小心的话可能会导致一些隐藏的 bug 出现。使用 wire 的缺点就是功能限制多一些，但是好处就是编译的时候就可以发现问题，并且生成的代码其实和我们自己手写相关代码差不太多，更符合直觉，心智负担更小，所以我更加推荐 wire，如果对 dig 感兴趣可以跳转到文章参考文献处跳转查阅。</p><p>本文分为两个部分，首先介绍 wire 的使用方法，然后是结合上一篇文章中的工程目录，我在使用 wire 过程中的一些 “最佳实践” 避免大家重复踩坑。</p><h2 id="wire-使用教程"><a href="#wire-使用教程" class="headerlink" title="wire 使用教程"></a>wire 使用教程</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">如果你对 wire 已经比较熟悉可以直接跳过这一部分，阅读完本文之后建议对照看一下官方文档再进行操作。<br>注：本文基于 wire 0.5.0 进行编写</div><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装很简单，只要安装了 Go 并且已经把 <code>$GOPATH/bin</code>  加入到了 <code>PATH</code>  当中，终端执行下面的语句即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get github.com/google/wire/cmd/wire<br></code></pre></td></tr></table></figure><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>正式开始前需要先了解一下 wire 当中的两个概念：provider 和 injector</p><p>Provider 是一个普通的函数，这个函数会返回构建依赖关系所需的组件。如下所示，就是一个 provider 函数，在实际使用的时候，往往是一些简单的工厂函数，这个函数不会太复杂。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewPostRepo 创建文章 Repo</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPostRepo</span><span class="hljs-params">()</span> <span class="hljs-title">IPostRepo</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>不过需要注意的是<strong>在 wire 中不能存在两个 provider 返回相同的组件类型</strong></p><h3 id="Injector"><a href="#Injector" class="headerlink" title="Injector"></a>Injector</h3><p>injector 也是一个普通函数，我们常常在 <code>wire.go</code>  文件中定义 injector 函数签名，然后通过 <code>wire</code>  命令自动生成一个完整的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//+build wireinject</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetBlogService</span><span class="hljs-params">()</span> *<span class="hljs-title">Blog</span></span> &#123;<br>    <span class="hljs-built_in">panic</span>(wire.Build(NewBlogService, NewPostUsecase, NewPostRepo))<br>&#125;<br></code></pre></td></tr></table></figure><p>第一行的 <code>//+build wireinject</code>  注释确保了这个文件在我们正常编译的时候不会被引用，而 <code>wire .</code>  生成的文件 <code>wire_gen.go</code>  会包含 <code>//+build !wireinject</code>  注释，正常编译的时候，不指定 tag 的情况下会引用这个文件</p><p><code>wire.Build</code>  在 <code>injector</code>  函数中使用，用于表名这个 <code>injector</code>  由哪些 <code>provider</code>  提供依赖， <code>injector</code>  函数本身只是一个函数签名，所以我们直接在函数中 <code>panic</code>  实际生成代码的时候并不会直接调用 panic</p><h3 id="一个完整的-🌰"><a href="#一个完整的-🌰" class="headerlink" title="一个完整的 🌰"></a>一个完整的 🌰</h3><h4 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> example<br><br><span class="hljs-comment">// repo</span><br><br><span class="hljs-comment">// IPostRepo IPostRepo</span><br><span class="hljs-keyword">type</span> IPostRepo <span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-comment">// NewPostRepo NewPostRepo</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPostRepo</span><span class="hljs-params">()</span> <span class="hljs-title">IPostRepo</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(IPostRepo)<br>&#125;<br><br><span class="hljs-comment">// usecase</span><br><br><span class="hljs-comment">// IPostUsecase IPostUsecase</span><br><span class="hljs-keyword">type</span> IPostUsecase <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-keyword">type</span> postUsecase <span class="hljs-keyword">struct</span> &#123;<br>repo IPostRepo<br>&#125;<br><br><span class="hljs-comment">// NewPostUsecase NewPostUsecase</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPostUsecase</span><span class="hljs-params">(repo IPostRepo)</span> <span class="hljs-title">IPostUsecase</span></span> &#123;<br><span class="hljs-keyword">return</span> postUsecase&#123;repo: repo&#125;<br>&#125;<br><br><span class="hljs-comment">// service service</span><br><br><span class="hljs-comment">// PostService PostService</span><br><span class="hljs-keyword">type</span> PostService <span class="hljs-keyword">struct</span> &#123;<br>usecase IPostUsecase<br>&#125;<br><br><span class="hljs-comment">// NewPostService NewPostService</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPostService</span><span class="hljs-params">(u IPostUsecase)</span> *<span class="hljs-title">PostService</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;PostService&#123;usecase: u&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的是一个简单的示例， <code>NewPostService</code> <code>NewPostUsecase</code>  这些都是 <code>Provider</code>  函数，下面我们在 <code>wire.go</code>  当中构建 <code>Injector</code>  函数签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//+build wireinject</span><br><br><span class="hljs-keyword">package</span> example<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/google/wire&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPostService</span><span class="hljs-params">()</span> *<span class="hljs-title">PostService</span></span> &#123;<br><span class="hljs-built_in">panic</span>(wire.Build(<br>NewPostService,<br>NewPostUsecase,<br>NewPostRepo,<br>))<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在目录下执行 <code>wire .</code>  生成如下文件，可以看到生成的函数和我们自己手写其实差不多</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Code generated by Wire. DO NOT EDIT.</span><br><br><span class="hljs-comment">//go:generate wire</span><br><span class="hljs-comment">//+build !wireinject</span><br><br><span class="hljs-keyword">package</span> example<br><br><span class="hljs-comment">// Injectors from wire.go:</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPostService</span><span class="hljs-params">()</span> *<span class="hljs-title">PostService</span></span> &#123;<br>iPostRepo := NewPostRepo()<br>iPostUsecase := NewPostUsecase(iPostRepo)<br>postService := NewPostService(iPostUsecase)<br><span class="hljs-keyword">return</span> postService<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="缺少-provider"><a href="#缺少-provider" class="headerlink" title="缺少 provider"></a>缺少 provider</h4><p>在执行 <code>wire .</code>  的时候，如果我们的缺少某个 <code>Provider</code>  提供依赖，wire 会进行提示，帮助我们快速找到问题并且修改<br>还是上面的这个例子，我们删除掉一个 Provider 函数试试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPostService</span><span class="hljs-params">()</span> *<span class="hljs-title">PostService</span></span> &#123;<br><span class="hljs-built_in">panic</span>(wire.Build(<br>NewPostService,<br>NewPostUsecase,<br>))<br>&#125;<br></code></pre></td></tr></table></figure><p>再次执行 <code>wire</code>  命令，可以发现报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">▶ wire .<br>wire: /Go<span class="hljs-number">-000</span>/Week04/blog/<span class="hljs-number">03</span>_wire/<span class="hljs-number">01</span>_example/wire.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>:<span class="hljs-number">1</span>: inject GetPostService: no provider found <span class="hljs-keyword">for</span> github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week04/blog/<span class="hljs-number">03</span>_wire/<span class="hljs-number">01</span>_example.IPostRepo<br>        needed by github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week04/blog/<span class="hljs-number">03</span>_wire/<span class="hljs-number">01</span>_example.IPostUsecase in provider <span class="hljs-string">&quot;NewPostUsecase&quot;</span> (/Go<span class="hljs-number">-000</span>/Week04/blog/<span class="hljs-number">03</span>_wire/<span class="hljs-number">01</span>_example/example.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span>:<span class="hljs-number">6</span>)<br>        needed by *github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week04/blog/<span class="hljs-number">03</span>_wire/<span class="hljs-number">01</span>_example.PostService in provider <span class="hljs-string">&quot;NewPostService&quot;</span> (/Go<span class="hljs-number">-000</span>/Week04/blog/<span class="hljs-number">03</span>_wire/<span class="hljs-number">01</span>_example/example.<span class="hljs-keyword">go</span>:<span class="hljs-number">34</span>:<span class="hljs-number">6</span>)<br>wire: github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week04/blog/<span class="hljs-number">03</span>_wire/<span class="hljs-number">01</span>_example: generate failed<br>wire: at least one generate failure<br></code></pre></td></tr></table></figure><h4 id="返回错误"><a href="#返回错误" class="headerlink" title="返回错误"></a>返回错误</h4><p>在 go 中如果遇到错误，我们会在最后一个返回值返回 error，wire 同样也支持返回错误的情况，只需要在 injector 的函数签名中加上 error 返回值即可，还是前面的那个例子，我们让 <code>NewPostService</code>  返回 error，并且修改 <code>GetPostService</code>  这个 <code>Injector</code>  函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// example.go</span><br><span class="hljs-comment">// NewPostService NewPostService</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPostService</span><span class="hljs-params">(u IPostUsecase)</span> <span class="hljs-params">(*PostService, error)</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;PostService&#123;usecase: u&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// wire.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPostService</span><span class="hljs-params">()</span> <span class="hljs-params">(*PostService, error)</span></span> &#123;<br><span class="hljs-built_in">panic</span>(wire.Build(<br>NewPostService,<br>NewPostUsecase,<br>NewPostRepo,<br>))<br>&#125;<br></code></pre></td></tr></table></figure><p>生成的代码如下所示，可以发现会像我们自己写代码一样判断一下 <code>if err</code>  然后返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// wire_gen.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPostService</span><span class="hljs-params">()</span> <span class="hljs-params">(*PostService, error)</span></span> &#123;<br>iPostRepo := NewPostRepo()<br>iPostUsecase := NewPostUsecase(iPostRepo)<br>postService, err := NewPostService(iPostUsecase)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> postService, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="清理函数"><a href="#清理函数" class="headerlink" title="清理函数"></a>清理函数</h4><p>有时候我们需要打开文件，或者是链接这种需要关闭的资源，这时候 provider 可以返回一个闭包函数 <code>func()</code> ，wire 在进行构建的时候，会在报错的时候调用，并且会将所有的闭包函数聚合返回。<br>这个特性一般用的不多，但是有需求的时候会十分有用。</p><p>还是之前的示例，我们修改一下 <code>NewPostRepo</code> <code>NewPostUsecase</code>  让他们返回一个清理函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// example.go</span><br><br><span class="hljs-comment">// NewPostRepo NewPostRepo</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPostRepo</span><span class="hljs-params">()</span> <span class="hljs-params">(IPostRepo, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(IPostRepo), <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// NewPostUsecase NewPostUsecase</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPostUsecase</span><span class="hljs-params">(repo IPostRepo)</span> <span class="hljs-params">(IPostUsecase, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> &#123;<br><span class="hljs-keyword">return</span> postUsecase&#123;repo: repo&#125;, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// wire.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPostService</span><span class="hljs-params">()</span> <span class="hljs-params">(*PostService, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> &#123;<br><span class="hljs-built_in">panic</span>(wire.Build(<br>NewPostService,<br>NewPostUsecase,<br>NewPostRepo,<br>))<br>&#125;<br></code></pre></td></tr></table></figure><p>执行 <code>wire .</code>  之后我们可以发现生成的函数当中，当 <code>NewPostUsecase</code>  出现错误的时候会自动帮我们调用 <code>NewPostRepo</code>  返回的 <code>cleanup</code>  函数，而 <code>NewPostService</code>  返回错误，会调用它依赖的所有 provider 的 cleanup 函数，如果都没有问题，就会把所有 cleanup 函数聚合为一个函数返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPostService</span><span class="hljs-params">()</span> <span class="hljs-params">(*PostService, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> &#123;<br>iPostRepo, cleanup, err := NewPostRepo()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br>iPostUsecase, cleanup2, err := NewPostUsecase(iPostRepo)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>cleanup()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br>postService, err := NewPostService(iPostUsecase)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>cleanup2()<br>cleanup()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> postService, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>cleanup2()<br>cleanup()<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高级方法"><a href="#高级方法" class="headerlink" title="高级方法"></a>高级方法</h3><h4 id="接口注入"><a href="#接口注入" class="headerlink" title="接口注入"></a>接口注入</h4><p>我们应该依赖接口，而不是实现。返回数据的时候返回实现而不是接口，这是在 Golang 中的最佳实践（当然也不是所有的都是这样），所以如果我们的 provider 返回了实现，但是我们的依赖的是接口，这时候就会报错了，我们先来看一个例子。</p><p>我们修改一下 <code>NewPostUsecase</code>  方法，让他返回 <code>*PostUsecase</code>  而不是接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewPostUsecase NewPostUsecase</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPostUsecase</span><span class="hljs-params">(repo IPostRepo)</span> <span class="hljs-params">(*PostUsecase, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> &#123;<br><span class="hljs-keyword">return</span> &amp;PostUsecase&#123;repo: repo&#125;, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这时候执行 <code>wire .</code>  生成代码会发现报错，找不到 <code>IPostUsecase</code>  的 provider</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">▶ wire .<br>wire: /Go<span class="hljs-number">-000</span>/Week04/blog/<span class="hljs-number">03</span>_wire/<span class="hljs-number">01</span>_example/wire.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>:<span class="hljs-number">1</span>: inject GetPostService: no provider found <span class="hljs-keyword">for</span> github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week04/blog/<span class="hljs-number">03</span>_wire/<span class="hljs-number">01</span>_example.IPostUsecase<br>        needed by *github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week04/blog/<span class="hljs-number">03</span>_wire/<span class="hljs-number">01</span>_example.PostService in provider <span class="hljs-string">&quot;NewPostService&quot;</span> (/Go<span class="hljs-number">-000</span>/Week04/blog/<span class="hljs-number">03</span>_wire/<span class="hljs-number">01</span>_example/example.<span class="hljs-keyword">go</span>:<span class="hljs-number">36</span>:<span class="hljs-number">6</span>)<br>wire: github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week04/blog/<span class="hljs-number">03</span>_wire/<span class="hljs-number">01</span>_example: generate failed<br>wire: at least one generate failure<br></code></pre></td></tr></table></figure><p>这时候就需要使用 <code>wire.Bind</code>  将 <code>Struct</code>  和接口进行绑定了，表示这个结构体实现了这个接口，我们修改一下 <code>injector</code>  函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPostService</span><span class="hljs-params">()</span> <span class="hljs-params">(*PostService, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> &#123;<br><span class="hljs-built_in">panic</span>(wire.Build(<br>NewPostService,<br>wire.Bind(<span class="hljs-built_in">new</span>(IPostUsecase), <span class="hljs-built_in">new</span>(*PostUsecase)),<br>NewPostUsecase,<br>NewPostRepo,<br>))<br>&#125;<br></code></pre></td></tr></table></figure><p><code>wire.Bind</code>  的使用方法就是 <code>wire.Bind(new(接口), new(实现))</code></p><h4 id="Struct-属性注入"><a href="#Struct-属性注入" class="headerlink" title="Struct 属性注入"></a>Struct 属性注入</h4><p>在上面 <code>NewPostService</code>  代码，我们可以发现有很多 <code>Struct</code>  的初始化其实就是填充里面的属性，没有其他的逻辑，这种情况我们可以偷点懒直接使用 <code>wire.Struct</code>  方法直接生成 provider</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// structType: 结构体类型</span><br><span class="hljs-comment">// fieldNames: 需要填充的字段，使用 &quot;*&quot; 表示所有字段都需要填充</span><br>Struct(structType <span class="hljs-keyword">interface</span>&#123;&#125;, fieldNames ...<span class="hljs-keyword">string</span>)<br></code></pre></td></tr></table></figure><p>我们修改一下 <code>Injector</code>  函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPostService</span><span class="hljs-params">()</span> <span class="hljs-params">(*PostService, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> &#123;<br><span class="hljs-built_in">panic</span>(wire.Build(<br><span class="hljs-comment">// 这里由于只有一个字段，所以这两种是等价的 wire.Struct(new(PostService), &quot;*&quot;),</span><br>wire.Struct(<span class="hljs-built_in">new</span>(PostService), <span class="hljs-string">&quot;usecase&quot;</span>),<br>wire.Bind(<span class="hljs-built_in">new</span>(IPostUsecase), <span class="hljs-built_in">new</span>(*PostUsecase)),<br>NewPostUsecase,<br>NewPostRepo,<br>))<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到生成的代码当中自动就生成了一个结构体并且填充数据了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPostService</span><span class="hljs-params">()</span> <span class="hljs-params">(*PostService, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> &#123;<br>iPostRepo, cleanup, err := NewPostRepo()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br>postUsecase, cleanup2, err := NewPostUsecase(iPostRepo)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>cleanup()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br>    <span class="hljs-comment">// 注意这里</span><br>postService := &amp;PostService&#123;<br>usecase: postUsecase,<br>&#125;<br><span class="hljs-keyword">return</span> postService, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>cleanup2()<br>cleanup()<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h4><p>除了依赖某一个类型之外，有时候我们还会依赖一些具体的值，这时候我们就可以使用 <code>wire.Value</code>  或者是 <code>wire.InterfaceValue</code> ，为某个类型绑定具体的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// wire.Value 为某个类型绑定值，但是不能为接口绑定值</span><br>Value(<span class="hljs-keyword">interface</span>&#123;&#125;) ProvidedValue<br><span class="hljs-comment">// wire.InterfaceValue 为接口绑定值</span><br>InterfaceValue(typ <span class="hljs-keyword">interface</span>&#123;&#125;, x <span class="hljs-keyword">interface</span>&#123;&#125;) ProvidedValue<br></code></pre></td></tr></table></figure><p>我们修改一下 <code>PostService</code>  使他依赖一个 int 和 io.Reader 然后为它直接绑定 <code>a=99</code> <code>io.Reader = os.Stdin</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// example.go</span><br><br><span class="hljs-keyword">type</span> PostService <span class="hljs-keyword">struct</span> &#123;<br>usecase IPostUsecase<br>a       <span class="hljs-keyword">int</span><br>r       io.Reader<br>&#125;<br><br><span class="hljs-comment">// wire.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPostService</span><span class="hljs-params">()</span> <span class="hljs-params">(*PostService, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> &#123;<br><span class="hljs-built_in">panic</span>(wire.Build(<br>wire.Struct(<span class="hljs-built_in">new</span>(PostService), <span class="hljs-string">&quot;*&quot;</span>),<br>wire.Value(<span class="hljs-number">10</span>),<br>wire.InterfaceValue(<span class="hljs-built_in">new</span>(io.Reader), os.Stdin),<br>wire.Bind(<span class="hljs-built_in">new</span>(IPostUsecase), <span class="hljs-built_in">new</span>(*PostUsecase)),<br>NewPostUsecase,<br>NewPostRepo,<br>))<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到生成的代码当中直接生成了两个全局变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPostService</span><span class="hljs-params">()</span> <span class="hljs-params">(*PostService, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> &#123;<br>iPostRepo, cleanup, err := NewPostRepo()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br>postUsecase, cleanup2, err := NewPostUsecase(iPostRepo)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>cleanup()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br>int2 := _wireIntValue<br>reader := _wireFileValue<br>postService := &amp;PostService&#123;<br>usecase: postUsecase,<br>a:       int2,<br>r:       reader,<br>&#125;<br><span class="hljs-keyword">return</span> postService, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>cleanup2()<br>cleanup()<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 注意这里</span><br><span class="hljs-keyword">var</span> (<br>_wireIntValue  = <span class="hljs-number">10</span><br>_wireFileValue = os.Stdin<br>)<br></code></pre></td></tr></table></figure><h4 id="ProviderSet-Provider-集合"><a href="#ProviderSet-Provider-集合" class="headerlink" title="ProviderSet(Provider 集合)"></a>ProviderSet(Provider 集合)</h4><p>在真实的项目当中依赖往往是一组一组的，就像我们的示例一样，只要依赖 <code>PostService</code>  那么 <code>NewPostUsecase</code> <code>NewPostRepo</code>  这两个就必不可少，所以我们往往会创建一些 <code>ProviderSet</code>  在 <code>Injector</code>  函数中直接依赖 <code>ProviderSet</code>  就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 参数是一些 provider</span><br>NewSet(...<span class="hljs-keyword">interface</span>&#123;&#125;) ProviderSet<br></code></pre></td></tr></table></figure><p>示例如下所示，生成代码和之前一样就不另外贴了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// example.go</span><br><br><span class="hljs-comment">// PostServiceSet PostServiceSet</span><br><span class="hljs-keyword">var</span> PostServiceSet = wire.NewSet(<br>wire.Struct(<span class="hljs-built_in">new</span>(PostService), <span class="hljs-string">&quot;*&quot;</span>),<br>wire.Value(<span class="hljs-number">10</span>),<br>wire.InterfaceValue(<span class="hljs-built_in">new</span>(io.Reader), os.Stdin),<br>wire.Bind(<span class="hljs-built_in">new</span>(IPostUsecase), <span class="hljs-built_in">new</span>(*PostUsecase)),<br>NewPostUsecase,<br>NewPostRepo,<br>)<br><br><span class="hljs-comment">// wire.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPostService</span><span class="hljs-params">()</span> <span class="hljs-params">(*PostService, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> &#123;<br><span class="hljs-built_in">panic</span>(wire.Build(<br>PostServiceSet,<br>))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wire-使用最佳实践"><a href="#wire-使用最佳实践" class="headerlink" title="wire 使用最佳实践"></a>wire 使用最佳实践</h2><h3 id="不要使用默认类型"><a href="#不要使用默认类型" class="headerlink" title="不要使用默认类型"></a>不要使用默认类型</h3><p>之前有提到过，wire 不支持两个提供两个相同类型的 provider，所以如果我们使用默认类型如 <code>int</code> <code>string</code>  等，只要有两个依赖就会导致报错，解决方案是使用类型别名。<br>先来看一个报错的示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PostService <span class="hljs-keyword">struct</span> &#123;<br>usecase IPostUsecase<br>a       <span class="hljs-keyword">int</span><br>b       <span class="hljs-keyword">int</span><br>r       io.Reader<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，wire 在构建依赖关系的时候，并不知道 int 的值该分配给 a 还是 b 所以就会报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">▶ wire .<br>wire: /Go<span class="hljs-number">-000</span>/Week04/blog/<span class="hljs-number">03</span>_wire/<span class="hljs-number">01</span>_example/example.<span class="hljs-keyword">go</span>:<span class="hljs-number">40</span>:<span class="hljs-number">2</span>: provider <span class="hljs-keyword">struct</span> has multiple fields of <span class="hljs-keyword">type</span> <span class="hljs-keyword">int</span><br>wire: github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week04/blog/<span class="hljs-number">03</span>_wire/<span class="hljs-number">01</span>_example: generate failed<br>wire: at least one generate failure<br></code></pre></td></tr></table></figure><p>我们自定义两个类型就好了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">int</span><br><span class="hljs-keyword">type</span> B <span class="hljs-keyword">int</span><br><br><span class="hljs-comment">// PostService PostService</span><br><span class="hljs-keyword">type</span> PostService <span class="hljs-keyword">struct</span> &#123;<br>usecase IPostUsecase<br>a       A<br>b       B<br>r       io.Reader<br>&#125;<br><br><span class="hljs-comment">// PostServiceSet PostServiceSet</span><br><span class="hljs-keyword">var</span> PostServiceSet = wire.NewSet(<br>wire.Struct(<span class="hljs-built_in">new</span>(PostService), <span class="hljs-string">&quot;*&quot;</span>),<br>wire.Value(A(<span class="hljs-number">10</span>)),<br>wire.Value(B(<span class="hljs-number">10</span>)),<br>wire.InterfaceValue(<span class="hljs-built_in">new</span>(io.Reader), os.Stdin),<br>wire.Bind(<span class="hljs-built_in">new</span>(IPostUsecase), <span class="hljs-built_in">new</span>(*PostUsecase)),<br>NewPostUsecase,<br>NewPostRepo,<br>)<br></code></pre></td></tr></table></figure><p>这种方式在使用上会感觉有点糟心，但是就我目前的使用来看，用到基础类型的情况还是比价少，所以也还好</p><h3 id="Option-Struct"><a href="#Option-Struct" class="headerlink" title="Option Struct"></a>Option Struct</h3><p>在实际的业务场景当中我们的 <code>NewXXX</code>  函数的参数列表可能会很长，这个时候就可以直接定义一个 Option Struct 然后使用 <code>wire.Strcut</code>  来构建 Option Strcut 的依赖</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PostUsecaseOption PostUsecaseOption</span><br><span class="hljs-keyword">type</span> PostUsecaseOption <span class="hljs-keyword">struct</span> &#123;<br>a    A<br>b    B<br>repo IPostRepo<br>&#125;<br><br><span class="hljs-comment">// NewPostUsecase NewPostUsecase</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPostUsecase</span><span class="hljs-params">(opt *PostUsecaseOption)</span> <span class="hljs-params">(*PostUsecase, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> &#123;<br><span class="hljs-keyword">return</span> &amp;PostUsecase&#123;repo: opt.repo&#125;, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// PostServiceSet PostServiceSet</span><br><span class="hljs-keyword">var</span> PostServiceSet = wire.NewSet(<br>wire.Struct(<span class="hljs-built_in">new</span>(PostService), <span class="hljs-string">&quot;*&quot;</span>),<br>wire.Value(A(<span class="hljs-number">10</span>)),<br>wire.Value(B(<span class="hljs-number">10</span>)),<br>wire.InterfaceValue(<span class="hljs-built_in">new</span>(io.Reader), os.Stdin),<br><br>    <span class="hljs-comment">// for usecase</span><br>    wire.Bind(<span class="hljs-built_in">new</span>(IPostUsecase), <span class="hljs-built_in">new</span>(*PostUsecase)),<br>wire.Struct(<span class="hljs-built_in">new</span>(PostUsecaseOption), <span class="hljs-string">&quot;*&quot;</span>),<br>NewPostUsecase,<br><br>    NewPostRepo,<br>)<br><br></code></pre></td></tr></table></figure><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── api<br>├── cmd<br>│   └── app<br>│       ├── main.go<br>│       ├── wire.go<br>│       └── wire_gen.go<br>└── internal<br>    ├── domain<br>    │   └── post.go<br>    ├── repo<br>    │   └── repo.go<br>    ├── service<br>    │   └── service.go<br>    ├── usecase<br>    │   └── usecase.go<br>    └── wire_set.go<br></code></pre></td></tr></table></figure><ul><li>一般在 cmd/xxx 目录下创建 <code>wire.go</code>  用于构建 <code>injector</code>  函数签名，因为我们一般会在 <code>main</code>  当中构建依赖关系完成服务启动</li><li>在 internal 或者是 internal/app 目录下创建 <code>wire_set.go</code>  构建 <code>ProviderSet</code> ，这里要注意<ul><li>这里的 <code>ProviderSet</code>  中的 <code>Provider</code>  函数只能是当前目录下创建的 Provider 函数</li><li>例如可能存在 usecase 和 repo 都依赖 config 如果 repo 创建一个 ProviderSet 包含 <code>NewConfig</code> ，usecase 也来一个，就会导致在 <code>wire .</code>  生成代码的时候报错，因为有冲突，同一个组件有两个 Provider</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细的介绍了 wire 的使用方法和一些存在的坑，避免大家重复踩坑，同时结合上一篇文章当中的项目结构给出了一种实践方式。依赖注入这个东西如果只是一个比较简单的应用并且这个应用的开发同学比较少，可以不用引入，引入依赖注入的框架还是会带来一些复杂性和学习成本，但是如果这个项目有很多同学在协作开发，并且部门要求的依赖组件比较多的时候还是需要引入的，随着项目代码的膨胀会导致后面依赖管理的管理越来越复杂，如果想要做一点点重构会带来很多麻烦。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></li><li><a href="https://github.com/uber-go/dig">GitHub - uber-go/dig: A reflection based dependency injection toolkit for Go.</a></li><li><a href="https://github.com/google/wire">GitHub - google/wire: Compile-time Dependency Injection for Go</a></li><li><a href="https://medium.com/@dche423/master-wire-cn-d57de86caa1b">https://medium.com/@dche423/master-wire-cn-d57de86caa1b</a></li><li><a href="https://juejin.cn/post/6844903901469097998#heading-7">Golang 依赖注入框架 wire 全攻略</a></li><li><a href="https://blog.golang.org/wire">Compile-time Dependency Injection With Go Cloud’s Wire - The Go Blog</a></li><li><a href="https://github.com/golang/go/wiki/CodeReviewComments#interfaces">https://github.com/golang/go/wiki/CodeReviewComments#interfaces</a></li></ol><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新</h2><p>看到这里了还不关注点赞走一波</p><ul><li><a href="https://lailin.xyz">博客</a> 可以订阅 RSS，也可以点击首页通过 webpush 订阅浏览器消息通知</li><li><a href="https://github.com/mohuishou">Github</a> Follow me</li><li><a href="https://www.zhihu.com/people/mo-hui-shou-76">知乎</a> 关注账号，顺便点个 👍</li><li><a href="https://toutiao.io/subjects/387401?f=new">开发者头条</a> 订阅订阅号，顺便点个 👍</li></ul><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week04: Go 工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go工程化(二) 项目目录结构</title>
    <link href="/post/go-training-week4-project-layout.html"/>
    <url>/post/go-training-week4-project-layout.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>工程化这一节说简单看似简单，无非就是目录结构，代码分层，依赖注入等等。但是其中很多坑如果没踩过是不知道这里面的痛点的。除此之外这里面也会有很多架构的思想在里面，这也就是为什么我会把架构整洁之道的阅读笔记放在第一小节的原因。</p><p>接来下包含这一篇文章在内，我会先用几篇文章结合参考材料以及个人的理解整理一下毛老师课上讲的内容。然后恰好在这个课程前，我也在对我们之前的一些项目做重构，所以会再用一到两篇文章大概说一些我最后选择的方式，已经在实践过程中的一些取舍，就工程化这个事情来说大概原理上基本都是相通的，但是每个团队甚至每个人所面临的一些问题都各不相同，所以最后出来的东西肯定不是完全一致的。</p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">注意，你如果是只是需要写一个脚本，或者是做一些简单的 demo 大可不必像文章接下来介绍的这样搞的这么麻烦，直接一个 main.go 简单快捷方便即可，但是如果你这是一个长期维护的项目，甚至涉及到的多个人之间的合作，那么接下来的几篇文章就不能错过了，可以仔细阅读，希望可以对你有所帮助。</div><h2 id="Standard-Go-Project-Layout"><a href="#Standard-Go-Project-Layout" class="headerlink" title="Standard Go Project Layout"></a>Standard Go Project Layout</h2><p>这一部分的内容主要来自于 github 的高星项目：<a href="https://github.com/golang-standards/project-layout/blob/master/README_zh.md">golang-standards/project-layout</a> 通过这个我们可以大概的了解到在 Go 中一些约定俗成的目录含义，虽然这些不是强制性的，但是如果有去看官方的源码或者是一些知名的项目可以发现大多都是这么命名的，所以我们最好和社区保持一致，大家保持同样的语言。</p><h3 id="cmd"><a href="#cmd" class="headerlink" title="/cmd"></a>/cmd</h3><p>我们一般采用 <code>/cmd/[appname]/main.go</code>  的形式进行组织</p><ul><li>首先 cmd 目录下一般是项目的主干目录</li><li>这个目录下的文件<strong>不应该有太多的代码，不应该包含业务逻辑</strong></li><li>main.go 当中主要做的事情就是负责程序的生命周期，服务所需资源的依赖注入等，其中依赖注入一般而言我们会使用一个依赖注入框架，这个主要看复杂程度，后续会有一篇文章单独介绍这个</li></ul><h3 id="internal"><a href="#internal" class="headerlink" title="/internal"></a>/internal</h3><p>internal 目录下的包，不允许被其他项目中进行导入，这是在 Go 1.4 当中引入的 feature，会在编译时执行</p><ul><li>所以我们一般会把项目文件夹放置到 internal 当中，例如 <code>/internal/app</code></li><li>如果是可以被其他项目导入的包我们一般会放到 pkg 目录下</li><li>如果是我们项目内部进行共享的包，而不期望外部共享，我们可以放到 <code>/internal/pkg</code>  当中</li><li>注意 internal 目录的限制并不局限于顶级目录，在任何目录当中都是生效的</li></ul><p>举个 🌰 下面的是我们当前的目录结构，其中的代码很简单，在 <code>t.go</code>  当中导出了一个变量 <code>I</code>  然后在 <code>a/cmd/a/main.go</code>  和 <code>b/cmd/b/main.go</code>  当中分别导入输出这个变量的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">❯ tree<br>.<br>├── a<br>│   ├── cmd<br>│   │   └── a<br>│   │       └── main.<span class="hljs-keyword">go</span><br>│   └── internal<br>│       └── pkg<br>│           └── t<br>│               └── t.<span class="hljs-keyword">go</span><br>└── b<br>    └── cmd<br>        └── b<br>            └── main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>我们可以发现， <code>a</code>  目录下可以直接输出 <code>I</code>  的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">❯ <span class="hljs-keyword">go</span> run ./a/cmd/a/main.<span class="hljs-keyword">go</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>但是在 <code>b</code>  目录下，编译器会直接报错说导入了 <code>a</code>  的私有包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">❯ <span class="hljs-keyword">go</span> run ./b/cmd/b/main.<span class="hljs-keyword">go</span><br><span class="hljs-keyword">package</span> command-line-arguments<br>        b/cmd/b/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">3</span>:<span class="hljs-number">8</span>: use of internal <span class="hljs-keyword">package</span> github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week04/blog/<span class="hljs-number">02</span>_project_layout/<span class="hljs-number">01</span>_internal_example/a/internal/pkg/t not allowed<br></code></pre></td></tr></table></figure><h3 id="pkg"><a href="#pkg" class="headerlink" title="/pkg"></a>/pkg</h3><p>一般而言，我们在 pkg 目录下放置可以被外部程序安全导入的包，对于不应该被外部程序依赖的包我们应该放置到 <code>internal</code>  目录下， <code>internal</code>  目录会有编译器进行强制验证</p><ul><li>pkg 目录下的包一般会按照功能进行区分，例如 <code>/pkg/cache</code> 、 <code>/pkg/conf</code>  等</li><li>如果你的目录结构比较简单，内容也比较少，其实也可以不使用 <code>pkg</code>  目录，直接把上面的这些包放在最上层即可</li><li>一般而言我们应用程序 app 在最外层会包含很多文件，例如 <code>.gitlab-ci.yml</code>  <code>makefile</code>  <code>.gitignore</code>  等等，这种时候顶层目录会很多并且会有点杂乱，建议还是放到 <code>/pkg</code>  目录比较好</li></ul><h2 id="Kit-Project-Layout"><a href="#Kit-Project-Layout" class="headerlink" title="Kit Project Layout"></a>Kit Project Layout</h2><p>kit 库其实也就是一些基础库</p><ul><li>每一个公司正常来说应该<strong>有且仅有一个基础库项目</strong></li><li>kit 库一般会包含一些常用的公共的方法，例如缓存，配置等等，比较典型的例子就是 <a href="https://github.com/go-kit/kit">go-kit</a></li><li>kit 库必须具有的特点：<ul><li>统一</li><li>标准库方式布局</li><li>高度抽象</li><li>支持插件</li><li>尽量减少依赖</li><li>持续维护</li></ul></li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">减少依赖和持续维护是我后面补充的，这一点其实很遗憾，我们部门刚进来的时候方向是对的也建立了一套基础库，然后大家都使用这同一套库，但是很遗憾，我们这一套库一是没人维护，二是没有一套机制来进行迭代，到现在很多团队和项目已经各搞各的了。<br>这样其实会导致做很多重复工作以及后续的一些改动很难推进，前车之鉴，如果有类似的情况一定要在小火苗出来的时候先摁住，从大的角度来讲统一有时候比好用重要，不好用应该参与贡献而不是另起炉灶。</div><h2 id="Service-Application-Project-Layout"><a href="#Service-Application-Project-Layout" class="headerlink" title="Service Application Project Layout"></a>Service Application Project Layout</h2><p>在这一小节我们会先看到毛老师在课上讲解的他们的应用程序目录的迭代变化，然后说一些我最后的采用的目录结构以及里面的取舍，关于具体怎么演进来的当中遇到了什么问题，我们会在 Go 工程化这个系列的最后一篇文章详细说明。</p><h3 id="api"><a href="#api" class="headerlink" title="/api"></a>/api</h3><p>API 定义的目录，如果我们采用的是 grpc 那这里面一般放的就是 proto 文件，除此之外也有可能是 openapi/swagger 定义文件，以及他们生成的文件。</p><p>下面给出一个我现在使用的 api 目录的定义，其实和毛老师课上讲的类似，后面还有一篇文章会专门讲 api 的设计会讲到这里就不详细讲了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">.<br>└── api<br>    └── product_name <span class="hljs-comment">// 产品名称</span><br>        └── app_name <span class="hljs-comment">// 应用名称</span><br>            └── v1   <span class="hljs-comment">// 版本号</span><br>                └── v1.proto<br></code></pre></td></tr></table></figure><h3 id="config-s"><a href="#config-s" class="headerlink" title="/config(s)"></a>/config(s)</h3><p>为什么加个(s) 是课上讲的还有参考材料中很多都叫 configs 但是我们习惯使用 config 但是含义上都是一样的<br>这里面一般放置配置文件文件和默认模板</p><h3 id="test"><a href="#test" class="headerlink" title="/test"></a>/test</h3><p>额外的外部测试应用程序和测试数据。一般会放测试一些辅助方法和测试数据</p><h3 id="服务类型"><a href="#服务类型" class="headerlink" title="服务类型"></a>服务类型</h3><p>微服务中的 app 服务类型分为 4 类：interface、service、job、admin。</p><ul><li>interface: 对外的 BFF 服务，接受来自用户的请求，比如暴露了 HTTP/gRPC 接口。</li><li>service: 对内的微服务，仅接受来自内部其他服务或者网关的请求，比如暴露了 gRPC 接口只对内服务。</li><li>admin：区别于 service，更多是面向运营测的服务，通常数据权限更高，隔离带来更好的代码级别安全。</li><li>job: 流式任务处理的服务，上游一般依赖 message broker。</li><li>task: 定时任务，类似 cronjob，部署到 task 托管平台中。</li></ul><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612614638378-d00b94ac-f743-414e-bca2-b9d941da7902.png" alt="image.png"><br>这上面是毛老师课上讲解的类型，和我们常用的做法类似，但是有点区别，同样假设我们有一个应用叫 <code>myapp</code></p><ul><li>myapp-api: 这个是对外暴露的 api 的服务，可以是 http, 也可以是 grpc</li><li>myapp-cron: 这个是定时任务</li><li>myapp-job: 这个用于处理来自 message 的流式任务</li><li>myapp-migration: 数据库迁移任务，用于初始化数据库</li><li>scripts/xxx: 一次性执行的脚本，有时候会有一些脚本任务</li></ul><p>大多大同小异，主要是 BFF 层我们一般是一个独立的应用，不会放在同一个仓库里面，</p><h3 id="项目布局-v1"><a href="#项目布局-v1" class="headerlink" title="项目布局 v1"></a>项目布局 v1</h3><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612615089844-dfc6a101-710e-42e4-983f-ea340676b5f4.png" alt="image.png"><br>项目的依赖路径为: model -&gt; dao -&gt; service -&gt; api，model struct 串联各个层，直到 api 需要做 DTO 对象转换。</p><ul><li>model: 放对应“存储层”的结构体，是对存储的一一隐射。</li><li>dao: 数据读写层，数据库和缓存全部在这层统一处理，包括 cache miss 处理。</li><li>service: 组合各种数据访问来构建业务逻辑。</li><li>server: 依赖 proto 定义的服务作为入参，提供快捷的启动服务全局方法。</li><li>api: 定义了 API proto 文件，和生成的 stub 代码，它生成的 interface，其实现者在 service 中。</li><li>service 的方法签名因为实现了 API 的 接口定义，DTO 直接在业务逻辑层直接使用了，更有 dao 直接使用，最简化代码。</li><li>DO(Domain Object): 领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。缺乏 DTO -&gt; DO 的对象转换。</li></ul><h4 id="v1-存在的问题"><a href="#v1-存在的问题" class="headerlink" title="v1 存在的问题"></a>v1 存在的问题</h4><ul><li>没有 DTO 对象，model 中的对象贯穿全局，所有层都有<ul><li>model 层的数据不是每个接口都需要的，这个时候会有一些问题</li><li>在上一篇文章中其实也反复提到了 “如果两段看似重复的代码，如果有不同的变更速率和原因，那么这两段代码就不算是真正的重复”</li></ul></li><li>server 层的代码可以通过基础库干掉，提供统一服务暴露方式</li></ul><h3 id="项目布局-v2"><a href="#项目布局-v2" class="headerlink" title="项目布局 v2"></a>项目布局 v2</h3><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612615164024-9156a848-53f7-4324-963a-e7e4ae110424.png" alt="image.png"></p><ul><li>app 目录下有 api、cmd、configs、internal 目录，目录里一般还会放置 README、CHANGELOG、OWNERS。</li><li><strong>internal:</strong> 是为了避免有同业务下有人跨目录引用了内部的 biz、data、service 等内部 struct。<ul><li>如果存在一个仓库多个应用，那么可以在 internal 里面进行分层，例如 <code>/internal/app</code> , <code>/internal/job</code></li><li><strong>biz</strong>: 业务逻辑的组装层，类似 DDD 的 domain 层，data 类似 DDD 的 repo，repo 接口在这里定义，使用依赖倒置的原则。</li><li><strong>data</strong>: 业务数据访问，包含 cache、db 等封装，实现了 biz 的 repo 接口。我们可能会把 data 与 dao 混淆在一起，data 偏重业务的含义，它所要做的是将领域对象重新拿出来，我们去掉了 DDD 的 infra 层。</li><li><strong>service</strong>: 实现了 api 定义的服务层，类似 DDD 的 application 层，处理 DTO 到 biz 领域实体的转换(DTO -&gt; DO)，同时协同各类 biz 交互，但是不应处理复杂逻辑。</li></ul></li><li>PO(Persistent Object): 持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么数据表中的每个字段（或若干个）就对应 PO 的一个（或若干个）属性。</li></ul><p>示例可以参考 <a href="https://github.com/go-kratos/examples/tree/main/blog">kratos v2 的 example</a></p><h3 id="我的项目布局"><a href="#我的项目布局" class="headerlink" title="我的项目布局"></a>我的项目布局</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">.<br>├── api<br>├── cmd<br>│   └── app<br>├── config<br>├── internal<br>│   ├── domain<br>│   ├── repo<br>│   ├── service<br>│   └── usecase<br>└── pkg<br></code></pre></td></tr></table></figure><p><strong>internal:</strong> 是为了避免有同业务下有人跨目录引用了内部的对象</p><ul><li>domain: 类似之前的 model 层，这里面包含了 DO 对象，usecase interface, repo interface 的定义</li><li>repo: 定于数据访问，包含 cache, db 的封装</li><li>usecase: 这里是业务逻辑的组装层，类似上面的 biz 层，但是区别是我们这里不包含 DO 对象和 repo 对象的定义</li><li>service: 实现 api 的服务层，主要实现 DTO 和 DO 对象的转化，参数的校验等等<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">我们这里的定义和上面 v2 最大的区别是多了一个 domain 层，这里面有一个原因是我们对于单元测试的要求比较高，如果按照上面 v2 的代码进行组织，service 层直接依赖 usecase 的实现，service 的代码不太好进行单元测试。如果依赖 interface 会导致循环依赖，所以采用类似 go-clean-arch 的组织，单独抽象一层 domain 层</div></li></ul><h2 id="应该避免的坏习惯"><a href="#应该避免的坏习惯" class="headerlink" title="应该避免的坏习惯"></a>应该避免的坏习惯</h2><h3 id="src"><a href="#src" class="headerlink" title="/src"></a>/src</h3><p>一般而言，在 Go 项目当中不应该出现 src 目录，Go 和 Java 不同，在 Go 中每一个目录都是一个包，每一个包都是一等公民，我们不需要将项目代码放到 src 当中，不要用写其他语言的方式来写 Go</p><h3 id="utils，common"><a href="#utils，common" class="headerlink" title="utils，common"></a>utils，common</h3><p>不要在项目中出现 utils 和 common 这种包，如果出现这种包，因为我们并不能从包中知道你这个包的作用，长久之后这个包就会变成一个大杂烩，所有东西都往这里面扔。<br>有的同学这个时候会问说，那我们的工具函数应该放到哪里？怎么放？<br>举个例子，我们当前使用 <code>gin</code>  作为路由框架，但是 <code>gin</code>  的 handler 注册其实不是很方便，所以我们做了一层封装，这个时候这个工具方法我们一般放在 <code>/pkg/ginx</code>  目录下，表示这个是对 <code>gin</code>  增强的包，不直接使用 <code>gin</code>  作为包名的原因是因为我们在项目中也会引用 <code>gin</code>  相同的命名一个是会导致误解，另一个是在同时导入的时候也会需要去进行重命名会比较麻烦</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于项目目录结构这种真的算是见仁见智，不同的理论有不同的方法，但是我觉得有两件事比较重要，就服务应用而言需要灵活应用，就基础库而言一定要统一，做的好不好和要不要做是两件事情，如果因为当前做的不够好而不做，那么越到后面就越做不了。<br>下一篇文章会讲一讲依赖注入框架 wire 的使用与最佳(?)实践</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;utm_medium=lailin.xyz">Go 进阶训练营-极客时间</a></li><li><a href="https://github.com/golang-standards/project-layout/blob/master/README_zh.md">golang-standards/project-layout · GitHub</a></li><li><a href="https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html">Package Oriented Design</a></li><li><a href="https://golang.org/doc/go1.4#internalpackages">Go 1.4 Release Notes - The Go Programming Language</a></li><li><a href="https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/">I’ll take pkg over internal</a></li><li><a href="https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1">https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week04: Go 工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go工程化(一) 架构整洁之道阅读笔记</title>
    <link href="/post/go-training-week4-clean-arch.html"/>
    <url>/post/go-training-week4-clean-arch.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><p>其实这一篇文章不应该算在这里面，（PS: 毛老师课程上没讲这本书）但是恰好最近把这本书读完了，并且部门内推荐大家读这本书，毛老师在课上也推荐这本书，也和我们这次的主题有一些关系，一切都是最好的安排，那就放这系列吧。</p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">阅读建议: 全文接近 2W 字，篇幅较长，采用书中重点摘录+不成熟的个人小结组成，桌面端可以点击右侧目录快速定位到你感兴趣的章节</div><h2 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>今天的软件与过去的软件本质上仍然是一样的。都是由 if 语句、赋值语句以及 while 循环组成的</li><li>软件架构的规则其实就是排列组合代码块的规则<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">这说明什么呢，说明了可能我们以为过时的，古老的技术或者解决方案也是有用的</div></li></ul><h3 id="第一部分-概述"><a href="#第一部分-概述" class="headerlink" title="第一部分 概述"></a>第一部分 概述</h3><h4 id="第-1-章-设计与架构究竟是什么"><a href="#第-1-章-设计与架构究竟是什么" class="headerlink" title="第 1 章 设计与架构究竟是什么"></a>第 1 章 设计与架构究竟是什么</h4><ul><li>架构图里实际上包含了所有的<strong>底层设计细节</strong>，这些细节信息共同支撑了顶层的架构设计，<strong>底层设计信息和顶层架构设计</strong>共同组成了整个房屋的架构文档。</li><li><strong>软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。</strong></li><li>一个软件架构的优劣，<strong>可以用它满足用户需求所需要的成本来衡量。</strong></li><li>乱麻系统：这种系统一般都是没有经过设计，匆匆忙忙被构建起来的<ul><li>我们经常使用一句话来欺骗自己<strong>“我们可以未来再重构代码，产品上线最重要！”</strong></li><li>另外一个错误的观点：<strong>“在工程中容忍糟糕的代码存在可以在短期内加快该工程上线的速度，未来这些代码会造成一些额外的工作量，但是并没有什么大不了”</strong></li></ul></li><li>研发团队最好的选择是清晰地认识并避开工程师们过度自信的特点，开始认真地对待自己的代码架构，对其质量负责<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">软件的架构的终极目标，以及如何衡量一个架构的优劣，尤其是两个错误的观点非常感同身受，我也说过类似的话语，还有一句话是“当前的需求非常紧急，这只是一个临时的系统很快就会被替换掉，我们先完成它”。作为一个专业的技术人员我们需要有一些底线来保证我们的代码架构和质量，不能轻易妥协，这在 Bob 大叔整洁系列的另外一本书中也有提到。</div></li></ul><h4 id="第-2-章-两个价值纬度"><a href="#第-2-章-两个价值纬度" class="headerlink" title="第 2 章 两个价值纬度"></a>第 2 章 两个价值纬度</h4><ul><li><p>行为价值</p><ul><li>软件系统的行为是其最直观的价值维度。程序员的工作就是让机器按照某种指定方式运转，给系统的使用者创造或者提高利润。</li><li>按照需求文档编写代码，并且修复任何 Bug。这真是大错特错。</li><li><strong>系统行为，是紧急的，但是并不总是特别重要。</strong><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">只有可以产生收入的代码才是有用的代码，技术是需要为业务服务的，但是我们的工作并不是说就按照需求文档写代码，修bug就行了</div></li></ul></li><li><p>架构价值</p><ul><li>为了达到软件的本来目的，软件系统必须够“软”——也就是说，软件应该容易被修改。</li><li>当需求方改变需求的时候，随之所需的软件变更必须可以简单而方便地实现。</li><li>变更实施的难度应该和变更的范畴（scope）成等比关系，而与变更的具体形状（shape）无关。</li><li><strong>系统架构，是重要的，但是并不总是特别紧急。</strong><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">架构价值主要就是为了能够应对变化，其实举个反面例子，我们之前有一个系统 A 是直接在 A 中调用接口获取数据，随着业务的发展我们拆分了一个应用 B 需要从 B 中获取对应的数据，这个时候我们发现代码变更非常严重，从里到外都需要进行重构修改，这就是典型了依赖了“具体的形状”导致的额外成本</div></li></ul></li><li><p>重要紧急的排序</p><ul><li>重要且紧急</li><li>重要不紧急</li><li>不重要但紧急</li><li>不重要且不紧急</li></ul></li><li><p>业务/市场的同事往往是无法评估架构的重要性的，所以，<strong>平衡系统架构的重要性与功能的紧急程度这件事，是软件研发人员自己的职责。</strong></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">我们当前处在公共技术的部门，这也是一个经常困扰的一个例子，所有的业务方在提需求的时候都会表示需求非常紧急，但是这个功能的实现对我们来说重要吗？这个需要打上一个大大的问号，其他部门的同学其实是无法对评估需求对于我们的重要性的，这个需要我们自己来权衡。</div></li><li><p>为好的软件架构而持续斗争</p><ul><li>软件架构师这一职责本身就应更关注系统的整体结构，而不是具体的功能和系统行为的实现。</li><li><strong>软件架构师必须创建出一个可以让功能实现起来更容易、修改起来更简单、扩展起来更轻松的软件架构。</strong></li><li>如果忽视软件架构的价值，系统将会变得越来越难以维护，终会有一天，系统将会变得再也无法修改。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">这不仅仅是架构师的职责，这是每一位开发同学的职责，忽略架构的价值会导致我们带来无休止的加班，领导的质疑，产品的argue</div></li></ul></li></ul><h3 id="第二部分-从基础构件开始：编程范式"><a href="#第二部分-从基础构件开始：编程范式" class="headerlink" title="第二部分 从基础构件开始：编程范式"></a>第二部分 从基础构件开始：编程范式</h3><p>编程范式指的是程序的编写模式，与具体的编程语言关系相对较小。这些范式会告诉你应该在什么时候采用什么样的代码结构<br>当前的三种编程范式，结构化编程，面向对象，函数式编程</p><h4 id="第-3-章-编程范式总览"><a href="#第-3-章-编程范式总览" class="headerlink" title="第 3 章 编程范式总览"></a>第 3 章 编程范式总览</h4><ul><li>结构化编程（面向过程）<ul><li>结构化编程对程序控制权的直接转移进行了限制和规范。</li><li>限制了 goto 语句的使用</li></ul></li><li>面向对象<ul><li>面向对象编程对程序控制权的间接转移进行了限制和规范。</li><li>限制了函数指针的使用</li></ul></li><li>函数式编程<ul><li>函数式编程对程序中的赋值进行了限制和规范。</li><li>限制了赋值语句的使用<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">这个角度之前还没有看到过，对我而言还是比较新奇，从限制的角度来看不同的编程范式有着不同限制，可以减少在编程当中出错的可能</div></li></ul></li></ul><h4 id="第-4-章-结构化编程"><a href="#第-4-章-结构化编程" class="headerlink" title="第 4 章 结构化编程"></a>第 4 章 结构化编程</h4><ul><li>Bohm 和 Jocopini 刚刚证明了人们可以用顺序结构、分支结构、循环结构这三种结构构造出任何程序。</li><li>证明了我们构建可推导模块所需要的控制结构集与构建所有程序所需的控制结构集的最小集是等同的。</li><li>结构化编程范式可将模块递归降解拆分为可推导的单元，这就意味着模块也可以按功能进行降解拆分。</li><li>测试只能展示 Bug 的存在，并不能证明不存在 Bug。<ul><li>换句话说，一段程序可以由一个测试来证明其错误性，但是却不能被证明是正确的。测试的作用是让我们得出某段程序已经足够实现当前目标这一结论。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">结构化编程可以让我们将一个大的模块按照功能进行拆分，变成小的功能模块，同时通过测试我们可以证明其错误性，无论是架构上还是实际的开发过程中，大模块拆小模块的思路的数不胜数，其实单体应用拆分为微服务应用也是这个范畴内的。</div></li></ul></li></ul><h4 id="第-5-章-面向对象编程"><a href="#第-5-章-面向对象编程" class="headerlink" title="第 5 章 面向对象编程"></a>第 5 章 面向对象编程</h4><ul><li>什么是面向对象？<ul><li>一种常见的回答是“数据与函数的组合”，这种不太贴切</li><li>另一种常见的回答是“面向对象编程是一种对真实世界进行建模的方式”，这有点避重就轻<ul><li>面向对象理论是在 1966 年提出的，当时 Dahl 和 Nygaard 主要是将函数调用栈迁移到了堆区域中</li></ul></li><li>面向对象编程是封装（encapsulation）、继承（inheritance）、多态（polymorphism）这三项的有机组合</li></ul></li><li>封装<ul><li>通过采用封装特性，我们可以把一组相关联的数据和函数圈起来，使圈外面的代码只能看见部分函数，数据则完全不可见</li><li>C 语言也支持完整的封装特性，使用 C 语言的时候应用头文件 <code>.h</code>  的模块是无法知道结构体中的成员变量的，但是 C++ 的头文件中包含了成员信息。</li><li>不是面向对象语言的 C 语言相对于面向对象语言 C++ 反而拥有更好的封装特性，所以<strong>我们很难说强封装是面向对象编程的必要条件</strong></li></ul></li><li>继承<ul><li>继承的主要作用是让我们可以在某个作用域内对外部定义的某一组变量与函数进行覆盖</li><li>C 其实也可以实现继承，只是相对面向对象语言而言会更加困难。</li></ul></li><li>多态<ul><li>归根结底，多态其实不过就是函数指针的一种应用。但是函数指针非常危险，需要人为的遵守很多约定，容易出 bug。</li><li>面向对象编程语言虽然在多态上并没有理论创新，但它们也确实让多态变得更安全、更便于使用了。</li></ul></li><li>依赖反转<ul><li>依赖关系（或者叫继承关系）的方向和控制流正好是相反的，我们称之为依赖反转</li><li>依赖关系都可以通过引入接口的方式来进行反转。</li><li>通过这种方法，软件架构师可以完全控制采用了面向对象这种编程方式的系统中所有的源代码依赖关系，</li><li>而不再受到系统控制流的限制。不管哪个模块调用或者被调用，软件架构师都可以随意更改源代码依赖关系。</li><li>当某个组件的源代码需要修改时，仅仅需要重新部署该组件，不需要更改其他组件，这就是独立部署能力。</li></ul></li><li><strong>面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，</strong>这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">在刚学习编程的时候，学到面向对象一定会说到，封装、继承、和多态，但是通过这一章我们可以发现，面向对象语言的封装不一定比面向过程的 C 语言做的更好，这里强调的更重要的是使用多态的手段对源码的依赖关系进行控制，主要是指通过接口来实现依赖反转，这样就可以将组件进行分离，可以进行独立开发和部署。<br>我现在主要使用的语言是 Go，有一个常见的问题就是 Go 是不是一个面向对象语言，回答也是 Yes or no，是也不是，Go 不支持继承，也不支持函数重载，运算符重载等在面向对象语言非常常见的特性，但是 Go 的接口非常强大，不需要显示依赖接口的设计让我们在依赖反转的使用上更加游刃有余。</div></li></ul><h4 id="第-6-章-函数式编程"><a href="#第-6-章-函数式编程" class="headerlink" title="第 6 章 函数式编程"></a>第 6 章 函数式编程</h4><ul><li>函数式编程语言中的变量（Variable）是不可变（Vary）的。</li><li>为什么软件架构师要操心变量的可变性呢？答案显而易见：所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的。</li><li>一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量。</li><li>事件溯源体系下，我们只存储事务记录，不存储具体状态。当需要具体状态时，我们只要从头开始计算所有的事务即可。</li><li>这种数据存储模式中不存在删除和更新的情况，我们的应用程序不是 CRUD，而是 CR。因为更新和删除这两种操作都不存在了，自然也就不存在并发问题。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">在我们刚刚结束的上一个系列，<a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Go并发编程</a>中，我们讲到的大量手段来避免数据竞争，这些都是由于在并发时写入导致的，而函数式编程最重要的一个特性就是变量不可变，由于变量无法被修改所以自然而然就不存在数据竞争，也就不需要加锁，这样可以获得很高的性能。</div></li></ul><h3 id="第三部分-设计原则"><a href="#第三部分-设计原则" class="headerlink" title="第三部分 设计原则"></a>第三部分 设计原则</h3><p>软件构建中层结构的主要目标:</p><ul><li>使软件可容忍被改动。</li><li>使软件更容易被理解。</li><li>构建可在多个软件系统中复用的组件。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">在之前的<a href="https://lailin.xyz/post/go-design-pattern.html">《Go设计模式》</a>系列文章当中也有提到 SOLID 原则，换个角度可以发现这些其实都是殊途同归的一些东西，SOLID 原则的历史已经非常悠久了，但是直到现在它仍然非常具有指导意义。</div></li></ul><h4 id="第-7-章-SRP：单一职责原则"><a href="#第-7-章-SRP：单一职责原则" class="headerlink" title="第 7 章 SRP：单一职责原则"></a>第 7 章 SRP：单一职责原则</h4><ul><li><strong>任何一个软件模块都应该有且仅有一个被修改的原因。</strong></li><li>任何一个软件模块都应该只对一个用户（User）或系统利益相关者（Stakeholder）负责。</li><li><strong>任何一个软件模块都应该只对某一类行为者负责。</strong></li><li><strong>反例: 代码合并冲突</strong><ul><li>多人为了不同的目的修改了同一份源代码，这很容易造成问题的产生。</li><li>避免这种问题产生的方法就是将服务不同行为者的代码进行切分。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">单一职责原则非常容易被误认为“每个模块应该只做一件事”，没错之前我也是这么理解的，虽然这个描述没错，但是这并不是 SRP 的全部。</div></li></ul></li></ul><h4 id="第-8-章-OCP：开闭原则"><a href="#第-8-章-OCP：开闭原则" class="headerlink" title="第 8 章 OCP：开闭原则"></a>第 8 章 OCP：开闭原则</h4><ul><li>设计良好的计算机软件应该易于扩展，同时抗拒修改。<ul><li>换句话说，<strong>一个设计良好的计算机系统应该在不需要修改的前提下就可以轻易被扩展。</strong></li></ul></li><li>一个好的软件架构设计师会努力将旧代码的修改需求量降至最小，甚至为 0。<ul><li>可以先将满足不同需求的代码分组（即 SRP），然后再来调整这些分组之间的依赖关系（即 DIP）</li></ul></li><li>如果 A 组件不想被 B 组件上发生的修改所影响，那么就应该让 B 组件依赖于 A 组件。</li><li>软件架构师可以根据相关函数被修改的原因、修改的方式及修改的时间来对其进行分组隔离，并将这些互相隔离的函数分组整理成组件结构，使得高阶组件不会因低阶组件被修改而受到影响。</li><li>OCP 是我们进行系统架构设计的主导原则，其主要目标是让系统易于扩展，同时限制其每次被修改所影响的范围。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">开闭原则在架构设计上非常常见，其中最常见的做法就是使用接口实现依赖反转，如果开闭原则实现的不好就有可能导致我们在进行后续功能扩展的时候牵一发而动全身，成本非常的高。</div></li></ul><h4 id="第-9-章-LSP：里氏替换原则"><a href="#第-9-章-LSP：里氏替换原则" class="headerlink" title="第 9 章 LSP：里氏替换原则"></a>第 9 章 LSP：里氏替换原则</h4><ul><li>如果对于每个类型是 S 的对象 o1 都存在一个类型为 T 的对象 o2，能使操作 T 类型的程序 P 在用 o2 替换 o1 时行为保持不变，我们就可以将 S 称为 T 的子类型。</li><li>比较常见的一个违反 LSP 原则的例子，长方形与正方形<ul><li>Square 类并不是 Rectangle 类的子类型，因为 Rectangle 类的高和宽可以分别修改，而 Square 类的高和宽则必须一同修改。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">这个反面例子对我的震撼比较大，依稀记得最开始在学习编程语言继承的例子的时候就常常用长方形正方形来举例，但是这个其实是违反了里式替换原则的。<br>在架构设计上这个原则也十分的重要，因为我们只有做到了 LSP 我们才可以在例如数据库类型切换，微服务拆分这种场景下做的游刃有余。</div></li></ul></li></ul><h4 id="第-10-章-ISP：接口隔离原则"><a href="#第-10-章-ISP：接口隔离原则" class="headerlink" title="第 10 章 ISP：接口隔离原则"></a>第 10 章 ISP：接口隔离原则</h4><ul><li>ISP 最初的成因：在一般情况下，任何层次的软件设计如果依赖于不需要的东西，都会是有害的。</li><li>任何层次的软件设计如果依赖了它并不需要的东西，就会带来意料之外的麻烦。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">由于 Go 接口的隐式依赖的特性，让 ISP 在 Go 中处处可见，我们常常采用的方式就是在调用者处依赖接口，而不管实现，这样就可以做到，模块分离以及最小化依赖。</div></li></ul><h4 id="第-11-章-DIP：依赖反转原则"><a href="#第-11-章-DIP：依赖反转原则" class="headerlink" title="第 11 章 DIP：依赖反转原则"></a>第 11 章 DIP：依赖反转原则</h4><ul><li>如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。</li><li>在应用 DIP 时，我们也不必考虑稳定的操作系统或者平台设施，因为这些系统接口很少会有变动。</li><li>主要应该关注的是软件系统内部那些会经常变动的（volatile）具体实现模块，这些模块是不停开发的，也就会经常出现变更。</li><li>编码规范<ul><li>应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。</li><li>不要在具体实现类上创建衍生类。我们对继承的使用应该格外小心。即使是在稍微便于修改的动态类型语言中，这条守则也应该被认真考虑</li><li>不要覆盖（override）包含具体实现的函数</li><li>应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物的名字。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">通常来说，接口会比实现更加稳定，举个反例，如果接口变动实现是必须要跟着修改的，因为实现是依赖接口的，但是反过来确未必。DIP 原则指导我们无论是在架构设计还是在编码实现当中都应该尽量的依赖抽象而不是实现细节。</div></li></ul></li></ul><h3 id="第四部分-组件构建原则"><a href="#第四部分-组件构建原则" class="headerlink" title="第四部分 组件构建原则"></a>第四部分 组件构建原则</h3><h4 id="第-12-章-组件"><a href="#第-12-章-组件" class="headerlink" title="第 12 章 组件"></a>第 12 章 组件</h4><ul><li>组件是软件的部署单元，是整个软件系统在部署过程中可以独立完成部署的最小实体<ul><li>例如：.jar, .gem, .dll 文件</li></ul></li><li>链接加载器让程序员们可以将程序切分成多个可被分别编译、加载的程序段</li><li>组件化的插件式架构已经成为我们习以为常的软件构建形式了。</li></ul><h4 id="第-13-章-组件聚合"><a href="#第-13-章-组件聚合" class="headerlink" title="第 13 章 组件聚合"></a>第 13 章 组件聚合</h4><ul><li>构建组件相关的基本原则<ul><li>REP：复用/发布等同原则</li><li>CCP：共同闭包原则</li><li>CRP：共同复用原则</li></ul></li><li>REP：复用/发布等同原则<ul><li>软件复用的最小粒度应等同于其发布的最小粒度。</li><li>REP 原则就是指组件中的类与模块必须是彼此紧密相关的</li><li>一个组件不能由一组毫无关联的类和模块组成，它们之间应该有一个共同的主题或者大方向。</li></ul></li><li>CCP：共同闭包原则<ul><li>我们应该将那些会同时修改，并且为相同目的而修改的类放到同一个组件中，而将不会同时修改，并且不会为了相同目的而修改的那些类放到不同的组件中。</li></ul></li><li>CRP：共同复用原则<ul><li>不要强迫一个组件的用户依赖他们不需要的东西。</li><li>不要依赖不需要用到的东西。</li></ul></li><li>组件张力图</li></ul><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1611759265457-d9a543c3-8c0c-45e2-9f4f-071352f100a1.png" alt="image.png"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">看到这三个原则会感到有点熟悉，像共同闭包原则就和 SOLID 中的单一职责原则类似，共同复用原则和接口隔离原则看上去也有那么几分相似，这些知识从不同的角度看待总结问题的不同术语。<br>最后这个组件张力图很有意思，这说明我们在进行架构设计的时候是不可能做到每一项都很完美的，这当中会有一个取舍的过程，书中讲到，一般而言会项目初期会从三角右侧开始，进行一段时间后会滑动到左边，是因为在初期为了效率我们可以牺牲一定的复用性，但是随着依赖关系越来越复杂，那么我们就要考虑复用和扩展了。</div><h4 id="第-14-章-组件耦合"><a href="#第-14-章-组件耦合" class="headerlink" title="第 14 章 组件耦合"></a>第 14 章 组件耦合</h4><ul><li>组件依赖关系图中不应该出现环。</li><li>当组件结构依赖图中存在循环依赖时，想要按正确的顺序构建组件几乎是不可能的。</li><li>打破循环依赖<ul><li>应用依赖反转原则（DIP）</li><li>创建一个新的组件，并让 Entities 与 Authorize 这两个组件都依赖于它。将现有的这两个组件中互相依赖的类全部放入新组件</li></ul></li><li>组件结构图是不可能自上而下被设计出来的。它必须随着软件系统的变化而变化和扩张，而不可能在系统构建的最初就被完美设计出来。</li><li>组件依赖结构图并不是用来描述应用程序功能的，它更像是应用程序在构建性与维护性方面的一张地图</li><li>组件结构图中的一个重要目标是指导如何隔离频繁的变更</li><li><p>如果我们在设计具体类之前就来设计组件依赖关系，那么几乎是必然要失败的。因为在当下，我们对项目中的共同闭包一无所知，也不可能知道哪些组件可以复用，这样几乎一定会创造出循环依赖的组件。</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">在 Go 中在编译器上就限制了我们不能出现循环依赖，所以我们大量的使用了 DIP 的方式，但是讲层次拔高一点，从微服务的角度来讲仍然不应该出现循环依赖，如果出现那么在版本发布的时候可能会导致灾难性的后果，架构的原则都是想通的，我们要时刻警惕循环依赖的出现，对于微服务来说可以在 api 网关进行判定是否成环</div></li><li><p>稳定依赖原则</p><ul><li>依赖关系必须要指向更稳定的方向</li><li>任何一个我们预期会经常变更的组件都不应该被一个难于修改的组件所依赖，否则这个多变的组件也将会变得非常难以被修改</li><li>让软件组件难于修改的一个最直接的办法就是让很多其他组件依赖于它。</li></ul></li><li><p>稳定性指标</p><ul><li>其中一种方法是计算所有入和出的依赖关系。通过这种方法，我们就可以计算出一个组件的位置稳定性（positionalstability）。<ul><li>Fan-in：入向依赖，这个指标指代了组件外部类依赖于组件内部类的数量。</li><li>Fan-out：出向依赖，这个指标指代了组件内部类依赖于组件外部类的数量。</li><li>I：不稳定性，I=Fan-out/（Fan-in+Fan-out）。该指标的范围是[0,1],I=0 意味着组件是最稳定的，I=1 意味着组件是最不稳定的。</li></ul></li><li>稳定依赖原则（SDP）的要求是让每个组件的 I 指标都必须大于其所依赖组件的 I 指标。也就是说，组件结构依赖图中各组件的 I 指标必须要按其依赖关系方向递减。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">这一部分提出了一个对我现阶段非常有用的一个原则，被大量依赖的组件应该是稳定的，依赖关系必须要指向更稳定的方向，我当前处在公共技术团队，我们的服务被外部大量的依赖，所以在变更的时候会非常的麻烦，我们 I 值非常的小，几乎可以说接近于 0，所以我们的服务在设计时一定要满足开闭原则，保证足够的扩展性。</div></li></ul></li><li><p>稳定抽象原则</p><ul><li>一个组件的抽象化程度应该与其稳定性保持一致。</li><li>如何才能让一个无限稳定的组件（I=0）接受变更呢？开闭原则（OCP）为我们提供了答案。这个原则告诉我们：创造一个足够灵活、能够被扩展，而且不需要修改的类是可能的，而这正是我们所需</li><li>假设 A 指标是对组件抽象化程度的一个衡量，它的值是组件中抽象类与接口所占的比例。那么：<ul><li>Nc：组件中类的数量。</li><li>Na：组件中抽象类和接口的数量。</li><li>A：抽象程度，A=Na÷Nc</li><li>A 指标的取值范围是从 0 到 1，值为 0 代表组件中没有任何抽象类，值为 1 就意味着组件中只有抽象类。</li></ul></li><li><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1611759933727-6f8124f5-4d50-4c18-8b73-4d79c88e6f1b.png" alt="image.png"><ul><li>只有多变的软件组件落在痛苦区中才会造成麻烦</li><li>现在我们来看看靠近（1,1）这一位置点的组件。该位置上的组件不会是我们想要的，因为这些组件通常是无限抽象的，但是没有被其他组件依赖，这样的组件往往无法使用。</li><li>追求让这些组件位于主序列线上，或者贴近这条线即可。</li></ul></li><li>D 指标[8]：距离 D=|A+I-1|，该指标的取值范围是[0,1]。值为 0 意味着组件是直接位于主序列线上的，值为 1 则意味着组件在距离主序列最远的位置。</li><li>对于一个良好的系统设计来说，D 指标的平均值和方差都应该接近于 0<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">稳定抽象原则说明了越稳定的组件应该越抽象，从代码的角度来讲，接口是最抽象的组件之一，因为接口一般不会有其他外部的依赖，而被大量依赖，同时还给出一个统计抽象程度的方法，这个可以用来统计一下我们现在的现状。</div></li></ul></li></ul><h3 id="第五部分-软件架构"><a href="#第五部分-软件架构" class="headerlink" title="第五部分 软件架构"></a>第五部分 软件架构</h3><h4 id="第-15-章-什么是软件架构"><a href="#第-15-章-什么是软件架构" class="headerlink" title="第 15 章 什么是软件架构"></a>第 15 章 什么是软件架构</h4><ul><li>软件架构师自身需要是程序员，并且必须一直坚持做一线程序员，绝对不要听从那些说应该让软件架构师从代码中解放出来以专心解决高阶问题的伪建议</li><li><p>如果不亲身承受因系统设计而带来的麻烦，就体会不到设计不佳所带来的痛苦，接着就会逐渐迷失正确的设计方向。</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">这个也是常常会遇到的问题，就现在我能观察到的为例，架构师级别的基本上没有看到过再做一线的程序开发工作，仅仅是平时的各种管理，规划上的事务就已经忙的不可开交，这其实不仅仅导致了架构师本身会脱节，同时也会导致下面的同学很少有机会学习到架构师们过往的经验。</div></li><li><p>软件架构这项工作的实质就是规划如何将系统切分成组件，并安排好组件之间的排列关系，以及组件之间互相通信的方式。</p></li><li>设计软件架构的目的，就是为了在工作中更好地对这些组件进行研发、部署、运行以及维护。</li><li>如果想设计一个便于推进各项工作的系统，其策略就是要在设计中尽可能长时间地保留尽可能多的可选项。</li><li>设计良好的架构可以让系统便于理解、易于修改、方便维护，并且能轻松部署。<strong>软件架构的终极目标就是最大化程序员的生产力，同时最小化系统的总运营成本。</strong></li><li>开发<ul><li>实现一键式的轻松部署应该是我们设计软件架构的一个目标</li></ul></li><li><p>运行</p><ul><li>几乎任何运行问题都可以通过增加硬件的方式来解决，这避免了软件架构的重新设计</li><li>基于投入/产出比的考虑，我们的优化重心应该更倾向于系统的开发、部署以及维护</li><li>一个设计良好的软件架构应该能明确地反映该系统在运行时的需求。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">人力成本往往会比机器的成本更高，所以这也就是我们在代码编写的过程当中对可读性和性能需要有一个权衡，如果不是差异过大往往代码的可读性需要更为重要</div></li></ul></li><li><p>维护</p><ul><li>在软件系统的所有方面中，维护所需的成本是最高的</li></ul></li><li>保持可选项<ul><li>软件有行为价值与架构价值两种价值。这其中的第二种价值又比第一种更重要</li><li>软件的灵活性则取决于系统的整体状况、组件的布置以及组件之间的连接方式。<ul><li>软件的高层策略不应该关心其底层到底使用哪一种数据库</li><li>开发的早期阶段也不应该选定使用的 Web 服务</li><li>软件的高层策略压根不应该跟这些有关。</li><li>在开发的早期阶段不应过早地采用依赖注入框架</li></ul></li><li>如果在开发高层策略时有意地让自己摆脱具体细节的纠缠，我们就可以将与具体实现相关的细节决策推迟或延后，因为越到项目的后期，我们就拥有越多的信息来做出合理的决策。</li><li>一个优秀的软件架构师应该致力于最大化可选项数量</li></ul></li><li><strong>优秀的架构师会小心地将软件的高层策略与其底层实现隔离开，让高层策略与实现细节脱钩，使其策略部分完全不需要关心底层细节，当然也不会对这些细节有任何形式的依赖。</strong>另外，<strong>优秀的架构师所设计的策略应该允许系统尽可能地推迟与实现细节相关的决策，越晚做决策越好</strong><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">这一点其实很容易被忽略掉，因为我们经常做的工作就是细节性的工作，在进行设计的时候很容易就不自觉的假定 Web UI，MySQL 数据库这些技术选型，在这本书的最后一个章节还会讲到，这些细节。</div></li></ul><h4 id="第-16-章-独立性"><a href="#第-16-章-独立性" class="headerlink" title="第 16 章 独立性"></a>第 16 章 独立性</h4><ul><li>用例<ul><li>软件的架构必须为其用例提供支持。</li></ul></li><li>任何一个组织在设计系统时，往往都会复制出一个与该组织内沟通结构相同的系统。</li><li>一个设计良好的架构通常不会依赖于成堆的脚本与配置文件，也不需要用户手动创建一堆“有严格要求”的目录与文件</li><li>如果我们按照变更原因的不同对系统进行解耦，就可以持续地向系统内添加新的用例，而不会影响旧有的用例。如果我们同时对支持这些用例的 UI 和数据库也进行了分组，那么每个用例使用的就是不同面向的 UI 与数据库，因此增加新用例就更不太可能会影响旧有的用例了。</li><li>如果有两段看起来重复的代码，它们走的是不同的演进路径，也就是说它们有着不同的变更速率和变更缘由，那么这两段代码就不是真正的重复</li><li>解耦模式<ul><li>源码层次：我们可以控制源代码模块之间的依赖关系，以此来实现一个模块的变更不会导致其他模块也需要变更或重新编译</li><li>部署层次：我们可以控制部署单元（譬如 jar 文件、DLL、共享库等）之间的依赖关系，以此来实现一个模块的变更不会导致其他模块的重新构建和部署。</li><li>服务层次：我们可以将组件间的依赖关系降低到数据结构级别，然后仅通过网络数据包来进行通信。</li><li>一个设计良好的架构应该能允许一个系统从单体结构开始，以单一文件的形式部署，然后逐渐成长为一组相互独立的可部署单元，甚至是独立的服务或者微服务。最后还能随着情况的变化，允许系统逐渐回退到单体结构<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“如果两段看似重复的代码，如果有不同的变更速率和原因，那么这两段代码就不算是真正的重复”这有个非常典型的例子就是 API 接口的参数和最后我们模型数据虽然很多时候大部分字段是相同的，但是它们的变更速率和原因其实都是不一样的，如果把他们耦合在一起虽然前期可能可以减少一些代码的编写，但是到最后需要扩展时会发现变更会很困难。之前我还写了一篇文章 《<a href="https://lailin.xyz/post/11996.html#2-%E7%94%A8-model-%E5%B1%82%E7%9A%84-struct-%E7%BB%91%E5%AE%9A%E5%8F%82%E6%95%B0">Go Web 小技巧（三）Gin 参数绑定 </a>》总结这种埋坑的技巧 😂</div></li></ul></li></ul><h4 id="第-17-章-划分边界"><a href="#第-17-章-划分边界" class="headerlink" title="第 17 章 划分边界"></a>第 17 章 划分边界</h4><ul><li>软件架构设计本身就是一门划分边界的艺术。</li><li>通过划清边界，我们可以推迟和延后一些细节性的决策，这最终会为我们节省大量的时间、避免大量的问题。</li><li>I/O 是无关紧要的</li><li>GUI 和 BusinessRules 这两个组件之间也应该有一条边界线</li><li>插件式架构的好处<ul><li><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1611763160147-6a16b0e6-d3de-43d2-8bf3-b1bf597dd0ed.png" alt="image.png"></li><li>将系统设计为插件式架构，就等于构建起了一面变更无法逾越的防火墙。换句话说，只要 GUI 是以插件形式插入系统的业务逻辑中的，那么 GUI 这边所发生的变更就不会影响系统的业务逻辑。</li><li>边界线也应该沿着系统的变更轴来画。也就是说，位于边界线两侧的组件应该以不同原因、不同速率变化着。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">真正核心的是我们业务逻辑，而输入输出是细节</div></li></ul></li></ul><h4 id="第-18-章-边界剖析"><a href="#第-18-章-边界剖析" class="headerlink" title="第 18 章 边界剖析"></a>第 18 章 边界剖析</h4><ul><li>跨边界调用指的是边界线一侧的函数调用另一侧的函数，并同时传递数据的行为</li><li>最简单的跨边界调用形式，是由低层客户端来调用高层服务函数，这种依赖关系在运行时和编译时会保持指向一致，都是从低层组件指向高层组件</li><li>在单体结构中，组件之间的交互一般情况下都只是普通的函数调用，迅速而廉价，这就意味着这种跨源码层次解耦边界的通信会很频繁</li><li>服务之间的跨边界通信相对于函数调用来说，速度是非常缓慢的，其往返时间可以从几十毫秒到几秒不等。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">不同的边界的跨边界调用的成本是不同的，对于服务而言跨服务调用的成本非常高，这样我们在进行服务划分的时候一定要尽量的内聚减少频繁调用的情况。</div></li></ul><h4 id="第-19-章-策略与层次"><a href="#第-19-章-策略与层次" class="headerlink" title="第 19 章 策略与层次"></a>第 19 章 策略与层次</h4><ul><li>策略<ul><li>本质上，所有的软件系统都是一组策略语句的集合</li><li>变更原因、时间和层次相同的策略应该被分到同一个组件中。反之，变更原因、时间和层次不同的策略则应该分属于不同的组件</li><li>依赖关系的方向通常取决于它们所关联的组件层次。一般来说，低层组件被设计为依赖于高层组件</li></ul></li><li>层次<ul><li>一条策略距离系统的输入/输出越远，它所属的层次就越高。而直接管理输入/输出的策略在系统中的层次是最低的。</li><li>数据流向和源码中的依赖关系并不总处于同一方向上</li><li>我们希望源码中的依赖关系与其数据流向脱钩，而与组件所在的层次挂钩。</li><li>低层组件应该成为高层组件的插件<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">距离 I/O 越远的策略层次越高，也就是说我们常见的 Web UI 应该属于最低层次，我们不应该依赖 Web UI 这种输入输出设备。同时给出了组件的划分原则，变更的时间原因和层次相同的属于同一个组件。</div></li></ul></li></ul><h4 id="第-20-章-业务逻辑"><a href="#第-20-章-业务逻辑" class="headerlink" title="第 20 章 业务逻辑"></a>第 20 章 业务逻辑</h4><ul><li>业务逻辑就是程序中那些真正用于赚钱或省钱的业务逻辑与过程</li><li>“关键业务逻辑”是一项业务的关键部分，不管有没有自动化系统来执行这项业务，这一点是不会改变的。</li><li>业务实体<ul><li>业务实体这个概念中应该只有业务逻辑，没有别的。</li><li>业务实体这个概念只要求我们将关键业务数据和关键业务逻辑绑定在一个独立的软件模块内。</li><li>业务实体不一定是类</li></ul></li><li><p>用例（usecase）</p><ul><li>用例本质上就是关于如何操作一个自动化系统的描述，它定义了用户需要提供的输入数据、用户应该得到的输出信息以及产生输出所应该采取的处理步骤。</li><li>用例中包含了对如何调用业务实体中的关键业务逻辑的定义。简而言之，用例控制着业务实体之间的交互方式。</li><li>用例除非正式地描述了数据流入/流出接口以外，并不详细描述用户界面。</li><li>用例并不描述系统与用户之间的接口，它只描述该应用在某些特定情景下的业务逻辑，这些业务逻辑所规范的是用户与业务实体之间的交互方式，它与数据流入/流出系统的方式无关。</li><li>业务实体并不会知道是哪个业务用例在控制它们，这也是依赖反转原则（DIP）的另一个应用情景</li><li>为什么业务实体属于高层概念，而用例属于低层概念呢？因为用例描述的是一个特定的应用情景，这样一来，用例必然会更靠近系统的输入和输出。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">用例和业务实体应该是应用当中最重要的，所以我们的单元测试最低的要求就是要覆盖所有的 usecase 逻辑，这一部分应该保持纯净不依赖数据库，Web 等 I/O 方式</div></li></ul></li><li><p>选择直接在数据结构中使用对业务实体对象的引用。毕竟，业务实体与请求/响应模型之间有很多相同的数据。但请一定不要这样做！这两个对象存在的意义是非常、非常不一样的。随着时间的推移，这两个对象会以不同的原因、不同的速率发生变更。</p></li><li>这些业务逻辑应该保持纯净，不要掺杂用户界面或者所使用的数据库相关的东西。在理想情况下，这部分代表业务逻辑的代码应该是整个系统的核心，其他低层概念的实现应该以插件形式接入系统中。业务逻辑应该是系统中最独立、复用性最高的代码。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">再次强调了不要偷懒，今天刚好看到之前写的一个反面例子的代码，代码里面有一个 GetA 函数，从数据库当中获取A对象数据和一些统计数据，这个函数中的统计数据部分其实只有在一个 Web 页面的接口中使用到，但是为了偷懒，在其他地方查询的时候也调用了这个函数，导致最后很多地方的接口性能都由于这个没用的统计数据多耗费了将近 1s 的时间。</div></li></ul><h4 id="第-21-章-尖叫的软件架构"><a href="#第-21-章-尖叫的软件架构" class="headerlink" title="第 21 章 尖叫的软件架构"></a>第 21 章 尖叫的软件架构</h4><ul><li>架构设计的主题<ul><li>软件的系统架构应该为该系统的用例提供支持。这就像住宅和图书馆的建筑计划满篇都在非常明显地凸显这些建筑的用例一样，软件系统的架构设计图也应该非常明确地凸显该应用程序会有哪些用例</li></ul></li><li>架构设计的核心目标<ul><li>一个良好的架构设计应该围绕着用例来展开，这样的架构设计可以在脱离框架、工具以及使用环境的情况下完整地描述用例</li><li>良好的架构设计应该尽可能地允许用户推迟和延后决定采用什么框架、数据库、Web 服务以及其他与环境相关的工具</li><li>良好的架构设计应该只关注用例，并能将它们与其他的周边因素隔离。</li></ul></li><li>可测试的架构设计<ul><li>我们在运行测试的时候不应该运行 Web 服务，也不应该需要连接数据库。我们测试的应该只是一个简单的业务实体对象，没有任何与框架、数据库相关的依赖关系。</li></ul></li><li>一个系统的架构应该着重于展示系统本身的设计，而并非该系统所使用的框架<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">用例是架构设计当中最应该关注的部分，框架数据库Web服务的选择都是细节，这些细节应该延后选择，我们的用例不应该依赖这些细节，这样才能很好的测试</div></li></ul><h4 id="第-22-章-整洁架构"><a href="#第-22-章-整洁架构" class="headerlink" title="第 22 章 整洁架构"></a>第 22 章 整洁架构</h4><ul><li>按照不同关注点对软件进行切割。也就是说，这些架构都会将软件切割成不同的层，至少有一层是只包含该软件的业务逻辑的，而用户接口、系统接口则属于其他层。</li><li>特点<ul><li>独立于框架：这些系统的架构并不依赖某个功能丰富的框架之中的某个函数。</li><li>可被测试：这些系统的业务逻辑可以脱离 UI、数据库、Web 服务以及其他的外部元素来进行测试。</li><li>独立于 UI：这些系统的 UI 变更起来很容易，不需要修改其他的系统部分。</li><li>独立于数据库：我们可以轻易将这些系统使用的</li><li>独立于任何外部机构：这些系统的业务逻辑并不需要知道任何其他外部接口的存在。</li></ul></li></ul><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1611803924995-df9764d2-32c6-407b-b1e3-224c0feef3b1.png" alt="image.png"></p><ul><li>依赖关系规则<ul><li>外层圆代表的是机制，内层圆代表的是策略。</li><li>源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。</li><li>外层圆中使用的数据格式也不应该被内层圆中的代码所使用，尤其是当数据格式是由外层圆的框架所生成时。</li></ul></li><li>业务实体<ul><li>业务实体这一层中封装的是整个系统的关键业务逻辑，一个业务实体既可以是一个带有方法的对象，也可以是一组数据结构和函数的集合。</li></ul></li><li>用例<ul><li>软件的用例层中通常包含的是特定应用场景下的业务逻辑，这里面封装并实现了整个系统的所有用例。这些用例引导了数据在业务实体之间的流入/流出，并指挥着业务实体利用其中的关键业务逻辑来实现用例的设计目标。</li></ul></li><li>接口适配器<ul><li>软件的接口适配器层中通常是一组数据转换器，它们负责将数据从对用例和业务实体而言最方便操作的格式，转化成外部系统（譬如数据库以及 Web）最方便操作的格式。</li></ul></li><li>层次越往内，其抽象和策略的层次越高，同时软件的抽象程度就越高，其包含的高层策略就越多。最内层的圆中包含的是最通用、最高层的策略，最外层的圆包含的是最具体的实现细节。</li><li>这里最重要的是这个跨边界传输的对象应该有一个独立、简单的数据结构。</li><li><strong>不要投机取巧地直接传递业务实体或数据库记录对象。</strong><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">看过前面的部分再来看整洁架构这一章节会发现非常的自然</div></li></ul><h4 id="第-23-章-展示器和谦卑对象"><a href="#第-23-章-展示器和谦卑对象" class="headerlink" title="第 23 章 展示器和谦卑对象"></a>第 23 章 展示器和谦卑对象</h4><ul><li>谦卑对象模式<ul><li>谦卑对象模式最初的设计目的是帮助单元测试的编写者区分容易测试的行为与难以测试的行为，并将它们隔离。</li></ul></li><li>展示器与视图<ul><li>视图部分属于难以测试的谦卑对象。这种对象的代码通常应该越简单越好，它只应负责将数据填充到 GUI 上，而不应该对数据进行任何处理。</li><li>展示器则是可测试的对象。展示器的工作是负责从应用程序中接收数据，然后按视图的需要将这些数据格式化，以便视图将其呈现在屏幕上。</li><li>展示器则是可测试的对象。展示器的工作是负责从应用程序中接收数据，然后按视图的需要将这些数据格式化，以便视图将其呈现在屏幕上。</li><li>视图部分除了加载视图模型所需要的值，不应该再做任何其他事情。因此，我们才能说视图是谦卑对象</li></ul></li><li>数据库网关<ul><li>这些实现也应该都属于谦卑对象，它们应该只利用 SQL 或其他数据库提供的接口来访问所需要的数据。</li><li>交互器尽管不属于谦卑对象，却是可测试的，</li></ul></li><li>数据映射器（ORM）<ul><li>这样的 ORM 系统应该属于系统架构中的哪一层呢？当然是数据库层。ORM 其实就是在数据库和数据库网关接口之间构建了另一种谦卑对象的边界。</li></ul></li><li>因为跨边界的通信肯定需要用到某种简单的数据结构，而边界会自然而然地将系统分割成难以测试的部分与容易测试的部分，所以通过在系统的边界处运用谦卑对象模式，我们可以大幅地提高整个系统的可测试性。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">这里主要是将很难进行单元测试的行为和容易测试的行为进行分离，很难被测试的行为常常会被分离成为一个谦卑对象，这个对象非常的简单，不会包含很多逻辑</div></li></ul><h4 id="第-24-章-不完全边界"><a href="#第-24-章-不完全边界" class="headerlink" title="第 24 章 不完全边界"></a>第 24 章 不完全边界</h4><ul><li>构建不完全边界的方式<ul><li>构建不完全边界的一种方式就是在将系统分割成一系列可以独立编译、独立部署的组件之后，再把它们构建成一个组件。</li><li>单向边界</li><li>门户模式<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">架构是需要取舍的，我们不可能每一项都做的很完美，边界的划分也是这样，所以就有了不完全的边界</div></li></ul></li></ul><h4 id="第-25-章-层次与边界"><a href="#第-25-章-层次与边界" class="headerlink" title="第 25 章 层次与边界"></a>第 25 章 层次与边界</h4><ul><li><strong>过度的工程设计往往比工程设计不足还要糟糕</strong></li><li>现实就是这样。作为软件架构师，我们必须有一点未卜先知的能力。有时候要依靠猜测——当然还要用点脑子。软件架构师必须仔细权衡成本，决定哪里需要设计架构边界，以及这些地方需要的是完整的边界，还是不完全的边界，还是可以忽略的边界</li><li>架构师必须持续观察系统的演进，时刻注意哪里可能需要设计边界，然后仔细观察这些地方会由于不存在边界而出现哪些问题。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">不要过度优化，但是也不要什么都不管的一把梭，架构师需要演进和取舍的，没有完美的架构只有不断持续演进优化的架构。</div></li></ul><h4 id="第-26-章-Main-组件"><a href="#第-26-章-Main-组件" class="headerlink" title="第 26 章 Main 组件"></a>第 26 章 Main 组件</h4><ul><li>Main 是最细节化的部分</li><li>Main 组件的任务是创建所有的工厂类、策略类以及其他的全局设施，并最终将系统的控制权转交给最高抽象层的代码来处理。</li><li>Main 组件中的依赖关系通常应该由依赖注入框架来注入。</li><li>我们在这里的重点是要说明 Main 组件是整个系统中的一个底层模块，它处于整洁架构的最外圈，主要负责为系统加载所有必要的信息，然后再将控制权转交回系统的高层组件。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">main 是一个程序的入口，这是最细节的部分，因为之前为了很多东西不被依赖，我们一般会采用接口来实现依赖反转，这时候就会导致我们所有的依赖关系的构建都需要在 main 中进行完成，所以一般而言我们会在 main 中引入依赖注入框架。</div></li></ul><h4 id="第-27-章-服务：宏观与微观"><a href="#第-27-章-服务：宏观与微观" class="headerlink" title="第 27 章 服务：宏观与微观"></a>第 27 章 服务：宏观与微观</h4><ul><li>所谓的服务本身只是一种比函数调用方式成本稍高的，分割应用程序行为的一种形式，与系统架构无关。</li><li>服务所带来的好处？<ul><li>解耦合的谬论</li><li>独立开发部署的谬论</li><li>这种理念有一些道理——但也仅仅是一些而已。首先，<strong>无数历史事实证明，大型系统一样可以采用单体模式，或者组件模式来构建，不一定非得服务化。</strong>因此服务化并不是构建大型系统的唯一选择。</li></ul></li><li>横跨型变更（cross-cutting concern）问题，它是所有的软件系统都要面对的问题，无论服务化还是非服务化的。</li><li>服务也可以按照 SOLID 原则来设计，按照组件结构来部署，这样就可以做到在添加/删除组件时不影响服务中的其他组件。</li><li>系统的架构边界事实上并不落在服务之间，而是穿透所有服务，在服务内部以组件的形式存在</li><li><strong>服务边界并不能代表系统的架构边界，服务内部的组件边界才是。</strong></li><li>系统的架构是由系统内部的架构边界，以及边界之间的依赖关系所定义的，与系统中各组件之间的调用和通信方式无关。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">虽然现在微服务架构非常火热，基本上所有的服务都是拆分了服务，但是拆分了服务并不一定表示就解耦合了，也并不一定就真的能独立部署，想一想这是现在很常见的，一个应用必须要和另外一个应用一同上线，根本做不了独立部署。</div></li></ul><h4 id="第-28-章-测试边界"><a href="#第-28-章-测试边界" class="headerlink" title="第 28 章 测试边界"></a>第 28 章 测试边界</h4><ul><li>可测试性设计</li><li>如果测试代码与系统是强耦合的，它就得随着系统变更而变更。哪怕只是系统中组件的一点小变化，都可能会导致许多与之相耦合的测试出现问题，需要做出相应的变更。</li><li>软件设计的第一条原则——不管是为了可测试性还是其他什么东西——是不变的，就是不要依赖于多变的东西。</li><li>没有按系统组成部分来设计的测试代码，往往是非常脆弱且难以维护的。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">不变的组件不要依赖多变的东西，这样会导致非常难以测试</div></li></ul><h4 id="第-29-章-整洁的嵌入式架构"><a href="#第-29-章-整洁的嵌入式架构" class="headerlink" title="第 29 章 整洁的嵌入式架构"></a>第 29 章 整洁的嵌入式架构</h4><ul><li>虽然软件本身并不会随时间推移而磨损，但硬件及其固件却会随时间推移而过时，随即也需要对软件做相应改动</li><li>虽然软件质量本身并不会随时间推移而损耗，但是未妥善管理的硬件依赖和固件依赖却是软件的头号杀手。</li><li>但如果你在代码中嵌入了 SQL 或者是代码中引入了对某个平台的依赖的话，其实就是在写固件代码。</li><li>软件构建过程中的三个阶段<ul><li>“先让代码工作起来”——如果代码不能工作，就不能产生价值。</li><li>“然后再试图将它变好”——通过对代码进行重构，让我们自己和其他人更好地理解代码，并能按照需求不断地修改代码</li><li>“最后再试着让它运行得更快”——按照性能提升的“需求”来重构代码。</li></ul></li><li>整洁的嵌入式架构就是可测试的嵌入式架构</li><li>软件与固件集成在一起也属于设计上的反模式（anti-pattern）<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">软件并不会随着时间磨损但是硬件是会过时的，而且换的还非常频繁，这时候我们就必须要把硬件以及固件代码给隔离起来，对了不要认为我们不做嵌入式开发平时就很少接触到这个，SQL 语句其实也是一种固件代码</div></li></ul><h3 id="第六部门-实现细节"><a href="#第六部门-实现细节" class="headerlink" title="第六部门 实现细节"></a>第六部门 实现细节</h3><h4 id="第-30-章-数据库只是实现细节"><a href="#第-30-章-数据库只是实现细节" class="headerlink" title="第 30 章 数据库只是实现细节"></a>第 30 章 数据库只是实现细节</h4><ul><li>就数据库与整个系统架构的关系打个比方，它们之间就好比是门把手和整个房屋架构的关系</li><li>但当问题涉及数据存储时，这方面的操作通常是被封装起来，隔离在业务逻辑之外的</li><li>数据本身很重要，但数据库系统仅仅是一个实现细节。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">数据很重要，但是数据库系统是一个细节，书上这一章用了一个例子说明有时候可能真的用不到数据库。换个常见的例子，我们可能系统刚开始的时候使用 SQlite 就可以，随着业务发展用上了 MySQL，然后随着并发的提高又会引入缓存组件，这些变化其实和业务逻辑都没有关系，数据库的变化是不应该影响到业务逻辑的</div></li></ul><h4 id="第-31-章-Web-是实现细节"><a href="#第-31-章-Web-是实现细节" class="headerlink" title="第 31 章 Web 是实现细节"></a>第 31 章 Web 是实现细节</h4><ul><li>GUI 只是一个实现细节。而 Web 则是 GUI 的一种，所以也是一个实现细节。作为一名软件架构师，我们需要将这类细节与核心业务逻辑隔离开来。</li></ul><h4 id="第-32-章-应用程序框架是实现细节"><a href="#第-32-章-应用程序框架是实现细节" class="headerlink" title="第 32 章 应用程序框架是实现细节"></a>第 32 章 应用程序框架是实现细节</h4><ul><li>我们可以使用框架——但要时刻警惕，别被它拖住</li><li>毕竟 Main 组件作为系统架构中最低层、依赖最多的组件，它依赖于 Spring 并不是问题。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">框架的选择要慎重，我们业务逻辑本身不能依赖框架</div></li></ul><h4 id="第-33-章-案例分析：视频销售网站"><a href="#第-33-章-案例分析：视频销售网站" class="headerlink" title="第 33 章 案例分析：视频销售网站"></a>第 33 章 案例分析：视频销售网站</h4><ul><li>系统架构设计中的第一步，是识别系统中的各种角色和用例<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">这一步看起来简单，但是非常考验一个人的功力</div></li></ul><h4 id="第-34-章-拾遗"><a href="#第-34-章-拾遗" class="headerlink" title="第 34 章 拾遗"></a>第 34 章 拾遗</h4><ul><li>分层架构无法展现具体的业务领域信息。把两个不同业务领域的、但是都采用了分层架构的代码进行对比，你会发现它们的相似程度极高</li><li>宽松的分层架构，允许某些层跳过直接相邻的邻居。</li><li>一个架构设计原则——内容是“Web 控制器永远不应该直接访问数据层”。</li><li>系统由一个或者多个容器组成（例如 Web 应用、移动 App、独立应用、数据库、文件系统），每个容器包含一个或多个组件，每个组件由一个或多个类组成。</li><li>如果不考虑具体实现细节，再好的设计也无法长久。必须要将设计映射到对应的代码结构上，考虑如何组织代码树，以及在编译期和运行期采用哪种解耦合的模式。</li><li>最好能利用编译器来维护所选的系统架构设计风格，小心防范来自其他地方的耦合模式，例如数据结构</li></ul><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1611842328934-ca4190d2-94c9-415a-befe-bcaebcd1aa4f.png" alt="image.png"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">这一章对比了四种架构风格，同时提出了，架构设计是需要考虑实现细节的，设计需要映射到代码结构和代码树上，这个其实和最开始的“软件架构师自身需要是程序员，并且必须一直坚持做一线程序员”交相呼应。<br>如果可以在编译时解决的问题，就不要放到运行时，编译的问题往往要比运行时的问题好解决，这也是为什么 Go 的依赖注入框架我更加推荐 wire 的原因，同理作者提出了 如果要防止直接中 web控制器调用数据层，那么我们就不应该将数据层（repo）暴露出来，只需要暴露 usecase 就好了。</div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前其实也大概了解过整洁架构，从最开始觉得它又臭又长，到现在工作两三年后觉得“不听老人言，吃亏在眼前”，当我们在对一个架构或者是事务进行批判的时候一定要了解它面对的场景以及它的理念，这是最重要的。当然软件领域是没有银弹的，我们需要做的是吸收每一种思想，在不同的场景下做不同的取舍，接下来会有几篇文章结合毛老师课上讲的 Go 工程化相关的内容，以及我在工作当中进行的一些总结最后提出一种当下我觉得的 Go 项目的组织方式，这种方式不是最好的，但是我觉得是现阶段最适合的。<br>推荐大家在仔细的阅读一下本书，期望你能有更多的收获。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://weread.qq.com/web/reader/480322f072021a3248038c8kc81322c012c81e728d9d180">架构整洁之道-罗伯特·C·马丁-微信读书</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week04: Go 工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>工程化</tag>
      
      <tag>读书笔记</tag>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程(十一) 总结</title>
    <link href="/post/go-training-week3-sum.html"/>
    <url>/post/go-training-week3-sum.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最开始打算一周更新 1 - 2 篇学习笔记，这样既可以跟上课程的进度又能输出一些文章，分享一点知识，但是在写到 week03 Go 并发编程这个系列的时候发现，掉进坑里面了，毛老师虽然只讲了两节课，大概 7 小时左右，但是实际上每一个点如果要深入理解学习透还是要花费大量时间的。这也就导致了这一周的课程加上本文一共输出了十一篇文章，超过了 4W 字，但是这还没结束，还有几个常用的数据数据结构没有讲到，例如 <code>sync.Map</code>  <code>sync.Pool</code>  等，这些会再接下来不定期的去更新。<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1610684635316-6d61e196-4450-40f7-99d1-0a3b5317b1bb.png" alt="image.png"><br>写完这一篇文章之后能够发现之前写的代码很多不太合理的地方，看了一圈源码之后现在也可以说在 Go 并发编程上面算是入门了。接下来我们就一起回顾一下我们之前所讲的内容。我把文章目录放在了最后，可分别点击查看。</p><h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h3><blockquote><p>第一篇文章主要讲解了 Goroutine 使用的相关注意事项，或者也可以说是最佳实践</p></blockquote><ol><li><strong>请将是否异步调用的选择权交给调用者</strong>，不然很有可能大家并不知道你在这个函数里面使用了 goroutine</li><li>如果你要启动一个 goroutine 请对它负责<ol><li><strong>永远不要启动一个你无法控制它退出，或者你无法知道它何时推出的 goroutine</strong></li><li>还有上一篇提到的，启动 goroutine 时请加上 panic recovery 机制，避免服务直接不可用</li><li>造成 goroutine 泄漏的主要原因就是 goroutine 中造成了阻塞，并且没有外部手段控制它退出</li></ol></li><li><strong>尽量避免在请求中直接启动 goroutine 来处理问题</strong>，而应该通过启动 worker 来进行消费，这样可以避免由于请求量过大，而导致大量创建 goroutine 从而导致 oom，当然如果请求量本身非常小，那当我没说</li></ol><h3 id="Go-内存模型"><a href="#Go-内存模型" class="headerlink" title="Go 内存模型"></a>Go 内存模型</h3><blockquote><p>第二篇文章主要是根据 Go 官方文档中的内存模型进行阐述，后面也提到了一些 CPU 内存重排的相关知识, 主要目的是让大家知道为什么我们要使用同步原语来进行显示的同步控制</p></blockquote><ol><li>编译器重排，现代编译器为了能够获取到极致的性能，可能会在编译时做一些指令重排，这就会导致有一些在单线程跑的程序在并发执行时出现一些不可预期的意外情况。</li><li>内存重排，现代 CPU 大多都是多核 CPU，CPU 为了提高性能会在每个核心下设有缓存，现在一般是有三级缓存，其中一二级是 CPU 独有的，这就可能会存在在并发执行时，多个 Goroutine 在不同的 CPU 上执行看到的变量数据不一致的情况发生。</li><li>hanppens before，如果 <code>e1</code> 发生在 <code>e2</code> 之前，那么我们就说 <code>e2</code> 发生在 <code>e1</code> 之后，如果 <code>e1</code> 既不在 <code>e2</code> 前，也不在 <code>e2</code> 之后，那我们就说这俩是并发的</li><li>机器字，对大于单个机器字的值进行读取和写入，其表现如同以不确定的顺序对多个机器字大小的值进行操作<ol><li>我们现在常见的还有 32 位系统和 64 位的系统，cpu 在执行一条指令的时候对于单个机器字长的的数据的写入可以保证是原子的，对于 32 位的就是 4 个字节，对于 64 位的就是 8 个字节，对于在 32 位情况下去写入一个 8 字节的数据时就需要执行两次写入操作，这两次操作之间就没有原子性，那就可能出现先写入后半部分的数据再写入前半部分，或者是写入了一半数据然后写入失败的情况。</li><li>这也是后面我们去看源码的时候很多情况下会去做 8 字节的对齐的原因</li></ol></li><li>init，若包 p 导入了包 q，则 q 的 init 函数会在 p 的任何函数启动前完成，函数 main.main 会在所有的 init 函数结束后启动。<ol><li>不建议在生产应用依赖这个隐式的顺序</li></ol></li><li><code>go</code> 语句会在当前 goroutine 开始执行前启动新的 goroutine</li><li>goroutine 无法确保在程序中的任何事件发生之前退出</li><li>解决这些问题的方法就是使用显示的同步</li></ol><h3 id="data-race"><a href="#data-race" class="headerlink" title="data race"></a>data race</h3><blockquote><p>在了解了并发编程的时候为什么需要显示的同步后，这一篇文章讲述了我们如何去发现存在并发问题，也就是数据竞争的情况</p></blockquote><ol><li>在编译和运行单元测试时加上 <code>-race</code> flag 就可以开启 data race 的检测<ol><li>不建议在生产环境 build 的时候开启数据竞争检测，因为这会带来一定的性能损失(一般内存 5-10 倍，执行时间 2-20 倍)，当然   必须要 debug 的时候除外。</li><li>建议在执行单元测试时始终开启数据竞争的检测。</li></ol></li><li>总共讲解六个案例来说明哪些场景下可能会出现数据竞争，可以查看原文了解</li></ol><h3 id="mutex-互斥锁"><a href="#mutex-互斥锁" class="headerlink" title="mutex 互斥锁"></a>mutex 互斥锁</h3><blockquote><p>在了解了为什么要用同步原语，以及知道如何发现并发问题之后，我们就开始依次讲解相关的同步原语，第一篇就是 mutex</p></blockquote><ol><li>首先通过一个案例引入说明了锁的基本使用方法，并且了解了互斥锁的使用原则，范围尽量小，一定要解锁并且注意顺序，小心死锁。</li><li>然后讲了互斥锁的实现原理，三种模式<ol><li>Barging: 这种模式是为了提高吞吐量，当锁被释放时，它会唤醒第一个等待者，然后把锁给第一个等待者或者给第一个请求锁的人</li><li>Handoff: 当锁释放时候，锁会一直持有直到第一个等待者准备好获取锁。它降低了吞吐量，因为锁被持有，即使另一个 goroutine 准备获取它。</li><li>Spining：自旋在等待队列为空或者应用程序重度使用锁时效果不错。Parking 和 Unparking goroutines 有不低的性能成本开销，相比自旋来说要慢得多。</li></ol></li><li>然后我们查看分析源码了解了互斥锁和读写锁的具体实现。在 1.9 之后结合上面的三种方式，这一部分的内容比较多建议仔细阅读原文</li></ol><h3 id="sync-atomic"><a href="#sync-atomic" class="headerlink" title="sync/atomic"></a>sync/atomic</h3><blockquote><p>互斥锁其实就是大量使用了 atomic 来实现的，所以紧接着我们就来看了 atomic 包的相关实现</p></blockquote><ol><li>首先通过配置热更新的案例引入，提到了 atomic.Value 的相关使用方法</li><li>然后分别介绍了 atomic 包中的各类方法的用途， <code>AddXXX</code>  等</li><li>详细讲解了 CAS 的的实现原理，主要是在转换为汇编的时候使用看 <code>LOCK</code>  指令，然后通过查阅 Intel 手册我们知道了<ol><li>对于 P6 之前的处理器，LOCK 指令会总是锁总线，但是 P6 之后可能会执行“缓存锁定”，如果被锁定的内存区域被缓存在了处理器中，这个时候会通过缓存一致性来保证操作的原子性</li></ol></li><li>然后详细分析了 atomic.Value 的实现源码，并且利用 atomic 实现了一个无锁栈</li></ol><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><blockquote><p>在前面的案例中不止一次出现了 waitgroup 的身影，这篇文章深入分析了 waitgroup 的实现</p></blockquote><ul><li><code>WaitGroup</code> 可以用于一个 goroutine 等待多个 goroutine 干活完成，也可以多个 goroutine 等待一个 goroutine 干活完成，是一个多对多的关系<ul><li>多个等待一个的典型案例是 <a href="https://pkg.go.dev/golang.org/x/sync/singleflight">singleflight</a>，这个在后面将微服务可用性的时候还会再讲到，感兴趣可以看看源码</li></ul></li><li><code>Add(n&gt;0)</code> 方法应该在启动 goroutine 之前调用，然后在 goroution 内部调用 <code>Done</code> 方法</li><li><code>WaitGroup</code> 必须在 <code>Wait</code> 方法返回之后才能再次使用</li><li><code>Done</code> 只是 <code>Add</code> 的简单封装，所以实际上是可以通过一次加一个比较大的值减少调用，或者达到快速唤醒的目的。</li><li><code>WaitGroup</code>  中关于 32 位和 64 位机器的处理非常巧妙，值得学习</li></ul><h3 id="errgroup"><a href="#errgroup" class="headerlink" title="errgroup"></a>errgroup</h3><blockquote><p>WaitGroup 学习完了我们紧接着就学习了 errgroup，因为相对于 WaitGroup errgroup 在某些场景下更加实用</p></blockquote><ul><li>首先说明了 errgroup 常用的使用场景<ul><li>虽然 WaitGroup 已经帮我们做了很好的封装，但是仍然存在一些问题，例如如果需要返回错误，或者只要一个 goroutine 出错我们就不再等其他 goroutine 了，减少资源浪费，</li></ul></li><li>然后分析了 errgroup 的源码，源码非常简答但是功能却很实用<ul><li>注意有一个坑，在后面的代码中不要把这个 ctx 当做父 context 又传给下游，因为 errgroup 取消了，这个 context 就没用了，会导致下游复用的时候出错</li></ul></li><li>然后用 week3 的作业作为案例<ul><li>基于 errgroup 实现一个 http server 的启动和关闭 ，以及 linux signal 信号的注册和处理，要保证能够 一个退出，全部注销退出。</li></ul></li></ul><h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><blockquote><p>这篇文章主要讲解了 sync.once 的使用和实现</p></blockquote><ul><li>Once 保证了传入的函数只会执行一次，这常用在单例模式，配置文件加载，初始化这些场景下</li><li>但是需要注意。Once 是不能复用的，只要执行过了，再传入其他的方法也不会再执行了</li><li>并且 Once.Do 在执行的过程中如果 f 出现 panic，后面也不会再执行了</li></ul><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><blockquote><p>这篇文章讲解的比较细致，从源码分析，到使用准则和场景以及存在的缺点都讲到了</p></blockquote><h4 id="使用准则"><a href="#使用准则" class="headerlink" title="使用准则"></a>使用准则</h4><p>context 包一开始就告诉了我们应该怎么用，不应该怎么用，这是应该被共同遵守的约定。</p><ul><li>对 server 应用而言，传入的请求应该创建一个 context，接受</li><li>通过 <code>WithCancel</code> , <code>WithDeadline</code> , <code>WithTimeout</code> 创建的 Context 会同时返回一个 cancel 方法，这个方法必须要被执行，不然会导致 context 泄漏，这个可以通过执行 <code>go vet</code> 命令进行检查</li><li>应该将 <code>context.Context</code> 作为函数的第一个参数进行传递，参数命名一般为 <code>ctx</code> 不应该将 Context 作为字段放在结构体中。</li><li>不要给 context 传递 nil，如果你不知道应该传什么的时候就传递 <code>context.TODO()</code></li><li>不要将函数的可选参数放在 context 当中，context 中一般只放一些全局通用的 metadata 数据，例如 tracing id 等等</li><li>context 是并发安全的可以在多个 goroutine 中并发调用</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>超时控制</li><li>错误取消</li><li>跨 goroutine 数据同步</li><li>防止 goroutine 泄漏</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>最显著的一个就是 context 引入需要修改函数签名，并且会病毒的式的扩散到每个函数上面，不过这个见仁见智，我看着其实还好</li><li>某些情况下虽然是可以做到超时返回提高用户体验，但是实际上是不会退出相关 goroutine 的，这时候可能会导致 goroutine 的泄漏，针对这个我们来看一个例子</li></ul><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><blockquote><p>这篇文章从资料收集，到源码阅读再到最终成文花了快半个月的时间，不过写完之后就我个人而言是收获满满的，不知到能不能为屏幕前的你带来一点点启发，如果可以那就太赞了。这篇文章从最开始的理论 csp/actor 到 hanpens before 再到 channel 的基本用法，源码实现，最后讲到了一些使用场景，但是由于长度精力还是个人水平等多种限制有的地方讲解还是不够细致，具体强烈建议阅读一些参考文献里面的十几篇文章，每一个都值得细细品味。</p></blockquote><ul><li>从 <strong>“不要通过共享内存来通信，我们应该使用通信来共享内存”</strong> 出发先探讨了为什么我们要这么做</li><li>在回到了最开始的 Go 内存模型章节故意没有讲解的部分</li><li>从原理到使用，说明了 channel 的基本用法</li><li>然后详细分析了相关源代码：实质上底层是一个循环队列<ul><li>数据结构</li><li>如何创建</li><li>发送数据</li><li>接收数据</li></ul></li><li>然后讲到了几个常用的场景<ul><li>通过关闭 channel 实现一对多的通知</li><li>使用 channel 做异步编程(future/promise)</li><li>超时控制</li></ul></li></ul><h2 id="Go-并发编程文章索引"><a href="#Go-并发编程文章索引" class="headerlink" title="Go 并发编程文章索引"></a>Go 并发编程文章索引</h2><p>我将本系列的所有文章地址都放在这里，感兴趣可以点击链接查看文章详情</p><ol><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go 并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go 并发编程(十) 深入理解 Channel - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week3-context.html">Week03: Go 并发编程(九) 深入理解 Context - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week3-once.html">Week03: Go 并发编程(八) 深入理解 sync.Once - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week3-errgroup.html">Week03: Go 并发编程(七) 深入理解 errgroup - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week3-waitgroup.html">Week03: Go 并发编程(六) 深入理解 WaitGroup - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week3-atomic.html">Week03: Go 并发编程(五) 深入理解 sync/atomic - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sync.html">Week03: Go 并发编程(四) 深入理解 Mutex - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go 并发编程(三) data race - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go 并发编程(二) Go 内存模型 - Mohuishou</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go 并发编程(一) goroutine - Mohuishou</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week03: Go 并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程(十) 深入理解 Channel</title>
    <link href="/post/go-training-week3-channel.html"/>
    <url>/post/go-training-week3-channel.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h2><h3 id="使用通信共享内存"><a href="#使用通信共享内存" class="headerlink" title="使用通信共享内存"></a>使用通信共享内存</h3><p><strong>“不要通过共享内存来通信，我们应该使用通信来共享内存”</strong> 这句话想必大家已经非常熟悉了，在官方的博客，初学时的教程，甚至是在 Go 的源码中都能看到，我们之前讲 sync 包的时候也有提到过。</p><p>无论是通过共享内存来通信还是通过通信来共享内存，最终我们应用程序都是读取的内存当中的数据，只是前者是直接读取内存的数据，而后者是通过发送消息的方式来进行同步。而通过发送消息来同步的这种方式常见的就是 Go 采用的 CSP(Communication Sequential Process) 模型以及 Erlang 采用的 Actor 模型，这两种方式都是通过通信来共享内存。<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1610460699237-f6400aaa-34d5-4c8d-b323-27683704abd2.png" alt="02_Go进阶03_blog_channel.png"><br>大部分的语言采用的都是第一种方式直接去操作内存，然后通过互斥锁，CAS 等操作来保证并发安全。Go 引入了 Channel 和 Goroutine 实现 CSP 模型来解耦这个操作，这样做的好处是在 Goroutine 当中我们就不用手动去做资源的锁定与释放，同时将生产者和消费者进行了解耦，Channel 其实和消息队列很相似。而 Actor 模型和 CSP 模型都是通过发送消息来共享内存，但是它们之间最大的区别就是 Actor 模型当中并没有一个独立的 Channel 组件，而是 Actor 与 Actor 之间直接进行消息的发送与接收，每个 Actor 都有一个本地的“信箱”消息都会先发送到这个“信箱当中”。</p><p><strong>小结</strong></p><ul><li>相对于互斥锁，原子操作而言 channel 是一个更高层级的抽象，使用 channel 会更加方便，心智成本也更低，同时也更不容易出错（channel 保证了并发安全），后面就会讲到，由于 Channel 底层也是通过这些低级的同步原语实现的，所以性能上会差一些，如果有极高的性能要求时也可以用 sync 包中提供的低级同步原语</li><li>使用 channel 可以帮助我们解耦生产者和消费者，可以降低并发当中的耦合</li></ul><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens before"></a>happens before</h3><p>在 <a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go 并发编程(二) Go 内存模型</a> 这篇文章当中讲到同步的时候，Channel 相关部分我们特意略过了，在后面 channel 部分我们就会详细的讲到 channel 的使用以及是怎么实现的，这里先回顾一下 happens before 相关的知识点，详细可以看之前的那篇文章。</p><p><strong>happens before 定义: </strong>如果 <code>e1</code> 发生在 <code>e2</code> 之前，那么我们就说 <code>e2</code> 发生在 <code>e1</code> 之后，如果 <code>e1</code> 既不在 <code>e2</code> 前，也不在 <code>e2</code> 之后，那我们就说这俩是并发的</p><p>但是在我们进行并发编程的过程中由于编译器和 CPU 的各种优化，所以在并发执行的时候并不一定按照代码书写的顺序进行执行（在单个 Goroutine 是可以保证的），所以我们就要采用各种同步原语来保证有序，在 Go 中最常用的就是 Channel，接下来我们就进入正题吧。</p><p><strong>channel:</strong></p><ul><li>channel 上的发送操作总在对应的接收操作完成前发生</li><li>如果 channel 关闭后从中接收数据，接受者就会收到该 channel 返回的零值</li><li>从无缓冲的 channel 中进行的接收，要发生在对该 channel 进行的发送完成前</li></ul><p>这些看起来会比较绕，记住这几条规则，我们接着往下走，希望可以解决你的困惑</p><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>channel 的关键字为 <code>chan</code> ，使用时还需要给 channel 指定一个类型，所以完整的就是 <code>chan T</code> ，使用 <code>&lt;-</code>  表示 channel 的数据流向，在定义变量时，我们也可以使用 <code>&lt;- chan T</code> 、 <code>chan&lt;- T</code>  来分别表示只读和只写的 channel。<br>channel 的初始化采用 <code>make(chan T, cap)</code>  表示， <code>cap</code>  为可选参数，如果不填默认值为 0 表示创建了一个无缓冲的 channel。接下来我们看一个简单的例子，来了解 channel 的基本使用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// 这里只能读</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span><span class="hljs-params">(c &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read:&quot;</span>, &lt;-c)<br>&#125;<br><br><span class="hljs-comment">// 这里只能写</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>)</span></span> &#123;<br>c &lt;- <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><span class="hljs-keyword">go</span> read(c)<br>write(c)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后会输出 <code>read: 0</code> , 注意我们这里使用的是无缓冲的 channel，如果换成有缓存的，这里有可能就不会输出了，因为</p><ol><li><strong>channel 上的发送操作总在对应的接收操作完成前发生，</strong>所以在 read 还没有完成时候，write 就已经开始写入了</li><li><strong>从无缓冲的 channel 中进行的接收，要发生在对该 channel 进行的发送完成前，</strong>如果是无缓冲的 channel， write 还没写入结束，read 就已经开始接收了，所以可以保证 read 执行，但是反过来如果有缓冲，那么 read 可能还没开始 write 就结束了，所以就有可能什么都不输出就结束了</li></ol><p>关于有无缓冲的 channel 有两张图非常经典，基本上看完就明白了，建议阅读一下原文，在参考文献 [14] 中</p><h4 id="无缓冲-channel"><a href="#无缓冲-channel" class="headerlink" title="无缓冲 channel"></a>无缓冲 channel</h4><p>如下图所示，无缓冲的 channel 会阻塞直到数据接收完成，常用于两个 goroutine 互相等待同步<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1610518966242-7cf0d17a-8c64-4eb0-9459-615d10bdf56d.png" alt="image.png"></p><h4 id="有缓冲-channel"><a href="#有缓冲-channel" class="headerlink" title="有缓冲 channel"></a>有缓冲 channel</h4><p>有缓冲的 channel 如果在缓冲区未满的情况下发送是不阻塞的，在缓冲区不为空时，接收是不阻塞的<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1610518977443-794150b4-3b89-4279-b18c-50ae8e334945.png" alt="image.png"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>大概了解了 channel 的使用方法和原理之后我们接下来就进入稍微硬核一些的源码模式</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>qcount   <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// 队列中元素总数量</span><br>dataqsiz <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// 循环队列的长度</span><br>buf      unsafe.Pointer <span class="hljs-comment">// 指向长度为 dataqsiz 的底层数组，只有在有缓冲时这个才有意义</span><br>elemsize <span class="hljs-keyword">uint16</span>         <span class="hljs-comment">// 能够发送和接受的元素大小</span><br>closed   <span class="hljs-keyword">uint32</span>         <span class="hljs-comment">// 是否关闭</span><br>elemtype *_type <span class="hljs-comment">// 元素的类型</span><br>sendx    <span class="hljs-keyword">uint</span>   <span class="hljs-comment">// 当前已发送的元素在队列当中的索引位置</span><br>recvx    <span class="hljs-keyword">uint</span>   <span class="hljs-comment">// 当前已接收的元素在队列当中的索引位置</span><br>recvq    waitq  <span class="hljs-comment">// 接收 Goroutine 链表</span><br>sendq    waitq  <span class="hljs-comment">// 发送 Goroutine 链表</span><br><br>lock mutex <span class="hljs-comment">// 互斥锁</span><br>&#125;<br><br><span class="hljs-comment">// waitq 是一个双向链表，里面保存了 goroutine</span><br><span class="hljs-keyword">type</span> waitq <span class="hljs-keyword">struct</span> &#123;<br>first *sudog<br>last  *sudog<br>&#125;<br></code></pre></td></tr></table></figure><p>如下图所示，channel 底层其实是一个循环队列<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1610547861474-f3573434-0261-4255-91dd-6e6a4a532030.png" alt="image.png"></p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>在 Go 中我们使用 <code>make(chan T, cap)</code>  来创建 channel，make 语法会在编译时，转换为 <code>makechan64</code>  和 <code>makechan</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan64</span><span class="hljs-params">(t *chantype, size <span class="hljs-keyword">int64</span>)</span> *<span class="hljs-title">hchan</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">int64</span>(<span class="hljs-keyword">int</span>(size)) != size &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;makechan: size out of range&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">return</span> makechan(t, <span class="hljs-keyword">int</span>(size))<br>&#125;<br></code></pre></td></tr></table></figure><p><code>makechan64</code>  主要是做了一下检查，最终还是会调用 <code>makechan</code> ，在看 <code>makechan</code>  源码之前，我们先来看两个全局常量，接下来会用到</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>maxAlign  = <span class="hljs-number">8</span><br>hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="hljs-keyword">uintptr</span>(-<span class="hljs-keyword">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="hljs-number">-1</span>))<br>)<br></code></pre></td></tr></table></figure><ul><li><code>maxAlign</code>  是内存对齐的最大值，这个等于 64 位 CPU 下的 cacheline 的大小</li><li><code>hchanSize</code>  计算 <code>unsafe.Sizeof(hchan&#123;&#125;)</code>  最近的 8 的倍数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">hchan</span></span> &#123;<br>elem := t.elem<br><br><span class="hljs-comment">// 先做一些检查</span><br>    <span class="hljs-comment">// 元素大小不能大于等于 64k</span><br><span class="hljs-keyword">if</span> elem.size &gt;= <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span> &#123;<br>throw(<span class="hljs-string">&quot;makechan: invalid channel element type&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 判断当前的 hchanSize 是否是 maxAlign 整数倍，并且元素的对齐大小不能大于最大对齐的大小</span><br><span class="hljs-keyword">if</span> hchanSize%maxAlign != <span class="hljs-number">0</span> || elem.align &gt; maxAlign &#123;<br>throw(<span class="hljs-string">&quot;makechan: bad alignment&quot;</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 这里计算内存是否超过限制</span><br>mem, overflow := math.MulUintptr(elem.size, <span class="hljs-keyword">uintptr</span>(size))<br><span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;makechan: size out of range&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">var</span> c *hchan<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> mem == <span class="hljs-number">0</span>: <span class="hljs-comment">// 如果是无缓冲通道</span><br>c = (*hchan)(mallocgc(hchanSize, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>)) <span class="hljs-comment">// 为 hchan 分配内存</span><br>c.buf = c.raceaddr() <span class="hljs-comment">// 这个是 for data race 检测的</span><br><span class="hljs-keyword">case</span> elem.ptrdata == <span class="hljs-number">0</span>: <span class="hljs-comment">// 元素不包含指针</span><br>c = (*hchan)(mallocgc(hchanSize+mem, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>)) <span class="hljs-comment">// 为 hchan 和底层数组分配一段连续的内存地址</span><br>c.buf = add(unsafe.Pointer(c), hchanSize)<br><span class="hljs-keyword">default</span>: <span class="hljs-comment">// 如果元素包含指针，分别为 hchan 和 底层数组分配内存地址</span><br>c = <span class="hljs-built_in">new</span>(hchan)<br>c.buf = mallocgc(mem, elem, <span class="hljs-literal">true</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 初始化一些值</span><br>c.elemsize = <span class="hljs-keyword">uint16</span>(elem.size)<br>c.elemtype = elem<br>c.dataqsiz = <span class="hljs-keyword">uint</span>(size)<br>lockInit(&amp;c.lock, lockRankHchan)<br><br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>注释已经写得很全了，简单做个小结：</p><ul><li>创建时会做一些检查<ul><li>元素大小不能超过 64K</li><li>元素的对齐大小不能超过 maxAlign 也就是 8 字节</li><li>计算出来的内存是否超过限制</li></ul></li><li>创建时的策略<ul><li>如果是无缓冲的 channel，会直接给 hchan 分配内存</li><li>如果是有缓冲的 channel，并且元素不包含指针，那么会为 hchan 和底层数组分配一段连续的地址</li><li>如果是有缓冲的 channel，并且元素包含指针，那么会为 hchan 和底层数组分别分配地址</li></ul></li></ul><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><p>我们在 <code>x &lt;- chan T</code>  进行发送数据的时候最终会被编译成 <code>chansend1</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;<br>chansend(c, elem, <span class="hljs-literal">true</span>, getcallerpc())<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>chansend1</code>  最终还是调用了 <code>chansend</code>  主要的逻辑都在 <code>chansend</code>  上面，注意看下方源码和注释</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码中删除了调试相关的代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-keyword">bool</span>, callerpc <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-comment">// 如果是一个 nil 值的 channel</span><br>    <span class="hljs-comment">// 如果是非阻塞的话就直接返回</span><br>    <span class="hljs-comment">// 如果不是，那么则调用 gopark 休眠当前 goroutine 并且抛出 panic 错误</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br><br>    <span class="hljs-comment">// fast path 如果当前是非阻塞的</span><br>    <span class="hljs-comment">// 并且通道尚未关闭</span><br>    <span class="hljs-comment">// 并且缓冲区已满时，直接返回</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; c.closed == <span class="hljs-number">0</span> &amp;&amp; full(c) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br>    <span class="hljs-comment">// 加锁</span><br>lock(&amp;c.lock)<br><br>    <span class="hljs-comment">// 如果通道已经关闭了，直接 panic，不允许向一个已经关闭的 channel 写入数据</span><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br><br>    <span class="hljs-comment">// 如果当前存在等待接收数据的 goroutine 直接取出第一个，将数据传递给第一个等待的 goroutine</span><br><span class="hljs-keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// send 用于发送数据，我们后面再看</span><br>send(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 如果当前 channel 包含缓冲区，并且缓冲区没有满</span><br><span class="hljs-keyword">if</span> c.qcount &lt; c.dataqsiz &#123;<br><span class="hljs-comment">// 计算数组中下一个可以存放数据的地址</span><br>qp := chanbuf(c, c.sendx)<br><br>        <span class="hljs-comment">// 将当前的数据放到缓冲区中</span><br>typedmemmove(c.elemtype, qp, ep)<br><br>        <span class="hljs-comment">// 索引加一</span><br>        c.sendx++<br><br>        <span class="hljs-comment">// 由于是循环队列，如果索引地址等于数组长度，就需要将索引移动到 0</span><br><span class="hljs-keyword">if</span> c.sendx == c.dataqsiz &#123;<br>c.sendx = <span class="hljs-number">0</span><br>&#125;<br><br>        <span class="hljs-comment">// 当前缓存数据量加一</span><br>c.qcount++<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br>    <span class="hljs-comment">// 如果是非阻塞的就直接返回了，因为非阻塞发送的情况已经走完了，下面是阻塞发送的逻辑</span><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 获取发送数据的 goroutine</span><br>gp := getg()<br>    <span class="hljs-comment">// 获取 sudog 结构体，并且设置相关信息，包括当前的 channel，是否是 select 等</span><br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.waiting = mysg<br>gp.param = <span class="hljs-literal">nil</span><br><br>    <span class="hljs-comment">// 将 sudog 结构加入到发送的队列中</span><br>c.sendq.enqueue(mysg)<br><br>    <span class="hljs-comment">// 挂起当前 goroutine 等待接收 channel数据</span><br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment">// 保证当前数据处于活跃状态避免被回收</span><br>KeepAlive(ep)<br><br><span class="hljs-comment">// 发送者 goroutine 被唤醒，检查当前 sg 的状态</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> gp.param == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> c.closed == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;chansend: spurious wakeup&quot;</span>)<br>&#125;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br>gp.param = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 取消 channel 绑定</span><br>mysg.c = <span class="hljs-literal">nil</span><br>    <span class="hljs-comment">// 释放 sudog</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>send</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">send</span><span class="hljs-params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">skip</span> <span class="hljs-title">int</span>)</span> &#123;<br>    <span class="hljs-comment">// 如果 sudog 上存在数据元素，就调用 sendDirect 直接把数据拷贝到接收变量的地址上</span><br><span class="hljs-keyword">if</span> sg.elem != <span class="hljs-literal">nil</span> &#123;<br>sendDirect(c.elemtype, sg, ep)<br>sg.elem = <span class="hljs-literal">nil</span><br>&#125;<br>gp := sg.g<br>unlockf()<br>gp.param = unsafe.Pointer(sg)<br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br><br>    <span class="hljs-comment">// 调用 goready 将接受者的 Goroutine 标记为可运行状态，并把它放到发送方的所在处理器的 runnext 等待执行，下次调度时就会执行到它。</span><br>    <span class="hljs-comment">// 注意这里不是立即执行</span><br>goready(gp, skip+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小结</strong><br>向 channel 中发送数据时大概分为两大块，检查和数据发送，而数据发送又分为三种情况</p><ul><li>如果 channel 的 <code>recvq</code>  存在阻塞等待的接收数据的 goroutine 那么将会直接将数据发送给第一个等待的 goroutine<ul><li>这里会直接将数据拷贝到 <code>x &lt;-ch</code>  接收者的变量 <code>x</code>  上</li><li>然后将接收者的 Goroutine 修改为可运行状态，并把它放到发送方所在处理器的 runnext 上等待下一次调度时执行。</li></ul></li><li>如果 channel 是有缓冲的，并且缓冲区没有满，这个时候就会把数据放到缓冲区中</li><li>如果 channel 的缓冲区满了，这个时候就会走阻塞发送的流程，获取到 sudog 之后将当前 Goroutine 挂起等待唤醒，唤醒后将相关的数据解绑，回收掉 sudog</li></ul><h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><p>在 Go 中接收 channel 数据有两种方式</p><ul><li><code>x &lt;- ch</code>  编译时会被转换为 <code>chanrecv1</code></li><li><code>x, ok &lt;- ch</code>   编译时会被转换为 <code>chanrecv2</code></li></ul><p><code>chanrecv1</code> 和 <code>chanrecv2</code> 没有多大区别，只是 <code>chanrecv2</code> 比 <code>chanrecv1</code> 多了一个返回值，最终都是调用的 <code>chanrecv</code> 来实现的接收数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// selected 用于 select&#123;&#125; 语法中是否会选中该分支</span><br><span class="hljs-comment">// received 表示当前是否真正的接收到数据，用来判断 channel 是否 closed 掉了</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-keyword">bool</span>)</span> <span class="hljs-params">(selected, received <span class="hljs-keyword">bool</span>)</span></span> &#123;<br><span class="hljs-comment">// 和发送数据类似，先判断是否为nil，如果是 nil 并且阻塞接收就会 panic</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Fast path: 检查非阻塞的操作</span><br>    <span class="hljs-comment">// empty 主要是有两种情况返回 true:</span><br>    <span class="hljs-comment">// 1. 无缓冲channel，并且没有阻塞住发送者</span><br>    <span class="hljs-comment">// 2. 有缓冲 channel，但是缓冲区没有数据</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; empty(c) &#123;<br><span class="hljs-comment">// 这里判断通道是否关闭，如果是未关闭的通道说明当前还没准备好数据，直接返回</span><br><span class="hljs-keyword">if</span> atomic.Load(&amp;c.closed) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 如果通道已经关闭了，再检查一下通道还有没有数据，如果已经没数据了，我们清理到 ep 指针中的数据并且返回</span><br><span class="hljs-keyword">if</span> empty(c) &#123;<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 上锁</span><br>lock(&amp;c.lock)<br><br>    <span class="hljs-comment">// 和上面类似，如果通道已经关闭了，并且已经没数据了，我们清理到 ep 指针中的数据并且返回</span><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &amp;&amp; c.qcount == <span class="hljs-number">0</span> &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br><br>    <span class="hljs-comment">// 和发送类似，接收数据时也是先看一下有没有正在阻塞的等待发送数据的 Goroutine</span><br>    <span class="hljs-comment">// 如果有的话 直接调用 recv 方法从发送者或者是缓冲区中接收数据，recv 方法后面会讲到</span><br><span class="hljs-keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br>recv(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br><br>    <span class="hljs-comment">// 如果 channel 的缓冲区还有数据</span><br><span class="hljs-keyword">if</span> c.qcount &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 获取当前 channel 接收的地址</span><br>qp := chanbuf(c, c.recvx)<br><br>        <span class="hljs-comment">// 如果传入的指针不是 nil 直接把数据复制到对应的变量上</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemmove(c.elemtype, ep, qp)<br>&#125;<br>        <span class="hljs-comment">// 清除队列中的数据，设置接受者索引并且返回</span><br>typedmemclr(c.elemtype, qp)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.qcount--<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br><br>    <span class="hljs-comment">// 和发送一样剩下的就是阻塞操作了，如果是非阻塞的情况，直接返回</span><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 阻塞接受，和发送类似，拿到当前 Goroutine 和 sudog 并且做一些数据填充</span><br>gp := getg()<br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>gp.waiting = mysg<br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.param = <span class="hljs-literal">nil</span><br><br>    <span class="hljs-comment">// 把 sudog 放入到接收者队列当中</span><br>c.recvq.enqueue(mysg)<br>    <span class="hljs-comment">// 然后休眠当前 Goroutine 等待唤醒</span><br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// Goroutine 被唤醒，接收完数据，做一些数据清理的操作，释放掉 sudog 然后返回</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br>closed := gp.param == <span class="hljs-literal">nil</span><br>gp.param = <span class="hljs-literal">nil</span><br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, !closed<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>recv</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recv</span><span class="hljs-params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">skip</span> <span class="hljs-title">int</span>)</span> &#123;<br><span class="hljs-comment">// 如果无缓冲的 channel 直接调用 recvDirect 将数据从发送者 Goroutine 拷贝到变量</span><br>    <span class="hljs-keyword">if</span> c.dataqsiz == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// copy data from sender</span><br>recvDirect(c.elemtype, sg, ep)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 否则的话说明这是一个有缓冲的 channel 并且缓冲已经满了</span><br><br>        <span class="hljs-comment">// 先从底层数组中拿到数据地址</span><br>qp := chanbuf(c, c.recvx)<br><br><span class="hljs-comment">// 然后把数据复制到接收变量上</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemmove(c.elemtype, ep, qp)<br>&#125;<br><br><span class="hljs-comment">// 然后将发送者 Goroutine 中的数据拷贝到底层数组上</span><br>typedmemmove(c.elemtype, qp, sg.elem)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.sendx = c.recvx <span class="hljs-comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span><br>&#125;<br>    <span class="hljs-comment">// 最后做一些清理操作</span><br>sg.elem = <span class="hljs-literal">nil</span><br>gp := sg.g<br>unlockf()<br>gp.param = unsafe.Pointer(sg)<br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>goready(gp, skip+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小结: </strong>数据接收和发送其实大同小异，也是分为检查和数据接收，数据接收又分三种情况</p><ul><li>直接获取数据，如果当前有阻塞的发送者 Goroutine 走这条路<ul><li>如果是无缓冲 channel，直接从发送者那里把数据拷贝给接收变量</li><li>如果是有缓冲 channel，并且 channel 已经满了，就先从 channel 的底层数组拷贝数据，再把阻塞的发送者 Goroutine 的数据拷贝到 channel 的循环队列中</li></ul></li><li>从 channel 的缓冲中获取数据，有缓冲 channel 并且缓存队列有数据时走这条路<ul><li>直接从缓存队列中复制数据给接收变量</li></ul></li><li>阻塞接收，剩余情况走这里<ul><li>和发送类似，先获取当前 Goroutine 信息，构造 sudog 加入到 channel 的 recvq 上</li><li>然后休眠当前 Goroutine 等待唤醒</li><li>唤醒后做一些清理工作，释放 sudog 返回</li></ul></li></ul><h4 id="关闭-channel"><a href="#关闭-channel" class="headerlink" title="关闭 channel"></a>关闭 channel</h4><p>我们使用 <code>close(ch)</code>  来关闭 channel 最后会调用 runtime 中的 <code>closechan</code>  方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closechan</span><span class="hljs-params">(c *hchan)</span></span> &#123;<br>    <span class="hljs-comment">// 关闭 nil 的 channel 会导致 panic</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of nil channel&quot;</span>))<br>&#125;<br><br>    <span class="hljs-comment">// 加锁</span><br>lock(&amp;c.lock)<br><br>    <span class="hljs-comment">// 关闭已关闭的 channel 会导致 panic</span><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of closed channel&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// 设置 channel 状态</span><br>c.closed = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">var</span> glist gList<br><br><span class="hljs-comment">// 释放所有的接收者 Goroutine</span><br><span class="hljs-keyword">for</span> &#123;<br>sg := c.recvq.dequeue()<br><span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> sg.elem != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, sg.elem)<br>sg.elem = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>gp := sg.g<br>gp.param = <span class="hljs-literal">nil</span><br><br>glist.push(gp)<br>&#125;<br><br><span class="hljs-comment">// 释放所有的发送者channel，会 panic 因为不允许向已关闭的 channel 发送数据</span><br><span class="hljs-keyword">for</span> &#123;<br>sg := c.sendq.dequeue()<br><span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>sg.elem = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>gp := sg.g<br>gp.param = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquireg(gp, c.raceaddr())<br>&#125;<br>glist.push(gp)<br>&#125;<br>unlock(&amp;c.lock)<br><br><span class="hljs-comment">// 将所有的 Goroutine 设置为可运行状态</span><br><span class="hljs-keyword">for</span> !glist.empty() &#123;<br>gp := glist.pop()<br>gp.schedlink = <span class="hljs-number">0</span><br>goready(gp, <span class="hljs-number">3</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小结:</strong></p><ul><li>关闭一个 nil 的 channel 和已关闭了的 channel 都会导致 panic</li><li>关闭 channel 后会释放所有因为 channel 而阻塞的 Goroutine</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>关于 channel 的使用场景在 Go 语言 101 当中已经很完善了，如果感兴趣可以看一下参考文献[5]，我这里只讲一些常见或是我觉得有趣的例子</p><h4 id="1-通过关闭-channel-实现一对多的通知"><a href="#1-通过关闭-channel-实现一对多的通知" class="headerlink" title="1. 通过关闭 channel 实现一对多的通知"></a>1. 通过关闭 channel 实现一对多的通知</h4><p>刚刚讲到了关闭 channel 时会释放所有阻塞的 Goroutine，所以我们就可以利用这个特性来做一对多的通知，除了一对多之外我们还用了 <code>done</code>  做了多对一的通知，当然多对一这种情况还是建议直接使用 WaitGroup 即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, done <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-comment">// 每一秒打印一次 hello</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-stop:<br>fmt.Println(<span class="hljs-string">&quot;stop...&quot;</span>)<br>done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> &lt;-time.After(time.Second):<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 一对多</span><br>stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-comment">// 多对一</span><br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> run(stop, done)<br>&#125;<br><br><span class="hljs-comment">// 5s 后退出</span><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br><span class="hljs-built_in">close</span>(stop)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>&lt;-done<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-使用-channel-做异步编程-future-promise"><a href="#2-使用-channel-做异步编程-future-promise" class="headerlink" title="2. 使用 channel 做异步编程(future/promise)"></a>2. 使用 channel 做异步编程(future/promise)</h4><p>其实最开始的例子就是这种情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// 这里只能读</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span><span class="hljs-params">(c &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read:&quot;</span>, &lt;-c)<br>&#125;<br><br><span class="hljs-comment">// 这里只能写</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>)</span></span> &#123;<br>c &lt;- <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><span class="hljs-keyword">go</span> read(c)<br>write(c)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-超时控制"><a href="#3-超时控制" class="headerlink" title="3. 超时控制"></a>3. 超时控制</h4><p>具体可以看案例一里面的 run 方法, 不过超时控制还是建议使用 context</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, done <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-comment">// 每一秒打印一次 hello</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-stop:<br>fmt.Println(<span class="hljs-string">&quot;stop...&quot;</span>)<br>done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> &lt;-time.After(time.Second):<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章从资料收集，到源码阅读再到最终成文花了快半个月的时间了，不过写完之后就我个人而言是收获满满的，不知到能不能为屏幕前的你带来一点点启发，如果可以那就太赞了。这篇文章从最开始的理论 csp/actor 到 hanpens before 再到 channel 的基本用法，源码实现，最后讲到了一些使用场景，但是由于长度精力还是个人水平等多种限制有的地方讲解还是不够细致，具体强烈建议阅读一些参考文献里面的十几篇文章，每一个都值得细细品味。<br>我们下一篇文章见 👀</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://golang.org/ref/spec#Channel_types">The Go Programming Language Specification - The Go Programming Language</a></li><li><a href="https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/">Go advanced concurrency patterns: part 3 (channels) - Blog Title</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/">Go 语言 Channel 实现原理精要 | Go 语言设计与实现</a></li><li><a href="https://colobu.com/2016/04/14/Golang-Channels/">Go Channel 详解 | 鸟窝</a></li><li><a href="https://gfw.go101.org/article/channel.html">通道 - Go 语言 101（通俗版 Go 白皮书）</a></li><li><a href="https://gfw.go101.org/article/channel-use-cases.html">通道用例大全 - Go 语言 101（通俗版 Go 白皮书）</a></li><li><a href="https://gfw.go101.org/article/channel-closing.html">如何优雅地关闭通道 - Go 语言 101（通俗版 Go 白皮书）</a></li><li><a href="https://qcrao.com/2019/07/22/dive-into-go-channel/">深度解密 Go 语言之 channel | qcrao</a></li><li><a href="https://draveness.me/whys-the-design-communication-shared-memory/">为什么使用通信来共享内存 - 面向信仰编程</a></li><li><a href="http://www.usingcsp.com/cspbook.pdf">http://www.usingcsp.com/cspbook.pdf</a></li><li><a href="https://mp.weixin.qq.com/s/ZXYpfLNGyej0df2zXqfnHQ">一文带你解密 Go 语言之通道 channel</a></li><li><a href="https://www.cyub.vip/2020/11/04/Golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BChannel%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">Golang 源码分析系列之 Channel 底层实现 | Tink’s Blog</a></li><li><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html">The Behavior Of Channels</a></li><li><a href="https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html">The Nature Of Channels In Go</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week03: Go 并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程(九) 深入理解 Context</title>
    <link href="/post/go-training-week3-context.html"/>
    <url>/post/go-training-week3-context.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h2><p>在 <a href="https://lailin.xyz/post/go-training-week3-waitgroup.html">Week03: Go 并发编程(六) 深入理解 WaitGroup</a> 、 <a href="https://lailin.xyz/post/go-training-week3-errgroup.html">Week03: Go 并发编程(七) 深入理解 errgroup</a> 中我们提到了等待多个 goroutine 协作的方式，但是我们现在想一下这么一个常见的场景。现在有一个 Server 服务在执行，当请求来的时候我们启动一个 goroutine 去处理，然后在这个 goroutine 当中有对下游服务的 rpc 调用，也会去请求数据库获取一些数据，这时候如果下游依赖的服务比较慢，但是又没挂，只是很慢，可能一次调用要 1min 才能返回结果，这个时候我们该如何处理？</p><p>如下图所示，首先假设我们使用 WaitGroup 进行控制，等待所有的 goroutine 处理完成之后返回，可以看到我们实际的耗时远远大于了用户可以容忍的时间。<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1610027116078-2e1368bf-015e-4459-8517-73dc858ed083.svg" alt="02_Go进阶03_blog_context.drawio.svg"><br>如下图所示，再考虑一个常见的场景，万一上面的 rpc goroutine 很早就报错了，但是 下面的 db goroutine 又执行了很久，我们最后要返回错误信息，很明显后面 db goroutine 执行的这段时间都是在白白的浪费用户的时间。<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1610027303842-4272e9a1-af9c-4804-a779-f72c1f82a1a0.svg" alt="02_Go进阶03_blog_context.drawio.svg"></p><p>这时候就应该请出 context 包了，<strong>context 主要就是用来在多个 goroutine 中设置截止日期、同步信号，传递请求相关值。</strong><br><strong>每一次 context 都会从顶层一层一层的传递到下面一层的 goroutine 当上面的 context 取消的时候，下面所有的 context 也会随之取消。</strong><br>**<br>上面的例子当中，如果引入 context 后就会是这样，如下图所示，context 会类似一个树状结构一样依附在每个 goroutine 上，当上层的 req goroutine 的 context 超时之后就会将取消信号同步到下面的所有 goroutine 上一起返回，从而达到超时控制的作用<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1610027726018-4ff7389e-ec4a-4107-99ac-493f587f2a88.svg" alt="02_Go进阶03_blog_context.drawio.svg"><br>如下图所示，当 rpc 调用失败之后，会出发 context 取消，然后这个取消信号就会同步到其他的 goroutine 当中<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1610027762059-43c810a8-619e-4f8d-ad74-7a2767635aa0.svg" alt="02_Go进阶03_blog_context.drawio.svg"></p><h2 id="package-context"><a href="#package-context" class="headerlink" title="package context"></a>package context</h2><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>在使用一个新的库的时候，我们一般需要先看它的官方说明，得益于 godoc 的约束，所以标准库和第三方库的文档都可以通过 <a href="https://pkg.go.dev">pkg.go.dev</a> 进行搜索查询</p><h4 id="使用准则"><a href="#使用准则" class="headerlink" title="使用准则"></a>使用准则</h4><p>context 包一开始就告诉了我们应该怎么用，不应该怎么用，这是应该被共同遵守的约定。</p><ul><li>对 server 应用而言，传入的请求应该创建一个 context，接受</li><li>通过 <code>WithCancel</code> , <code>WithDeadline</code> , <code>WithTimeout</code>  创建的 Context 会同时返回一个 cancel 方法，这个方法必须要被执行，不然会导致 context 泄漏，这个可以通过执行 <code>go vet</code>  命令进行检查</li><li>应该将 <code>context.Context</code>  作为函数的第一个参数进行传递，参数命名一般为 <code>ctx</code>  不应该将 Context 作为字段放在结构体中。</li><li>不要给 context 传递 nil，如果你不知道应该传什么的时候就传递 <code>context.TODO()</code></li><li>不要将函数的可选参数放在 context 当中，context 中一般只放一些全局通用的 metadata 数据，例如 tracing id 等等</li><li>context 是并发安全的可以在多个 goroutine 中并发调用</li></ul><h4 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h4><p>context 包暴露的方法不多，看下方说明即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个带有新的 Done channel 的 context，并且返回一个取消的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span> <span class="hljs-params">(ctx Context, cancel CancelFunc)</span></span><br><span class="hljs-comment">// 创建一个具有截止时间的 context</span><br><span class="hljs-comment">// 截止时间是 d 和 parent(如果有截止时间的话) 的截止时间中更早的那一个</span><br><span class="hljs-comment">// 当 parent 执行完毕，或 cancel 被调用 或者 截止时间到了的时候，这个 context done 掉</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, d time.Time)</span> <span class="hljs-params">(Context, CancelFunc)</span></span><br><span class="hljs-comment">// 其实就是调用的 WithDeadline</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span> <span class="hljs-params">(Context, CancelFunc)</span></span><br><span class="hljs-keyword">type</span> CancelFunc<br><span class="hljs-keyword">type</span> Context<br><span class="hljs-comment">// 一般用于创建 root context，这个 context 永远也不会被取消，或者是 done</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Background</span><span class="hljs-params">()</span> <span class="hljs-title">Context</span></span><br><span class="hljs-comment">// 底层和 Background 一致，但是含义不同，当不清楚用什么的时候或者是还没准备好的时候可以用它</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TODO</span><span class="hljs-params">()</span> <span class="hljs-title">Context</span></span><br><span class="hljs-comment">// 为 context 附加值</span><br><span class="hljs-comment">// key 应该具有可比性，一般不应该是 string int 这种默认类型，应该自己创建一个类型</span><br><span class="hljs-comment">// 避免出现冲突，一般 key 不应该导出，如果要导出的话应该是一个接口或者是指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Context</span></span><br></code></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="context-Context-接口"><a href="#context-Context-接口" class="headerlink" title="context.Context 接口"></a>context.Context 接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-comment">// 返回当前 context 的结束时间，如果 ok = false 说明当前 context 没有设置结束时间</span><br>Deadline() (deadline time.Time, ok <span class="hljs-keyword">bool</span>)<br>    <span class="hljs-comment">// 返回一个 channel，用于判断 context 是否结束，多次调用同一个 context done 方法会返回相同的 channel</span><br>Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>    <span class="hljs-comment">// 当 context 结束时才会返回错误，有两种情况</span><br>    <span class="hljs-comment">// context 被主动调用 cancel 方法取消：Canceled</span><br>    <span class="hljs-comment">// context 超时取消: DeadlineExceeded</span><br>Err() error<br>    <span class="hljs-comment">// 用于返回 context 中保存的值, 如何查找，这个后面会讲到</span><br>Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="默认上下文-context-Backgroud"><a href="#默认上下文-context-Backgroud" class="headerlink" title="默认上下文: context.Backgroud"></a>默认上下文: context.Backgroud</h4><p><strong>Backgroud()，</strong>在前面有讲到，  一般用于创建 root context，这个 context 永远也不会被取消，或超时<br><strong>TODO()， </strong>底层和 Background 一致，但是含义不同，当不清楚用什么的时候或者是还没准备好的时候可以用它</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>background = <span class="hljs-built_in">new</span>(emptyCtx)<br>todo       = <span class="hljs-built_in">new</span>(emptyCtx)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Background</span><span class="hljs-params">()</span> <span class="hljs-title">Context</span></span> &#123;<br><span class="hljs-keyword">return</span> background<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TODO</span><span class="hljs-params">()</span> <span class="hljs-title">Context</span></span> &#123;<br><span class="hljs-keyword">return</span> todo<br>&#125;<br></code></pre></td></tr></table></figure><p>查看源码我们可以发现，background 和 todo 都是实例化了一个 emptyCtx</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> emptyCtx <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Deadline</span><span class="hljs-params">()</span> <span class="hljs-params">(deadline time.Time, ok <span class="hljs-keyword">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Done</span><span class="hljs-params">()</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">struct</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Err</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span> <span class="hljs-title">Value</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>emptyCtx 就如同他的名字一样，全都返回空值</p><h4 id="如何取消-context-WithCancel"><a href="#如何取消-context-WithCancel" class="headerlink" title="如何取消 context : WithCancel"></a>如何取消 context : WithCancel</h4><p><strong>WithCancel(),</strong> 方法会创建一个可以取消的 context</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span> <span class="hljs-params">(ctx Context, cancel CancelFunc)</span></span> &#123;<br><span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 包装出新的 cancelContext</span><br>c := newCancelCtx(parent)<br>    <span class="hljs-comment">// 构建父子上下文的联系，确保当父 Context 取消的时候，子 Context 也会被取消</span><br>propagateCancel(parent, &amp;c)<br><span class="hljs-keyword">return</span> &amp;c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不止 WithCancel 方法，其他的 WithXXX 方法也不允许传入一个 nil 值的父 context<br><code>newCancelCtx</code>  只是一个简单的包装就不展开了， <code>propagateCancel</code>  比较有意思，我们一起来看看</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">propagateCancel</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;<br><span class="hljs-comment">// 首先判断 parent 能不能被取消</span><br>    done := parent.Done()<br><span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// parent is never canceled</span><br>&#125;<br><br>    <span class="hljs-comment">// 如果可以，看一下 parent 是不是已经被取消了，已经被取消的情况下直接取消 子 context</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-done:<br><span class="hljs-comment">// parent is already canceled</span><br>child.cancel(<span class="hljs-literal">false</span>, parent.Err())<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><br>    <span class="hljs-comment">// 这里是向上查找可以被取消的 parent context</span><br><span class="hljs-keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;<br>        <span class="hljs-comment">// 如果找到了并且没有被取消的话就把这个子 context 挂载到这个 parent context 上</span><br>        <span class="hljs-comment">// 这样只要 parent context 取消了子 context 也会跟着被取消</span><br>p.mu.Lock()<br><span class="hljs-keyword">if</span> p.err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// parent has already been canceled</span><br>child.cancel(<span class="hljs-literal">false</span>, p.err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> p.children == <span class="hljs-literal">nil</span> &#123;<br>p.children = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br>p.children[child] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>p.mu.Unlock()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果没有找到的话就会启动一个 goroutine 去监听 parent context 的取消 channel</span><br>        <span class="hljs-comment">// 收到取消信号之后再去调用 子 context 的 cancel 方法</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-parent.Done():<br>child.cancel(<span class="hljs-literal">false</span>, parent.Err())<br><span class="hljs-keyword">case</span> &lt;-child.Done():<br>&#125;<br>&#125;()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们就看看 cancelCtx 长啥样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> &#123;<br>Context <span class="hljs-comment">// 这里保存的是父 Context</span><br><br>mu       sync.Mutex            <span class="hljs-comment">// 互斥锁</span><br>done     <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;         <span class="hljs-comment">// 关闭信号</span><br>children <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// 保存所有的子 context，当取消的时候会被设置为 nil</span><br>err      error<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Done 方法这里采用了 懒汉式加载的方式，第一次调用的时候才会去创建这个 channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span> <span class="hljs-title">Done</span><span class="hljs-params">()</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">struct</span></span>&#123;&#125; &#123;<br>c.mu.Lock()<br><span class="hljs-keyword">if</span> c.done == <span class="hljs-literal">nil</span> &#123;<br>c.done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br>d := c.done<br>c.mu.Unlock()<br><span class="hljs-keyword">return</span> d<br>&#125;<br></code></pre></td></tr></table></figure><p>Value 方法很有意思，这里相当于是内部 <code>cancelCtxKey</code>  这个变量的地址作为了一个特殊的 key，当查询这个 key 的时候就会返回当前 context 如果不是这个 key 就会向上递归的去调用 parent context 的 Value 方法查找有没有对应的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span> <span class="hljs-title">Value</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">if</span> key == &amp;cancelCtxKey &#123;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><span class="hljs-keyword">return</span> c.Context.Value(key)<br>&#125;<br></code></pre></td></tr></table></figure><p>在前面讲到构建父子上下文之间的关系的时候，有一个去查找可以被取消的父 context 的方法 <code>parentCancelCtx</code>  就用到了这个特殊 value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parentCancelCtx</span><span class="hljs-params">(parent Context)</span> <span class="hljs-params">(*cancelCtx, <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 这里先判断传入的 parent 是不是永远不可取消的，如果是就直接返回了</span><br>done := parent.Done()<br><span class="hljs-keyword">if</span> done == closedchan || done == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><br>    <span class="hljs-comment">// 这里利用了 context.Value 不断向上查询值的特点，只要出现第一个可以取消的 context 的时候就会返回</span><br>    <span class="hljs-comment">// 如果没有的话，这时候 ok 就会等于 false</span><br>p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br>    <span class="hljs-comment">// 这里去判断返回的 parent 的 channel 和传入的 parent 是不是同一个，是的话就返回这个 parent</span><br>p.mu.Lock()<br>ok = p.done == done<br>p.mu.Unlock()<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> p, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来看最重要的这个 cancel 方法，cancel 接收两个参数，removeFromParent 用于确认是不是把自己从 parent context 中移除，err 是 ctx.Err() 最后返回的错误信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span> <span class="hljs-title">cancel</span><span class="hljs-params">(removeFromParent <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;context: internal error: missing cancel error&quot;</span>)<br>&#125;<br>c.mu.Lock()<br><span class="hljs-keyword">if</span> c.err != <span class="hljs-literal">nil</span> &#123;<br>c.mu.Unlock()<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// already canceled</span><br>&#125;<br>c.err = err<br>    <span class="hljs-comment">// 由于 cancel context 的 done 是懒加载的，所以有可能存在还没有初始化的情况</span><br><span class="hljs-keyword">if</span> c.done == <span class="hljs-literal">nil</span> &#123;<br>c.done = closedchan<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">close</span>(c.done)<br>&#125;<br>    <span class="hljs-comment">// 循环的将所有的子 context 取消掉</span><br><span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span><br>child.cancel(<span class="hljs-literal">false</span>, err)<br>&#125;<br>    <span class="hljs-comment">// 将所有的子 context 和当前 context 关系解除</span><br>c.children = <span class="hljs-literal">nil</span><br>c.mu.Unlock()<br><br>    <span class="hljs-comment">// 如果需要将当前 context 从 parent context 移除，就移除掉</span><br><span class="hljs-keyword">if</span> removeFromParent &#123;<br>removeChild(c.Context, c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="超时自动取消如何实现-WithDeadline-WithTimeout"><a href="#超时自动取消如何实现-WithDeadline-WithTimeout" class="headerlink" title="超时自动取消如何实现: WithDeadline, WithTimeout"></a>超时自动取消如何实现: WithDeadline, WithTimeout</h4><p>我们先看看比较常用的 WithTimeout, 可以发现 WithTimeout 其实就是调用了 WithDeadline 然后再传入的参数上用当前时间加上了 timeout 的时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span> <span class="hljs-params">(Context, CancelFunc)</span></span> &#123;<br><span class="hljs-keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))<br>&#125;<br></code></pre></td></tr></table></figure><p>再来看一下实现超时的 timerCtx，WithDeadline 我们放到后面一点点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> timerCtx <span class="hljs-keyword">struct</span> &#123;<br>cancelCtx <span class="hljs-comment">// 这里复用了 cancelCtx</span><br>timer *time.Timer <span class="hljs-comment">// Under cancelCtx.mu.</span><br><br>deadline time.Time <span class="hljs-comment">// 这里保存了快到期的时间</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Deadline()</code>  就是返回了结构体中保存的过期时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span> <span class="hljs-title">Deadline</span><span class="hljs-params">()</span> <span class="hljs-params">(deadline time.Time, ok <span class="hljs-keyword">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">return</span> c.deadline, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>cancel</code>  其实就是复用了 cancelCtx 中的取消方法，唯一区别的地方就是在后面加上了对 timer 的判断，如果 timer 没有结束主动结束 timer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span> <span class="hljs-title">cancel</span><span class="hljs-params">(removeFromParent <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;<br>c.cancelCtx.cancel(<span class="hljs-literal">false</span>, err)<br><span class="hljs-keyword">if</span> removeFromParent &#123;<br><span class="hljs-comment">// Remove this timerCtx from its parent cancelCtx&#x27;s children.</span><br>removeChild(c.cancelCtx.Context, c)<br>&#125;<br>c.mu.Lock()<br><span class="hljs-keyword">if</span> c.timer != <span class="hljs-literal">nil</span> &#123;<br>c.timer.Stop()<br>c.timer = <span class="hljs-literal">nil</span><br>&#125;<br>c.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p>timerCtx 并没有重新实现 Done() 和 Value 方法，直接复用了 cancelCtx 的相关方法</p><p>最后我们再看看这个最重要的 WithDeadline 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, d time.Time)</span> <span class="hljs-params">(Context, CancelFunc)</span></span> &#123;<br><span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>&#125;<br><br>   <span class="hljs-comment">// 会先判断 parent context 的过期时间，如果过期时间比当前传入的时间要早的话，就没有必要再设置过期时间了</span><br>    <span class="hljs-comment">// 只需要返回 WithCancel 就可以了，因为在 parent 过期的时候，子 context 也会被取消掉</span><br><span class="hljs-keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;<br><span class="hljs-comment">// The current deadline is already sooner than the new one.</span><br><span class="hljs-keyword">return</span> WithCancel(parent)<br>&#125;<br><br>    <span class="hljs-comment">// 构造相关结构体</span><br>c := &amp;timerCtx&#123;<br>cancelCtx: newCancelCtx(parent),<br>deadline:  d,<br>&#125;<br><br>    <span class="hljs-comment">// 和 WithCancel 中的逻辑相同，构建上下文关系</span><br>propagateCancel(parent, c)<br><br>    <span class="hljs-comment">// 判断传入的时间是不是已经过期，如果已经过期了就 cancel 掉然后再返回</span><br>dur := time.Until(d)<br><span class="hljs-keyword">if</span> dur &lt;= <span class="hljs-number">0</span> &#123;<br>c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded) <span class="hljs-comment">// deadline has already passed</span><br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">false</span>, Canceled) &#125;<br>&#125;<br>c.mu.Lock()<br><span class="hljs-keyword">defer</span> c.mu.Unlock()<br><br>    <span class="hljs-comment">// 这里是超时取消的逻辑，启动 timer 时间到了之后就会调用取消方法</span><br><span class="hljs-keyword">if</span> c.err == <span class="hljs-literal">nil</span> &#123;<br>c.timer = time.AfterFunc(dur, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded)<br>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现超时控制其实就是在复用 cancelCtx 的基础上加上了一个 timer 来做定时取消</p><h4 id="如何为-Context-附加一些值-WithValue"><a href="#如何为-Context-附加一些值-WithValue" class="headerlink" title="如何为 Context 附加一些值: WithValue"></a>如何为 Context 附加一些值: WithValue</h4><p>WithValue 相对简单一点，主要就是校验了一下 Key 是不是可比较的，然后构造出一个 valueCtx 的结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Context</span></span> &#123;<br><span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> key == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil key&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;key is not comparable&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>valueCtx 主要就是嵌入了 parent context 然后附加了一个 key val</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span> &#123;<br>Context<br>key, val <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Value 的查找和之前 cancelCtx 类似，都是先判断当前有没有，没有就向上递归，只是在 cancelCtx 当中 key 是一个固定的 key 而已</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span> <span class="hljs-title">Value</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">if</span> c.key == key &#123;<br><span class="hljs-keyword">return</span> c.val<br>&#125;<br><span class="hljs-keyword">return</span> c.Context.Value(key)<br>&#125;<br></code></pre></td></tr></table></figure><p>Value 就没有实现 Context 接口的其他方法了，其他的方法全都是复用的 parent context 的方法</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h4><p>这就是文章开始时候第一个场景下的一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 模拟一个耗时的操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rpc</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br>time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;rpc done&quot;</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;<br>data <span class="hljs-keyword">string</span><br>err  error<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handle</span><span class="hljs-params">(ctx context.Context, ms <span class="hljs-keyword">int</span>)</span></span> &#123;<br>ctx, cancel := context.WithTimeout(ctx, time.Duration(ms)*time.Millisecond)<br><span class="hljs-keyword">defer</span> cancel()<br><br>r := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> result)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>data, err := rpc()<br>r &lt;- result&#123;data: data, err: err&#125;<br>&#125;()<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Printf(<span class="hljs-string">&quot;timeout: %d ms, context exit: %+v\n&quot;</span>, ms, ctx.Err())<br><span class="hljs-keyword">case</span> res := &lt;-r:<br>fmt.Printf(<span class="hljs-string">&quot;result: %s, err: %+v\n&quot;</span>, res.data, res.err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 这里模拟接受请求，启动一个协程去发起请求</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br><span class="hljs-keyword">go</span> handle(context.Background(), i*<span class="hljs-number">50</span>)<br>&#125;<br><br><span class="hljs-comment">// for test, hang</span><br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">▶ <span class="hljs-keyword">go</span> run *.<span class="hljs-keyword">go</span><br>timeout: <span class="hljs-number">50</span> ms, context exit: context deadline exceeded<br>result: rpc done, err: &lt;<span class="hljs-literal">nil</span>&gt;<br>result: rpc done, err: &lt;<span class="hljs-literal">nil</span>&gt;<br>result: rpc done, err: &lt;<span class="hljs-literal">nil</span>&gt;<br></code></pre></td></tr></table></figure><p>我们可以发现在第一次执行的时候传入的超时时间 50ms 程序超时直接退出了，但是后面超过 50ms 的时候均返回了结果。</p><h4 id="错误取消"><a href="#错误取消" class="headerlink" title="错误取消"></a>错误取消</h4><p>这是第二个场景的一个例子，假设我们在 main 中并发调用了 <code>f1</code>  <code>f2</code>  两个函数，但是 <code>f1</code>  很快就返回了，但是 <code>f2</code>  还在阻塞</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">(ctx context.Context)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;f1: %w&quot;</span>, ctx.Err())<br><span class="hljs-keyword">case</span> &lt;-time.After(time.Millisecond): <span class="hljs-comment">// 模拟短时间报错</span><br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;f1 err in 1ms&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(ctx context.Context)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;f2: %w&quot;</span>, ctx.Err())<br><span class="hljs-keyword">case</span> &lt;-time.After(time.Hour): <span class="hljs-comment">// 模拟一个耗时操作</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithTimeout(context.Background(), time.Second)<br><span class="hljs-keyword">defer</span> cancel()<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">if</span> err := f1(ctx); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>cancel()<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">if</span> err := f2(ctx); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>cancel()<br>&#125;<br>&#125;()<br><br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果，可以看到 f1 返回之后 f2 立即就返回了，并且报错 context 被取消</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">▶ <span class="hljs-keyword">go</span> run *.<span class="hljs-keyword">go</span><br>f1 err in <span class="hljs-number">1</span>ms<br>f2: context canceled<br></code></pre></td></tr></table></figure><p>细心的同学可能发现了，这个例子不就是 errgroup 的逻辑么，是的它就是类似 errgroup 的简单逻辑，这时候再反过来去看一下 《<a href="https://lailin.xyz/post/go-training-week3-errgroup.html">Week03: Go 并发编程(七) 深入理解 errgroup - Mohuishou</a>》这篇文章可能会有不一样的体会</p><h4 id="传递共享数据"><a href="#传递共享数据" class="headerlink" title="传递共享数据"></a>传递共享数据</h4><p>一般会用来传递 tracing id, request id 这种数据，不要用来传递可选参数，这里借用一下饶大的一个例子，在实际的生产案例中我们代码也是这样大同小异</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> requestIDKey <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithRequestID</span><span class="hljs-params">(next http.Handler)</span> <span class="hljs-title">http</span>.<span class="hljs-title">Handler</span></span> &#123;<br><span class="hljs-keyword">return</span> http.HandlerFunc(<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 从 header 中提取 request-id</span><br>reqID := req.Header.Get(<span class="hljs-string">&quot;X-Request-ID&quot;</span>)<br><span class="hljs-comment">// 创建 valueCtx。使用自定义的类型，不容易冲突</span><br>ctx := context.WithValue(<br>req.Context(), requestIDKey, reqID)<br><br><span class="hljs-comment">// 创建新的请求</span><br>req = req.WithContext(ctx)<br><br><span class="hljs-comment">// 调用 HTTP 处理函数</span><br>next.ServeHTTP(rw, req)<br>&#125;<br>)<br>&#125;<br><br><span class="hljs-comment">// 获取 request-id</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetRequestID</span><span class="hljs-params">(ctx context.Context)</span> <span class="hljs-title">string</span></span> &#123;<br>ctx.Value(requestIDKey).(<span class="hljs-keyword">string</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handle</span><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 拿到 reqId，后面可以记录日志等等</span><br>reqID := GetRequestID(req.Context())<br>...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>handler := WithRequestID(http.HandlerFunc(Handle))<br>http.ListenAndServe(<span class="hljs-string">&quot;/&quot;</span>, handler)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="在某些情况下可以用来防止-goroutine-泄漏"><a href="#在某些情况下可以用来防止-goroutine-泄漏" class="headerlink" title="在某些情况下可以用来防止 goroutine 泄漏"></a>在某些情况下可以用来防止 goroutine 泄漏</h4><p>我们看一下官方文档的这个例子, 这里面 gen 这个函数中如果不使用 context done 来控制的话就会导致 goroutine 泄漏，因为这里面的 for 是一个死循环，没有 ctx 就没有相关的退出机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// gen generates integers in a separate goroutine and</span><br><span class="hljs-comment">// sends them to the returned channel.</span><br><span class="hljs-comment">// The callers of gen need to cancel the context once</span><br><span class="hljs-comment">// they are done consuming generated integers not to leak</span><br><span class="hljs-comment">// the internal goroutine started by gen.</span><br>gen := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">int</span></span> &#123;<br>dst := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>n := <span class="hljs-number">1</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// returning not to leak the goroutine</span><br><span class="hljs-keyword">case</span> dst &lt;- n:<br>n++<br>&#125;<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> dst<br>&#125;<br><br>ctx, cancel := context.WithCancel(context.Background())<br><span class="hljs-keyword">defer</span> cancel() <span class="hljs-comment">// cancel when we are finished consuming integers</span><br><br><span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> gen(ctx) &#123;<br>fmt.Println(n)<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">5</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="使用准则-1"><a href="#使用准则-1" class="headerlink" title="使用准则"></a>使用准则</h3><p>context 包一开始就告诉了我们应该怎么用，不应该怎么用，这是应该被共同遵守的约定。</p><ul><li>对 server 应用而言，传入的请求应该创建一个 context，接受</li><li>通过 <code>WithCancel</code> , <code>WithDeadline</code> , <code>WithTimeout</code> 创建的 Context 会同时返回一个 cancel 方法，这个方法必须要被执行，不然会导致 context 泄漏，这个可以通过执行 <code>go vet</code> 命令进行检查</li><li>应该将 <code>context.Context</code> 作为函数的第一个参数进行传递，参数命名一般为 <code>ctx</code> 不应该将 Context 作为字段放在结构体中。</li><li>不要给 context 传递 nil，如果你不知道应该传什么的时候就传递 <code>context.TODO()</code></li><li>不要将函数的可选参数放在 context 当中，context 中一般只放一些全局通用的 metadata 数据，例如 tracing id 等等</li><li>context 是并发安全的可以在多个 goroutine 中并发调用</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>超时控制</li><li>错误取消</li><li>跨 goroutine 数据同步</li><li>防止 goroutine 泄漏</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>最显著的一个就是 context 引入需要修改函数签名，并且会病毒的式的扩散到每个函数上面，不过这个见仁见智，我看着其实还好</li><li>某些情况下虽然是可以做到超时返回提高用户体验，但是实际上是不会退出相关 goroutine 的，这时候可能会导致 goroutine 的泄漏，针对这个我们来看一个例子</li></ul><p>我们使用标准库的 timeout handler 来实现超时控制，底层是通过 context 来实现的。我们设置了超时时间为 1ms 并且在 handler 中模拟阻塞 1000s 不断的请求，然后看 pprof 的 goroutine 数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 这里阻塞住，goroutine 不会释放的</span><br>time.Sleep(<span class="hljs-number">1000</span> * time.Second)<br>rw.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>))<br>&#125;)<br>handler := http.TimeoutHandler(mux, time.Millisecond, <span class="hljs-string">&quot;xxx&quot;</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8066&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;()<br>http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, handler)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>查看数据我们可以发现请求返回后， goroutine 其实并未回收，但是如果不阻塞的话是会立即回收的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">goroutine profile: total <span class="hljs-number">29</span><br><span class="hljs-number">24</span> @ <span class="hljs-number">0x103b125</span> <span class="hljs-number">0x106cc9f</span> <span class="hljs-number">0x1374110</span> <span class="hljs-number">0x12b9584</span> <span class="hljs-number">0x12bb4ad</span> <span class="hljs-number">0x12c7fbf</span> <span class="hljs-number">0x106fd01</span><br></code></pre></td></tr></table></figure><p>我们来看看它的源码，超时控制主要在 ServeHTTP 中实现，我删掉了部分不关键的数据， 我们可以看到函数内部启动了一个 goroutine 去处理请求逻辑，然后再外面等待，但是这里的问题是，当 context 超时之后 ServeHTTP 这个函数就直接返回了，在这里面启动的这个 goroutine 就没人管了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *timeoutHandler)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w ResponseWriter, r *Request)</span></span> &#123;<br>ctx := h.testContext<br><span class="hljs-keyword">if</span> ctx == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">var</span> cancelCtx context.CancelFunc<br>ctx, cancelCtx = context.WithTimeout(r.Context(), h.dt)<br><span class="hljs-keyword">defer</span> cancelCtx()<br>&#125;<br>r = r.WithContext(ctx)<br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>tw := &amp;timeoutWriter&#123;<br>w:   w,<br>h:   <span class="hljs-built_in">make</span>(Header),<br>req: r,<br>&#125;<br>panicChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> p := <span class="hljs-built_in">recover</span>(); p != <span class="hljs-literal">nil</span> &#123;<br>panicChan &lt;- p<br>&#125;<br>&#125;()<br>h.handler.ServeHTTP(tw, r)<br><span class="hljs-built_in">close</span>(done)<br>&#125;()<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> p := &lt;-panicChan:<br><span class="hljs-built_in">panic</span>(p)<br><span class="hljs-keyword">case</span> &lt;-done:<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-comment">// ...</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>context 是一个优缺点都十分明显的包，这个包目前基本上已经成为了在 go 中做超时控制错误取消的标准做法，但是为了添加超时取消我们需要去修改所有的函数签名，对代码的侵入性比较大，如果之前一直都没有使用后续再添加的话还是会有一些改造成本</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://pkg.go.dev/context">context · pkg.go.dev</a></li><li><a href="https://www.flysnow.org/2017/05/12/go-in-action-go-context.html#%E5%88%9D%E8%AF%86context">Go 语言实战笔记（二十）| Go Context</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">Go 语言并发编程与 Context | Go 语言设计与实现</a></li><li><a href="https://qcrao.com/2019/06/12/dive-into-go-context/">深度解密 Go 语言之 context | qcrao</a></li><li><a href="https://blog.golang.org/context">Go Concurrency Patterns: Context - The Go Blog</a></li><li><a href="https://blog.golang.org/pipelines">Go Concurrency Patterns: Pipelines and cancellation - The Go Blog</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week03: Go 并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
      <tag>context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程(八) 深入理解 sync.Once</title>
    <link href="/post/go-training-week3-once.html"/>
    <url>/post/go-training-week3-once.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><p>在上一篇文章《<a href="https://lailin.xyz/post/go-training-week3-errgroup.html">Week03: Go 并发编程(七) 深入理解 errgroup</a>》当中看 <code>errgourp</code>  源码的时候我们发现最后返回 <code>err</code>  是通过 once 来只保证返回一个非 nil 的值的，本文就来看一下 Once 的使用与实现</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>once 的使用很简单</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>o  sync.Once<br>wg sync.WaitGroup<br>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>o.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;once&quot;</span>, i)<br>&#125;)<br>&#125;(i)<br>&#125;<br><br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">❯ <span class="hljs-keyword">go</span> run ./main.<span class="hljs-keyword">go</span><br>once <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br>done <span class="hljs-keyword">uint32</span><br>m    Mutex<br>&#125;<br></code></pre></td></tr></table></figure><p>done 用于判定函数是否执行，如果不为 0 会直接返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span> <span class="hljs-title">Do</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span> &#123;<br><span class="hljs-comment">// Note: Here is an incorrect implementation of Do:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//if atomic.CompareAndSwapUint32(&amp;o.done, 0, 1) &#123;</span><br><span class="hljs-comment">//f()</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Do guarantees that when it returns, f has finished.</span><br><span class="hljs-comment">// This implementation would not implement that guarantee:</span><br><span class="hljs-comment">// given two simultaneous calls, the winner of the cas would</span><br><span class="hljs-comment">// call f, and the second would return immediately, without</span><br><span class="hljs-comment">// waiting for the first&#x27;s call to f to complete.</span><br><span class="hljs-comment">// This is why the slow path falls back to a mutex, and why</span><br><span class="hljs-comment">// the atomic.StoreUint32 must be delayed until after f returns.</span><br><br><span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Outlined slow-path to allow inlining of the fast-path.</span><br>o.doSlow(f)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看 go 的源码真的可以学到很多东西，在这里还给出了很容易犯错的一种实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> atomic.CompareAndSwapUint32(&amp;o.done, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) &#123;<br>f()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这么实现最大的问题是，如果并发调用，一个 goroutine 执行，另外一个不会等正在执行的这个成功之后返回，而是直接就返回了，这就不能保证传入的方法一定会先执行一次了<br>所以回头看官方的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-comment">// Outlined slow-path to allow inlining of the fast-path.</span><br>    o.doSlow(f)<br>&#125;<br></code></pre></td></tr></table></figure><p>会先判断 done 是否为 0，如果不为 0 说明还没执行过，就进入 <code>doSlow</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span> <span class="hljs-title">doSlow</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span> &#123;<br>o.m.Lock()<br><span class="hljs-keyword">defer</span> o.m.Unlock()<br><span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>)<br>f()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>doSlow</code>  当中使用了互斥锁来保证只会执行一次</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Once 保证了传入的函数只会执行一次，这常用在单例模式，配置文件加载，初始化这些场景下</li><li>但是需要注意。Once 是不能复用的，只要执行过了，再传入其他的方法也不会再执行了</li><li>并且 Once.Do 在执行的过程中如果 f 出现 panic，后面也不会再执行了</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://pkg.go.dev/sync#Once">https://pkg.go.dev/sync#Once</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#once">6.2 同步原语与锁</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week03: Go 并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
      <tag>sync</tag>
      
      <tag>once</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程(七) 深入理解 errgroup</title>
    <link href="/post/go-training-week3-errgroup.html"/>
    <url>/post/go-training-week3-errgroup.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在上一篇文章 《<a href="https://lailin.xyz/post/go-training-week3-waitgroup.html">Week03: Go 并发编程(六) 深入理解 WaitGroup</a>》当中我们从源码层面深入的了解了 WaitGroup 相关的使用与实现。</p><ul><li>在一个 goroutine 需要等待多个 goroutine 完成和多个 goroutine 等待一个 goroutine 干活时都可以解决问题。</li></ul><p>虽然 WaitGroup 已经帮我们做了很好的封装，但是仍然存在一些问题，例如如果需要返回错误，或者只要一个 goroutine 出错我们就不再等其他 goroutine 了，减少资源浪费，这些 WaitGroup 都不能很好的解决，这时候就派出本文的选手 errgroup 出场了。</p><h2 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Group<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithContext</span><span class="hljs-params">(ctx context.Context)</span> <span class="hljs-params">(*Group, context.Context)</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span> <span class="hljs-title">Go</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span> <span class="hljs-title">error</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span> <span class="hljs-title">Wait</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span><br></code></pre></td></tr></table></figure><p>整个包就一个 Group 结构体</p><ul><li>通过 <code>WithContext</code>  可以创建一个带取消的 <code>Group</code></li><li>当然除此之外也可以零值的 Group 也可以直接使用，但是出错之后就不会取消其他的 goroutine 了</li><li><code>Go</code>  方法传入一个 <code>func() error</code>  内部会启动一个 goroutine 去处理</li><li><code>Wait</code>  类似 WaitGroup 的 Wait 方法，等待所有的 goroutine 结束后退出，返回的错误是一个出错的 err</li></ul><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// context 的 cancel 方法</span><br>cancel <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><br>    <span class="hljs-comment">// 复用 WaitGroup</span><br>wg sync.WaitGroup<br><br><span class="hljs-comment">// 用来保证只会接受一次错误</span><br>errOnce sync.Once<br>    <span class="hljs-comment">// 保存第一个返回的错误</span><br>err     error<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="WithContext"><a href="#WithContext" class="headerlink" title="WithContext"></a>WithContext</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithContext</span><span class="hljs-params">(ctx context.Context)</span> <span class="hljs-params">(*Group, context.Context)</span></span> &#123;<br>ctx, cancel := context.WithCancel(ctx)<br><span class="hljs-keyword">return</span> &amp;Group&#123;cancel: cancel&#125;, ctx<br>&#125;<br></code></pre></td></tr></table></figure><p><code>WithContext</code>  就是使用 <code>WithCancel</code>  创建一个可以取消的 context 将 cancel 赋值给 Group 保存起来，然后再将 context 返回回去</p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">注意这里有一个坑，在后面的代码中不要把这个 ctx 当做父 context 又传给下游，因为 errgroup 取消了，这个 context 就没用了，会导致下游复用的时候出错</div><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span> <span class="hljs-title">Go</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span> <span class="hljs-title">error</span>)</span> &#123;<br>g.wg.Add(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> g.wg.Done()<br><br><span class="hljs-keyword">if</span> err := f(); err != <span class="hljs-literal">nil</span> &#123;<br>g.errOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>g.err = err<br><span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> &#123;<br>g.cancel()<br>&#125;<br>&#125;)<br>&#125;<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Go</code>  方法其实就类似于 <code>go</code>  关键字，会启动一个携程，然后利用 <code>waitgroup</code>  来控制是否结束，如果有一个非 <code>nil</code>  的 error 出现就会保存起来并且如果有 <code>cancel</code>  就会调用 <code>cancel</code>  取消掉，使 <code>ctx</code>  返回</p><h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span> <span class="hljs-title">Wait</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>g.wg.Wait()<br><span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> &#123;<br>g.cancel()<br>&#125;<br><span class="hljs-keyword">return</span> g.err<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Wait</code>  方法其实就是调用 <code>WaitGroup</code>  等待，如果有 <code>cancel</code>  就调用一下</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><blockquote><p>这个其实是 week03 的作业</p></blockquote><p>基于  errgroup  实现一个  http server  的启动和关闭  ，以及  linux signal  信号的注册和处理，要保证能够   一个退出，全部注销退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>g, ctx := errgroup.WithContext(context.Background())<br><br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;pong&quot;</span>))<br>&#125;)<br><br><span class="hljs-comment">// 模拟单个服务错误退出</span><br>serverOut := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>mux.HandleFunc(<span class="hljs-string">&quot;/shutdown&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>serverOut &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;)<br><br>server := http.Server&#123;<br>Handler: mux,<br>Addr:    <span class="hljs-string">&quot;:8080&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// g1</span><br><span class="hljs-comment">// g1 退出了所有的协程都能退出么？</span><br><span class="hljs-comment">// g1 退出后, context 将不再阻塞，g2, g3 都会随之退出</span><br><span class="hljs-comment">// 然后 main 函数中的 g.Wait() 退出，所有协程都会退出</span><br>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> server.ListenAndServe()<br>&#125;)<br><br><span class="hljs-comment">// g2</span><br><span class="hljs-comment">// g2 退出了所有的协程都能退出么？</span><br><span class="hljs-comment">// g2 退出时，调用了 shutdown，g1 会退出</span><br><span class="hljs-comment">// g2 退出后, context 将不再阻塞，g3 会随之退出</span><br><span class="hljs-comment">// 然后 main 函数中的 g.Wait() 退出，所有协程都会退出</span><br>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>log.Println(<span class="hljs-string">&quot;errgroup exit...&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-serverOut:<br>log.Println(<span class="hljs-string">&quot;server will out...&quot;</span>)<br>&#125;<br><br>timeoutCtx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">3</span>*time.Second)<br><span class="hljs-comment">// 这里不是必须的，但是如果使用 _ 的话静态扫描工具会报错，加上也无伤大雅</span><br><span class="hljs-keyword">defer</span> cancel()<br><br>log.Println(<span class="hljs-string">&quot;shutting down server...&quot;</span>)<br><span class="hljs-keyword">return</span> server.Shutdown(timeoutCtx)<br>&#125;)<br><br><span class="hljs-comment">// g3</span><br><span class="hljs-comment">// g3 捕获到 os 退出信号将会退出</span><br><span class="hljs-comment">// g3 退出了所有的协程都能退出么？</span><br><span class="hljs-comment">// g3 退出后, context 将不再阻塞，g2 会随之退出</span><br><span class="hljs-comment">// g2 退出时，调用了 shutdown，g1 会退出</span><br><span class="hljs-comment">// 然后 main 函数中的 g.Wait() 退出，所有协程都会退出</span><br>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">0</span>)<br>signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-keyword">return</span> ctx.Err()<br><span class="hljs-keyword">case</span> sig := &lt;-quit:<br><span class="hljs-keyword">return</span> errors.Errorf(<span class="hljs-string">&quot;get os signal: %v&quot;</span>, sig)<br>&#125;<br>&#125;)<br><br>fmt.Printf(<span class="hljs-string">&quot;errgroup exiting: %+v\n&quot;</span>, g.Wait())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要用到了 errgroup 一个出错，其余取消的能力</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://pkg.go.dev/golang.org/x/sync/errgroup">https://pkg.go.dev/golang.org/x/sync/errgroup</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week03: Go 并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
      <tag>sync</tag>
      
      <tag>errgroup</tag>
      
      <tag>waitgroup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程(六) 深入理解 WaitGroup</title>
    <link href="/post/go-training-week3-waitgroup.html"/>
    <url>/post/go-training-week3-waitgroup.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><p>在前面的几篇文章中我们或多或少都用到了 WaitGroup 来等待多个 goroutine 执行结束，今天我们来深入学习一下</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><code>WaitGroup</code> 可以解决一个 goroutine 等待多个 goroutine 同时结束的场景，这个比较常见的场景就是例如 后端 worker 启动了多个消费者干活，还有爬虫并发爬取数据，多线程下载等等。<br>我们这里模拟一个 worker 的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;worker: &quot;</span>, i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>worker(i)<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">问题: 反过来支持多个 goroutine 等待一个 goroutine 完成后再干活吗？<br>看我们接下来的源码分析你就知道了</div><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> WaitGroup <span class="hljs-keyword">struct</span> &#123;<br>noCopy noCopy<br><br><span class="hljs-comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span><br><span class="hljs-comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span><br><span class="hljs-comment">// compilers do not ensure it. So we allocate 12 bytes and then use</span><br><span class="hljs-comment">// the aligned 8 bytes in them as state, and the other 4 as storage</span><br><span class="hljs-comment">// for the sema.</span><br>state1 [<span class="hljs-number">3</span>]<span class="hljs-keyword">uint32</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>WaitGroup</code> 结构十分简单，由 <code>nocopy</code> 和 <code>state1</code> 两个字段组成，其中 <code>nocopy</code> 是用来防止复制的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> noCopy <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Lock is a no-op used by -copylocks checker from `go vet`.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*noCopy)</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span>   &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*noCopy)</span> <span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>由于嵌入了 <code>nocopy</code> 所以在执行 <code>go vet</code> 时如果检查到 <code>WaitGroup</code> 被复制了就会报错。这样可以一定程度上保证 <code>WaitGroup</code> 不被复制，对了直接 go run 是不会有错误的，所以我们代码 push 之前都会强制要求进行 lint 检查，在 ci/cd 阶段也需要先进行 lint 检查，避免出现这种类似的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">~/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">06</span>_waitgroup/<span class="hljs-number">02</span> main*<br>❯ <span class="hljs-keyword">go</span> run ./main.<span class="hljs-keyword">go</span><br><br>~/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">06</span>_waitgroup/<span class="hljs-number">02</span> main*<br>❯ <span class="hljs-keyword">go</span> vet .<br># github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week03/blog/<span class="hljs-number">06</span>_waitgroup/<span class="hljs-number">02</span><br>./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>:<span class="hljs-number">9</span>: assignment copies lock value to wg2: sync.WaitGroup contains sync.noCopy<br></code></pre></td></tr></table></figure><p><code>state1</code> 的设计非常巧妙，这是一个是十二字节的数据，这里面主要包含两大块，counter 占用了 8 字节用于计数，sema 占用 4 字节用做信号量</p><p>为什么要这么搞呢？直接用两个字段一个表示 counter，一个表示 sema 不行么？<br>不行，我们看看注释里面怎么写的。</p><blockquote><p><em>// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</em> &gt; <em>// 64-bit atomic operations require 64-bit alignment, but 32-bit</em> &gt; <em>// compilers do not ensure it. So we allocate 12 bytes and then use</em> &gt; <em>// the aligned 8 bytes in them as state, and the other 4 as storage</em> &gt; <em>// for the sema.</em></p></blockquote><p>这段话的关键点在于，在做 64 位的原子操作的时候必须要保证 64 位（8 字节）对齐，如果没有对齐的就会有问题，但是 32 位的编译器并不能保证 64 位对齐所以这里用一个 12 字节的 state1 字段来存储这两个状态，然后根据是否 8 字节对齐选择不同的保存方式。<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1609085423413-88a8f508-0269-4cf9-9474-9f78b78a53ea.svg" alt="02_Go进阶03_blog_waitgroup.drawio.svg"><br>这个操作巧妙在哪里呢？</p><ul><li>如果是 64 位的机器那肯定是 8 字节对齐了的，所以是上面第一种方式</li><li>如果在 32 位的机器上<ul><li>如果恰好 8 字节对齐了，那么也是第一种方式取前面的 8 字节数据</li><li>如果是没有对齐，但是 32 位 4 字节是对齐了的，所以我们只需要后移四个字节，那么就 8 字节对齐了，所以是第二种方式</li></ul></li></ul><p>所以通过 sema 信号量这四个字节的位置不同，保证了 counter 这个字段无论在 32 位还是 64 为机器上都是 8 字节对齐的，后续做 64 位原子操作的时候就没问题了。<br>这个实现是在 <code>state</code> 方法实现的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span> <span class="hljs-title">state</span><span class="hljs-params">()</span> <span class="hljs-params">(statep *<span class="hljs-keyword">uint64</span>, semap *<span class="hljs-keyword">uint32</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="hljs-number">8</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> (*<span class="hljs-keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="hljs-number">2</span>]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> (*<span class="hljs-keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="hljs-number">1</span>])), &amp;wg.state1[<span class="hljs-number">0</span>]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>state</code> 方法返回 counter 和信号量，通过 <code>uintptr(unsafe.Pointer(&amp;wg.state1))%8 == 0</code> 来判断是否 8 字节对齐</p><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span> <span class="hljs-title">Add</span><span class="hljs-params">(delta <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 先从 state 当中把数据和信号量取出来</span><br>statep, semap := wg.state()<br><br>    <span class="hljs-comment">// 在 waiter 上加上 delta 值</span><br>state := atomic.AddUint64(statep, <span class="hljs-keyword">uint64</span>(delta)&lt;&lt;<span class="hljs-number">32</span>)<br>    <span class="hljs-comment">// 取出当前的 counter</span><br>v := <span class="hljs-keyword">int32</span>(state &gt;&gt; <span class="hljs-number">32</span>)<br>    <span class="hljs-comment">// 取出当前的 waiter，正在等待 goroutine 数量</span><br>w := <span class="hljs-keyword">uint32</span>(state)<br><br>    <span class="hljs-comment">// counter 不能为负数</span><br><span class="hljs-keyword">if</span> v &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync: negative WaitGroup counter&quot;</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 这里属于防御性编程</span><br>    <span class="hljs-comment">// w != 0 说明现在已经有 goroutine 在等待中，说明已经调用了 Wait() 方法</span><br>    <span class="hljs-comment">// 这时候 delta &gt; 0 &amp;&amp; v == int32(delta) 说明在调用了 Wait() 方法之后又想加入新的等待者</span><br>    <span class="hljs-comment">// 这种操作是不允许的</span><br><span class="hljs-keyword">if</span> w != <span class="hljs-number">0</span> &amp;&amp; delta &gt; <span class="hljs-number">0</span> &amp;&amp; v == <span class="hljs-keyword">int32</span>(delta) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 如果当前没有人在等待就直接返回，并且 counter &gt; 0</span><br><span class="hljs-keyword">if</span> v &gt; <span class="hljs-number">0</span> || w == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>    <span class="hljs-comment">// 这里也是防御 主要避免并发调用 add 和 wait</span><br><span class="hljs-keyword">if</span> *statep != state &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 唤醒所有 waiter，看到这里就回答了上面的问题了</span><br>*statep = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ; w != <span class="hljs-number">0</span>; w-- &#123;<br>runtime_Semrelease(semap, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h3><p>wait 主要就是等待其他的 goroutine 完事之后唤醒</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span> <span class="hljs-title">Wait</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 先从 state 当中把数据和信号量的地址取出来</span><br>    statep, semap := wg.state()<br><br><span class="hljs-keyword">for</span> &#123;<br>     <span class="hljs-comment">// 这里去除 counter 和 waiter 的数据</span><br>state := atomic.LoadUint64(statep)<br>v := <span class="hljs-keyword">int32</span>(state &gt;&gt; <span class="hljs-number">32</span>)<br>w := <span class="hljs-keyword">uint32</span>(state)<br><br>        <span class="hljs-comment">// counter = 0 说明没有在等的，直接返回就行</span><br>        <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Counter is 0, no need to wait.</span><br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// waiter + 1，调用一次就多一个等待者，然后休眠当前 goroutine 等待被唤醒</span><br><span class="hljs-keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="hljs-number">1</span>) &#123;<br>runtime_Semacquire(semap)<br><span class="hljs-keyword">if</span> *statep != <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h3><p>这个只是 add 的简单封装</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span> <span class="hljs-title">Done</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>WaitGroup</code> 可以用于一个 goroutine 等待多个 goroutine 干活完成，也可以多个 goroutine 等待一个 goroutine 干活完成，是一个多对多的关系<ul><li>多个等待一个的典型案例是 <a href="https://pkg.go.dev/golang.org/x/sync/singleflight">singleflight</a>，这个在后面将微服务可用性的时候还会再讲到，感兴趣可以看看源码</li></ul></li><li><code>Add(n&gt;0)</code> 方法应该在启动 goroutine 之前调用，然后在 goroution 内部调用 <code>Done</code> 方法</li><li><code>WaitGroup</code> 必须在 <code>Wait</code> 方法返回之后才能再次使用</li><li><code>Done</code> 只是 <code>Add</code> 的简单封装，所以实际上是可以通过一次加一个比较大的值减少调用，或者达到快速唤醒的目的。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://pkg.go.dev/sync">https://pkg.go.dev/sync</a> 官网文档，必读</li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/">Go 语言设计与实现-6.2 同步原语与锁</a> 这本书值得一看</li><li><a href="https://gobyexample.com/waitgroups">Go by Example: WaitGroups</a></li><li><a href="https://golang.org/issues/8005#issuecomment-190753527">https://golang.org/issues/8005#issuecomment-190753527</a></li><li><a href="https://juejin.cn/post/6893019249263001613">Golang 源码系列 sync.waitgroup 源码剖析</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week03: Go 并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
      <tag>sync</tag>
      
      <tag>waitgroup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程(五) 深入理解 sync/atomic</title>
    <link href="/post/go-training-week3-atomic.html"/>
    <url>/post/go-training-week3-atomic.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在上一篇文章《<a href="https://lailin.xyz/post/go-training-week3-sync.html">Week03: Go 并发编程(四) 深入理解 Mutex</a>》当中我们主要讲到了互斥锁以及读写锁的使用以及源码解析。在看源码的时候我们可以发现里面使用了很多 atomic 包的方法来保证原子，那么我们就趁热打铁接下来就随着本文来看一看 atomic 应该怎么用，以及它又是如何实现的</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>上一篇文章我们在讲读写锁的时候讲到了一个配置读取的例子，这里我们使用 atomic 实现看一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Config atomic 实现</span><br><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>v atomic.Value <span class="hljs-comment">// 假设 data 就是整个 config 了</span><br>&#125;<br><br><span class="hljs-comment">// Get get config data</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Config)</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span> []<span class="hljs-title">int</span></span> &#123;<br><span class="hljs-comment">// 这里偷个懒，不要学</span><br><span class="hljs-keyword">return</span> (*c.v.Load().(*[]<span class="hljs-keyword">int</span>))<br>&#125;<br><br><span class="hljs-comment">// Set set config data</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Config)</span> <span class="hljs-title">Set</span><span class="hljs-params">(n []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>c.v.Store(&amp;n)<br>&#125;<br></code></pre></td></tr></table></figure><p>跑一个一样的测试，可以发现 atomic 的性能又好上了许多</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">❯ <span class="hljs-keyword">go</span> test -race -bench=.<br>goos: linux<br>goarch: amd64<br>pkg: github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week03/blog/<span class="hljs-number">05</span>_atomic<br>BenchmarkMutexConfig<span class="hljs-number">-4</span>           <span class="hljs-number">1021684</span>              <span class="hljs-number">1121</span> ns/op<br>BenchmarkRWMutexConfig<span class="hljs-number">-4</span>         <span class="hljs-number">2604524</span>               <span class="hljs-number">433</span> ns/op<br>BenchmarkConfig<span class="hljs-number">-4</span>                <span class="hljs-number">6941658</span>               <span class="hljs-number">170</span> ns/op<br>PASS<br></code></pre></td></tr></table></figure><p><code>atomic.Value</code>  这种适合配置文件这种读特别多，写特别少的场景，因为他是 COW（Copy On Write）写时复制的一种思想，COW 就是指我需要写入的时候我先把老的数据复制一份到一个新的对象，然后再写入新的值。<br>我们看看维基百科的描述，我觉得已经说得很清楚了</p><blockquote><p>写入时复制（英语：Copy-on-write，简称 COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p></blockquote><p>这种思路会有一个问题，就是可能有部分 goroutine 在使用老的对象，所以老的对象不会立即被回收，如果存在大量写入的话，会导致产生大量的副本，性能反而不一定好 。<br>这种方式的好处就是不用加锁，所以也不会有 goroutine 的上下文切换，并且在读取的时候大家都读取的相同的副本所以性能上回好一些。<br>COW 策略在 linux， redis 当中都用的很多，具体可以看一下我后面的参考文献，本文就不展开讲了。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="方法一览"><a href="#方法一览" class="headerlink" title="方法一览"></a>方法一览</h3><p>如果去看文档会发现 atomic 的函数签名有很多，但是大部分都是重复的为了不同的数据类型创建了不同的签名，这就是没有泛型的坏处了，基础库会比较麻烦</p><p>1、第一类 <code>AddXXX</code>  当需要添加的值为负数的时候，做减法，正数做加法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第一类，AddXXX，delta 为</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddInt32</span><span class="hljs-params">(addr *<span class="hljs-keyword">int32</span>, delta <span class="hljs-keyword">int32</span>)</span> <span class="hljs-params">(<span class="hljs-built_in">new</span> <span class="hljs-keyword">int32</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddInt64</span><span class="hljs-params">(addr *<span class="hljs-keyword">int64</span>, delta <span class="hljs-keyword">int64</span>)</span> <span class="hljs-params">(<span class="hljs-built_in">new</span> <span class="hljs-keyword">int64</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUint32</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint32</span>, delta <span class="hljs-keyword">uint32</span>)</span> <span class="hljs-params">(<span class="hljs-built_in">new</span> <span class="hljs-keyword">uint32</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUint64</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint64</span>, delta <span class="hljs-keyword">uint64</span>)</span> <span class="hljs-params">(<span class="hljs-built_in">new</span> <span class="hljs-keyword">uint64</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUintptr</span><span class="hljs-params">(addr *<span class="hljs-keyword">uintptr</span>, delta <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-params">(<span class="hljs-built_in">new</span> <span class="hljs-keyword">uintptr</span>)</span></span><br></code></pre></td></tr></table></figure><p>2、第二类 <code>CompareAndSwapXXX</code> CAS 操作，  会先比较传入的地址的值是否是 old，如果是的话就尝试赋新值，如果不是的话就直接返回 false，返回 true 时表示赋值成功。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapInt32</span><span class="hljs-params">(addr *<span class="hljs-keyword">int32</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-keyword">int32</span>)</span> <span class="hljs-params">(swapped <span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapInt64</span><span class="hljs-params">(addr *<span class="hljs-keyword">int64</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-keyword">int64</span>)</span> <span class="hljs-params">(swapped <span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapPointer</span><span class="hljs-params">(addr *unsafe.Pointer, old, <span class="hljs-built_in">new</span> unsafe.Pointer)</span> <span class="hljs-params">(swapped <span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapUint32</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint32</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-keyword">uint32</span>)</span> <span class="hljs-params">(swapped <span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapUint64</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint64</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-keyword">uint64</span>)</span> <span class="hljs-params">(swapped <span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapUintptr</span><span class="hljs-params">(addr *<span class="hljs-keyword">uintptr</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-params">(swapped <span class="hljs-keyword">bool</span>)</span></span><br></code></pre></td></tr></table></figure><p>3、第三类 <code>LoadXXX</code> ，从某个地址中取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadInt32</span><span class="hljs-params">(addr *<span class="hljs-keyword">int32</span>)</span> <span class="hljs-params">(val <span class="hljs-keyword">int32</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadInt64</span><span class="hljs-params">(addr *<span class="hljs-keyword">int64</span>)</span> <span class="hljs-params">(val <span class="hljs-keyword">int64</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadPointer</span><span class="hljs-params">(addr *unsafe.Pointer)</span> <span class="hljs-params">(val unsafe.Pointer)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadUint32</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint32</span>)</span> <span class="hljs-params">(val <span class="hljs-keyword">uint32</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadUint64</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint64</span>)</span> <span class="hljs-params">(val <span class="hljs-keyword">uint64</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadUintptr</span><span class="hljs-params">(addr *<span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-params">(val <span class="hljs-keyword">uintptr</span>)</span></span><br></code></pre></td></tr></table></figure><p>4、第四类 <code>StoreXXX</code> ，给某个地址赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreInt32</span><span class="hljs-params">(addr *<span class="hljs-keyword">int32</span>, val <span class="hljs-keyword">int32</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreInt64</span><span class="hljs-params">(addr *<span class="hljs-keyword">int64</span>, val <span class="hljs-keyword">int64</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StorePointer</span><span class="hljs-params">(addr *unsafe.Pointer, val unsafe.Pointer)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreUint32</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint32</span>, val <span class="hljs-keyword">uint32</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreUint64</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint64</span>, val <span class="hljs-keyword">uint64</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreUintptr</span><span class="hljs-params">(addr *<span class="hljs-keyword">uintptr</span>, val <span class="hljs-keyword">uintptr</span>)</span></span><br></code></pre></td></tr></table></figure><p>5、第五类 <code>SwapXXX</code> ，交换两个值，并且返回老的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapInt32</span><span class="hljs-params">(addr *<span class="hljs-keyword">int32</span>, <span class="hljs-built_in">new</span> <span class="hljs-keyword">int32</span>)</span> <span class="hljs-params">(old <span class="hljs-keyword">int32</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapInt64</span><span class="hljs-params">(addr *<span class="hljs-keyword">int64</span>, <span class="hljs-built_in">new</span> <span class="hljs-keyword">int64</span>)</span> <span class="hljs-params">(old <span class="hljs-keyword">int64</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapPointer</span><span class="hljs-params">(addr *unsafe.Pointer, <span class="hljs-built_in">new</span> unsafe.Pointer)</span> <span class="hljs-params">(old unsafe.Pointer)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapUint32</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint32</span>, <span class="hljs-built_in">new</span> <span class="hljs-keyword">uint32</span>)</span> <span class="hljs-params">(old <span class="hljs-keyword">uint32</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapUint64</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint64</span>, <span class="hljs-built_in">new</span> <span class="hljs-keyword">uint64</span>)</span> <span class="hljs-params">(old <span class="hljs-keyword">uint64</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapUintptr</span><span class="hljs-params">(addr *<span class="hljs-keyword">uintptr</span>, <span class="hljs-built_in">new</span> <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-params">(old <span class="hljs-keyword">uintptr</span>)</span></span><br></code></pre></td></tr></table></figure><p>6、最后一类 <code>Value</code>  用于任意类型的值的 Store、Load，我们开始的案例就用到了这个，这是 1.4 版本之后引入的，签名的方法都只能作用于特定的类型，引入这个方法之后就可以用于任意类型了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Value<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Value)</span> <span class="hljs-title">Load</span><span class="hljs-params">()</span> <span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Value)</span> <span class="hljs-title">Store</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br></code></pre></td></tr></table></figure><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>在 <code>sync/atomic</code>  包中的源码除了 <code>Value</code>  之外其他的函数都是没有直接的源码的，需要去 <code>runtime/internal/atomic</code>  中找寻，这里为 <code>CAS</code>  函数为例，其他的都是大同小异</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// bool Cas(int32 *val, int32 old, int32 new)</span><br><span class="hljs-comment">// Atomically:</span><br><span class="hljs-comment">//if(*val == old)&#123;</span><br><span class="hljs-comment">//*val = new;</span><br><span class="hljs-comment">//return 1;</span><br><span class="hljs-comment">//&#125; else</span><br><span class="hljs-comment">//return 0;</span><br>TEXT runtime∕internal∕atomic·Cas(SB),NOSPLIT,$<span class="hljs-number">0</span><span class="hljs-number">-17</span><br>MOVQptr+<span class="hljs-number">0</span>(FP), BX<br>MOVLold+<span class="hljs-number">8</span>(FP), AX<br>MOVL<span class="hljs-built_in">new</span>+<span class="hljs-number">12</span>(FP), CX<br>LOCK<br>CMPXCHGLCX, <span class="hljs-number">0</span>(BX)<br>SETEQret+<span class="hljs-number">16</span>(FP)<br>RET<br></code></pre></td></tr></table></figure><p>在注释部分写的非常清楚，这个函数主要就是先比较一下当前传入的地址的值是否和 old 值相等，如果相等，就赋值新值返回 true，如果不相等就返回 false<br>我们看这个具体汇编代码就可以发现，使用了 <code>LOCK</code>  来保证操作的原子性，《<a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html#%E5%86%85%E5%AD%98%E9%87%8D%E6%8E%92">Week03: Go 并发编程(二) Go 内存模型</a>》提到过的一致性问题， <code>CMPXCHG</code>  指令其实就是 CPU 实现的 CAS 操作。</p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">关于 LOCK 指令通过查阅 intel 的手册我们可以发现，对于P6之前的处理器，LOCK 指令会总是锁总线，但是 P6 之后可能会执行“缓存锁定”，如果被锁定的内存区域被缓存在了处理器中，这个时候会通过缓存一致性来保证操作的原子性</div><h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Value <span class="hljs-keyword">struct</span> &#123;<br>v <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构非常简单，只有一个 v 用来保存传入的值</p><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p>我们先看看 store 方法，store 方法会将值存储为 x，这里需要注意，每次传入的 x 不能为 nil，并且他们类型必须是相同的，不然会导致 panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Value)</span> <span class="hljs-title">Store</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync/atomic: store of nil value into Value&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// ifaceWords 其实就是定义了一下 interface 的结构，包含 data 和 type 两部分</span><br>    <span class="hljs-comment">// 这里 vp 是原有值</span><br>    <span class="hljs-comment">// xp 是传入的值</span><br>vp := (*ifaceWords)(unsafe.Pointer(v))<br>xp := (*ifaceWords)(unsafe.Pointer(&amp;x))<br>    <span class="hljs-comment">// for 循环不断尝试</span><br><span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-comment">// 这里先用原子方法取一下老的类型值</span><br>typ := LoadPointer(&amp;vp.typ)<br><span class="hljs-keyword">if</span> typ == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// 等于 nil 就说明这是第一次 store</span><br>            <span class="hljs-comment">// 调用 runtime 的方法禁止抢占，避免操作完成一半就被抢占了</span><br>            <span class="hljs-comment">// 同时可以避免 GC 的时候看到 unsafe.Pointer(^uintptr(0)) 这个中间状态的值</span><br>runtime_procPin()<br><span class="hljs-keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="hljs-literal">nil</span>, unsafe.Pointer(^<span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>))) &#123;<br>runtime_procUnpin()<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// 分别把值和类型保存下来</span><br>StorePointer(&amp;vp.data, xp.data)<br>StorePointer(&amp;vp.typ, xp.typ)<br>runtime_procUnpin()<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">uintptr</span>(typ) == ^<span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果判断发现这个类型是这个固定值，说明当前第一次赋值还没有完成，所以进入自旋等待</span><br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 第一次赋值已经完成，判断新的赋值的类型和之前是否一致，如果不一致就直接 panic</span><br><span class="hljs-keyword">if</span> typ != xp.typ &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync/atomic: store of inconsistently typed value into Value&quot;</span>)<br>&#125;<br>        <span class="hljs-comment">// 保存值</span><br>StorePointer(&amp;vp.data, xp.data)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的逻辑都写在注释中了，这里面复杂逻辑在第一次写入，因为第一次写入的时候有两次原子写操作，所以这个时候用 typ 值作为一个判断，通过不同值判断当前所处的状态，这个在我们业务代码中其实也经常用到。然后因为引入了这个中间状态，所以又使用了 <code>runtime_procPin</code>  方法避免抢占</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sync_runtime_procPin</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> procPin()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">procPin</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// 获取到当前 goroutine 的 m</span><br>_g_ := getg()<br>mp := _g_.m<br><br>    <span class="hljs-comment">// unpin 的时候就是 locks--</span><br>mp.locks++<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">int</span>(mp.p.ptr().id)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Value)</span> <span class="hljs-title">Load</span><span class="hljs-params">()</span> <span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>vp := (*ifaceWords)(unsafe.Pointer(v))<br>    <span class="hljs-comment">// 先拿到类型值</span><br>typ := LoadPointer(&amp;vp.typ)<br>    <span class="hljs-comment">// 这个说明还没有第一次 store 或者是第一次 store 还没有完成</span><br><span class="hljs-keyword">if</span> typ == <span class="hljs-literal">nil</span> || <span class="hljs-keyword">uintptr</span>(typ) == ^<span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// First store not yet completed.</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>    <span class="hljs-comment">// 获取值</span><br>data := LoadPointer(&amp;vp.data)<br>    <span class="hljs-comment">// 构造 x 类型</span><br>xp := (*ifaceWords)(unsafe.Pointer(&amp;x))<br>xp.typ = typ<br>xp.data = data<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实战-实现一个“无锁”栈"><a href="#实战-实现一个“无锁”栈" class="headerlink" title="实战: 实现一个“无锁”栈"></a>实战: 实现一个“无锁”栈</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync/atomic&quot;</span><br><span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-comment">// LFStack 无锁栈</span><br><span class="hljs-comment">// 使用链表实现</span><br><span class="hljs-keyword">type</span> LFStack <span class="hljs-keyword">struct</span> &#123;<br>head unsafe.Pointer <span class="hljs-comment">// 栈顶</span><br>&#125;<br><br><span class="hljs-comment">// Node 节点</span><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>val  <span class="hljs-keyword">int32</span><br>next unsafe.Pointer<br>&#125;<br><br><span class="hljs-comment">// NewLFStack NewLFStack</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLFStack</span><span class="hljs-params">()</span> *<span class="hljs-title">LFStack</span></span> &#123;<br>n := unsafe.Pointer(&amp;Node&#123;&#125;)<br><span class="hljs-keyword">return</span> &amp;LFStack&#123;head: n&#125;<br>&#125;<br><br><span class="hljs-comment">// Push 入栈</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *LFStack)</span> <span class="hljs-title">Push</span><span class="hljs-params">(v <span class="hljs-keyword">int32</span>)</span></span> &#123;<br>n := &amp;Node&#123;val: v&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 先取出栈顶</span><br>old := atomic.LoadPointer(&amp;s.head)<br>n.next = old<br><span class="hljs-keyword">if</span> atomic.CompareAndSwapPointer(&amp;s.head, old, unsafe.Pointer(n)) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Pop 出栈，没有数据时返回 nil</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *LFStack)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">int32</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 先取出栈顶</span><br>old := atomic.LoadPointer(&amp;s.head)<br><span class="hljs-keyword">if</span> old == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br>oldNode := (*Node)(old)<br><span class="hljs-comment">// 取出下一个节点</span><br>next := atomic.LoadPointer(&amp;oldNode.next)<br><span class="hljs-comment">// 重置栈顶</span><br><span class="hljs-keyword">if</span> atomic.CompareAndSwapPointer(&amp;s.head, old, next) &#123;<br><span class="hljs-keyword">return</span> oldNode.val<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的无锁其实只是没用互斥锁，用了原子操作，前面我们看 atomic 的源码的时候可以发现实际上在 CPU 上还是有锁的，只是我们这个锁的粒度非常小</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然在一些情况下 atomic 的性能要好很多，但是这个是一个 low level 的库，在实际的业务代码中最好还是使用 channel 但是我们也需要知道，在一些基础库，或者是需要极致性能的地方用上这个还是很爽的，但是使用的过程中一定要小心，不然还是会容易出 bug。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://pkg.go.dev/sync/atomic">https://pkg.go.dev/sync/atomic</a></li><li><a href="https://blog.betacat.io/post/golang-atomic-value-exploration/">Go 语言标准库中 atomic.Value 的前世今生</a></li><li><a href="https://xie.infoq.cn/article/562eff7a1108a7a2bc46058ca">深入浅出 Go - sync/atomic 源码分析</a></li><li><a href="https://juejin.cn/post/6844903702373859335">COW 奶牛！Copy On Write 机制了解一下</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD">维基百科: COW</a></li><li><a href="https://albk.tech/%E8%81%8A%E8%81%8ACPU%E7%9A%84LOCK%E6%8C%87%E4%BB%A4.html">聊聊 CPU 的 LOCK 指令</a></li><li><a href="https://zhuanlan.zhihu.com/p/24146167">浅论 Lock 与 X86 Cache 一致性</a></li><li><a href="https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf">intel 手册</a></li><li><a href="https://colobu.com/2020/08/14/lock-free-queue-in-go/">使用 Go 实现 lock-free 的队列</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week03: Go 并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
      <tag>atomic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程(四) 深入理解 Mutex</title>
    <link href="/post/go-training-week3-sync.html"/>
    <url>/post/go-training-week3-sync.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>前面几篇文章当中我们都反复提到了 goroutine 建是简单的，但是我们仍然要小心，习惯总会不经意间的导致我们写出很多 bug 对于语言规范没有定义的内容我们不要做任何假设。我们需要通过同步语义控制他们的执行顺序，关于之前的内容可以看前面的三篇文章：</p><ul><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go 并发编程(一) goroutine</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go 并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go 并发编程(三) data race</a></li></ul><p>接下来的几篇文章就让我们我们一起来了解一下 sync 包相关的一些用法，以及部分实现原理，当然这里说是 sync 包，实际上包含了三个包分别是: sync, sync/atomic, golang.org/x/sync/errgroup</p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">这些包提供了一些基础的同步语义，但是在实际的并发编程当中，我们应该使用 channel 来进行同步控制。“Share memory by communicating; don’t communicate by sharing memory.”</div><h1 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h1><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>我们先来看一下上一篇文章说到的例子应该怎么改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.Mutex<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> routine(i)<br>&#125;<br>wg.Wait()<br>fmt.Printf(<span class="hljs-string">&quot;Final Counter: %d\n&quot;</span>, counter)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">routine</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>mu.Lock()<br>counter++<br>mu.Unlock()<br>&#125;<br>wg.Done()<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要的目的就是为了保护我们临界区的数据，通过锁来进行保证。锁的使用非常的简单，但是还是有几个需要注意的点</p><ul><li>锁的范围要尽量的小，不要搞很多大锁</li><li>用锁一定要解锁，小心产生死锁</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>我们来看一下在 Go 中锁是怎么实现的</p><h3 id="锁的实现模式-5"><a href="#锁的实现模式-5" class="headerlink" title="锁的实现模式[5]"></a>锁的实现模式[5]</h3><ul><li><strong>Barging</strong>: 这种模式是为了提高吞吐量，当锁被释放时，它会唤醒第一个等待者，然后把锁给第一个等待者或者给第一个请求锁的人</li></ul><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1608967840701-d8c54ee4-964b-49d0-8fab-6f98dd777fd2.png" alt="1_B1atM-b6GPDS0_Q_TPEUBw.png"></p><ul><li><strong>Handoff: </strong>当锁释放时候，锁会一直持有直到第一个等待者准备好获取锁。它降低了吞吐量，因为锁被持有，即使另一个 goroutine 准备获取它。<strong><em>这种模式可以解决公平性的问题，因为在 Barging 模式下可能会存在被唤醒的 goroutine 永远也获取不到锁的情况，毕竟一直在 cpu 上跑着的 goroutine 没有上下文切换会更快一些。缺点就是性能会相对差一些</em></strong></li></ul><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1608967902210-d4c2937f-56fd-49e8-a5a3-903bec31e6fc.png" alt="image.png"></p><ul><li><strong>Spining：</strong>自旋在等待队列为空或者应用程序重度使用锁时效果不错。Parking 和 Unparking goroutines 有不低的性能成本开销，相比自旋来说要慢得多。<em><strong>但是自旋是有成本的，所以在 go 的实现中进入自旋的条件十分的苛刻。</strong></em></li></ul><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1608967913891-eb4cf780-6ffd-4a2d-a3d5-8e05d7e3fce3.png" alt="image.png"></p><h3 id="Go-Mutex-实现原理"><a href="#Go-Mutex-实现原理" class="headerlink" title="Go Mutex 实现原理"></a>Go Mutex 实现原理</h3><p>我们先来看一下在 Go 中具体是怎么实现的，我们先讲原理再看源码，避免看的云里雾里的。**</p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>如下图所示，Go 在 1.15 的版本中锁的实现结合上面提到的三种模式，调用 Lock 方法的时候。</p><ol><li>首先如果当前锁处于初始化状态就直接用 CAS 方法尝试获取锁，这是<strong>_ Fast Path_</strong></li><li>如果失败就进入<strong><em> Slow Path</em></strong><ol><li>会首先判断当前能不能进入自旋状态，如果可以就进入自旋，最多自旋 4 次</li><li>自旋完成之后，就会去计算当前的锁的状态</li><li>然后尝试通过 CAS 获取锁</li><li>如果没有获取到就调用 <code>runtime_SemacquireMutex</code> 方法休眠当前 goroutine 并且尝试获取信号量</li><li>goroutine 被唤醒之后会先判断当前是否处在饥饿状态，（如果当前 goroutine 超过 1ms 都没有获取到锁就会进饥饿模式） 1. 如果处在饥饿状态就会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出 1. 如果不在，就会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环<br><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">CAS 方法在这里指的是 <code>atomic.CompareAndSwapInt32(addr, old, new) bool</code> 方法，这个方法会先比较传入的地址的值是否是 old，如果是的话就尝试赋新值，如果不是的话就直接返回 false，返回 true 时表示赋值成功<br>饥饿模式是 Go 1.9 版本之后引入的优化，用于解决公平性的问题[10]</div><br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1608970759375-09d8cda7-77ac-48d3-b2f3-b8890e927bd4.svg" alt="02_Go进阶03_blog_sync.drawio.svg"></li></ol></li></ol><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>解锁的流程相对于加锁简单许多<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1608978117259-455cf28e-aa1e-46cf-8fd6-6040ed6c0a7a.svg" alt="02_Go进阶03_blog_sync.drawio.svg"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Mutex-基本结构"><a href="#Mutex-基本结构" class="headerlink" title="Mutex 基本结构"></a>Mutex 基本结构</h3><p>知道其中的原理之后，我们再来看看源码分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>state <span class="hljs-keyword">int32</span><br>sema  <span class="hljs-keyword">uint32</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Mutex</code>  结构体由 <code>state</code>  <code>sema</code>  两个 4 字节成员组成，其中 <code>state</code>  表示了当前锁的状态， <code>sema</code>  是用于控制锁的信号量<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1608972241012-8c0fe8e2-b1c8-4696-a9c4-454e11753e0f.svg" alt="02_Go进阶03_blog_sync.drawio.svg"><br><code>state</code>  字段的最低三位表示三种状态，分别是 <code>mutexLocked</code>  <code>mutexWoken</code> <code>mutexStarving</code> ，剩下的用于统计当前在等待锁的 goroutine 数量</p><ul><li><code>mutexLocked</code>  表示是否处于锁定状态</li><li><code>mutexWoken</code> 表示是否处于唤醒状态</li><li><code>mutexStarving</code> 表示是否处于饥饿状态</li></ul><h3 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h3><p>回味一下上面看到的流程图，我们来看看互斥锁是如何加锁的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// Fast path: grab unlocked mutex.</span><br><span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="hljs-number">0</span>, mutexLocked) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// Slow path (outlined so that the fast path can be inlined)</span><br>m.lockSlow()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当我们调用 <code>Lock</code>  方法的时候，会先尝试走 Fast Path，也就是如果当前互斥锁如果处于未加锁的状态，尝试加锁，只要加锁成功就直接返回</li><li>否则的话就进入 slow path</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">lockSlow</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> waitStartTime <span class="hljs-keyword">int64</span> <span class="hljs-comment">// 等待时间</span><br>starving := <span class="hljs-literal">false</span> <span class="hljs-comment">// 是否处于饥饿状态</span><br>awoke := <span class="hljs-literal">false</span> <span class="hljs-comment">// 是否处于唤醒状态</span><br>iter := <span class="hljs-number">0</span> <span class="hljs-comment">// 自旋迭代次数</span><br>old := m.state<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// Don&#x27;t spin in starvation mode, ownership is handed off to waiters</span><br><span class="hljs-comment">// so we won&#x27;t be able to acquire the mutex anyway.</span><br><span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;<br><span class="hljs-comment">// Active spinning makes sense.</span><br><span class="hljs-comment">// Try to set mutexWoken flag to inform Unlock</span><br><span class="hljs-comment">// to not wake other blocked goroutines.</span><br><span class="hljs-keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="hljs-number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="hljs-number">0</span> &amp;&amp;<br>atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;<br>awoke = <span class="hljs-literal">true</span><br>&#125;<br>runtime_doSpin()<br>iter++<br>old = m.state<br><span class="hljs-keyword">continue</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>lockSlow</code>  方法中我们可以看到，有一个大的 for 循环，不断的尝试去获取互斥锁，在循环的内部，第一步就是判断能否自旋状态。<br>进入自旋状态的判断比较苛刻，具体需要满足什么条件呢？ <code>runtime_canSpin</code>  源码见下方</p><ul><li>当前互斥锁的状态是非饥饿状态，并且已经被锁定了</li><li>自旋次数不超过 4 次</li><li>cpu 个数大于一，必须要是多核 cpu</li><li>当前正在执行当中，并且队列空闲的 p 的个数大于等于一</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Active spinning for sync.Mutex.</span><br><span class="hljs-comment">//go:linkname sync_runtime_canSpin sync.runtime_canSpin</span><br><span class="hljs-comment">//go:nosplit</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sync_runtime_canSpin</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="hljs-number">1</span> || gomaxprocs &lt;= <span class="hljs-keyword">int32</span>(sched.npidle+sched.nmspinning)+<span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果可以进入自旋状态之后就会调用 <code>runtime_doSpin</code>  方法进入自旋， <code>doSpin</code>  方法会调用 <code>procyield(30)</code>  执行三十次 <code>PAUSE</code>  指令</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">TEXT runtime·procyield(SB),NOSPLIT,$<span class="hljs-number">0</span><span class="hljs-number">-0</span><br>MOVLcycles+<span class="hljs-number">0</span>(FP), AX<br>again:<br>PAUSE<br>SUBL$<span class="hljs-number">1</span>, AX<br>JNZagain<br>RET<br></code></pre></td></tr></table></figure><p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">为什么使用 PAUSE 指令呢？<br>PAUSE 指令会告诉 CPU 我当前处于处于自旋状态，这时候 CPU 会针对性的做一些优化，并且在执行这个指令的时候 CPU 会降低自己的功耗，减少能源消耗</div><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="hljs-number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="hljs-number">0</span> &amp;&amp;<br>atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;<br>awoke = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><br>在自旋的过程中会尝试设置 <code>mutexWoken</code> 来通知解锁，从而避免唤醒其他已经休眠的 <code>goroutine</code> 在自旋模式下，当前的 <code>goroutine</code> 就能更快的获取到锁<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">new</span> := old<br><span class="hljs-comment">// Don&#x27;t try to acquire starving mutex, new arriving goroutines must queue.</span><br><span class="hljs-keyword">if</span> old&amp;mutexStarving == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">new</span> |= mutexLocked<br>&#125;<br><span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">new</span> += <span class="hljs-number">1</span> &lt;&lt; mutexWaiterShift<br>&#125;<br><span class="hljs-comment">// The current goroutine switches mutex to starvation mode.</span><br><span class="hljs-comment">// But if the mutex is currently unlocked, don&#x27;t do the switch.</span><br><span class="hljs-comment">// Unlock expects that starving mutex has waiters, which will not</span><br><span class="hljs-comment">// be true in this case.</span><br><span class="hljs-keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">new</span> |= mutexStarving<br>&#125;<br><span class="hljs-keyword">if</span> awoke &#123;<br><span class="hljs-comment">// The goroutine has been woken from sleep,</span><br><span class="hljs-comment">// so we need to reset the flag in either case.</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexWoken == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;sync: inconsistent mutex state&quot;</span>)<br>&#125;<br><span class="hljs-built_in">new</span> &amp;^= mutexWoken<br>&#125;<br></code></pre></td></tr></table></figure><br>自旋结束之后就会去计算当前互斥锁的状态，如果当前处在饥饿模式下则不会去请求锁，而是会将当前 goroutine 放到队列的末端<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>    <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">break</span> <span class="hljs-comment">// locked the mutex with CAS</span><br>    &#125;<br>    <span class="hljs-comment">// If we were already waiting before, queue at the front of the queue.</span><br>    queueLifo := waitStartTime != <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> waitStartTime == <span class="hljs-number">0</span> &#123;<br>        waitStartTime = runtime_nanotime()<br>    &#125;<br>    runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="hljs-number">1</span>)<br>    starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs<br>    old = m.state<br>    <span class="hljs-keyword">if</span> old&amp;mutexStarving != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// If this goroutine was woken and mutex is in starvation mode,</span><br>        <span class="hljs-comment">// ownership was handed off to us but mutex is in somewhat</span><br>        <span class="hljs-comment">// inconsistent state: mutexLocked is not set and we are still</span><br>        <span class="hljs-comment">// accounted as waiter. Fix that.</span><br>        <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="hljs-number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> &#123;<br>            throw(<span class="hljs-string">&quot;sync: inconsistent mutex state&quot;</span>)<br>        &#125;<br>        delta := <span class="hljs-keyword">int32</span>(mutexLocked - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift)<br>        <span class="hljs-keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-comment">// Exit starvation mode.</span><br>            <span class="hljs-comment">// Critical to do it here and consider wait time.</span><br>            <span class="hljs-comment">// Starvation mode is so inefficient, that two goroutines</span><br>            <span class="hljs-comment">// can go lock-step infinitely once they switch mutex</span><br>            <span class="hljs-comment">// to starvation mode.</span><br>            delta -= mutexStarving<br>        &#125;<br>        atomic.AddInt32(&amp;m.state, delta)<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>    awoke = <span class="hljs-literal">true</span><br>    iter = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><br>状态计算完成之后就会尝试使用 CAS 操作获取锁，如果获取成功就会直接退出循环<br>如果获取失败，则会调用 <code>runtime_SemacquireMutex(&amp;m.sema, queueLifo, 1)</code> 方法保证锁不会同时被两个 goroutine 获取。<code>runtime_SemacquireMutex</code> 方法的主要作用是:</p><ul><li>不断调用尝试获取锁</li><li>休眠当前 goroutine</li><li>等待信号量，唤醒 goroutine</li></ul><p>goroutine 被唤醒之后就会去判断当前是否处于饥饿模式，如果当前等待超过 <code>1ms</code>  就会进入饥饿模式</p><ul><li>饥饿模式下：会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出</li><li>正常模式下：会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环</li></ul><h3 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h3><p>和加锁比解锁就很简单了，直接看注释就好</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 解锁一个没有锁定的互斥量会报运行时错误</span><br><span class="hljs-comment">// 解锁没有绑定关系，可以一个 goroutine 锁定，另外一个 goroutine 解锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// Fast path: 直接尝试设置 state 的值，进行解锁</span><br><span class="hljs-built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)<br>    <span class="hljs-comment">// 如果减去了 mutexLocked 的值之后不为零就会进入慢速通道，这说明有可能失败了，或者是还有其他的 goroutine 等着</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span> != <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Outlined slow path to allow inlining the fast path.</span><br><span class="hljs-comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span><br>m.unlockSlow(<span class="hljs-built_in">new</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">unlockSlow</span><span class="hljs-params">(<span class="hljs-built_in">new</span> <span class="hljs-keyword">int32</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 解锁一个没有锁定的互斥量会报运行时错误</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;sync: unlock of unlocked mutex&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 判断是否处于饥饿模式</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexStarving == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 正常模式</span><br>old := <span class="hljs-built_in">new</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 如果当前没有等待者.或者 goroutine 已经被唤醒或者是处于锁定状态了，就直接返回</span><br><span class="hljs-keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 唤醒等待者并且移交锁的控制权</span><br><span class="hljs-built_in">new</span> = (old - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken<br><span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>old = m.state<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 饥饿模式，走 handoff 流程，直接将锁交给下一个等待的 goroutine，注意这个时候不会从饥饿模式中退出</span><br>runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h1><p>读写锁相对于互斥锁来说粒度更细，使用读写锁可以并发读，但是不能并发读写，或者并发写写</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>读</strong></th><th style="text-align:center"><strong>写</strong></th></tr></thead><tbody><tr><td style="text-align:center">读</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">写</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><p>其实大部分的业务应用都是读多写少的场景，这个时候使用读写锁的性能就会比互斥锁要好一些，例如下面的这个例子，是一个配置读写的例子，我们分别使用读写锁和互斥锁实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RWMutexConfig 读写锁实现</span><br><span class="hljs-keyword">type</span> RWMutexConfig <span class="hljs-keyword">struct</span> &#123;<br>rw   sync.RWMutex<br>data []<span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// Get get config data</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *RWMutexConfig)</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span> []<span class="hljs-title">int</span></span> &#123;<br>c.rw.RLock()<br><span class="hljs-keyword">defer</span> c.rw.RUnlock()<br><span class="hljs-keyword">return</span> c.data<br>&#125;<br><br><span class="hljs-comment">// Set set config data</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *RWMutexConfig)</span> <span class="hljs-title">Set</span><span class="hljs-params">(n []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>c.rw.Lock()<br><span class="hljs-keyword">defer</span> c.rw.Unlock()<br>c.data = n<br>&#125;<br></code></pre></td></tr></table></figure><p>互斥锁实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// MutexConfig 互斥锁实现</span><br><span class="hljs-keyword">type</span> MutexConfig <span class="hljs-keyword">struct</span> &#123;<br>data []<span class="hljs-keyword">int</span><br>mu   sync.Mutex<br>&#125;<br><br><span class="hljs-comment">// Get get config data</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *MutexConfig)</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span> []<span class="hljs-title">int</span></span> &#123;<br>c.mu.Lock()<br><span class="hljs-keyword">defer</span> c.mu.Unlock()<br><span class="hljs-keyword">return</span> c.data<br>&#125;<br><br><span class="hljs-comment">// Set set config data</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *MutexConfig)</span> <span class="hljs-title">Set</span><span class="hljs-params">(n []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>c.mu.Lock()<br><span class="hljs-keyword">defer</span> c.mu.Unlock()<br>c.data = n<br>&#125;<br></code></pre></td></tr></table></figure><p>并发基准测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> iConfig <span class="hljs-keyword">interface</span> &#123;<br>Get() []<span class="hljs-keyword">int</span><br>Set([]<span class="hljs-keyword">int</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bench</span><span class="hljs-params">(b *testing.B, c iConfig)</span></span> &#123;<br>b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *testing.PB)</span></span> &#123;<br><span class="hljs-keyword">for</span> p.Next() &#123;<br>c.Set([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">100</span>&#125;)<br>c.Get()<br>c.Get()<br>c.Get()<br>c.Set([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">100</span>&#125;)<br>c.Get()<br>c.Get()<br>&#125;<br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMutexConfig</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>conf := &amp;MutexConfig&#123;data: []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;&#125;<br>bench(b, conf)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkRWMutexConfig</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>conf := &amp;RWMutexConfig&#123;data: []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;&#125;<br>bench(b, conf)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">❯ <span class="hljs-keyword">go</span> test -race -bench=.<br>goos: linux<br>goarch: amd64<br>pkg: github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week03/blog/<span class="hljs-number">04</span>_sync/<span class="hljs-number">02</span>_rwmutex<br>BenchmarkMutexConfig<span class="hljs-number">-4</span>            <span class="hljs-number">179577</span>              <span class="hljs-number">6912</span> ns/op<br>BenchmarkRWMutexConfig<span class="hljs-number">-4</span>          <span class="hljs-number">341620</span>              <span class="hljs-number">3425</span> ns/op<br>PASS<br>ok      github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week03/blog/<span class="hljs-number">04</span>_sync/<span class="hljs-number">02</span>_rwmutex <span class="hljs-number">3.565</span>s<br></code></pre></td></tr></table></figure><p>可以看到首先是没有 data race 问题，其次读写锁的性能几乎是互斥锁的一倍</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RWMutex <span class="hljs-keyword">struct</span> &#123;<br>w           Mutex  <span class="hljs-comment">// 复用互斥锁</span><br>writerSem   <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// 信号量，用于写等待读</span><br>readerSem   <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// 信号量，用于读等待写</span><br>readerCount <span class="hljs-keyword">int32</span>  <span class="hljs-comment">// 当前执行读的 goroutine 数量</span><br>readerWait  <span class="hljs-keyword">int32</span>  <span class="hljs-comment">// 写操作被阻塞的准备读的 goroutine 的数量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于复用了互斥锁的代码，读写锁的源码很简单，这里我就不单独画图了</p><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><h4 id="加锁-2"><a href="#加锁-2" class="headerlink" title="加锁"></a>加锁</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span> <span class="hljs-title">RLock</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// A writer is pending, wait for it.</span><br>runtime_SemacquireMutex(&amp;rw.readerSem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是读锁， <code>atomic.AddInt32(&amp;rw.readerCount, 1)</code>  调用这个原子方法，对当前在读的数量加一，如果返回负数，那么说明当前有其他写锁，这时候就调用 <code>runtime_SemacquireMutex</code>  休眠 goroutine 等待被唤醒</p><h4 id="解锁-2"><a href="#解锁-2" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span> <span class="hljs-title">RUnlock</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="hljs-number">-1</span>); r &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Outlined slow-path to allow the fast-path to be inlined</span><br>rw.rUnlockSlow(r)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解锁的时候对正在读的操作减一，如果返回值小于 0 那么说明当前有在写的操作，这个时候调用 <code>rUnlockSlow</code>  进入慢速通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span> <span class="hljs-title">rUnlockSlow</span><span class="hljs-params">(r <span class="hljs-keyword">int32</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> r+<span class="hljs-number">1</span> == <span class="hljs-number">0</span> || r+<span class="hljs-number">1</span> == -rwmutexMaxReaders &#123;<br>race.Enable()<br>throw(<span class="hljs-string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)<br>&#125;<br><span class="hljs-comment">// A writer is pending.</span><br><span class="hljs-keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="hljs-number">-1</span>) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// The last reader unblocks the writer.</span><br>runtime_Semrelease(&amp;rw.writerSem, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>被阻塞的准备读的 goroutine 的数量减一，readerWait 为 0，就表示当前没有正在准备读的 goroutine 这时候调用 <code>runtime_Semrelease</code>  唤醒写操作</p><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><h4 id="加锁-3"><a href="#加锁-3" class="headerlink" title="加锁"></a>加锁</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// First, resolve competition with other writers.</span><br>rw.w.Lock()<br><span class="hljs-comment">// Announce to readers there is a pending writer.</span><br>r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders<br><span class="hljs-comment">// Wait for active readers.</span><br><span class="hljs-keyword">if</span> r != <span class="hljs-number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="hljs-number">0</span> &#123;<br>runtime_SemacquireMutex(&amp;rw.writerSem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先调用互斥锁的 lock，获取到互斥锁之后，</p><ul><li><code>atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders)</code>  调用这个函数阻塞后续的读操作</li><li>如果计算之后当前仍然有其他 goroutine 持有读锁，那么就调用 <code>runtime_SemacquireMutex</code>  休眠当前的 goroutine 等待所有的读操作完成</li></ul><h4 id="解锁-3"><a href="#解锁-3" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span> <span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// Announce to readers there is no active writer.</span><br>r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)<br><span class="hljs-keyword">if</span> r &gt;= rwmutexMaxReaders &#123;<br>race.Enable()<br>throw(<span class="hljs-string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Unblock blocked readers, if any.</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">int</span>(r); i++ &#123;<br>runtime_Semrelease(&amp;rw.readerSem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解锁的操作，会先调用 <code>atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</code>  将恢复之前写入的负数，然后根据当前有多少个读操作在等待，循环唤醒</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://pkg.go.dev/sync">https://pkg.go.dev/sync</a> 官网文档，必读</li><li><a href="https://pkg.go.dev/golang.org/x/sync@v0.0.0-20201207232520-09787c993a3a/errgroup">https://pkg.go.dev/golang.org/x/sync@v0.0.0-20201207232520-09787c993a3a/errgroup</a> 官网文档，必读</li><li><a href="https://pkg.go.dev/sync/atomic">https://pkg.go.dev/sync/atomic</a> 官网文档，必读</li><li><a href="https://medium.com/a-journey-with-go/go-how-to-reduce-lock-contention-with-the-atomic-package-ba3b2664b549">Go: How to Reduce Lock Contention with the Atomic Package</a></li><li><a href="https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50">Go: Mutex and Starvation</a></li><li><a href="https://mojotv.cn/go/golang-muteex-starvation">Go 进阶 27:Go 语言 Mutex Starvation(译)</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/">Go 语言设计与实现-6.2 同步原语与锁</a> 这本书值得一看</li><li><a href="https://www.felixcloutier.com/x86/pause">PAUSE — Spin Loop Hint</a></li><li><a href="https://github.com/freelancer-leon/notes/blob/master/kernel/lock/Lock-2-Linux_x86_Spin_Lock.md#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF-pause-%E6%8C%87%E4%BB%A4">Linux x86 自旋锁的实现</a></li><li><a href="https://github.com/golang/go/commit/0556e26273f704db73df9e7c4c3d2e8434dec7be">https://github.com/golang/go/commit/0556e26273f704db73df9e7c4c3d2e8434dec7be</a></li></ol><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week03: Go 并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
      <tag>mutex</tag>
      
      <tag>互斥锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程(三) data race</title>
    <link href="/post/go-training-week3-data-race.html"/>
    <url>/post/go-training-week3-data-race.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在前两篇文章当中我们反复提到了虽然在 go 中，并发编程十分简单，我们只需要使用 <code>go func()</code>  就能启动一个 goroutine 去做一些事情，但是正是由于这种简单我们要十分当心，不然很容易出现一些莫名其妙的 bug 或者是你的服务由于不知名的原因就重启了。</p><h2 id="数据竞争-data-race"><a href="#数据竞争-data-race" class="headerlink" title="数据竞争(data race)"></a>数据竞争(data race)</h2><p>之前我们提到了很多次在多个 goroutine 对同一个变量的数据进行修改的时候会出现很多奇奇怪怪的问题，那我们有没有什么办法检测它呢，除了通过我们聪明的脑袋？</p><p>答案就是 data race tag，go 官方早在 1.1 版本就引入了数据竞争的检测工具，我们只需要在执行测试或者是编译的时候加上 <code>-race</code>  的 flag 就可以开启数据竞争的检测</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> test -race ./...<br><span class="hljs-keyword">go</span> build -race<br></code></pre></td></tr></table></figure><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">不建议在生产环境 build 的时候开启数据竞争检测，因为这会带来一定的性能损失(一般内存5-10倍，执行时间2-20倍)，当然   必须要 debug 的时候除外。<br>建议在执行单元测试时始终开启数据竞争的检测。</div><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p>我们来直接看一下下面的这个例子，这是来自课上的一个例子，但是我稍稍做了一些改造，源代码没有跑 10w 次这个操作，会导致看起来每次跑的结果都是差不多的，我们只需要把这个次数放大就可以发现每次结果都会不一样</p><h4 id="正常执行"><a href="#正常执行" class="headerlink" title="正常执行"></a>正常执行</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">var</span> counter <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 多跑几次来看结果</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++ &#123;<br>run()<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> routine(i)<br>&#125;<br>wg.Wait()<br>fmt.Printf(<span class="hljs-string">&quot;Final Counter: %d\n&quot;</span>, counter)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">routine</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>value := counter<br>value++<br>counter = value<br>&#125;<br>wg.Done()<br>&#125;<br></code></pre></td></tr></table></figure><p>我执行了三次每次的结果都不一致，分别是:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">Final Counter: <span class="hljs-number">399996</span><br>Final Counter: <span class="hljs-number">399989</span><br>Final Counter: <span class="hljs-number">399988</span><br></code></pre></td></tr></table></figure><p>为什么会导致这样的结果呢，是因为每一次执行的时候，我们都使用 <code>go routine(i)</code>  启动了两个 goroutine，但是我们并没有控制它的执行顺序，那就有好几种可能了，我这里描述两种情况</p><ol><li>执行一次 <code>run()</code> , <code>counter + 4</code> 这种情况下，第二个 goroutine 开始执行时，拿到了第一个 goroutine 的执行结果，也就是 <code>value := counter</code>  这一步时，value = 2</li><li>执行一次 <code>run()</code> , <code>counter + 2</code> 这种情况下，第二个 goroutine 开始执行时，没有拿到了第一个 goroutine 的执行结果，也就是 <code>value := counter</code> 这一步时，counter 还是零值，这时候 value = 0</li></ol><p>当然由于种种不确定性，所有肯定不止这两种情况，但是这个不是本文讨论的重点，具体的原因可以结合上一篇文章 <a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go 并发编程(二) Go 内存模型</a> 进行思考</p><h4 id="data-race-执行"><a href="#data-race-执行" class="headerlink" title="data race 执行"></a>data race 执行</h4><p>可以发现，写出这种代码时上线后如果出现 bug 会非常难定位，因为你不知道到底是哪里出现了问题，所以我们就要在测试阶段就结合 data race 工具提前发现问题。<br>我们执行以下命令</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> run -race ./main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>会发现结果会所有的都输出， <code>data race</code>  的报错信息，我们已经看不到了，因为终端的打印的太长了，可以发现的是，最后打印出发现了一处 data race 并且推出码为  <code>66</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">Final Counter: <span class="hljs-number">399956</span><br>Final Counter: <span class="hljs-number">399960</span><br>Found <span class="hljs-number">1</span> data race(s)<br>exit status <span class="hljs-number">66</span><br></code></pre></td></tr></table></figure><h4 id="data-race-配置"><a href="#data-race-配置" class="headerlink" title="data race 配置"></a>data race 配置</h4><p>问题来了，我们有没有什么办法可以立即知道 data race 的报错呢？<br>答案就在官方的文档当中，我们可以通过设置 <code>GORACE</code>  环境变量，来控制 data race 的行为， 格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">GORACE=<span class="hljs-string">&quot;option1=val1 option2=val2&quot;</span><br></code></pre></td></tr></table></figure><p>可选配置:</p><table><thead><tr><th><strong> 配置 </strong></th><th><strong> 默认值 </strong></th><th><strong> 说明 </strong></th></tr></thead><tbody><tr><td>log_path</td><td>stderr</td><td>日志文件的路径，除了文件路径外支持  stderr, stdout  这两个特殊值</td></tr><tr><td>exitcode</td><td>66</td><td>退出码</td></tr><tr><td>strip_path_prefix</td><td>“”</td><td>从日志中的文件信息里面去除相关的前缀，可以去除本地信息，同时会更好看</td></tr><tr><td>history_size</td><td>1</td><td>per-goroutine 内存访问历史记录为 32K * 2 ** history_size，增加这个可以避免出现堆栈还原失败的错误，但是增加这个会导致使用的内存也跟着增加</td></tr><tr><td>halt_on_error</td><td>0</td><td>用来控制第一个数据竞争错误出现后是否立即退出</td></tr><tr><td>atexit_sleep_ms</td><td>100</td><td>用来控制  main  退出之前  sleep  的时间</td></tr></tbody></table><p>有了这个背景知识后就很简单了，在我们这个场景我们可以控制发现数据竞争后直接退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">GORACE=<span class="hljs-string">&quot;halt_on_error=1 strip_path_prefix=/home/ll/project/Go-000/Week03/blog/03_sync/01_data_race&quot;</span> <span class="hljs-keyword">go</span> run -race ./main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>重新执行后我们的结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go">==================<br>WARNING: DATA RACE<br>Read at <span class="hljs-number">0x00000064a9c0</span> by goroutine <span class="hljs-number">7</span>:<br>  main.routine()<br>      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">29</span> +<span class="hljs-number">0x47</span><br><br>Previous write at <span class="hljs-number">0x00000064a9c0</span> by goroutine <span class="hljs-number">8</span>:<br>  main.routine()<br>      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">31</span> +<span class="hljs-number">0x64</span><br><br>Goroutine <span class="hljs-number">7</span> (running) created at:<br>  main.run()<br>      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">21</span> +<span class="hljs-number">0x75</span><br>  main.main()<br>      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span> +<span class="hljs-number">0x38</span><br><br>Goroutine <span class="hljs-number">8</span> (finished) created at:<br>  main.run()<br>      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">21</span> +<span class="hljs-number">0x75</span><br>  main.main()<br>      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span> +<span class="hljs-number">0x38</span><br>==================<br>exit status <span class="hljs-number">66</span><br></code></pre></td></tr></table></figure><p>这个结果非常清晰的告诉了我们在 29 行这个地方我们有一个 goroutine 在读取数据，但是呢，在 31 行这个地方又有一个 goroutine 在写入，所以产生了数据竞争。<br>然后下面分别说明这两个 goroutine 是什么时候创建的，已经当前是否在运行当中。</p><h3 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h3><p>接来下我们再来看一些典型案例，这些案例都来自 go 官方的文档 <a href="https://golang.org/doc/articles/race_detector.html">Data Race Detector</a>，这些也是初学者很容易犯的错误</p><h4 id="案例二-在循环中启动-goroutine-引用临时变量"><a href="#案例二-在循环中启动-goroutine-引用临时变量" class="headerlink" title="案例二 在循环中启动 goroutine 引用临时变量"></a>案例二 在循环中启动 goroutine 引用临时变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(i) <span class="hljs-comment">// Not the &#x27;i&#x27; you are looking for.</span><br>wg.Done()<br>&#125;()<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你去找一些 go 的面试题，肯定能找到类似的例子，然后会问你这里会输出什么？<br>常见的答案就是会输出 5 个 5，因为在 for 循环的 i++ 会执行的快一些，所以在最后打印的结果都是 5<br>这个答案不能说不对，因为真的执行的话大概率也是这个结果，但是不全<br>因为这里本质上是有数据竞争，在新启动的 goroutine 当中读取 i 的值，在 main 中写入，导致出现了 data race，这个结果应该是不可预知的，因为我们不能假定 goroutine 中 print 就一定比外面的 i++ 慢，习惯性的做这种假设在并发编程中是很有可能会出问题的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br>fmt.Println(i)<br>wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>这个要修改也很简单，只需要将 i 作为参数传入即可，这样每个 goroutine 拿到的都是拷贝后的数据</p><h4 id="案例三-一不小心就把变量共享了"><a href="#案例三-一不小心就把变量共享了" class="headerlink" title="案例三 一不小心就把变量共享了"></a>案例三 一不小心就把变量共享了</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ParallelWrite([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;xxx&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// ParallelWrite writes data to file1 and file2, returns the errors.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParallelWrite</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">chan</span> <span class="hljs-title">error</span></span> &#123;<br>res := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> error, <span class="hljs-number">2</span>)<br>f1, err := os.Create(<span class="hljs-string">&quot;/tmp/file1&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>res &lt;- err<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// This err is shared with the main goroutine,</span><br><span class="hljs-comment">// so the write races with the write below.</span><br>_, err = f1.Write(data)<br>res &lt;- err<br>f1.Close()<br>&#125;()<br>&#125;<br>f2, err := os.Create(<span class="hljs-string">&quot;/tmp/file2&quot;</span>) <span class="hljs-comment">// The second conflicting write to err.</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>res &lt;- err<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>_, err = f2.Write(data)<br>res &lt;- err<br>f2.Close()<br>&#125;()<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用 <code>go run -race main.go</code>  执行，可以发现这里报错的地方是，19 行和 24 行，有 data race，这里主要是因为共享了 err 这个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">==================<br>WARNING: DATA RACE<br>Write at <span class="hljs-number">0x00c0000a01a0</span> by goroutine <span class="hljs-number">7</span>:<br>  main.ParallelWrite.func1()<br>      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">19</span> +<span class="hljs-number">0x94</span><br><br>Previous write at <span class="hljs-number">0x00c0000a01a0</span> by main goroutine:<br>  main.ParallelWrite()<br>      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">24</span> +<span class="hljs-number">0x1dd</span><br>  main.main()<br>      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">6</span> +<span class="hljs-number">0x84</span><br><br>Goroutine <span class="hljs-number">7</span> (running) created at:<br>  main.ParallelWrite()<br>      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">16</span> +<span class="hljs-number">0x336</span><br>  main.main()<br>      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">6</span> +<span class="hljs-number">0x84</span><br>==================<br>Found <span class="hljs-number">1</span> data race(s)<br>exit status <span class="hljs-number">66</span><br></code></pre></td></tr></table></figure><p>修改的话只需要在两个 goroutine 中使用新的临时变量就行了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">...<br>_, err := f1.Write(data)<br>...<br>_, err := f2.Write(data)<br>...<br></code></pre></td></tr></table></figure><p>细心的同学可能会有这个疑问，在 24 行不也是重新赋值了么，为什么在这里会和 19 行产生 data race 呢？<br>这是由于 go 的语法规则导致的，我们在初始化变量的时候如果在同一个作用域下，如下方代码，这里使用的 err 其实是同一个变量，只是 f1 f2 不同，具体可以看 <a href="https://golang.org/doc/effective_go.html#redeclaration">effective go 当中 Redeclaration and reassignment</a> 的内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">f1, err := os.Create(<span class="hljs-string">&quot;a&quot;</span>)<br>f2, err := os.Create(<span class="hljs-string">&quot;b&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="案例四-不受保护的全局变量"><a href="#案例四-不受保护的全局变量" class="headerlink" title="案例四 不受保护的全局变量"></a>案例四 不受保护的全局变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> service = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;&#125;<br><br><span class="hljs-comment">// RegisterService RegisterService</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterService</span><span class="hljs-params">(name, addr <span class="hljs-keyword">string</span>)</span></span> &#123;<br>service[name] = addr<br>&#125;<br><br><span class="hljs-comment">// LookupService LookupService</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LookupService</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> service[name]<br>&#125;<br></code></pre></td></tr></table></figure><p>这个也是很容易犯的一个错，在之前写 Go 设计模式这个系列文章的时候，应该有提到过我们要写出可测性比较高的代码就要少用或者是尽量避免用全局变量，使用 map 作为全局变量比较常见的一种情况就是配置信息。关于全局变量的话一般的做法就是加锁，就本文这个问题也可以使用 sync.Map 这个下一篇文章会讲，这里篇幅有限就不多讲了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>service   <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span><br>serviceMu sync.Mutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterService</span><span class="hljs-params">(name, addr <span class="hljs-keyword">string</span>)</span></span> &#123;<br>serviceMu.Lock()<br><span class="hljs-keyword">defer</span> serviceMu.Unlock()<br>service[name] = addr<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LookupService</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>serviceMu.Lock()<br><span class="hljs-keyword">defer</span> serviceMu.Unlock()<br><span class="hljs-keyword">return</span> service[name]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="案例五-未受保护的成员变量"><a href="#案例五-未受保护的成员变量" class="headerlink" title="案例五 未受保护的成员变量"></a>案例五 未受保护的成员变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Watchdog <span class="hljs-keyword">struct</span>&#123; last <span class="hljs-keyword">int64</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Watchdog)</span> <span class="hljs-title">KeepAlive</span><span class="hljs-params">()</span></span> &#123;<br>w.last = time.Now().UnixNano() <span class="hljs-comment">// First conflicting access.</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Watchdog)</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(time.Second)<br><span class="hljs-comment">// Second conflicting access.</span><br><span class="hljs-keyword">if</span> w.last &lt; time.Now().Add(<span class="hljs-number">-10</span>*time.Second).UnixNano() &#123;<br>fmt.Println(<span class="hljs-string">&quot;No keepalives for 10 seconds. Dying.&quot;</span>)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>同样成员变量也会有这个问题，这里可以用 <code>atomic</code>  包来解决，同样这个我们下篇文章会细讲</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Watchdog <span class="hljs-keyword">struct</span>&#123; last <span class="hljs-keyword">int64</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Watchdog)</span> <span class="hljs-title">KeepAlive</span><span class="hljs-params">()</span></span> &#123;<br>atomic.StoreInt64(&amp;w.last, time.Now().UnixNano())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Watchdog)</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(time.Second)<br><span class="hljs-keyword">if</span> atomic.LoadInt64(&amp;w.last) &lt; time.Now().Add(<span class="hljs-number">-10</span>*time.Second).UnixNano() &#123;<br>fmt.Println(<span class="hljs-string">&quot;No keepalives for 10 seconds. Dying.&quot;</span>)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例六-一个有趣的例子"><a href="#案例六-一个有趣的例子" class="headerlink" title="案例六 一个有趣的例子"></a>案例六 一个有趣的例子</h3><p>dava 在博客中提到过一个很有趣的例子的 <a href="https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races">Ice cream makers and data races</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> IceCreamMaker <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Great a customer.</span><br>Hello()<br>&#125;<br><br><span class="hljs-keyword">type</span> Ben <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Ben)</span> <span class="hljs-title">Hello</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Ben says, \&quot;Hello my name is %s\&quot;\n&quot;</span>, b.name)<br>&#125;<br><br><span class="hljs-keyword">type</span> Jerry <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j *Jerry)</span> <span class="hljs-title">Hello</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Jerry says, \&quot;Hello my name is %s\&quot;\n&quot;</span>, j.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> ben = &amp;Ben&#123;name: <span class="hljs-string">&quot;Ben&quot;</span>&#125;<br><span class="hljs-keyword">var</span> jerry = &amp;Jerry&#123;<span class="hljs-string">&quot;Jerry&quot;</span>&#125;<br><span class="hljs-keyword">var</span> maker IceCreamMaker = ben<br><br><span class="hljs-keyword">var</span> loop0, loop1 <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><br>loop0 = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>maker = ben<br><span class="hljs-keyword">go</span> loop1()<br>&#125;<br><br>loop1 = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>maker = jerry<br><span class="hljs-keyword">go</span> loop0()<br>&#125;<br><br><span class="hljs-keyword">go</span> loop0()<br><br><span class="hljs-keyword">for</span> &#123;<br>maker.Hello()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子有趣的点在于，最后输出的结果会有这种例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Ben says, <span class="hljs-string">&quot;Hello my name is Jerry&quot;</span><br>Ben says, <span class="hljs-string">&quot;Hello my name is Jerry&quot;</span><br></code></pre></td></tr></table></figure><p>这是因为我们在 <code>maker = jerry</code>  这种赋值操作的时候并不是原子的，在上一篇文章中我们讲到过，只有对 single machine word 进行赋值的时候才是原子的，虽然这个看上去只有一行，但是 interface 在 go 中其实是一个结构体，它包含了 type 和 data 两个部分，所以它的复制也不是原子的，会出现问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-keyword">interface</span> <span class="hljs-keyword">struct</span> &#123;<br>       Type <span class="hljs-keyword">uintptr</span>     <span class="hljs-comment">// points to the type of the interface implementation</span><br>       Data <span class="hljs-keyword">uintptr</span>     <span class="hljs-comment">// holds the data for the interface&#x27;s receiver</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个案例有趣的点还在于，这个案例的两个结构体的内存布局一模一样所以出现错误也不会 panic 退出，如果在里面再加入一个 string 的字段，去读取就会导致 panic，但是这也恰恰说明这个案例很可怕，这种错误在线上实在太难发现了，而且很有可能会很致命。<br>这个案例还有一个衍生案例，大家有兴趣可以点开查看一下，并不是说要看起来一样才不会 panic <a href="https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html">https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾一下，这篇文章通过一个案例讲解了 data race 的使用方法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build -race main.<span class="hljs-keyword">go</span><br><span class="hljs-keyword">go</span> test -race ./...<br></code></pre></td></tr></table></figure><p>然后讲述了 data race 如何通过 GORACE 环境变量进行配置<br>最后讲解了几个典型案例，看完这篇相信你对 data race 已经有了一个基本的了解，希望可以在接下来的工作学习当中对你有有所启发<br>最后在重申一下关键点：</p><ul><li>善用 data race 这个工具帮助我们提前发现并发错误</li><li>不要对未定义的行为做任何假设，虽然有时候我们写的只是一行代码，但是 go 编译器可能后面坐了很多事情，并不是说一行写完就一定是原子的</li><li>即使是原子的出现了 data race 也不能保证安全，因为我们还有可见性的问题，上篇我们讲到了现代的 cpu 基本上都会有一些缓存的操作。</li><li>所有出现了 data race 的地方都需要进行处理</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races">https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races</a></li><li><a href="https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html">https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html</a></li><li><a href="http://blog.golang.org/race-detector">http://blog.golang.org/race-detector</a></li><li><a href="https://golang.org/doc/articles/race_detector.html">https://golang.org/doc/articles/race_detector.html</a></li><li><a href="https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package">https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package</a> 除了考虑原子性之外，还要考虑可见性，并不是说赋值原子了，并发操作就没有问题了</li><li><a href="https://golang.org/doc/effective_go.html#redeclaration">https://golang.org/doc/effective_go.html#redeclaration</a></li></ul><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week03: Go 并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程(二) Go 内存模型</title>
    <link href="/post/go-training-week3-go-memory-model.html"/>
    <url>/post/go-training-week3-go-memory-model.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在上一篇文章当中我们讲到了使用 goroutine 的一些注意事项，我们先简单回顾一下:</p><ol><li><strong>请将是否异步调用的选择权交给调用者</strong>，不然很有可能大家并不知道你在这个函数里面使用了 goroutine</li><li>如果你要启动一个 goroutine 请对它负责<ol><li><strong>永远不要启动一个你无法控制它退出，或者你无法知道它何时推出的 goroutine</strong></li><li>还有上一篇提到的，启动 goroutine 时请加上 panic recovery 机制，避免服务直接不可用</li><li>造成 goroutine 泄漏的主要原因就是 goroutine 中造成了阻塞，并且没有外部手段控制它退出</li></ol></li><li><strong>尽量避免在请求中直接启动 goroutine 来处理问题</strong>，而应该通过启动 worker 来进行消费，这样可以避免由于请求量过大，而导致大量创建 goroutine 从而导致 oom，当然如果请求量本身非常小，那当我没说</li></ol><p>那我们为什么要这么使用 goroutine 呢？今天我们从原理层面来了解一下 goroutine 的注意事项，本文以 Go 官方博客当中的 <a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a> 为主干穿插讲解，建议阅读本文前先自行看完一遍原文，会有更多的收获</p><h2 id="Go-内存模型"><a href="#Go-内存模型" class="headerlink" title="Go 内存模型"></a>Go 内存模型</h2><p>同样我们先来看一段代码，请问下面的代码可能会输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> a, b <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>a = <span class="hljs-number">1</span><br>b = <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-built_in">print</span>(a)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> f()<br>g()<br>&#125;<br></code></pre></td></tr></table></figure><p>ok，请带着你的答案或者是困惑我们往下走<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1608363233129-3653a44c-74a9-46dc-94b0-c6151da0c07c.svg" alt="02_Go进阶03_blog_img.drawio.svg"><br>比较容易想到的结果是:</p><ul><li>执行顺序: 1 - 2 - 3 - 4, f 先执行, g 后执行, 输出 <code>2 1</code></li><li>执行顺序: 3 - 4 - 1 - 2, g 先执行，f 后执行，输出 <code>0 0</code></li></ul><p>就这几种结果么？其实不然，还有可能</p><ul><li>执行顺序: 1 - 3 - 4 - 2, <code>f</code>  先执行一部分, 然后 <code>g</code>  执行, 输出 <code>0 1</code></li></ul><p>那能不能输出 <code>2 0</code>  呢？</p><ul><li>先说答案，是有可能的</li></ul><p>是不是感觉有点反常识？是不是感觉有点飘忽不定？引用参考文章里面曹大的一句话：</p><blockquote><p>软件(<em>编译器</em>)或硬件(<em>CPU</em>)系统可以根据其对代码的分析结果，一定程度上打乱代码的执行顺序，以达到其不可告人的目的(<em>提高 CPU 利用率)</em></p></blockquote><p>所以我们在编写并发程序的时候一定要小心，然后回到我们本次的主题 Go 内存模型，就是要解决两个问题，一个是要了解谁先谁后，有个专有名词叫 <code>Happens Before</code> ，另外一个就是了解可见性的问题，我这次读取能不能看到另外一个线程的写入<br>接下来我们官方的文档<a href="https://golang.org/ref/mem">《The Go Memory Model》</a>的思路一步一步的了解这些问题，因为官方的文档写的相对比较精炼，所以会比较难懂，我会尝试加入一些我的理解补充说明</p><h3 id="忠告"><a href="#忠告" class="headerlink" title="忠告"></a>忠告</h3><blockquote><p>Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access.<br>To serialize access, protect the data with channel operations or other synchronization primitives such as those in the <a href="https://golang.org/pkg/sync/"><code>sync</code></a> and <a href="https://golang.org/pkg/sync/atomic/"><code>sync/atomic</code></a> packages.</p></blockquote><p>这个是说如果你的程序存在多个 goroutine 去访问数据的时候，<strong>必须序列化的访问，</strong>如何保证序列化呢？我们可以采用 channel 或者是 sync 以及 sync/atomic 下面提供的同步语义来保证</p><h3 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens Before"></a>Happens Before</h3><h4 id="序"><a href="#序" class="headerlink" title="序"></a>序</h4><blockquote><p>Within a single goroutine, reads and writes must behave as if they executed in the order specified by the program. That is, compilers and processors may reorder the reads and writes executed within a single goroutine only when the reordering does not change the behavior within that goroutine as defined by the language specification. Because of this reordering, the execution order observed by one goroutine may differ from the order perceived by another. For example, if one goroutine executes a = 1; b = 2;, another might observe the updated value of b before the updated value of a.</p></blockquote><p>这段话就解释了上面我们示例当中为什么会出现 <code>2 0</code>  这种情况。<br>这段话就是说我们在单个 goroutine 当中的编写的代码会总是按照我们编写代码的顺序来执行</p><ul><li>当然这个也是符合我们的习惯的</li><li>当然这并不表示编译器在编译的时候不会对我们的程序进行指令重排</li><li>而是说只会在不影响语言规范对 goroutine 的行为定义的时候，编译器和 CPU 才会对读取和写入的顺序进行重新排序。</li></ul><p>但是正是因为存在这种重排的情况，所以一个 goroutine 监测到的执行顺序和另外一个 goroutine 监测到的有可能不一样。就像我们最上面的这个例子一样，可能我们在 f 执行的顺序是先执行 <code>a = 1</code> 后执行 <code>b = 2</code> 但是在 g 中我们只看到了 b = 2 具体什么情况可能会导致这个呢？不要着急，我们后面还会说到</p><h4 id="编译器重排"><a href="#编译器重排" class="headerlink" title="编译器重排"></a>编译器重排</h4><p>我们来看参考文章中的一个编译器重排例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">X = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i in <span class="hljs-keyword">range</span>(<span class="hljs-number">100</span>):<br>    X = <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span> X<br></code></pre></td></tr></table></figure><p>在这段代码中，X = 1 在 for 循环内部被重复赋值了 100 次，这完全没有必要，于是聪明的编译器就会帮助我们优化成下面的样子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">X = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i in <span class="hljs-keyword">range</span>(<span class="hljs-number">100</span>):<br>    <span class="hljs-built_in">print</span> X<br></code></pre></td></tr></table></figure><p>完美，在单个 goroutine 中并不会改变程序的执行，这时候同样会输出 100 次 1 ，并且减少了 100 次赋值操作。<br>但是，如果与此同时我们存在一个另外一个 goroutine 干了另外一个事情 X = 0 那么，这个输出就变的不可预知了，就有可能是 1001111101… 这种，所以回到刚开始的忠告：<strong>这个是说如果你的程序存在多个 goroutine 去访问数据的时候，必须序列化的访问</strong></p><h4 id="happens-before-定义"><a href="#happens-before-定义" class="headerlink" title="happens before 定义"></a>happens before 定义</h4><blockquote><p>To specify the requirements of reads and writes, we define happens before, a partial order on the execution of memory operations in a Go program. If event <code>e1</code> happens before event <code>e2</code>, then we say that <code>e2</code> happens after <code>e1</code>. Also, if <code>e1</code> does not happen before <code>e2</code> and does not happen after <code>e2</code>, then we say that <code>e1</code> and <code>e2</code> happen concurrently.</p></blockquote><p>这是 Happens Before 的定义，如果 <code>e1</code> 发生在 <code>e2</code> 之前，那么我们就说 <code>e2</code> 发生在 <code>e1</code> 之后，如果 <code>e1</code> 既不在 <code>e2</code> 前，也不在 <code>e2</code> 之后，那我们就说这俩是并发的</p><blockquote><p>Within a single goroutine, the happens-before order is the order expressed by the program.</p></blockquote><p>这就是我们前面提到的，在单个 goroutine 当中，事件发生的顺序，就是程序所表达的顺序</p><blockquote><p>A read r of a variable <code>v</code> is allowed to observe a write <code>w</code> to <code>v</code> if both of the following hold:</p><ol><li>r does not happen before <code>w</code>.</li><li>There is no other write <code>w&#39;</code> to <code>v</code> that happens after w but before <code>r</code>.</li></ol></blockquote><p>假设我们现在有一个变量 <code>v</code>，然后只要满足下面的两个条件，那么读取操作 <code>r</code> 就可以对这个变量 <code>v</code> 的写入操作 <code>w</code> 进行监测</p><ol><li>读取操作 <code>v</code> 发生在写入操作 <code>w</code> 之后</li><li>并且在 <code>w</code> 之后，<code>r</code> 之前没有其他对 <code>v</code> 的写入操作 <code>w&#39;</code></li></ol><p>注意这里说的只是读取操作 r 可以对 w 进行监测，但是能不能读到呢，可能可以也可能不行</p><blockquote><p>To guarantee that a read <code>r</code> of a variable <code>v</code> observes a particular write <code>w</code> to <code>v</code>, ensure that <code>w</code> is the only write <code>r</code> is allowed to observe. That is, <code>r</code> is guaranteed to observe <code>w</code> if both of the following hold:</p><ol><li><code>w</code> happens before <code>r</code>.</li><li>Any other write to the shared variable <code>v</code> either happens before <code>w</code> or after <code>r</code>.</li></ol></blockquote><p>为确保对变量 <code>v</code> 的读取操作 <code>r</code> 能够监测到特定的对 <code>v</code> 进行写入的操作 <code>w</code>，需确保 <code>w</code> 是唯一允许被 <code>r</code> 监测的写入操作。也就是说，若以下条件均成立，则 <code>r</code> 能保证监测到 <code>w</code>：</p><ol><li><code>w</code> 发生在 <code>r</code> 之前。</li><li>对共享变量 <code>v</code> 的其它任何写入操作都只能发生在 <code>w</code> 之前或 <code>r</code> 之后。</li></ol><p>这对条件的要求比第一个条件更强，它需要确保没有其它写入操作与 <code>w</code> 或 <code>r</code> 并发。<br>在单个 goroutine 当中这两个条件是等价的，因为单个 goroutine 中不存在并发，在多个 goroutine 中就必须使用同步语义来确保顺序，这样才能到保证能够监测到预期的写入<br><strong>单个 goroutine 的情况</strong>：<br>我们可以发现在单个 goroutine 当中，读取操作 r 总是可以读取到上一次 w 写入的值的<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1608372439492-359ad5bf-1b06-4f4f-ae77-84e96d9f6a7f.png" alt="image.png"><br><strong>多个 goroutine 的情况</strong>:<br>但是存在多个 goroutine 的时候这个就不一定了，r0 读到的是 哪一次写入的值呢？如果看图的话像是 w4 的，但其实不一定，因为图中的两个 goroutine 所表达的时间维度可能是不一致的，所以 r0 可能读到的是 w0 w3 w4 甚至是 w5 的结果，当然按照我们前面说的理论，读到的不可能是 w1 的结果的<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1608372753766-f3b66fe5-ac34-4f5e-a1b2-c74e7d3dfbc9.png" alt="image.png"><br><strong>添加一些同步点</strong><br>如下图所示我们通过 sync 包中的一些同步语义或者是 channel 为多个 goroutine 加入了 同步点，那么这个时候对于 r1 而言，他就是晚于 w4 并且早于 w1 和 w5 执行的，所以它读取到的是写入操作是可以确定的，是 w4<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1608373281116-271c756e-386e-490b-aa7b-0fb2b741ed40.png" alt="image.png"></p><blockquote><p>The initialization of variable <code>v</code> with the zero value for <code>v</code>‘s type behaves as a write in the memory model.</p></blockquote><p>以变量 <code>v</code> 所属类型的零值来对 <code>v</code> 进行初始化，其表现如同在内存模型中进行的写入操作。</p><h4 id="机器字"><a href="#机器字" class="headerlink" title="机器字"></a>机器字</h4><blockquote><p>Reads and writes of values larger than a single machine word behave as multiple machine-word-sized operations in an unspecified order.</p></blockquote><p>对大于单个机器字的值进行读取和写入，其表现如同以不确定的顺序对多个机器字大小的值进行操作。要理解这个我们首先要理解什么是机器字。<br>我们现在常见的还有 32 位系统和 64 位的系统，cpu 在执行一条指令的时候对于单个机器字长的的数据的写入可以保证是原子的，对于 32 位的就是 4 个字节，对于 64 位的就是 8 个字节，对于在 32 位情况下去写入一个 8 字节的数据时就需要执行两次写入操作，这两次操作之间就没有原子性，那就可能出现先写入后半部分的数据再写入前半部分，或者是写入了一半数据然后写入失败的情况。<br>也就是说虽然有时候我们看着仅仅只做了一次写入但是还是会有并发问题，因为它本身不是原子的</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><blockquote><p>Program initialization runs in a single goroutine, but that goroutine may create other goroutines, which run concurrently.<br>If a package <code>p</code> imports package <code>q</code>, the completion of <code>q</code>‘s <code>init</code> functions happens before the start of any of <code>p</code>‘s.<br>The start of the function <code>main.main</code> happens after all <code>init</code> functions have finished.</p></blockquote><ul><li>程序的初始化运行在单个 goroutine 中，但该 goroutine 可能会创建其它并发运行的 goroutine</li><li>若包 p 导入了包 q，则 q 的 init 函数会在 p 的任何函数启动前完成。</li><li>函数 main.main 会在所有的 init 函数结束后启动。<div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">注意: 在实际的应用代码中不要隐式的依赖这个启动顺序</div></li></ul><h4 id="goroutine-的创建"><a href="#goroutine-的创建" class="headerlink" title="goroutine 的创建"></a>goroutine 的创建</h4><blockquote><p>The <code>go</code> statement that starts a new goroutine happens before the goroutine’s execution begins.</p></blockquote><p><code>go</code>  语句会在 goroutine 开始执行前启动它</p><h4 id="goroutine-的销毁"><a href="#goroutine-的销毁" class="headerlink" title="goroutine 的销毁"></a>goroutine 的销毁</h4><blockquote><p>The exit of a goroutine is not guaranteed to happen before any event in the program。</p></blockquote><p>goroutine 无法确保在程序中的任何事件发生之前退出</p><p>注意 <a href="https://golang.org/ref/mem">《The Go Memory Model》</a>原文中还有关于 channel， 锁相关的阐述，因为篇幅原因在本文中就不多讲了，后面我们还有单独的文章详细讲 channel 和 锁 相关的使用，在强调一遍，原文一定要多看几遍</p><h2 id="内存重排"><a href="#内存重排" class="headerlink" title="内存重排"></a>内存重排</h2><p>在上面我们讲到了编译器重排，以及在最开始的例子中我们提到了可能会存在 <code>2 0</code>  这个答案，接下来我们就来看看为什么。如果大家购买电脑的时候有去对比 cpu 的话应该可以看到，每个 cpu 都会写一下一级缓存，二级缓存，三级缓存的大小，这个缓存就是这里的一个关键点，一般而言，越往下缓存的大小越大速度越慢，这是 cpu 为了提高执行速度做的缓存体系，就像我们平时在应用当中引入 redis 作为缓存类似，都是为了加速。同时这就会带来一些数据不一致的问题。<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1608385154319-591875fe-fc6f-457f-8fd0-966b8e603310.png" alt="02_Go进阶03_blog_img.drawio-第 4 页.png"><br><strong>如上图所示：</strong></p><ol><li>C1 执行 a = 1 将 store buffer 中 a 的值写为 1</li><li>C1 执行 b = 2 将 store buffer 中 b 的值写为 2, 然后由于某种原因将 b 的值写入到了内存中</li><li>C2 去读取 b 的值，发现缓存中没有，就去内存中读，这时候 print 出来 2</li><li>C2 去读取 a 的值，发现缓存中没有，就去内存中读，这时候 print 出来 0</li></ol><p>了解到这里之后可能会有一些疑问，既然会存在这种不确定性，我们有没有什么办法去保证一致呢？CPU 的一致性具体又是怎么回事？<br>保证一致从程序上来讲我们必须使用同步语义的工具确保一致，如果深入到底层的话就是使用 cpu 提供的内存屏障命令，保证所有对内存的操作都必须要“扩散”到 memory 之后才能继续执行其他对 memory 的操作。<br>CPU 一致性的原理建议看一下 MSI(E)协议的实现，我在参考文献中列出的最后两篇文章讲的已经比较通俗易懂了，在本文就不再叙述</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>Go 的并发编程非常的简单，只需要使用 go func 就能启动一个新的协程，但是并发编程本身就是很容易出现 bug 的，而且由于并发导致的 bug 还不太容易发现，所以我们在写并发逻辑的时候一定要非常小心，用官方的一句话就是<strong>使用显示的同步</strong></li><li>本文更多是抛砖引玉这里面提到了很多有意思的名词都值得好好研究</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a> 官方文档一定要多读几遍</li><li><a href="https://go-zh.org/ref/mem">https://go-zh.org/ref/mem</a> 官方文档的中文翻译，英文比较吃力可以看这篇</li><li><a href="https://qcrao.com/2019/06/17/cch-says-memory-reorder/">https://qcrao.com/2019/06/17/cch-says-memory-reorder/</a></li><li><a href="https://cch123.github.io/ooo/">https://cch123.github.io/ooo/</a></li><li><a href="https://www.cs.utexas.edu/~bornholt/post/memory-models.html">https://www.cs.utexas.edu/~bornholt/post/memory-models.html</a></li><li><a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF">https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%AD%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA">https://zh.wikipedia.org/wiki/%E5%AD%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a>&gt;)</li><li><a href="https://zhuanlan.zhihu.com/p/65245043">https://zhuanlan.zhihu.com/p/65245043</a></li><li><a href="https://zhuanlan.zhihu.com/p/94811032">https://zhuanlan.zhihu.com/p/94811032</a></li></ul><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week03: Go 并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程(一) goroutine</title>
    <link href="/post/go-training-week3-goroutine.html"/>
    <url>/post/go-training-week3-goroutine.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><p>接下来会一共会有 12 - 15 篇文章讲解 Go 并发编程，并发编程本身是一个挺大的话题，在第四周的两节课，毛老师花了将近 7 个小时讲解这些内容，我也结合自己的一些微不足道的经验，再加上一些大神们的文章，整理出了这一部分的笔记。<br>当然这里更多的是抛砖引玉的作用，更多的还是我们自己要有相关的意识避免踩坑，在各个坑的边缘反复横跳，可能我们有缘会在同一个坑中发现，咦，原来你也在这里 😄</p><h2 id="请对你创建的-goroutine-负责"><a href="#请对你创建的-goroutine-负责" class="headerlink" title="请对你创建的 goroutine 负责"></a>请对你创建的 goroutine 负责</h2><h3 id="不要创建一个你不知道何时退出的-goroutine"><a href="#不要创建一个你不知道何时退出的-goroutine" class="headerlink" title="不要创建一个你不知道何时退出的 goroutine"></a>不要创建一个你不知道何时退出的 goroutine</h3><p>请阅读下面这段代码，看看有什么问题？</p><blockquote><p>为什么先从下面这段代码出发，是因为在之前的经验里面我们写了大量类似的代码，之前没有意识到这个问题，并且还因为这种代码出现过短暂的事故</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Week03/blog/01/01.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 这里面有一些初始化的操作</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>setup()<br><br><span class="hljs-comment">// 主服务</span><br>server()<br><br><span class="hljs-comment">// for debug</span><br>pprof()<br><br><span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;pong&quot;</span>))<br>&#125;)<br><br><span class="hljs-comment">// 主服务</span><br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, mux); err != <span class="hljs-literal">nil</span> &#123;<br>log.Panicf(<span class="hljs-string">&quot;http server err: %+v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pprof</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 辅助服务，监听了其他端口，这里是 pprof 服务，用于 debug</span><br><span class="hljs-keyword">go</span> http.ListenAndServe(<span class="hljs-string">&quot;:8081&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>灵魂拷问来了，请问：</p><ul><li>如果 <code>server</code>  是在其他包里面，如果没有特殊说明，你知道这是一个异步调用么？</li><li><code>main</code>  函数当中最后在哪里空转干什么？会不会存在浪费？</li><li>如果线上出现事故，debug 服务已经退出，你想要 debug 这时你是否很茫然？</li><li>如果某一天服务突然重启，你却找不到事故日志，你是否能想起这个 <code>8081</code>  端口的服务？</li></ul><h4 id="请将选择权留给对方，不要帮别人做选择"><a href="#请将选择权留给对方，不要帮别人做选择" class="headerlink" title="请将选择权留给对方，不要帮别人做选择"></a>请将选择权留给对方，不要帮别人做选择</h4><p>请把是否并发的选择权交给你的调用者，而不是自己就直接悄悄的用上了 goroutine<br>下面这次改动将两个函数是否并发操作的选择权留给了 main 函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 这里面有一些初始化的操作</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>setup()<br><br><span class="hljs-comment">// for debug</span><br><span class="hljs-keyword">go</span> pprof()<br><br><span class="hljs-comment">// 主服务</span><br><span class="hljs-keyword">go</span> server()<br><br><span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">()</span></span> &#123;<br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;pong&quot;</span>))<br>&#125;)<br><br><span class="hljs-comment">// 主服务</span><br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, mux); err != <span class="hljs-literal">nil</span> &#123;<br>log.Panicf(<span class="hljs-string">&quot;http server err: %+v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pprof</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 辅助服务，监听了其他端口，这里是 pprof 服务，用于 debug</span><br>http.ListenAndServe(<span class="hljs-string">&quot;:8081&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="请不要作为一个旁观者"><a href="#请不要作为一个旁观者" class="headerlink" title="请不要作为一个旁观者"></a>请不要作为一个旁观者</h4><p>一般情况下，不要让主进程成为一个旁观者，明明可以干活，但是最后使用了一个 <code>select</code>  在那儿空跑<br>感谢上一步将是否异步的选择权交给了我( <code>main</code> )，在旁边看着也怪尴尬的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 这里面有一些初始化的操作</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>setup()<br><br><span class="hljs-comment">// for debug</span><br><span class="hljs-keyword">go</span> pprof()<br><br><span class="hljs-comment">// 主服务</span><br>server()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">()</span></span> &#123;<br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;pong&quot;</span>))<br>&#125;)<br><br><span class="hljs-comment">// 主服务</span><br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, mux); err != <span class="hljs-literal">nil</span> &#123;<br>log.Panicf(<span class="hljs-string">&quot;http server err: %+v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pprof</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 辅助服务，监听了其他端口，这里是 pprof 服务，用于 debug</span><br>http.ListenAndServe(<span class="hljs-string">&quot;:8081&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="不要创建一个你永远不知道什么时候会退出的-goroutine"><a href="#不要创建一个你永远不知道什么时候会退出的-goroutine" class="headerlink" title="不要创建一个你永远不知道什么时候会退出的 goroutine"></a>不要创建一个你永远不知道什么时候会退出的 goroutine</h4><p>我们再做一些改造，使用 <code>channel</code>  来控制，解释都写在代码注释里面了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 这里面有一些初始化的操作</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>setup()<br><br><span class="hljs-comment">// 用于监听服务退出</span><br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> error, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// 用于控制服务退出，传入同一个 stop，做到只要有一个服务退出了那么另外一个服务也会随之退出</span><br>stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// for debug</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>done &lt;- pprof(stop)<br>&#125;()<br><br><span class="hljs-comment">// 主服务</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>done &lt;- app(stop)<br>&#125;()<br><br><span class="hljs-comment">// stoped 用于判断当前 stop 的状态</span><br><span class="hljs-keyword">var</span> stoped <span class="hljs-keyword">bool</span><br><span class="hljs-comment">// 这里循环读取 done 这个 channel</span><br><span class="hljs-comment">// 只要有一个退出了，我们就关闭 stop channel</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">cap</span>(done); i++ &#123;<br><span class="hljs-keyword">if</span> err := &lt;-done; err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;server exit err: %+v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">if</span> !stoped &#123;<br>stoped = <span class="hljs-literal">true</span><br><span class="hljs-built_in">close</span>(stop)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">app</span><span class="hljs-params">(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;pong&quot;</span>))<br>&#125;)<br><br><span class="hljs-keyword">return</span> server(mux, <span class="hljs-string">&quot;:8080&quot;</span>, stop)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pprof</span><span class="hljs-params">(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-comment">// 注意这里主要是为了模拟服务意外退出，用于验证一个服务退出，其他服务同时退出的场景</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>server(http.DefaultServeMux, <span class="hljs-string">&quot;:8081&quot;</span>, stop)<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;mock pprof exit&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 启动一个服务</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">(handler http.Handler, addr <span class="hljs-keyword">string</span>, stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<br>s := http.Server&#123;<br>Handler: handler,<br>Addr:    addr,<br>&#125;<br><br><span class="hljs-comment">// 这个 goroutine 我们可以控制退出，因为只要 stop 这个 channel close 或者是写入数据，这里就会退出</span><br><span class="hljs-comment">// 同时因为调用了 s.Shutdown 调用之后，http 这个函数启动的 http server 也会优雅退出</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-stop<br>log.Printf(<span class="hljs-string">&quot;server will exiting, addr: %s&quot;</span>, addr)<br>s.Shutdown(context.Background())<br>&#125;()<br><br><span class="hljs-keyword">return</span> s.ListenAndServe()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看一下返回结果，这个代码启动 5s 之后就会退出程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">❯ <span class="hljs-keyword">go</span> run ./<span class="hljs-number">01</span>_goroutine/<span class="hljs-number">04</span><br><span class="hljs-number">2020</span>/<span class="hljs-number">12</span>/<span class="hljs-number">08</span> <span class="hljs-number">21</span>:<span class="hljs-number">49</span>:<span class="hljs-number">43</span> server exit err: mock pprof exit<br><span class="hljs-number">2020</span>/<span class="hljs-number">12</span>/<span class="hljs-number">08</span> <span class="hljs-number">21</span>:<span class="hljs-number">49</span>:<span class="hljs-number">43</span> server will exiting, addr: :<span class="hljs-number">8081</span><br><span class="hljs-number">2020</span>/<span class="hljs-number">12</span>/<span class="hljs-number">08</span> <span class="hljs-number">21</span>:<span class="hljs-number">49</span>:<span class="hljs-number">43</span> server will exiting, addr: :<span class="hljs-number">8080</span><br><span class="hljs-number">2020</span>/<span class="hljs-number">12</span>/<span class="hljs-number">08</span> <span class="hljs-number">21</span>:<span class="hljs-number">49</span>:<span class="hljs-number">43</span> server exit err: http: Server closed<br></code></pre></td></tr></table></figure><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>虽然我们已经经过了三轮优化，但是这里还是有一些需要注意的地方，可以思考一下怎么做</p><ul><li>虽然我们调用了 <code>Shutdown</code>  方法，但是我们其实并没有实现优雅退出，相信聪明的你可以完成这项工作。可以参考上一篇笔记：<a href="https://lailin.xyz/post/go-training-03.html">Go 错误处理最佳实践</a></li><li>在 <code>server</code>  方法中我们并没有处理 <code>panic</code>  的逻辑，这里需要处理么？如果需要那该如何处理呢？</li></ul><h3 id="不要创建一个永远都无法退出的-goroutine-goroutine-泄漏"><a href="#不要创建一个永远都无法退出的-goroutine-goroutine-泄漏" class="headerlink" title="不要创建一个永远都无法退出的 goroutine [goroutine 泄漏]"></a>不要创建一个永远都无法退出的 goroutine [goroutine 泄漏]</h3><p>再来看下面一个例子，这也是常常会用到的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">leak</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;异步任务做一些操作&quot;</span>)<br>&lt;-ch<br>&#125;()<br><br>w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;will leak&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>复用一下上面的 server 代码，我们经常会写出这种类似的代码</p><ul><li>http 请求来了，我们启动一个 goroutine 去做一些耗时一点的工作</li><li>然后返回了</li><li>然后之前创建的那个 <strong>goroutine 阻塞</strong>了</li><li>然后就泄漏了</li></ul><p>绝大部分的 goroutine 泄漏都是因为 goroutine 当中因为各种原因阻塞了，我们在外面也没有控制它退出的方式，所以就泄漏了，具体导致阻塞的常见原因会在接下来的 sync 包、channel 中讲到，这里就不过多赘述了<br>接下来我们验证一下是不是真的泄漏了<br>启动之后我们访问一下: <a href="http://localhost:8081/debug/pprof/goroutine?debug=1">http://localhost:8081/debug/pprof/goroutine?debug=1</a> 查看当前的 goroutine 个数为 7</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">goroutine profile: total <span class="hljs-number">7</span><br><span class="hljs-number">2</span> @ <span class="hljs-number">0x43b945</span> <span class="hljs-number">0x40814f</span> <span class="hljs-number">0x407d8b</span> <span class="hljs-number">0x770998</span> <span class="hljs-number">0x470381</span><br>#<span class="hljs-number">0x770997</span>main.server.func1+<span class="hljs-number">0x37</span>/home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">01</span>_goroutine/<span class="hljs-number">05</span>/<span class="hljs-number">05.</span><span class="hljs-keyword">go</span>:<span class="hljs-number">71</span><br></code></pre></td></tr></table></figure><p>然后我们再访问几次 <a href="http://localhost:8080/leak">http://localhost:8080/leak</a> 可以发现 goroutine 增加到了 15 个，而且一直不会下降</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">goroutine profile: total <span class="hljs-number">15</span><br><span class="hljs-number">7</span> @ <span class="hljs-number">0x43b945</span> <span class="hljs-number">0x40814f</span> <span class="hljs-number">0x407d8b</span> <span class="hljs-number">0x770ad0</span> <span class="hljs-number">0x470381</span><br>#<span class="hljs-number">0x770acf</span>main.leak.func1+<span class="hljs-number">0x8f</span>/home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">01</span>_goroutine/<span class="hljs-number">05</span>/<span class="hljs-number">05.</span><span class="hljs-keyword">go</span>:<span class="hljs-number">83</span><br></code></pre></td></tr></table></figure><h3 id="确保创建出的-goroutine-的工作已经完成"><a href="#确保创建出的-goroutine-的工作已经完成" class="headerlink" title="确保创建出的 goroutine 的工作已经完成"></a>确保创建出的 goroutine 的工作已经完成</h3><p>这个其实就是优雅退出的问题，我们可能启动了很多的 goroutine 去处理一些问题，但是服务退出的时候我们并没有考虑到就直接退出了。例如退出前日志没有 flush 到磁盘，我们的请求还没完全关闭，异步 worker 中还有 job 在执行等等。<br>我们也来看一个例子，假设现在有一个埋点服务，每次请求我们都会上报一些信息到埋点服务上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Reporter 埋点服务上报</span><br><span class="hljs-keyword">type</span> Reporter <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">var</span> reporter Reporter<br><br><span class="hljs-comment">// 模拟耗时</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r Reporter)</span> <span class="hljs-title">report</span><span class="hljs-params">(data <span class="hljs-keyword">string</span>)</span></span> &#123;<br>time.Sleep(time.Second)<br>fmt.Printf(<span class="hljs-string">&quot;report: %s\n&quot;</span>, data)<br>&#125;<br><br>mux.HandleFunc(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 在请求中异步调用</span><br>    <span class="hljs-keyword">go</span> reporter.report(<span class="hljs-string">&quot;ping pong&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;ping&quot;</span>)<br>    w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;pong&quot;</span>))<br>&#125;)<br></code></pre></td></tr></table></figure><p>我在发送了一次请求之后直接退出了，异步上报的逻辑根本没执行上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">❯ <span class="hljs-keyword">go</span> run ./<span class="hljs-number">01</span>_goroutine/<span class="hljs-number">06</span><br>ping<br>^Csignal: interrupt<br></code></pre></td></tr></table></figure><p>这个有两种改法，一种是给 reporter 加上 shutdown 方法，类似 http 的 shutdown，等待所有的异步上报完成之后，我们再退出，另外一种是我们直接使用 一些 worker 来执行，在当然这个 worker 也要实现类似 shutdown 的方法。一般推荐后一种，因为这样可以避免请求量比较大时，创建大量 goroutine，当然如果请求量比较小，不会很大，用第一种也是可以的。<br>我们给一个第二种的简单实现，第一种可以参考 <a href="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html">https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Reporter 埋点服务上报</span><br><span class="hljs-keyword">type</span> Reporter <span class="hljs-keyword">struct</span> &#123;<br>worker   <span class="hljs-keyword">int</span><br>messages <span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span><br>wg       sync.WaitGroup<br>closed   <span class="hljs-keyword">bool</span><br>&#125;<br><br><span class="hljs-comment">// NewReporter NewReporter</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewReporter</span><span class="hljs-params">(worker, buffer <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Reporter</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;Reporter&#123;worker: worker, messages: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, buffer)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reporter)</span> <span class="hljs-title">run</span><span class="hljs-params">(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-stop<br>r.shutdown()<br>&#125;()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r.worker; i++ &#123;<br>r.wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> r.messages &#123;<br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>fmt.Printf(<span class="hljs-string">&quot;report: %s\n&quot;</span>, msg)<br>&#125;<br>r.wg.Done()<br>&#125;()<br>&#125;<br>r.wg.Wait()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reporter)</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span> &#123;<br>r.closed = <span class="hljs-literal">true</span><br><span class="hljs-comment">// 注意，这个一定要在主服务结束之后再执行，避免关闭 channel 还有其他地方在啊写入</span><br><span class="hljs-built_in">close</span>(r.messages)<br>&#125;<br><br><span class="hljs-comment">// 模拟耗时</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reporter)</span> <span class="hljs-title">report</span><span class="hljs-params">(data <span class="hljs-keyword">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> r.closed &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>r.messages &lt;- data<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在 main 函数中我们加上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    reporter.run(stop)<br>    done &lt;- <span class="hljs-literal">nil</span><br>&#125;()<br></code></pre></td></tr></table></figure><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">留一个思考题：我们在 reporter 的实现可能会导致 panic，你是否发现了呢？如何修改可以避免这种情况？<br>感谢评论区 @hddxds 的指出，我这里给出一个实现例子: <a href="https://github.com/mohuishou/Go-000/blob/main/Week03/blog/01_goroutine/07/reporter.go">点击查看</a>，可以看看是否和你想的一样？<br>如果你对为什么会出现 panic 或者为什么要这么实现感到困惑可以查看后面的这篇文章 <a href="https://lailin.xyz/post/go-training-week3-channel.html">Go并发编程(十) 深入理解 Channel</a></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下这一部分讲到的几个要点，这也是我们</p><ol><li><strong>请将是否异步调用的选择权交给调用者</strong>，不然很有可能大家并不知道你在这个函数里面使用了 goroutine</li><li>如果你要启动一个 goroutine 请对它负责<ol><li><strong>永远不要启动一个你无法控制它退出，或者你无法知道它何时推出的 goroutine</strong></li><li>还有上一篇提到的，启动 goroutine 时请加上 panic recovery 机制，避免服务直接不可用</li><li>造成 goroutine 泄漏的主要原因就是 goroutine 中造成了阻塞，并且没有外部手段控制它退出</li></ol></li><li><strong>尽量避免在请求中直接启动 goroutine 来处理问题</strong>，而应该通过启动 worker 来进行消费，这样可以避免由于请求量过大，而导致大量创建 goroutine 从而导致 oom，当然如果请求量本身非常小，那当我没说</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 这篇 dave 在 Qcon China 上的文章值得好好拜读几遍</li><li><a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html">https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html</a></li><li><a href="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html">https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html</a></li><li><a href="https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html">https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html</a></li></ul><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week03: Go 并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go错误处理最佳实践</title>
    <link href="/post/go-training-03.html"/>
    <url>/post/go-training-03.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>太长不看系列，我们总结一下在 go 中 如何处理 error，具体的原因我们会在下面的内容中进行详细的解释</p><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><ol><li>在程序启动的时候，如果有强依赖的服务出现故障时 <code>panic</code>  退出</li><li>在程序启动的时候，如果发现有配置明显不符合要求， 可以 <code>panic</code>  退出（防御编程）</li><li>其他情况下只要不是不可恢复的程序错误，都不应该直接 <code>panic</code>  应该返回 <code>error</code></li><li>在程序入口处，例如 <code>gin</code>  中间件需要使用 <code>recover</code>  预防 <code>panic</code>  程序退出</li><li>在程序中我们应该避免使用野生的 <code>goroutine</code><ol><li>如果是在请求中需要执行异步任务，应该使用异步 <code>worker</code> ，消息通知的方式进行处理，避免请求量大时大量 <code>goroutine</code> 创建</li><li>如果需要使用 <code>goroutine</code> 时，应该使用同一的 <code>Go</code>  函数进行创建，这个函数中会进行 <code>recover</code> ，避免因为野生 <code>goroutine</code> panic 导致主进程退出</li></ol></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Go</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span>&#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>                log.Printf(<span class="hljs-string">&quot;panic: %+v&quot;</span>, err)<br>            &#125;<br>        &#125;()<br><br>        f()<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><ol><li>我们在应用程序中使用 <code>github.com/pkg/errors</code>  处理应用错误，<strong>注意在公共库当中，我们一般不使用这个</strong></li><li><code>error</code>  应该是函数的最后一个返回值，当 <code>error</code>  不为 <code>nil</code>  时，函数的其他返回值是不可用的状态，不应该对其他返回值做任何期待<ol><li><code>func f() (io.Reader, *S1, error)</code>  在这里，我们不知道 <code>io.Reader</code>  中是否有数据，可能有，也有可能有一部分</li></ol></li><li>错误处理的时候应该先判断错误， <code>if err != nil</code>  出现错误及时返回，使代码是一条流畅的直线，避免过多的嵌套.</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// good case</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>    a, err := A()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-comment">// ... 其他逻辑</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// bad case</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>    a, err := A()<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 其他逻辑</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>在<strong>应用程序</strong>中出现错误时，使用 <code>errors.New</code>  或者 <code>errors.Errorf</code>  返回错误</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *usecese)</span> <span class="hljs-title">usecase1</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>    money := u.repo.getMoney(uid)<br>    <span class="hljs-keyword">if</span> money &lt; <span class="hljs-number">10</span> &#123;<br>        errors.Errorf(<span class="hljs-string">&quot;用户余额不足, uid: %d, money: %d&quot;</span>, uid, money)<br>    &#125;<br>    <span class="hljs-comment">// 其他逻辑</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>如果是调用<strong>应用程序的</strong>其他函数出现错误，请直接返回，如果需要携带信息，请使用 <code>errors.WithMessage</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *usecese)</span> <span class="hljs-title">usecase2</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>    name, err := u.repo.getUserName(uid)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> errors.WithMessage(err, <span class="hljs-string">&quot;其他附加信息&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 其他逻辑</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>如果是调用其他库（标准库、企业公共库、开源第三方库等）获取到错误时，请使用 <code>errors.Wrap</code>  添加堆栈信息<ol><li>切记，不要每个地方都是用 <code>errors.Wrap</code>  只需要在错误第一次出现时进行 <code>errors.Wrap</code>  即可</li><li>根据场景进行判断是否需要将其他库的原始错误吞掉，例如可以把 <code>repository</code>  层的数据库相关错误吞掉，返回业务错误码，避免后续我们分割微服务或者更换 <code>ORM</code>  库时需要去修改上层代码</li><li>注意我们在基础库，被大量引入的第三方库编写时一般不使用 <code>errors.Wrap</code>  避免堆栈信息重复</li></ol></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>    err := json.Unmashal(&amp;a, data)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;其他附加信息&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 其他逻辑</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li><strong>禁止</strong>每个出错的地方都打日志，<strong>只需要</strong>在进程的最开始的地方使用 <code>%+v</code>  进行统一打印，例如 http/rpc 服务的中间件</li><li>错误判断使用 <code>errors.Is</code>  进行比较</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>    err := A()<br>    <span class="hljs-keyword">if</span> errors.Is(err, io.EOF)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 其他逻辑</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="9"><li>错误类型判断，使用 <code>errors.As</code>  进行赋值</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>    err := A()<br><br>    <span class="hljs-keyword">var</span> errA errorA<br>    <span class="hljs-keyword">if</span> errors.As(err, &amp;errA)&#123;<br>    <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-comment">// 其他逻辑</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="10"><li>如何判定错误的信息是否足够，想一想当你的代码出现问题需要排查的时候你的错误信息是否可以帮助你快速的定位问题，例如我们在请求中一般会输出参数信息，用于辅助判断错误</li><li>对于业务错误，推荐在一个统一的地方创建一个错误字典，错误字典里面应该包含错误的 code，并且在日志中作为独立字段打印，方便做业务告警的判断，错误必须有清晰的错误文档</li><li>不需要返回，被忽略的错误<strong>必须</strong>输出日志信息</li><li>同一个地方不停的报错，最好不要不停输出错误日志，这样可能会导致被大量的错误日志信息淹没，无法排查问题，比较好的做法是打印一次错误详情，然后打印出错误出现的次数</li><li>对同一个类型的错误，采用相同的模式，例如参数错误，不要有的返回 404 有的返回 200</li><li>处理错误的时候，需要处理已分配的资源，使用 <code>defer</code>  进行清理，例如文件句柄</li></ol><h2 id="panic-or-error"><a href="#panic-or-error" class="headerlink" title="panic or error?"></a>panic or error?</h2><ol><li>在 Go 中 panic 会导致程序直接退出，是一个致命的错误，如果使用 <code>panic</code>  <code>recover</code>  进行处理的话，会存在很多问题<ol><li>性能问题，频繁 panic recover 性能不好</li><li>容易导致程序异常退出，只要有一个地方没有处理到就会导致程序进程整个退出</li><li>不可控，一旦 panic 就将处理逻辑移交给了外部，我们并不能预设外部包一定会进行处理</li></ol></li><li>什么时候使用 panic 呢？<ol><li>对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic</li></ol></li><li>使用 error 处理有哪些好处？<ol><li>简单。</li><li>考虑失败，而不是成功(Plan for failure, not success)。</li><li>没有隐藏的控制流。</li><li>完全交给你来控制 error。</li><li>Error are values。</li></ol></li></ol><h2 id="为什么标准库中-errors-New-会返回一个指针"><a href="#为什么标准库中-errors-New-会返回一个指针" class="headerlink" title="为什么标准库中 errors.New 会返回一个指针"></a>为什么标准库中 errors.New 会返回一个指针</h2><p>翻看标准库的源代码我们可以发现， <code>errors</code>  库中的 <code>errorString</code>  结构体实现了 <code>error</code>  接口，为什么在 <code>New</code>  一个 error 的时候会返回一个结构体的指针呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// New returns an error that formats as the given text.</span><br><span class="hljs-comment">// Each call to New returns a distinct error value even if the text is identical.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;errorString&#123;text&#125;<br>&#125;<br><br><span class="hljs-comment">// errorString is a trivial implementation of error.</span><br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;<br>s <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> e.s<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先来看一个例子，我们同样创建了 errorString 的结构体，我们自定义的和标准库中的唯一不同就是，自建的这个返回的是值，而不是指针。<br>在 <code>main</code>  函数的对比中我们就可以发现，我们自定义的 <code>errorString</code>  在对比的时候只要对应的字符串相同就会返回 true，但是标准库的包不会。<br>这是因为，在对比两个 struct 是否相同的时候，会去对比，这两个 struct 里面的各个字段是否是相同的，如果相同就返回 true，但是对比指针的时候会去判断两个指针的地址是否一致。<br><strong>如果字符串相等就返回 true 会导致什么问题呢？</strong><br>如果我有两个包定义了字符串相同的想个错误，在其他库调用对比的时候，可能会由于不同的书写顺序走进不同的分支导致一些不可预期的奇奇怪怪的错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;<br>text <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e errorString)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> e.text<br>&#125;<br><br><span class="hljs-comment">// New 创建一个自定义错误</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> errorString&#123;text: s&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> errorString1 = New(<span class="hljs-string">&quot;test a&quot;</span>)<br><span class="hljs-keyword">var</span> err1 = errors.New(<span class="hljs-string">&quot;test b&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> errorString1 == New(<span class="hljs-string">&quot;test a&quot;</span>) &#123;<br>fmt.Println(<span class="hljs-string">&quot;err string a&quot;</span>) <span class="hljs-comment">// 会输出</span><br>&#125;<br><br><span class="hljs-keyword">if</span> err1 == errors.New(<span class="hljs-string">&quot;test b&quot;</span>) &#123;<br>fmt.Println(<span class="hljs-string">&quot;err b&quot;</span>) <span class="hljs-comment">// 不会输出</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="error-type-错误定义与判断"><a href="#error-type-错误定义与判断" class="headerlink" title="error type: 错误定义与判断"></a>error type: 错误定义与判断</h2><h3 id="Sentinel-Error"><a href="#Sentinel-Error" class="headerlink" title="Sentinel Error"></a>Sentinel Error</h3><p>哨兵错误，就是定义一些包级别的错误变量，然后在调用的时候外部包可以直接对比变量进行判定，在标准库当中大量的使用了这种方式<br>例如下方 <code>io</code>  库中定义的错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// EOF is the error returned by Read when no more input is available.</span><br><span class="hljs-comment">// Functions should return EOF only to signal a graceful end of input.</span><br><span class="hljs-comment">// If the EOF occurs unexpectedly in a structured data stream,</span><br><span class="hljs-comment">// the appropriate error is either ErrUnexpectedEOF or some other error</span><br><span class="hljs-comment">// giving more detail.</span><br><span class="hljs-keyword">var</span> EOF = errors.New(<span class="hljs-string">&quot;EOF&quot;</span>)<br><br><span class="hljs-comment">// ErrUnexpectedEOF means that EOF was encountered in the</span><br><span class="hljs-comment">// middle of reading a fixed-size block or data structure.</span><br><span class="hljs-keyword">var</span> ErrUnexpectedEOF = errors.New(<span class="hljs-string">&quot;unexpected EOF&quot;</span>)<br><br><span class="hljs-comment">// ErrNoProgress is returned by some clients of an io.Reader when</span><br><span class="hljs-comment">// many calls to Read have failed to return any data or error,</span><br><span class="hljs-comment">// usually the sign of a broken io.Reader implementation.</span><br><span class="hljs-keyword">var</span> ErrNoProgress = errors.New(<span class="hljs-string">&quot;multiple Read calls return no data or error&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们在外部判定的时候一般使用等值判定或者使用 <code>errors.Is</code>  进行判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-keyword">if</span> errors.Is(err, io.EOF)&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种错误处理方式有一个问题是，将 error 当做包的 API 暴露给了第三方，这样会导致在做重构或者升级的时候很麻烦，并且这种方式包含的错误信息会十分的有限</p><h3 id="error-types"><a href="#error-types" class="headerlink" title="error types"></a>error types</h3><p>这个就类似我们前面定义的 <code>errorString</code>  一样实现了 <code>error</code>  的接口，然后在外部是否类型断言来判断是否是这种错误类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStruct <span class="hljs-keyword">struct</span> &#123;<br>s <span class="hljs-keyword">string</span><br>    name <span class="hljs-keyword">string</span><br>    path <span class="hljs-keyword">string</span><br>&#125;<br><br><br><br><span class="hljs-comment">// 使用的时候</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">switch</span> err.(<span class="hljs-keyword">type</span>) &#123;<br>        <span class="hljs-keyword">case</span> *MyStruct:<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">case</span> others:<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式相对于哨兵来说，可以包含更加丰富的信息，但是同样也将错误的类型暴露给了外部，例如标准库中的 <code>os.PathError</code></p><h3 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h3><p>不透明的错误处理，这种方式最大的特点就是只返回错误，暴露错误判定接口，不返回类型，这样可以减少 API 的暴露，后续的处理会比较灵活，这个一般用在公共库会比较好</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> temporary <span class="hljs-keyword">interface</span> &#123;<br>Temporary() <span class="hljs-keyword">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsTemporary</span><span class="hljs-params">(err error)</span> <span class="hljs-title">bool</span></span> &#123;<br>te, ok := err.(temporary)<br><span class="hljs-keyword">return</span> ok &amp;&amp; te.Temporary()<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值</p><h2 id="error-handle-错误处理优化"><a href="#error-handle-错误处理优化" class="headerlink" title="error handle: 错误处理优化"></a>error handle: 错误处理优化</h2><p>在 go 中常常会存在大量的 <code>if err</code>  代码，下面介绍两种常见的减少这种代码的方式</p><h3 id="bufio-scan"><a href="#bufio-scan" class="headerlink" title="bufio.scan"></a>bufio.scan</h3><p>对比下面两个函数的处理我们可以发现， <code>count2</code>  使用 <code>sc.Scan</code>  之后一个 <code>if err</code>  的判断都没有，极大的简化了代码，这是因为在 <code>sc.Scan</code>  做了很多处理，像很多类似的，需要循环读取的都可以考虑像这样包装之后进行处理，这样外部包调用的时候就会非常简洁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 统计文件行数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">count</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>br    = bufio.NewReader(r)<br>lines <span class="hljs-keyword">int</span><br>err   error<br>)<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 读取到换行符就说明是一行</span><br>_, err = br.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>lines++<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 当错误是 EOF 的时候说明文件读取完毕了</span><br><span class="hljs-keyword">if</span> err != io.EOF &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> lines, err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">count2</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>sc    = bufio.NewScanner(r)<br>lines <span class="hljs-keyword">int</span><br>)<br><br><span class="hljs-keyword">for</span> sc.Scan() &#123;<br>lines++<br>&#125;<br><br><span class="hljs-keyword">return</span> lines, sc.Err()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="error-writer"><a href="#error-writer" class="headerlink" title="error writer"></a>error writer</h3><p>看一个来自 go blog 的例子：<a href="https://blog.golang.org/errors-are-values">https://blog.golang.org/errors-are-values</a><br>一般代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">_, err = fd.Write(p0[a:b])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br>_, err = fd.Write(p1[c:d])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br>_, err = fd.Write(p2[e:f])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">// and so on</span><br></code></pre></td></tr></table></figure><p>errWriter</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> errWriter <span class="hljs-keyword">struct</span> &#123;<br>    w   io.Writer<br>    err error<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ew *errWriter)</span> <span class="hljs-title">write</span><span class="hljs-params">(buf []<span class="hljs-keyword">byte</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> ew.err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    _, ew.err = ew.w.Write(buf)<br>&#125;<br><br><span class="hljs-comment">// 使用时</span><br>ew := &amp;errWriter&#123;w: fd&#125;<br>ew.write(p0[a:b])<br>ew.write(p1[c:d])<br>ew.write(p2[e:f])<br><span class="hljs-comment">// and so on</span><br><span class="hljs-keyword">if</span> ew.err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> ew.err<br>&#125;<br></code></pre></td></tr></table></figure><p>如果去翻 标准库中 bufio.Writer 的源代码，你会发现也有这种用法，这种就是将重复的逻辑进行了封装，然后把 error 暂存，然后我们就只需要在最后判断一下 error 就行了</p><h2 id="wrap-error-错误包装"><a href="#wrap-error-错误包装" class="headerlink" title="wrap error: 错误包装"></a>wrap error: 错误包装</h2><h3 id="errors-wrap-有何作用，为什么不用标准库的-fmt-Errorf-quot-w-quot"><a href="#errors-wrap-有何作用，为什么不用标准库的-fmt-Errorf-quot-w-quot" class="headerlink" title="errors.wrap 有何作用，为什么不用标准库的 fmt.Errorf(&quot;%w&quot;)"></a>errors.wrap 有何作用，为什么不用标准库的 <code>fmt.Errorf(&quot;%w&quot;)</code></h3><p>我们先看一下标准库的源码，我们可以发现当 <code>p.wrappedErr != nil</code>  的时候（也就是有 %w）的时候，会使用一个 <code>wrapError</code>  将错误包装，看 <code>wrapError</code>  的源码可以发现，这个方法只是包装了一下原始错误，并且可以做到附加一些文本信息，但是没有堆栈信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<br>p := newPrinter()<br>p.wrapErrs = <span class="hljs-literal">true</span><br>p.doPrintf(format, a)<br>s := <span class="hljs-keyword">string</span>(p.buf)<br><span class="hljs-keyword">var</span> err error<br><span class="hljs-keyword">if</span> p.wrappedErr == <span class="hljs-literal">nil</span> &#123;<br>err = errors.New(s)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>err = &amp;wrapError&#123;s, p.wrappedErr&#125;<br>&#125;<br>p.free()<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">type</span> wrapError <span class="hljs-keyword">struct</span> &#123;<br>msg <span class="hljs-keyword">string</span><br>err error<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> e.msg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span> <span class="hljs-title">Unwrap</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> e.err<br>&#125;<br></code></pre></td></tr></table></figure><p>在看一下 pkg/errors 的源码，我肯可以发现除了使用 <code>withMessage</code>  附加了错误信息之外还使用 <code>withStack</code>  附加了堆栈信息，这样我们在程序入口处打印日志信息的时候就可以将堆栈信息一并打出了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Wrap returns an error annotating err with a stack trace</span><br><span class="hljs-comment">// at the point Wrap is called, and the supplied message.</span><br><span class="hljs-comment">// If err is nil, Wrap returns nil.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Wrap</span><span class="hljs-params">(err error, message <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>err = &amp;withMessage&#123;<br>cause: err,<br>msg:   message,<br>&#125;<br><span class="hljs-keyword">return</span> &amp;withStack&#123;<br>err,<br>callers(),<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为什么不允许处处使用-errors-Wrap"><a href="#为什么不允许处处使用-errors-Wrap" class="headerlink" title="为什么不允许处处使用 errors.Wrap"></a>为什么不允许处处使用 errors.Wrap</h3><p>因为每一次 <code>errors.Wrap</code>  的调用都会为错误添加堆栈信息，如果处处调用那会有大量的无用堆栈<br>我们先看一下只有一处 wrap</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;err: %+v&quot;</span>, c())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(fmt.Errorf(<span class="hljs-string">&quot;xxx&quot;</span>), <span class="hljs-string">&quot;test&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> a()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> b()<br>&#125;<br></code></pre></td></tr></table></figure><p>看结果我们可以发现已经可以打印出全部的堆栈信息了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">err: xxx<br>test<br>main.a<br>        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span><br>main.b<br>        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">18</span><br>main.c<br>        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span><br>main.main<br>        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span><br>runtime.main<br>        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span><br>runtime.goexit<br>        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span><br></code></pre></td></tr></table></figure><p>再看多处 wrap 的现象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;err: %+v&quot;</span>, c())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(fmt.Errorf(<span class="hljs-string">&quot;xxx&quot;</span>), <span class="hljs-string">&quot;a&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(a(), <span class="hljs-string">&quot;b&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(b(), <span class="hljs-string">&quot;c&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到每一处 wrap 都添加了一次堆栈信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go">err: xxx<br>a<br>main.a<br>        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span><br>main.b<br>        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">18</span><br>main.c<br>        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span><br>main.main<br>        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span><br>runtime.main<br>        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span><br>runtime.goexit<br>        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span><br>b<br>main.b<br>        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">18</span><br>main.c<br>        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span><br>main.main<br>        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span><br>runtime.main<br>        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span><br>runtime.goexit<br>        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span><br>c<br>main.c<br>        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span><br>main.main<br>        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span><br>runtime.main<br>        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span><br>runtime.goexit<br>        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span><br></code></pre></td></tr></table></figure><h2 id="标准库-errors-Is-As-怎么判断错误"><a href="#标准库-errors-Is-As-怎么判断错误" class="headerlink" title="标准库 errors.Is / As 怎么判断错误"></a>标准库 errors.Is / As 怎么判断错误</h2><h3 id="errors-Is"><a href="#errors-Is" class="headerlink" title="errors.Is"></a>errors.Is</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Is</span><span class="hljs-params">(err, target error)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> target == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err == target<br>&#125;<br><span class="hljs-comment">// 通过反射判读 target 是否可以被比较</span><br>isComparable := reflectlite.TypeOf(target).Comparable()<br><span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-comment">// 循环判断是否相等</span><br><span class="hljs-keyword">if</span> isComparable &amp;&amp; err == target &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>        <span class="hljs-comment">// 判断是否实现了 is 接口，如果有实现就直接判断</span><br><span class="hljs-keyword">if</span> x, ok := err.(<span class="hljs-keyword">interface</span>&#123; Is(error) <span class="hljs-keyword">bool</span> &#125;); ok &amp;&amp; x.Is(target) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 去判断是否实现了 unwrap 的接口，如果实现了就进行 unwrap</span><br><span class="hljs-keyword">if</span> err = Unwrap(err); err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="errors-As"><a href="#errors-As" class="headerlink" title="errors.As"></a>errors.As</h3><p>和 is 的逻辑类似，就是不断的进行 unwrap 进行比较，只要有一个相同就返回，如果一直到底都不行就返回 false</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">As</span><span class="hljs-params">(err error, target <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> target == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;errors: target cannot be nil&quot;</span>)<br>&#125;<br>val := reflectlite.ValueOf(target)<br>typ := val.Type()<br><span class="hljs-keyword">if</span> typ.Kind() != reflectlite.Ptr || val.IsNil() &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;errors: target must be a non-nil pointer&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;&amp; !e.Implements(errorType) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;errors: *target must be interface or implement error&quot;</span>)<br>&#125;<br>targetType := typ.Elem()<br><span class="hljs-keyword">for</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> reflectlite.TypeOf(err).AssignableTo(targetType) &#123;<br>val.Elem().Set(reflectlite.ValueOf(err))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">if</span> x, ok := err.(<span class="hljs-keyword">interface</span>&#123; As(<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">bool</span> &#125;); ok &amp;&amp; x.As(target) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>err = Unwrap(err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week02: Go错误处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>error</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务(二) 服务发现&amp;多租户</title>
    <link href="/post/go-training-02.html"/>
    <url>/post/go-training-02.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><p>上篇文章我们讲到微服务的定义，优缺点，对外暴露等，服务除了对外暴露之外，服务之间还需要相互进行调用，不同的服务之间通过什么样的协议进行交互，服务发现如何实现，如何保证服务的平滑发布与重启，测试环境的问题如何解决等。</p><h2 id="服务间通信方式-gRPC"><a href="#服务间通信方式-gRPC" class="headerlink" title="服务间通信方式: gRPC"></a>服务间通信方式: gRPC</h2><ul><li><strong>为什么采用 gRPC?</strong><ul><li><strong>多语言：</strong>语言中立，支持多种语言。</li><li><strong>轻量级、高性能：</strong>序列化支持 PB(Protocol Buffer)和 JSON，PB 是一种语言无关的高性能序列化框架。</li><li><strong>可插拔</strong></li><li><strong>IDL：</strong>基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub。</li><li>移动端：基于<strong>标准的 HTTP2 设计，支持双向流、消息头压缩、单 TCP 的多路复用</strong>、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加<strong>省电和节省网络流量</strong>。</li><li><strong>服务而非对象、消息而非引用：</strong>促进微服务的系统间粗粒度消息交互设计理念。</li><li><strong>负载无关的：</strong>不同的服务需要使用不同的消息类型和编码，例如 protocol buffers、JSON、XML 和 Thrift。</li><li>流：Streaming API。</li><li><strong>阻塞式和非阻塞式：</strong>支持异步和同步处理在客户端和服务端间交互的消息序列。</li><li><strong>元数据交换：</strong>常见的横切关注点，如认证或跟踪，依赖数据交换。<ul><li>metadata</li></ul></li><li><strong>标准化状态码：</strong>客户端通常以有限的方式响应 API 调用返回的错误。</li></ul></li><li><strong>为什么不使用 restful</strong><ul><li>每个客户端都需要单独写 SDK，复杂麻烦</li><li>需要单独写文档，常常会因为代码更新了但是文档没更新陷入坑中</li><li>性能不太好，json 传递相对于 pb 更耗流量，性能更低</li><li>http1.1 是一个单连接的请求，在内部网络环境，使用 http 比较浪费</li><li><strong>restful 是一个松散约束的协议，非常灵活，每个人，每个团队出来的代码都不太一样，比较容易出错</strong></li></ul></li></ul><h2 id="优雅启动与优雅中止（健康检查）"><a href="#优雅启动与优雅中止（健康检查）" class="headerlink" title="优雅启动与优雅中止（健康检查）"></a>优雅启动与优雅中止（健康检查）</h2><h3 id="优雅启动"><a href="#优雅启动" class="headerlink" title="优雅启动"></a>优雅启动</h3><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1606735520428-1f37cd30-225e-4b2c-a104-7ba3bbfe17c2.svg" alt="01_Go进阶训练营_微服务_v1.svg"></p><ol><li>Provider 启动，k8s 中的启动脚本会定时去检查服务的健康检查接口</li><li>健康检查通过之后，服务注册脚本向注册中心注册服务（rpc://ip:port）</li><li>消费者定时从服务注册中心获取服务方地址信息</li><li>获取成功后，会定时的向服务方发起健康检查，健康检查通过后才会向这个地址发起请求<ol><li>在运行过程中如果健康检查出现问题，会从消费者本地的负载均衡中移除</li></ol></li></ol><h3 id="优雅中止"><a href="#优雅中止" class="headerlink" title="优雅中止"></a>优雅中止</h3><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1606742744880-38b16366-6370-408b-8619-7a67d56c0c49.svg" alt="01_Go进阶训练营_微服务_v1.drawio.svg"></p><ol><li>触发下线操作: 首先用户在发布平台点击发版/下线按钮</li><li>发布部署平台向注册中心发起服务注销请求，在注册中心下线服务的这个节点<ul><li>这里在发布部署平台实现有个好处，不用每个应用都去实现一遍相同的逻辑</li><li>在应用受到退出信号之后由应用主动发起注销操作也是可以的</li></ul></li></ol><ul><li>2.1 注册中心下线应用之后，消费者会获取到服务注销的事件，然后将服务方的节点从本地负载均衡当中移除<ol><li>注意这一步操作会有一段时间，下面的第四步并不是这一步结束了才开始</li></ol></li></ul><ol start="3"><li>发布部署平台向应用发送 <code>SIGTERM</code>  信号，应用捕获到之后执行<ol><li>将健康检查接口设置为不健康，返回错误<ol><li>这个时候如果消费者还在调用应用程序，调用健康检查接口发现无法通过，也会将服务节点从本地负载均衡当中移除</li></ol></li><li>调用 grpc/http 的 shutdown 接口，并且传递超时时间，等待连接全部关闭后退出<ol><li>这个超时时间一般为 2 个心跳周期</li></ol></li></ol></li><li>发布部署平台如果发现应用程序长时间没有完成退出，发送 <code>SIGKILL</code>  强制退出应用<ol><li>这个超时时间根据应用进行设置一般为 10 - 60s</li></ol></li></ol><h3 id="实战-在-gin-中实现优雅启动和优雅中止"><a href="#实战-在-gin-中实现优雅启动和优雅中止" class="headerlink" title="实战-在 gin 中实现优雅启动和优雅中止"></a>实战-在 gin 中实现优雅启动和优雅中止</h3><p>源码可以在这里找到<br><a href="https://github.com/mohuishou/Go-000/tree/main/Week01">https://github.com/mohuishou/Go-000/tree/main/Week01</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;os/signal&quot;</span><br><span class="hljs-string">&quot;syscall&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-comment">// 模拟慢请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sleep</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>t := ctx.Query(<span class="hljs-string">&quot;t&quot;</span>)<br>s, err := strconv.Atoi(t)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ctx.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;参数错误: &quot;</span> + t&#125;)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>time.Sleep(time.Duration(s) * time.Second)<br>ctx.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;msg&quot;</span>: fmt.Sprintf(<span class="hljs-string">&quot;sleep %d s&quot;</span>, s)&#125;)<br>&#125;<br><br><br><span class="hljs-keyword">const</span> (<br>stateHealth   = <span class="hljs-string">&quot;health&quot;</span><br>stateUnHealth = <span class="hljs-string">&quot;unhealth&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> state = stateHealth<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">health</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>status := http.StatusOK<br><span class="hljs-keyword">if</span> state == stateUnHealth &#123;<br>status = http.StatusServiceUnavailable<br>&#125;<br>ctx.JSON(status, gin.H&#123;<span class="hljs-string">&quot;data&quot;</span>: state&#125;)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>e := gin.Default()<br>e.GET(<span class="hljs-string">&quot;/health&quot;</span>, health)<br>e.GET(<span class="hljs-string">&quot;/sleep&quot;</span>, sleep)<br><br>server := &amp;http.Server&#123;<br>Addr:    <span class="hljs-string">&quot;:8080&quot;</span>,<br>Handler: e,<br>&#125;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := server.ListenAndServe(); err != <span class="hljs-literal">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;<br>log.Fatalf(<span class="hljs-string">&quot;server run err: %+v&quot;</span>, err)<br>&#125;<br>&#125;()<br><br><span class="hljs-comment">// 用于捕获退出信号</span><br>quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal)<br><br><span class="hljs-comment">// kill (no param) default send syscall.SIGTERM</span><br><span class="hljs-comment">// kill -2 is syscall.SIGINT</span><br><span class="hljs-comment">// kill -9 is syscall.SIGKILL but can&#x27;t be catch, so don&#x27;t need add it</span><br>signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)<br>&lt;-quit<br>log.Println(<span class="hljs-string">&quot;Shutting down server...&quot;</span>)<br><br><span class="hljs-comment">// 捕获到退出信号之后将健康检查状态设置为 unhealth</span><br>state = stateUnHealth<br>log.Println(<span class="hljs-string">&quot;Shutting down state: &quot;</span>, state)<br><br><span class="hljs-comment">// 设置超时时间，两个心跳周期，假设一次心跳 3s</span><br>ctx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">6</span>*time.Second)<br><span class="hljs-keyword">defer</span> cancel()<br><br><span class="hljs-comment">// Shutdown 接口，如果没有新的连接了就会释放，传入超时 context</span><br><span class="hljs-comment">// 调用这个接口会关闭服务，但是不会中断活动连接</span><br><span class="hljs-comment">// 首先会将端口监听移除</span><br><span class="hljs-comment">// 然后会关闭所有的空闲连接</span><br><span class="hljs-comment">// 然后等待活动的连接变为空闲后关闭</span><br><span class="hljs-comment">// 如果等待时间超过了传入的 context 的超时时间，就会强制退出</span><br><span class="hljs-comment">// 调用这个接口 server 监听端口会返回 ErrServerClosed 错误</span><br><span class="hljs-comment">// 注意，这个接口不会关闭和等待websocket这种被劫持的链接，如果做一些处理。可以使用 RegisterOnShutdown 注册一些清理的方法</span><br><span class="hljs-keyword">if</span> err := server.Shutdown(ctx); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;Server forced to shutdown:&quot;</span>, err)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;Server exiting&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1606744144537-0fe881ca-5716-4b80-8800-0dee0a266c5f.png" alt="image.png"></p><h3 id="客户端发现"><a href="#客户端发现" class="headerlink" title="客户端发现"></a>客户端发现</h3><ul><li>直连，比服务端服务发现少一次网络跳转</li><li>Consumer 需要内置特定的服务发现客户端和发现逻辑<ul><li>可以将负载均衡逻辑下放到 sidecar 中进行解耦</li></ul></li></ul><h3 id="服务端发现"><a href="#服务端发现" class="headerlink" title="服务端发现"></a>服务端发现</h3><ul><li>Consumer 无需关注服务发现具体细节，只需知道服务的 DNS 域名即可</li><li>支持异构语言开发，需要基础设施支撑，多了一次网络跳转，可能有性能损失，基础设施会比较复杂<blockquote><p>B 站这边采用的是客户端发现的模式，我们公司用的更多的是服务端发现的模式</p></blockquote></li></ul><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p><strong>CP、CA、还是 AP</strong><br>实际场景是海量服务发现和注册，服务状态可以弱一致, 需要的是 AP 系统，只需最终一致性即可</p><ul><li>注册的事件延迟<ul><li>高可用的服务在这方面问题不大</li></ul></li><li>注销的事件延迟<ul><li>因为有上文提到的健康检查的机制，即使注销延迟，客户端也会主动的将节点移除</li></ul></li><li>相关文档<ul><li>多个注册中心的对比：<a href="https://developer.aliyun.com/article/698930">https://developer.aliyun.com/article/698930</a></li><li><a href="https://nacos.io/zh-cn/index.html">https://nacos.io/zh-cn/index.html</a> 阿里开源的注册中心，毛老师推荐 😂</li></ul></li></ul><p><strong>eureka 实现原理</strong></p><blockquote><p>b 站仿照用 go 写了一个 <a href="https://github.com/bilibili/discovery">https://github.com/bilibili/discovery</a></p></blockquote><p><strong><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1606745349658-c7638390-9cbd-4eca-b2ad-4baa15449c3f.png" alt="image.png"></strong></p><ul><li>服务注册<ul><li><strong>注册：</strong>服务方启动后向注册中心任意一个节点发送注册请求，然后这个节点会向其他节点进行广播同步</li><li><strong>心跳：</strong>注册后定期（30s）向注册中心发送心跳</li><li><strong>下线：</strong>下线时向注册中心发送下线请求</li><li>注意：注册中心节点启东市需要加载缓存进行预热，所以不建议这个时候服务进行重启或者是发版</li></ul></li><li>服务发现<ul><li>消费者定期向注册中心长轮训获取节点信息，获取到之后缓存到本地</li></ul></li><li><strong>网络故障</strong><ul><li>服务方与注册中心<ul><li>注册中心会定期（60s）检测已失效（90s 未更新）的实例，失效之后就会移除，但是如果短时间内丢失大量心跳连接，（15min 内心跳低于期望值的 85%）就会开启自我保护模式，保留过期的服务不会进行删除</li></ul></li><li>注册中心与消费者<ul><li>消费者本地有缓存，问题不大</li></ul></li><li>服务方与消费者<ul><li>有健康检查，健康检查不通过时，会从消费者本地负载均衡中移除</li></ul></li></ul></li><li><strong>注册中心故障</strong><ul><li>不建议这个时候服务进行重启或者是发版，因为这个时候注册不上，会导致服务不可用，不发版短时间没有影响</li><li>如果全部挂掉，启动时必须要等两到三个心跳周期，等所有的服务都注册上之后再开始提供服务运行消费者拉取数据</li><li>如果挂掉一个，需要等其他的节点将信息同步到本机之后再提供服务</li><li>数据同步时会对比时间戳，会保证当前节点的数据是最新的</li></ul></li></ul><h2 id="多集群"><a href="#多集群" class="headerlink" title="多集群"></a>多集群</h2><blockquote><p>注意这里的多集群都是单个机房内的</p></blockquote><h3 id="多集群需求从何而来？"><a href="#多集群需求从何而来？" class="headerlink" title="多集群需求从何而来？"></a>多集群需求从何而来？</h3><p>对于类似账号服务的 L0 级别的服务，几乎所有的服务都有依赖，需要尽可能的提高服务的可用性</p><ul><li>从单一集群考虑，多个节点保证可用性，我们通常使用 N+2 的方式来冗余节点。<ul><li>N 一般通过压测得出</li></ul></li><li>从单一集群故障带来的影响面角度考虑冗余多套集群。<ul><li>例如依赖的 redis 出现问题，整个集群挂掉了</li></ul></li><li>单个机房内的机房故障导致的问题<ul><li>多机房部署，如果在云上可能是多个可用区</li></ul></li></ul><h3 id="什么是多集群？"><a href="#什么是多集群？" class="headerlink" title="什么是多集群？"></a>什么是多集群？</h3><ul><li>给某个服务部署多套，每一套都拥有独立的缓存，物理上相当于有多套资源，逻辑上划分为不同的集群，在服务注册的时候向注册中心注册的时候携带相关的集群标签</li></ul><h3 id="如何降低健康检查流量"><a href="#如何降低健康检查流量" class="headerlink" title="如何降低健康检查流量"></a>如何降低健康检查流量</h3><p>对于账号这种大量服务依赖的服务，仅仅是健康检查流量就会导致 30%以上的资源占用（B 站之前的真实情况）<br>可以使用子集算法，将后端的节点均分给所有的客户端</p><ul><li>通常 20-100 个后端，部分场景需要大子集，比如大批量读写操作。</li><li>后端平均分给客户端。</li><li>客户端重启，保持重新均衡，同时对后端重启保持透明，同时连接的变动最小<ul><li>消费者变化的时候需要 重新平衡</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// from google sre</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Subset</span><span class="hljs-params">(backends []<span class="hljs-keyword">string</span>, clientID, subsetSize <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">string</span></span> &#123;<br>subsetCount := <span class="hljs-built_in">len</span>(backends) / subsetSize<br><br><span class="hljs-comment">// Group clients into rounds; each round uses the same shuffled list:</span><br>round := clientID / subsetCount<br><br>r := rand.New(rand.NewSource(<span class="hljs-keyword">int64</span>(round)))<br>r.Shuffle(<span class="hljs-built_in">len</span>(backends), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123; backends[i], backends[j] = backends[j], backends[i] &#125;)<br><br><span class="hljs-comment">// The subset id corresponding to the current client:</span><br>subsetID := clientID % subsetCount<br><br>start := subsetID * subsetSize<br><span class="hljs-keyword">return</span> backends[start : start+subsetSize]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么上面这个算法可以保证可以均匀分布？</strong><br>首先，<strong>shuffle 算法保证在 round 一致的情况下，backend 的排列一定是一致的。</strong><br>因为每个实例拥有从 0 开始的连续唯一的自增 id，且计算过程能够保证每个 round 内所有实例拿到的服务列表的排列一致，因此在同一个 round 内的 client 会分别 backend 排列的不同部分的切片作为选中的后端服务来建立连接。<br>所以只要 client id 是连续的，那么 client 发向 后端的连接就一定是连续的<br><strong>参考资料:</strong><br><a href="https://sre.google/sre-book/load-balancing-datacenter/">https://sre.google/sre-book/load-balancing-datacenter/</a><br><a href="https://xargin.com/limiting-conn-wih-subset/">https://xargin.com/limiting-conn-wih-subset/</a></p><h2 id="多租户（如何解决多套测试环境的问题）"><a href="#多租户（如何解决多套测试环境的问题）" class="headerlink" title="多租户（如何解决多套测试环境的问题）"></a>多租户（如何解决多套测试环境的问题）</h2><p>在一个微服务架构中<strong>允许多系统共存</strong>是利用微服务稳定性以及模块化最有效的方式之一，这种方式一般被称为多租户(multi-tenancy)。租户可以是测试，金丝雀发布，影子系统(shadow systems)，甚至服务层或者产品线，使用租户能够保证代码的隔离性并且能够基于流量租户做路由决策。</p><h3 id="如何解决测试环境的问题"><a href="#如何解决测试环境的问题" class="headerlink" title="如何解决测试环境的问题"></a>如何解决测试环境的问题</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>假设现在有一个服务调用链 A -&gt; B -&gt; C，如果 C 同时有多个同学开发，如果甲同学的代码正在测试中，但是乙同学不小心发了一个版本，就会导致甲同学的代码被冲掉，导致测试同学测着测着就出现 bug。测试同学无法得知这个问题是由于环境导致的还是代码缺陷。</p><h4 id="解决方案-1：多套物理环境（类似上文的多集群）"><a href="#解决方案-1：多套物理环境（类似上文的多集群）" class="headerlink" title="解决方案 1：多套物理环境（类似上文的多集群）"></a>解决方案 1：多套物理环境（类似上文的多集群）</h4><p>搭建多套测试环境，可以做到物理隔离，但是也会存在一些问题：</p><ul><li>混用环境导致的不可靠测试。</li><li>多套环境带来的硬件成本。</li><li>难以做负载测试，仿真线上真实流量情况。</li><li>治标不治本，无法知道当前环境谁在使用，并且几套环境可以满足需求？万一又多几个人开发是不是又需要再来几套？</li></ul><h4 id="解决方案-2：多租户，染色发布"><a href="#解决方案-2：多租户，染色发布" class="headerlink" title="解决方案 2：多租户，染色发布"></a>解决方案 2：多租户，染色发布</h4><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1606799997241-a37aa06a-4d44-4001-96bb-b0287e9eead5.png" alt="image.png"></p><ul><li>注册流程<ul><li>假设我们现在有一套问题的 <code>FAT1</code>  测试环境，然后现在对应用 B 做了修改</li><li>开发同学通过发布平台发布一个新的 B 应用 B<code>，并且带上环境标签，例如:</code>red`</li><li>应用 B<code>向注册中心进行注册时候会带上</code>red`  标签</li><li>消费者 A 在向注册中心获取服务节点数据的时候也会获取到这个标签，并且在本地的负载均衡当中使用 <code>map[string]pool</code>  的结构进行保存</li></ul></li><li>调用流程<ul><li>测试同学通过 A 进行调用测试，如果是 http 就在 header 中打上这个 <code>red</code>  标签，如果是 grpc 就在 metadata 中加入这个标签</li><li>A 调用 B 的时候，发现 header 中存在 <code>red</code>  标签就会去本地负载均衡查询，发现负载均衡中有 red 标签的连接，这个之后就直接调用到 B`，并且在调用的时候 A 会将 header 的标签信息进行透传</li><li>B` 收到请求之后，需要调用 C、D 这时候也是一样的会去负载均衡中进行查询，发现没有就会退回到默认的连接池中</li></ul></li><li>如何进行联调？<ul><li>需要联调的应用打上相同的标签就可以了</li></ul></li><li>注意事项<ul><li>应用版本发布时数据结构，例如 db 中的表，redis 中的 key，必须保证向下兼容</li><li>测试的时候需要使用不同的测试账号</li><li>注意来自外网的请求中的 header 必须删除，确保安全</li></ul></li><li><strong>核心思路</strong><ul><li>跨服务传递请求携带上下文(context)，数据隔离的流量路由方案。<ul><li>根据标签进行流量路由，并且要确保可以透传</li></ul></li><li>利用服务发现注册租户信息，注册成特定的租户。<ul><li>发布部署平台需要支持方便启动多套环境，以及标签注入</li><li>对不同的环境做了隔离，可以保证对关键业务没有影响</li></ul></li></ul></li></ul><h3 id="如何进行全链路压测"><a href="#如何进行全链路压测" class="headerlink" title="如何进行全链路压测"></a>如何进行全链路压测</h3><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1606802196792-9f605d74-4f29-458a-923f-6adc7a087e70.png" alt="image.png"><br>和上面的测试环境的解决方案类似，但是我们需要搭建一套和线上一致的影子系统</p><ul><li>如何解决压测数据对线上数据的影响<ul><li>基础设施需要做改造，采用同样的基础设施节点</li><li>缓存：影子应用存储的数据放到影子库中，使用不同的 db</li><li>数据库：自动将线上的数据结构复制一份到影子数据库中。里面的表结构保持一致，数据库名做一些变化，例如 db_shadow</li><li>消息队列: 推送消息的时候使用不同的 topic 或者是携带一些 metadata 信息</li></ul></li><li>需要提前做一些数据初始化的操作，提前进行准备</li><li>压测时携带压测标签，将流量自动路由到影子服务进行压测</li></ul><p>这种方案同样可以用于灰度发版当中</p><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新</h2><p>看到这里了还不点个关注走一波</p><ul><li><a href="https://lailin.xyz">博客</a> 可以订阅 RSS</li><li><a href="https://github.com/mohuishou">Github</a> Follow me</li><li><a href="https://www.zhihu.com/people/mo-hui-shou-76">知乎</a> 关注账号，顺便点个 👍</li><li><a href="https://toutiao.io/subjects/387401?f=new">开发者头条</a> 订阅订阅号，顺便点个 👍</li></ul><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week01: 微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务(一) 微服务概览</title>
    <link href="/post/go-training-01.html"/>
    <url>/post/go-training-01.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 <a href="https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">博客: Go进阶训练营</a>, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。</p>          </div><p>几个问题</p><p>先问自己几个问题，看是否可以回答，下面我们就带着问题总结课程的内容</p><ul><li>为什么会有微服务？</li><li>微服务是什么？</li><li>微服务可以带来什么好处，又有那些缺点？</li><li>微服务如何构建？</li><li>微服务如何对外暴露？</li><li>微服务如何拆分？</li><li>如何保证微服务之间的安全？</li></ul><h2 id="Q1-为什么会有微服务？"><a href="#Q1-为什么会有微服务？" class="headerlink" title="Q1: 为什么会有微服务？"></a>Q1: 为什么会有微服务？</h2><ul><li>之前一般是一个单一的巨石架构，存在很多问题<ul><li>应用比较复杂，没有人能够搞懂</li><li>应用扩展比较复杂，可靠性比较低</li><li>无法进行敏捷开发和部署</li></ul></li><li>所以一般这个时候就会考虑按照服务、功能进行拆分</li></ul><h2 id="Q2-微服务是什么？"><a href="#Q2-微服务是什么？" class="headerlink" title="Q2: 微服务是什么？"></a>Q2: 微服务是什么？</h2><ul><li>SOA （面向服务）是什么？<ul><li>服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展</li><li><strong>单一职责，</strong>一个服务只做一件事情</li><li><strong>尽可能的早的创建原型，</strong>先定义 API，达成契约</li><li><strong>可移植性比效率更重要，</strong>通讯协议的可移植性更加重要</li></ul></li><li>SOA 和 微服务 是什么关系？<ul><li>微服务是 SOA 的一种实践，微服务也是面向服务的一种架构</li></ul></li><li>微服务是什么？<ul><li><strong>围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。</strong></li></ul></li></ul><h2 id="Q3-微服务可以带来那些好处，又有哪些缺点？"><a href="#Q3-微服务可以带来那些好处，又有哪些缺点？" class="headerlink" title="Q3: 微服务可以带来那些好处，又有哪些缺点？"></a>Q3: 微服务可以带来那些好处，又有哪些缺点？</h2><ul><li>优点<ul><li>服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展</li><li><strong>原子服务，</strong>一个服务只做一件事情，并且这个属于这个服务的也不应该拆分到其他服务去</li><li><strong>独立进程，</strong>一个服务只有一个独立进程，可以很好的和当前的容器化进行结合，无状态的服务可以很容易的享受到，k8s 上的故障转移，自动重启等好处</li><li><strong>隔离部署，</strong>每个服务之间独立部署，可以避免相互影响，并且和按需进行分配资源，节省成本</li><li><strong>去中心化服务治理</strong><ul><li>数据去中心化，每个服务独享数据库，缓存等设施，也有个别情况多个服务共享数据库，例如面向用户的管理后台和面向管理员的管理后台</li><li>治理去中心化</li><li>技术去中心化，每个服务可以使用适合自己的技术进行实施，但是注意如果技术栈过于发散对于企业或者团队本身也是不利的</li></ul></li></ul></li><li>缺点<ul><li><strong>服务之间的依赖关系复杂</strong>，成千上万个服务相互依赖就像一团乱麻一样，剪不断理还乱。<ul><li>常见的解决方案：全链路追踪，例如， opentracing</li></ul></li><li>微服务本身是分布式系统，需要使用 RPC 或者 消息进行通信，此外<strong>，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题</strong><ul><li>例子：服务调用流量会容易被放大，如果 服务 A -&gt; B -&gt;C 如果 A 有一个循环调用 B，B 也有一个循环调用 C，那么一个请求到达 C 之后就被放大了 100 倍甚至上千倍。这是扛不住的</li><li><strong>常见解决方案：粗粒度的进程间通信（batch 接口，批量请求，避免 n+1 问题），隔离，超时保护，负载保护，熔断、限流、降级、重试，负载均衡</strong></li></ul></li><li><strong>会有分布式事务问题，</strong>因为现在每个微服务之间都会有一个独立的数据库，事务在单体应用中很好处理，但是在跨服务时会变得很麻烦<ul><li>常见解决方案：两阶段提交、TCC 等</li><li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">小米信息部技术团队: 分布式事务，这一篇就够了</a></li></ul></li><li><strong>测试会非常复杂，</strong>由于依赖多，无法得知是因为功能异常还是依赖的某个服务发版出现问题<ul><li>常见解决方案：独立测试环境，后面会有一个解决方案</li></ul></li><li>服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。<ul><li>切记，在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，<strong>时刻谨记保持服务契约(接口)的兼容性</strong></li><li>发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</li></ul></li><li><strong>对基础建设的要求很高，</strong>基础设施需要自动化，日志采集，监控数据采集，告警，CICD，K8s 等<ul><li>常见解决方案：上云</li></ul></li></ul></li></ul><h2 id="Q4-微服务如何构建？"><a href="#Q4-微服务如何构建？" class="headerlink" title="Q4: 微服务如何构建？"></a>Q4: 微服务如何构建？</h2><blockquote><p>多个微服务组合(compose)完成了一个完整的用户场景(usecase)。</p></blockquote><ul><li>kit：一个微服务的基础库(框架)。</li><li>service：业务代码 + kit 依赖 + 第三方依赖组成的业务微服务</li><li>rpc + message queue：轻量级通讯</li></ul><h2 id="Q5-微服务如何对外暴露？"><a href="#Q5-微服务如何对外暴露？" class="headerlink" title="Q5: 微服务如何对外暴露？"></a>Q5: 微服务如何对外暴露？</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1606552913072-f2ae26c9-6897-4dc8-9384-95f493ff5006.svg" alt="01_Go进阶训练营_微服务_v1.svg"><br>流量链路是什么？</p><ul><li>移动端 -&gt; API Gateway -&gt; BFF -&gt; 微服务</li><li>不含 CDN、负载均衡（LB）</li><li>BFF 纯 web 的业务一般用 nodejs 做 SSR</li></ul><p>为什么我们的服务不直接对外进行暴露？</p><ul><li>前端（移动端、客户端、web）同学非常痛苦，需要对接多个服务，兼容性差，沟通效率低</li><li>后端同学也很痛苦，一年前的版本都有人使用，服务无法进行重构升级</li></ul><p>为什么需要最外层的 api gateway?</p><ul><li>基础库的同学非常同步，限流熔断安全等业务无关的功能需要进行升级的时候升不动</li></ul><h2 id="Q6-微服务如何拆分？"><a href="#Q6-微服务如何拆分？" class="headerlink" title="Q6: 微服务如何拆分？"></a>Q6: 微服务如何拆分？</h2><ul><li>在对业务领域不是特别熟悉的时候，按照<strong>部门职能进行划分，例如账号、财务等</strong><ul><li>注意划分的时候<strong>要闭环</strong>，不要相同的功能散落到几个部门当中</li></ul></li><li>在系统稳定之后，积累了相关的业务经验和微服务开发经验之后，再考虑使用 DDD 限界上下文进行划分</li><li>如果可以闭环的解决一个用户场景，那么它应该是一个微服务</li><li>还可以根据访问频率进行区分划分，将用户高频访问的部分划分为一个服务</li><li>还可以根据读写进行划分<ul><li>CQRS: 将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新</li><li><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1606631756304-ac2b31e1-771a-45e7-9b99-5234badc5d0d.svg" alt="01_Go进阶训练营_微服务_v1.svg"></li></ul></li></ul><h2 id="Q7-如何保证微服务之间的安全？"><a href="#Q7-如何保证微服务之间的安全？" class="headerlink" title="Q7: 如何保证微服务之间的安全？"></a>Q7: 如何保证微服务之间的安全？</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1606632869613-c887da17-ec2f-4221-822a-84bbd21e4d3f.svg" alt="01_Go进阶训练营_微服务_v1.svg"><br>在内网主要看安全级别一般有三种：</p><ul><li>Full Trust：假定内网服务之间是安全的，在内网裸奔</li><li>Half Trust：内网服务之间需要进行认证鉴权，但是不需要所有的都进行加密</li><li>Zero Trust: 零信任，任务内部网络是不安全的，类似公网，所有的请求通过身份认证鉴权之后，都需要通过安全加密，防止被嗅探<ul><li><a href="https://www.microsoft.com/en-us/security/business/zero-trust">https://www.microsoft.com/en-us/security/business/zero-trust</a></li></ul></li></ul><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新</h2><p>看到这里了还不点个关注走一波</p><ul><li><a href="https://lailin.xyz">博客</a> 可以订阅 RSS</li><li><a href="https://github.com/mohuishou">Github</a> Follow me</li><li><a href="https://www.zhihu.com/people/mo-hui-shou-76">知乎</a> 关注账号，顺便点个 👍</li><li><a href="https://toutiao.io/subjects/387401?f=new">开发者头条</a> 订阅订阅号，顺便点个 👍</li></ul><div class="note note-info">            <p>第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠<br><strong>扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦</strong></p>          </div><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/use-kind-create-k8s-local-cluster.html">Day1: 使用 Kind 搭建本地 K8s 开发环境</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-auto-limiter.html">Go可用性(五) 限流4: 自适应限流</a></li><li><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></li></ul></div><h2 id="关注我获取更新">  <a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新<a    class="anchorjs-link"    aria-label="Anchor"    data-anchorjs-icon=""    href="#关注我获取更新"    style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em"  ></a></h2><div class="row">  <div class="col-lg-6">    <img      style="width: 100%"      src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      alt="wechat"    />  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="http://s.zhihu.com/B4RT3"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/zhihu.png"        alt="知乎"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://toutiao.io/subjects/387401?f=new"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/toutiaoio.png"        alt="开发者头条"    /></a>  </div>  <div class="col-lg-2 col-4">    <a target="_blank" href="https://github.com/mohuishou"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/github.png"        alt="github"    /></a>  </div></div><!-- Add wechat img after categories --><script>document.addEventListener('DOMContentLoaded', (event) => {  let toc = $("#toc");  if (toc.height() >= 1){    toc.append(`    <a      class="fancybox fancybox.image"      href="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"      itemscope=""      itemtype="http://schema.org/ImageObject"      itemprop="url"      data-fancybox="default"      rel="default"      title="wechat"      data-caption="wechat"      ><img        style="width: 100%"        src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        srcset="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/custom/wechat_white.png"        alt="wechat"      />    `)  }})</script>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Week01: 微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据结构与算法05-栈下: 深入理解 defer</title>
    <link href="/post/defer.html"/>
    <url>/post/defer.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 数据结构与算法系列文章，本系列文章主要会包括常见的数据结构与算法实现，同时会包括 Go 标准库代码的分析理解，讲到对应章节的时候优先学习分析 Go 的源码实现，例如 slice、list、sort 等，然后可能会有一些常见的案例实现，同时这也是 <a href="https://time.geekbang.org/column/intro/126">极客时间-数据结构与算法之美</a> 的课程笔记</li><li><strong>本文代码仓库:</strong> <a href="https://github.com/mohuishou/go-algorithm">https://github.com/mohuishou/go-algorithm</a> 🌟🌟🌟🌟🌟</li><li><strong>RoadMap: </strong>持续更新中，预计一周更新 1 ~ 2 篇文章，预计到 202101 月底前更新完成</li><li><strong>获取更新:</strong> <a href="https://github.com/mohuishou">Github</a>、<a href="https://zhuanlan.zhihu.com/mohuishou">知乎</a>、<a href="https://lailin.xyz/atom.xml">RSS</a>、<a href="https://toutiao.io/subjects/387401?f=new">开发者头条</a></li><li>上一个系列刚刚完成了 <a href="https://lailin.xyz/post/go-design-pattern.html">Go 设计模式</a>，如果感兴趣也可以进行查看</li></ul><h2 id="深入理解-go-defer"><a href="#深入理解-go-defer" class="headerlink" title="深入理解 go defer"></a>深入理解 go defer</h2><p>上篇文章中我们讲到栈的时候说到先入后出这种特性，在 Go 中第一时间想到的就是 <code>defer</code>  接下来我们就深入理解一下 defer</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>下面先回顾一下基本的用法以及较为常见的坑，文末会给出输出结果，可以先想想会输出什么</p><h4 id="基本用法-1-延迟处理，资源清理"><a href="#基本用法-1-延迟处理，资源清理" class="headerlink" title="基本用法 1: 延迟处理，资源清理"></a>基本用法 1: 延迟处理，资源清理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 基本用法：延迟调用，清理资源</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;clean&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基本用法-2-后进先出"><a href="#基本用法-2-后进先出" class="headerlink" title="基本用法 2: 后进先出"></a>基本用法 2: 后进先出</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 基本用法1: 后进先出</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;1&quot;</span>)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;2&quot;</span>)<br><br>fmt.Println(<span class="hljs-string">&quot;3&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基本用法-3-异常恢复"><a href="#基本用法-3-异常恢复" class="headerlink" title="基本用法 3: 异常恢复"></a>基本用法 3: 异常恢复</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 基本用法2：异常恢复</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;paniced: %+v \n&quot;</span>, err)<br>&#125;<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;test&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="容易掉坑-1-闭包变量"><a href="#容易掉坑-1-闭包变量" class="headerlink" title="容易掉坑 1: 闭包变量"></a>容易掉坑 1: 闭包变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 容易掉坑之，函数变量修改</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> <span class="hljs-params">(res <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>res++<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="容易掉坑-2-参数传递"><a href="#容易掉坑-2-参数传递" class="headerlink" title="容易掉坑 2: 参数传递"></a>容易掉坑 2: 参数传递</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 容易掉坑之，参数复制</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> <span class="hljs-params">(res <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(res <span class="hljs-keyword">int</span>)</span></span> &#123;<br>res++<br>&#125;(res)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h3><p>想要看源码，我们需要先找到源码的位置，我们可以直接执行 <code>go tool compile -N -l -S main.go</code> 获取汇编代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">// ....<br> 0x00d8 00216 (main_2.go:6)PCDATA<span class="hljs-variable">$1</span>, <span class="hljs-variable">$0</span><br>0x00d8 00216 (main_2.go:6)CALLruntime.deferprocStack(SB)<br>0x00dd 00221 (main_2.go:6)NOP<br>0x00e0 00224 (main_2.go:6)TESTLAX, AX<br>0x00e2 00226 (main_2.go:6)JNE252<br>0x00e4 00228 (main_2.go:6)JMP230<br>0x00e6 00230 (main_2.go:7)XCHGLAX, AX<br>0x00e7 00231 (main_2.go:7)CALLruntime.deferreturn(SB)<br>0x00ec 00236 (main_2.go:7)MOVQ216(SP), BP<br>0x00f4 00244 (main_2.go:7)ADDQ<span class="hljs-variable">$224</span>, SP<br>0x00fb 00251 (main_2.go:7)RET<br>0x00fc 00252 (main_2.go:6)XCHGLAX, AX<br>0x00fd 00253 (main_2.go:6)NOP<br>0x0100 00256 (main_2.go:6)CALLruntime.deferreturn(SB)<br></code></pre></td></tr></table></figure><p>我们可以看到主要是调用了 <code>runtime.deferprocStack</code> ， <code>runtime.deferreturn</code>  这两个运行时的方法</p><h4 id="defer-定义"><a href="#defer-定义" class="headerlink" title="defer 定义"></a>defer 定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> _defer <span class="hljs-keyword">struct</span> &#123;<br>siz     <span class="hljs-keyword">int32</span> <span class="hljs-comment">// 所有传入参数和返回值的总大小</span><br>started <span class="hljs-keyword">bool</span>  <span class="hljs-comment">// defer 是否执行了</span><br>heap    <span class="hljs-keyword">bool</span>  <span class="hljs-comment">// 是否在堆上，这是 go1.13 新加的，划重点</span><br>sp        <span class="hljs-keyword">uintptr</span>  <span class="hljs-comment">// 函数栈指针寄存器，一般指向当前函数栈的栈顶</span><br>pc        <span class="hljs-keyword">uintptr</span>  <span class="hljs-comment">// 程序计数器，指向下一条需要执行的指令</span><br>fn        *funcval <span class="hljs-comment">// 指向传入的函数地址和参数</span><br>_panic    *_panic  <span class="hljs-comment">// 指向 panic 链表</span><br>link      *_defer  <span class="hljs-comment">// 指向 defer 链表</span><br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="deferprocStack"><a href="#deferprocStack" class="headerlink" title="deferprocStack"></a>deferprocStack</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deferprocStack</span><span class="hljs-params">(d *_defer)</span></span> &#123;<br>gp := getg() <span class="hljs-comment">// 获取 g，判断是否在用户栈上</span><br><span class="hljs-keyword">if</span> gp.m.curg != gp &#123;<br><span class="hljs-comment">// go code on the system stack can&#x27;t defer</span><br>throw(<span class="hljs-string">&quot;defer on system stack&quot;</span>)<br>&#125;<br><span class="hljs-comment">// siz and fn are already set.</span><br><span class="hljs-comment">// The other fields are junk on entry to deferprocStack and</span><br><span class="hljs-comment">// are initialized here.</span><br>d.started = <span class="hljs-literal">false</span><br>d.heap = <span class="hljs-literal">false</span><br>d.openDefer = <span class="hljs-literal">false</span><br>d.sp = getcallersp()<br>d.pc = getcallerpc()<br>d.framepc = <span class="hljs-number">0</span><br>d.varp = <span class="hljs-number">0</span><br><span class="hljs-comment">// The lines below implement:</span><br><span class="hljs-comment">//   d.panic = nil</span><br><span class="hljs-comment">//   d.fd = nil</span><br><span class="hljs-comment">//   d.link = gp._defer // 这两个是将当前 defer 插入到链表头部，也就是defer为什么时候先入后出的原因</span><br><span class="hljs-comment">//   gp._defer = d</span><br><span class="hljs-comment">// But without write barriers. The first three are writes to</span><br><span class="hljs-comment">// the stack so they don&#x27;t need a write barrier, and furthermore</span><br><span class="hljs-comment">// are to uninitialized memory, so they must not use a write barrier.</span><br><span class="hljs-comment">// The fourth write does not require a write barrier because we</span><br><span class="hljs-comment">// explicitly mark all the defer structures, so we don&#x27;t need to</span><br><span class="hljs-comment">// keep track of pointers to them with a write barrier.</span><br>*(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(&amp;d._panic)) = <span class="hljs-number">0</span><br>*(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(&amp;d.fd)) = <span class="hljs-number">0</span><br>*(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(&amp;d.link)) = <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(gp._defer))<br>*(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(&amp;gp._defer)) = <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(d))<br><br>return0()<br><span class="hljs-comment">// No code can go here - the C return register has</span><br><span class="hljs-comment">// been set and must not be clobbered.</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意这几行</strong><br>说明这个 defer 不在堆上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">d.heap = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>这两个是将当前 defer 插入到链表头部，也就是 defer 为什么时候先入后出的原因</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//   d.link = gp._defer</span><br><span class="hljs-comment">//   gp._defer = d</span><br></code></pre></td></tr></table></figure><h4 id="deferreturn"><a href="#deferreturn" class="headerlink" title="deferreturn"></a>deferreturn</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deferreturn</span><span class="hljs-params">(arg0 <span class="hljs-keyword">uintptr</span>)</span></span> &#123;<br>gp := getg()<br>d := gp._defer<br><span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>sp := getcallersp()<br><span class="hljs-keyword">if</span> d.sp != sp &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> d.openDefer &#123;<br>done := runOpenDeferFrame(gp, d)<br><span class="hljs-keyword">if</span> !done &#123;<br>throw(<span class="hljs-string">&quot;unfinished open-coded defers in deferreturn&quot;</span>)<br>&#125;<br>gp._defer = d.link<br>freedefer(d)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">switch</span> d.siz &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br><span class="hljs-comment">// Do nothing.</span><br><span class="hljs-keyword">case</span> sys.PtrSize:<br>*(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(&amp;arg0)) = *(*<span class="hljs-keyword">uintptr</span>)(deferArgs(d))<br><span class="hljs-keyword">default</span>:<br>memmove(unsafe.Pointer(&amp;arg0), deferArgs(d), <span class="hljs-keyword">uintptr</span>(d.siz))<br>&#125;<br>fn := d.fn<br>d.fn = <span class="hljs-literal">nil</span><br>gp._defer = d.link<br>freedefer(d)<br><span class="hljs-comment">// If the defer function pointer is nil, force the seg fault to happen</span><br><span class="hljs-comment">// here rather than in jmpdefer. gentraceback() throws an error if it is</span><br><span class="hljs-comment">// called with a callback on an LR architecture and jmpdefer is on the</span><br><span class="hljs-comment">// stack, because the stack trace can be incorrect in that case - see</span><br><span class="hljs-comment">// issue #8153).</span><br>_ = fn.fn<br>jmpdefer(fn, <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(&amp;arg0)))<br>&#125;<br></code></pre></td></tr></table></figure><p>如果函数中存在 defer 编译器就会自动在函数的最后插入一个 deferreturn</p><ul><li>清空 defer 的调用信息</li><li>freedefer 将 defer 对象放入到 defer 池中，后面可以复用</li><li>如果存在延迟函数就会调用 runtime·jmpdefer 方法跳转到对应的方法上去</li><li>runtime·jmpdefer 方法会递归调用 deferreturn 一直执行到结束为止</li></ul><h4 id="deferproc"><a href="#deferproc" class="headerlink" title="deferproc"></a>deferproc</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deferproc</span><span class="hljs-params">(siz <span class="hljs-keyword">int32</span>, fn *funcval)</span></span> &#123; <span class="hljs-comment">// arguments of fn follow fn</span><br>gp := getg()<br><span class="hljs-keyword">if</span> gp.m.curg != gp &#123;<br><span class="hljs-comment">// go code on the system stack can&#x27;t defer</span><br>throw(<span class="hljs-string">&quot;defer on system stack&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// the arguments of fn are in a perilous state. The stack map</span><br><span class="hljs-comment">// for deferproc does not describe them. So we can&#x27;t let garbage</span><br><span class="hljs-comment">// collection or stack copying trigger until we&#x27;ve copied them out</span><br><span class="hljs-comment">// to somewhere safe. The memmove below does that.</span><br><span class="hljs-comment">// Until the copy completes, we can only call nosplit routines.</span><br>sp := getcallersp()<br>argp := <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(&amp;fn)) + unsafe.Sizeof(fn)<br>callerpc := getcallerpc()<br><br>d := newdefer(siz)<br><span class="hljs-keyword">if</span> d._panic != <span class="hljs-literal">nil</span> &#123;<br>throw(<span class="hljs-string">&quot;deferproc: d.panic != nil after newdefer&quot;</span>)<br>&#125;<br>d.link = gp._defer<br>gp._defer = d<br>d.fn = fn<br>d.pc = callerpc<br>d.sp = sp<br><span class="hljs-keyword">switch</span> siz &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br><span class="hljs-comment">// Do nothing.</span><br><span class="hljs-keyword">case</span> sys.PtrSize:<br>*(*<span class="hljs-keyword">uintptr</span>)(deferArgs(d)) = *(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(argp))<br><span class="hljs-keyword">default</span>:<br>memmove(deferArgs(d), unsafe.Pointer(argp), <span class="hljs-keyword">uintptr</span>(siz))<br>&#125;<br><br><span class="hljs-comment">// deferproc returns 0 normally.</span><br><span class="hljs-comment">// a deferred func that stops a panic</span><br><span class="hljs-comment">// makes the deferproc return 1.</span><br><span class="hljs-comment">// the code the compiler generates always</span><br><span class="hljs-comment">// checks the return value and jumps to the</span><br><span class="hljs-comment">// end of the function if deferproc returns != 0.</span><br>return0()<br><span class="hljs-comment">// No code can go here - the C return register has</span><br><span class="hljs-comment">// been set and must not be clobbered.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>除了 deferprocStack 还有 deferproc 这个方法，那这个方法和之前的方法有什么区别呢？<br>主要的区别就是这个方法将 defer 分配在了堆上，看下方的 <code>newdefer</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newdefer</span><span class="hljs-params">(siz <span class="hljs-keyword">int32</span>)</span> *_<span class="hljs-title">defer</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    d.heap = <span class="hljs-literal">true</span><br><span class="hljs-keyword">return</span> d<br>&#125;<br></code></pre></td></tr></table></figure><p>其他和 deferprocStack 类似这里就不赘述了</p><h4 id="什么时候-defer-会在堆上什么时候会在栈上？"><a href="#什么时候-defer-会在堆上什么时候会在栈上？" class="headerlink" title="什么时候 defer 会在堆上什么时候会在栈上？"></a>什么时候 defer 会在堆上什么时候会在栈上？</h4><p>那问题来了如何判断 defer 在堆上还是在栈上呢？<br><a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/escape.go#L743">https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/escape.go#L743</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">topLevelDefer := where != <span class="hljs-literal">nil</span> &amp;&amp; where.Op == ODEFER &amp;&amp; e.loopDepth == <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> topLevelDefer &#123;<br>    <span class="hljs-comment">// force stack allocation of defer record, unless</span><br>    <span class="hljs-comment">// open-coded defers are used (see ssa.go)</span><br>    where.Esc = EscNever<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/6965b01ea248cabb70c3749fd218b36089a21efb/src/cmd/compile/internal/gc/ssa.go#L1116">https://github.com/golang/go/blob/6965b01ea248cabb70c3749fd218b36089a21efb/src/cmd/compile/internal/gc/ssa.go#L1116</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">d := callDefer<br><span class="hljs-keyword">if</span> n.Esc == EscNever &#123;<br>    d = callDeferStack<br>&#125;<br>s.call(n.Left, d)<br></code></pre></td></tr></table></figure><p>可以看到主要是在逃逸分析的时候，发现 <code>e.loopDepth == 1</code>  并且不是 open-coded defer 就会分配到栈上。<br>这也是为什么 go 1.13 之后 defer 性能提升的原因，所以<strong>切记不要在循环中使用 defer 不然优化也享受不到</strong><br>我们来验证一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f6</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;f6: %d\n&quot;</span>, i)<br>&#125;()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看一下汇编结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">0x0073</span> <span class="hljs-number">00115</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">67</span>)CALLruntime.deferproc(SB)<br><span class="hljs-number">0x0078</span> <span class="hljs-number">00120</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">67</span>)TESTLAX, AX<br><span class="hljs-number">0x007a</span> <span class="hljs-number">00122</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">67</span>)JNE<span class="hljs-number">151</span><br><span class="hljs-number">0x007c</span> <span class="hljs-number">00124</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">67</span>)JMP<span class="hljs-number">126</span><br><span class="hljs-number">0x007e</span> <span class="hljs-number">00126</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)PCDATA$<span class="hljs-number">1</span>, $<span class="hljs-number">-1</span><br><span class="hljs-number">0x007e</span> <span class="hljs-number">00126</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)NOP<br><span class="hljs-number">0x0080</span> <span class="hljs-number">00128</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)JMP<span class="hljs-number">130</span><br><span class="hljs-number">0x0082</span> <span class="hljs-number">00130</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)MOVQ<span class="hljs-string">&quot;&quot;</span>.&amp;i+<span class="hljs-number">32</span>(SP), AX<br><span class="hljs-number">0x0087</span> <span class="hljs-number">00135</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)MOVQ(AX), AX<br><span class="hljs-number">0x008a</span> <span class="hljs-number">00138</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)MOVQ<span class="hljs-string">&quot;&quot;</span>.&amp;i+<span class="hljs-number">32</span>(SP), CX<br><span class="hljs-number">0x008f</span> <span class="hljs-number">00143</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)INCQAX<br><span class="hljs-number">0x0092</span> <span class="hljs-number">00146</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)MOVQAX, (CX)<br><span class="hljs-number">0x0095</span> <span class="hljs-number">00149</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)JMP<span class="hljs-number">68</span><br><span class="hljs-number">0x0097</span> <span class="hljs-number">00151</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">67</span>)PCDATA$<span class="hljs-number">1</span>, $<span class="hljs-number">0</span><br><span class="hljs-number">0x0097</span> <span class="hljs-number">00151</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">67</span>)XCHGLAX, AX<br><span class="hljs-number">0x0098</span> <span class="hljs-number">00152</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">67</span>)CALLruntime.deferreturn(SB)<br></code></pre></td></tr></table></figure><p>可以发现在循环嵌套的场景下，的确调用的是 <code>runtime.deferproc</code>  方法，被分配到栈上了</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>算法</tag>
      
      <tag>Go</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据结构与算法04-栈上: 如何实现一个计算器</title>
    <link href="/post/stack.html"/>
    <url>/post/stack.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 数据结构与算法系列文章，本系列文章主要会包括常见的数据结构与算法实现，同时会包括 Go 标准库代码的分析理解，讲到对应章节的时候优先学习分析 Go 的源码实现，例如 slice、list、sort 等，然后可能会有一些常见的案例实现，同时这也是 <a href="https://time.geekbang.org/column/intro/126">极客时间-数据结构与算法之美</a> 的课程笔记</li><li><strong>本文代码仓库:</strong> <a href="https://github.com/mohuishou/go-algorithm">https://github.com/mohuishou/go-algorithm</a> 🌟🌟🌟🌟🌟</li><li><strong>RoadMap: </strong>持续更新中，预计一周更新 1 ~ 2 篇文章，预计到 202101 月底前更新完成</li><li><strong>获取更新:</strong> <a href="https://github.com/mohuishou">Github</a>、<a href="https://zhuanlan.zhihu.com/mohuishou">知乎</a>、<a href="https://lailin.xyz/atom.xml">RSS</a>、<a href="https://toutiao.io/subjects/387401?f=new">开发者头条</a></li><li>上一个系列刚刚完成了 <a href="https://lailin.xyz/post/go-design-pattern.html">Go 设计模式</a>，如果感兴趣也可以进行查看</li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>栈是一种“操作受限”的线性表，<strong>后进者先出，先进者后出。</strong><br>比较典型的例子就是我们在叠盘子的时候，叠的时候从下到上一个一个磊起来，取的时候，再从上到下一个一个的拿出来。<br>说到先入后出这种特性，在 Go 中你第一时间想到了什么？不知道是否和我的答案一样， <code>defer</code><br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1606140416813-6b90944b-87c1-43eb-8443-c747e6559200.svg" alt="01_stack.drawio.svg"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>存在两种实现方式，第一种是数组实现的顺序栈，第二种是链表链式栈</p><h4 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h4><p>数组实现我们直接使用了 <code>slice</code> ，并且借助 <code>slice</code>  实现了自动扩容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Stack Stack</span><br><span class="hljs-keyword">type</span> Stack <span class="hljs-keyword">struct</span> &#123;<br>items   []<span class="hljs-keyword">string</span><br>current <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// NewStack NewStack</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStack</span><span class="hljs-params">()</span> *<span class="hljs-title">Stack</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;Stack&#123;<br>items:   <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">10</span>),<br>current: <span class="hljs-number">0</span>,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Push 入栈</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span> <span class="hljs-title">Push</span><span class="hljs-params">(item <span class="hljs-keyword">string</span>)</span></span> &#123;<br>s.current++<br><span class="hljs-comment">// 判断底层 slice 是否满了，如果满了就 append</span><br><span class="hljs-keyword">if</span> s.current == <span class="hljs-built_in">len</span>(s.items) &#123;<br>s.items = <span class="hljs-built_in">append</span>(s.items, item)<br><span class="hljs-keyword">return</span><br>&#125;<br>s.items[s.current] = item<br>&#125;<br><br><span class="hljs-comment">// Pop 出栈</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">if</span> s.current == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>item := s.items[s.current]<br>s.current--<br><span class="hljs-keyword">return</span> item<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h4><p>链式栈的实现我们利用双向循环链表，简化栈的插入操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// node 节点</span><br><span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;<br>prev, next *node<br>value      <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// Stack 链式栈</span><br><span class="hljs-keyword">type</span> Stack <span class="hljs-keyword">struct</span> &#123;<br>root *node<br><span class="hljs-built_in">len</span>  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// NewStack NewStack</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStack</span><span class="hljs-params">()</span> *<span class="hljs-title">Stack</span></span> &#123;<br>n := &amp;node&#123;&#125;<br>n.next = n<br>n.prev = n<br><span class="hljs-keyword">return</span> &amp;Stack&#123;root: n&#125;<br>&#125;<br><br><span class="hljs-comment">// Push 入栈</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span> <span class="hljs-title">Push</span><span class="hljs-params">(item <span class="hljs-keyword">string</span>)</span></span> &#123;<br>n := &amp;node&#123;value: item&#125;<br>s.root.prev.next = n<br>n.prev = s.root.prev<br>n.next = s.root<br>s.root.prev = n<br>s.<span class="hljs-built_in">len</span>++<br>&#125;<br><br><span class="hljs-comment">// Pop 出栈</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>item := s.root.prev<br><span class="hljs-keyword">if</span> item == s.root &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br>s.root.prev = item.prev<br>item.prev.next = s.root<br><span class="hljs-comment">// 避免内存泄漏</span><br>item.prev = <span class="hljs-literal">nil</span><br>item.next = <span class="hljs-literal">nil</span><br>s.<span class="hljs-built_in">len</span>--<br><span class="hljs-keyword">return</span> item.value<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="典型问题"><a href="#典型问题" class="headerlink" title="典型问题"></a>典型问题</h3><h4 id="实现一个计算器"><a href="#实现一个计算器" class="headerlink" title="实现一个计算器"></a>实现一个计算器</h4><p>我们实现了支持<code>+、-、*、/、(、)</code>  的计算器，这也是<a href="https://leetcode-cn.com/problems/basic-calculator/">leetcode#244</a>的一种解法，并且我们这个实现更加复杂，原题只需要计算加减法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> calculation<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-comment">// 操作符的优先级</span><br><span class="hljs-keyword">var</span> operatorPriority = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;<br><span class="hljs-string">&quot;+&quot;</span>: <span class="hljs-number">0</span>,<br><span class="hljs-string">&quot;-&quot;</span>: <span class="hljs-number">0</span>,<br><span class="hljs-string">&quot;*&quot;</span>: <span class="hljs-number">1</span>,<br><span class="hljs-string">&quot;/&quot;</span>: <span class="hljs-number">1</span>,<br><span class="hljs-string">&quot;(&quot;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-string">&quot;)&quot;</span>: <span class="hljs-number">2</span>,<br>&#125;<br><br><span class="hljs-comment">// Calculator 计算器</span><br><span class="hljs-keyword">type</span> Calculator <span class="hljs-keyword">struct</span> &#123;<br>nums      *StackInt<br>operators *Stack<br>exp       <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// NewCalculator NewCalculator</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCalculator</span><span class="hljs-params">(exp <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">Calculator</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;Calculator&#123;<br>nums:      NewStackInt(),<br>operators: NewStack(),<br>exp:       exp,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Calculate 获取计算结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Calculator)</span> <span class="hljs-title">Calculate</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>l := <span class="hljs-built_in">len</span>(c.exp)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l; i++ &#123;<br><span class="hljs-keyword">switch</span> e := (c.exp[i]); e &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27; &#x27;</span>:<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>:<br><span class="hljs-comment">// 一直往后获取数字，如果下一个还是数字说明这一个数还不完整</span><br>j := i<br><span class="hljs-keyword">for</span> j &lt; l &amp;&amp; c.exp[j] &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &amp;&amp; c.exp[j] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>j++<br>&#125;<br>n, _ := strconv.Atoi(c.exp[i:j])<br>i = j - <span class="hljs-number">1</span><br>c.nums.Push(n)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>:<br><span class="hljs-comment">// 从计算符栈中获取栈顶元素，如果当前操作符的优先级低于栈顶元素的优先级</span><br><span class="hljs-comment">// 并且栈顶元素不为空，和括号</span><br><span class="hljs-comment">// 那么从数据栈中取两个数据和栈顶操作符进行计算</span><br>pre := c.operators.Pop()<br><span class="hljs-keyword">for</span> pre != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; pre != <span class="hljs-string">&quot;(&quot;</span> &amp;&amp; operatorPriority[<span class="hljs-keyword">string</span>(e)] &lt;= operatorPriority[pre] &#123;<br>c.nums.Push(c.calc(pre))<br>pre = c.operators.Pop()<br>&#125;<br><span class="hljs-keyword">if</span> pre != <span class="hljs-string">&quot;&quot;</span> &#123;<br>c.operators.Push(pre)<br>&#125;<br>c.operators.Push(<span class="hljs-keyword">string</span>(e))<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>c.operators.Push(<span class="hljs-keyword">string</span>(e))<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br><span class="hljs-comment">// 碰到右括号之后就一直不断操作符栈中弹出元素，并且取两个数据进行计算</span><br><span class="hljs-comment">// 直到碰到左括号为止</span><br><span class="hljs-keyword">for</span> o := c.operators.Pop(); o != <span class="hljs-string">&quot;(&quot;</span> &amp;&amp; o != <span class="hljs-string">&quot;&quot;</span>; o = c.operators.Pop() &#123;<br>c.nums.Push(c.calc(o))<br>&#125;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;invalid exp&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-comment">// 最后如果不存在操作符，说明数据栈中的栈顶元素就是最后结果</span><br>o := c.operators.Pop()<br><span class="hljs-keyword">if</span> o == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> c.nums.Pop()<br>&#125;<br><span class="hljs-comment">// 如果存在，就把最后的数据进行计算后返回</span><br><span class="hljs-keyword">return</span> c.calc(o)<br>&#125;<br><br><span class="hljs-comment">// calc 单次计算操作，o: 计算符</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Calculator)</span> <span class="hljs-title">calc</span><span class="hljs-params">(o <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>b := c.nums.Pop()<br>a := c.nums.Pop()<br><br>fmt.Printf(<span class="hljs-string">&quot;%d %s %d\n&quot;</span>, a, o, b)<br><br><span class="hljs-keyword">switch</span> o &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br><span class="hljs-keyword">return</span> a + b<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br><span class="hljs-keyword">return</span> a - b<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br><span class="hljs-keyword">return</span> a * b<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br><span class="hljs-keyword">return</span> a / b<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// calculate 计算器，支持加减乘除</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> NewCalculator(s).Calculate()<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>算法</tag>
      
      <tag>Go</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Struct 初始化风格的抉择</title>
    <link href="/post/go-new-struct-style-select.html"/>
    <url>/post/go-new-struct-style-select.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在对之前的代码做重构，从之前的 <code>MVC</code>  结构切换到 <code>Clean Arch</code>  的结构，但是在切换的时候关于代码风格出现了一些困惑<br>在下面的代码中 <code>repository</code>  是存储库，主要用于封装数据库查询或者是第三方微服务的调用，它实现了 <code>domain.IAzRepository</code>  接口，其他层的代码都只依赖这个接口而不依赖具体的实现</p><h2 id="三种代码风格"><a href="#三种代码风格" class="headerlink" title="三种代码风格"></a>三种代码风格</h2><h3 id="风格一"><a href="#风格一" class="headerlink" title="风格一"></a>风格一</h3><p>在 Go 中我们常常“返回实现(struct)，依赖接口”，其实就是在函数返回的时候我们返回一个具体的实现，函数的参数或者是 Struct 的成员部分我们依赖接口，这个风格看起来是违背了这个原则的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// repository 存储库</span><br><span class="hljs-keyword">type</span> repository <span class="hljs-keyword">struct</span> &#123;<br>db *gorm.DB<br>&#125;<br><br><span class="hljs-comment">// NewAZRepository NewAZRepository</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAZRepository</span><span class="hljs-params">(db *gorm.DB)</span> <span class="hljs-title">domain</span>.<span class="hljs-title">IAzRepository</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;repository&#123;db: db&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="风格二"><a href="#风格二" class="headerlink" title="风格二"></a>风格二</h3><p>这个风格返回了实现，并且由于并没有导出看起来也具有封装的特性，但是如果你运行 golint 你就会发现会抛出错误，因为这么写，会导致我们用导出的方法将没有导出 struct 给暴露了出去</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// repository 存储库</span><br><span class="hljs-keyword">type</span> repository <span class="hljs-keyword">struct</span> &#123;<br>db *gorm.DB<br>&#125;<br><br><span class="hljs-comment">// NewAZRepository NewAZRepository</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAZRepository</span><span class="hljs-params">(db *gorm.DB)</span> *<span class="hljs-title">repository</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;repository&#123;db: db&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="风格三"><a href="#风格三" class="headerlink" title="风格三"></a>风格三</h3><p>这个写法的主要问题是，由于 <code>Repository</code>  被导出，所以在外部其他的包中就可以直接通过 <code>&amp;Repository&#123;&#125;</code>  进行初始化，这样初始化之后使用就会导致 panic，因为成员函数是一个 nil 指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Repository 存储库</span><br><span class="hljs-keyword">type</span> Repository <span class="hljs-keyword">struct</span> &#123;<br>db *gorm.DB<br>&#125;<br><br><span class="hljs-comment">// NewAZRepository NewAZRepository</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAZRepository</span><span class="hljs-params">(db *gorm.DB)</span> *<span class="hljs-title">Repository</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;Repository&#123;db: db&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>选择总是困难的，带着这个问题我咨询了同组的同事还有好几个 Go 语言交流群的同学，其中大部分都会选择风格三，小部分会选择风格一，风格二几乎没有人选择。最后我选什么呢？<br>最后我的选择是风格一，这是针对场景来的，因为我们的这个包其实不希望其他包直接依赖实现，因为后续有可能随着发展被单独拆分成一个微服务或者是需要更换存储库，如果外部有包直接依赖 repository 会导致后续的重构比较困难<br>除此之外，我们在其他地方一般还是会选择风格三，因为结构体名不导出，外部其实没有比较好的办法进行初始化，例如想要 <code>var r Repository</code>，至于前面提到的直接字面量初始化的问题，我们可以通过统一代码风格解决。</p><blockquote><p>在<strong>外部包</strong>中除了用于参数传递的 <code>Option</code>  结构之外，其余的不允许直接通过 &amp;XXX{} 的方式进行初始化</p></blockquote><p>最后感谢热心回答我的困惑的小伙伴们 🤗</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>代码风格</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据结构与算法03-数组下: 使用 GDB 调试 Golang 代码</title>
    <link href="/post/array_2.html"/>
    <url>/post/array_2.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 数据结构与算法系列文章，本系列文章主要会包括常见的数据结构与算法实现，同时会包括 Go 标准库代码的分析理解，讲到对应章节的时候优先学习分析 Go 的源码实现，例如 slice、list、sort 等，然后可能会有一些常见的案例实现，同时这也是 <a href="https://time.geekbang.org/column/intro/126">极客时间-数据结构与算法之美</a> 的课程笔记</li><li><strong>本文代码仓库:</strong> <a href="https://github.com/mohuishou/go-algorithm">https://github.com/mohuishou/go-algorithm</a> 🌟🌟🌟🌟🌟</li><li><strong>RoadMap: </strong>持续更新中，预计一周更新 1 ~ 2 篇文章，预计到 202101 月底前更新完成</li><li><strong>获取更新:</strong> <a href="https://github.com/mohuishou">Github</a>、<a href="https://zhuanlan.zhihu.com/mohuishou">知乎</a>、<a href="https://lailin.xyz/atom.xml">RSS</a>、<a href="https://toutiao.io/subjects/387401?f=new">开发者头条</a></li><li>上一个系列刚刚完成了 <a href="https://lailin.xyz/post/go-design-pattern.html">Go 设计模式</a>，如果感兴趣也可以进行查看</li></ul><h2 id="问题回顾"><a href="#问题回顾" class="headerlink" title="问题回顾"></a>问题回顾</h2><p>本文章主要是为了回答上一篇文章的问题，并且介绍一下在这个过程中以及后续都会使用到的调试工具 <code>gdb</code></p><ul><li>请查看下面一段代码，会输出什么，为什么？<ul><li>A: 5 8 B: 8 8 C: 5 5 D: 5 6</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在讲解 slice 初始化的过程中，为什么 <code>s2</code> , <code>s3</code> 打印的数组指针都是 <code>0x587450</code> ?</li></ul><h2 id="slice-扩容算法是否遗漏了什么？"><a href="#slice-扩容算法是否遗漏了什么？" class="headerlink" title="slice 扩容算法是否遗漏了什么？"></a>slice 扩容算法是否遗漏了什么？</h2><p>首先我们回顾一下上一篇文章当中讲到的 slice 扩容的 算法:</p><ul><li>如果需要的最小容量比两倍原有容量大，那么就取需要的容量</li><li>如果原有 slice 长度小于 1024 那么每次就扩容为原来的两倍</li><li>如果原 slice 大于等于 1024 那么每次扩容就扩为原来的 1.25 倍</li></ul><p>按照这个逻辑进行套用:</p><ul><li><code>s</code>  初始化时 <code>len=2</code></li><li><code>s = append(s, 3, 4, 5)</code>  此时需要的最小容量为 <code>5 &gt; 2*2</code></li><li>按照这个逻辑最后的答案应该是 <code>C: 5 5</code></li><li>但是如果大家运行过这段代码应该会知道这个答案是 <code>D: 5 6</code>  为什么呢？这个逻辑和我们之前了解到的不太一样啊</li></ul><p>接下来我们就使用 gdb 调试一下看看结果</p><h2 id="使用-GDB-调试-Golang-代码"><a href="#使用-GDB-调试-Golang-代码" class="headerlink" title="使用 GDB 调试 Golang 代码"></a>使用 GDB 调试 Golang 代码</h2><p>调试 go 程序我们常用的调试工具其实是 <a href="https://github.com/go-delve/delve">dlv</a> 这个工具非常好用，并且可以很好的和 <code>VS Code</code> <code>Goland</code>  等 IDE 进行结合，但是它无法调试 runtime 的代码，这个时候就要使用上 gdb 了，如果大家不需要调试 runtime 的代码的话还是建议使用 dlv</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install gdb <span class="hljs-comment"># for mac</span><br></code></pre></td></tr></table></figure><p>如果是 linux 使用自带的包管理工具进行安装即可<br>注意安装完成之后需要在 home 目录上添加相关配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.gdbinit<br><br><span class="hljs-comment"># 输入下面</span><br>add-auto-load-safe-path <span class="hljs-variable">$GOROOT</span>/src/runtime/runtime-gdb.py <span class="hljs-comment"># 这里将 $GOROOT 替换为你的 GO 安装目录</span><br></code></pre></td></tr></table></figure><p>如果你是 mac 首次安装 gdb 需要给 gdb 签名，可以参考: <a href="https://gist.github.com/hlissner/898b7dfc0a3b63824a70e15cd0180154">https://gist.github.com/hlissner/898b7dfc0a3b63824a70e15cd0180154</a></p><h3 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h3><ul><li>我们使用 <code>-gcflags=all=&quot;-N -l&quot;</code>  禁用内联优化方便后面调试</li><li>在 mac 上如果不加 <code>-ldflags=&#39;-compressdwarf=false&#39;</code>  在 gdb 调试的时候可能会提示 <code>No symbol table is loaded. Use the &quot;file&quot; command.</code><ul><li>这是因为为了减少二进制大小会默认压缩 <strong>DWARF</strong> 调试信息，这个在 mac 和 windows 上部分工具不支持，linux 一般没有这个问题</li><li>加上 <code>-ldflags=&#39;-compressdwarf=false&#39;</code> 这个标志可以禁用压缩方便调试</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -o bin/03_q1_slice_cap -gcflags=all=<span class="hljs-string">&quot;-N -l&quot;</span> -ldflags=<span class="hljs-string">&#x27;-compressdwarf=false&#x27;</span> 02_array/03_q1_slice_cap/main.go<br></code></pre></td></tr></table></figure><h3 id="进入-GDB-调试窗口"><a href="#进入-GDB-调试窗口" class="headerlink" title="进入 GDB 调试窗口"></a>进入 GDB 调试窗口</h3><ul><li><code>-tui</code>  表示同时显示代码窗口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb -tui ./bin/03_q1_slice_cap<br></code></pre></td></tr></table></figure><p>如下图所示，回车几次之后出现 <code>Loading Go Runtime support.</code>  就说明正常了<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1605939788051-1d907407-893d-4d1c-bf87-8b9a91dc2905.png" alt="image.png"></p><h3 id="常用调试命令"><a href="#常用调试命令" class="headerlink" title="常用调试命令"></a>常用调试命令</h3><ul><li><code>b 文件名:行数</code>  打断点</li><li><code>info b</code>  当前的断点情况</li><li><code>r</code>  运行程序知道断点处</li><li><code>c</code>  继续执行到下一个断点</li><li><code>s</code>  单步执行，如果有调用函数则进入函数，注意和 n 的区别</li><li><code>n</code>  单步执行，如果有调用的函数不会进入函数内部</li><li><code>until</code>  退出循环</li><li><code>until:行号</code>  执行到指定行</li><li><code>info locals</code>  当前堆栈的所有变量</li><li><code>info args</code>  打印参数</li><li><code>info goroutines</code>  查看所有的 goroutine 及其 ID</li><li><code>help</code>  帮助</li><li><code>q</code>  退出</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>知道如何操作之后，我们开始干活</p><ol><li>首先给 append 函数打一个断点 <code>b main.go:11</code></li><li>然后执行到断点处 <code>r</code></li><li>如下图所示，单步运行进入到 <code>slice</code>  的扩容函数中 <code>s</code></li></ol><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1605942212393-f3cdd7f9-29a9-47ad-8d6b-f298dcf8a9e9.png" alt="image.png"></p><ol start="4"><li>接下来我们使用 <code>n</code>  一直单步执行到扩容算法结束，使用 <code>info locals</code>  打印变量。我们可以发现这个时候计算出的 <code>newcap</code>  和我们最初预计的一样是 5，那哪里出了问题呢？我们继续使用 <code>n</code>  接着看</li></ol><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1605942355389-cee6e121-db45-4062-b100-7fc225346368.png" alt="image.png"></p><ol start="5"><li>如下图所示，执行到这里我们发现， <code>newcap</code>  被重新赋值了，并且这个时候 <code>capmem=48</code> <code>PtrSize=8</code>  所以最后的出来了 <code>newcap</code>  等于 6</li></ol><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1605942584081-99ee845c-c590-48fe-8736-aafdc6088dbd.png" alt="image.png"><br>知道问题出现在哪里之后我们可以再来看一下源代码，有一个内存对齐的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Returns size of the memory block that mallocgc will allocate if you ask for the size.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">roundupsize</span><span class="hljs-params">(size <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">uintptr</span></span> &#123;<br><span class="hljs-keyword">if</span> size &lt; _MaxSmallSize &#123;<br><span class="hljs-keyword">if</span> size &lt;= smallSizeMax<span class="hljs-number">-8</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">uintptr</span>(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]])<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">uintptr</span>(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]])<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> size+_PageSize &lt; size &#123;<br><span class="hljs-keyword">return</span> size<br>&#125;<br><span class="hljs-keyword">return</span> alignUp(size, _PageSize)<br>&#125;<br><br><span class="hljs-keyword">const</span> (<br>_MaxSmallSize   = <span class="hljs-number">32768</span><br>smallSizeDiv    = <span class="hljs-number">8</span><br>smallSizeMax    = <span class="hljs-number">1024</span><br>largeSizeDiv    = <span class="hljs-number">128</span><br>_NumSizeClasses = <span class="hljs-number">67</span><br>_PageShift      = <span class="hljs-number">13</span><br>)<br><br><span class="hljs-keyword">var</span> class_to_size = [_NumSizeClasses]<span class="hljs-keyword">uint16</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">48</span>, <span class="hljs-number">64</span>, <span class="hljs-number">80</span>, <span class="hljs-number">96</span>, <span class="hljs-number">112</span>, ...&#125;<br><span class="hljs-keyword">var</span> class_to_allocnpages = [_NumSizeClasses]<span class="hljs-keyword">uint8</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, ...&#125;<br></code></pre></td></tr></table></figure><p>可以发现我们之前在计算 capmem 的时候传入的 <code>capmem = roundupsize(uintptr(newcap) * sys.PtrSize)</code>  值是 <code>5*8=40</code>  最后对齐出的结果就是 <code>48</code>  了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="slice-扩容算法"><a href="#slice-扩容算法" class="headerlink" title="slice 扩容算法"></a>slice 扩容算法</h3><ul><li><strong>如果需要的最小容量比两倍原有容量大，那么就取需要的容量</strong></li><li>如果原有 slice 长度小于 1024 那么每次就扩容为原来的两倍</li><li>如果原 slice 大于等于 1024 那么每次扩容就扩为原来的 1.25 倍</li><li><strong>除此之外扩容容量计算完成之后，还会进行一次内存对齐操作</strong></li></ul><p>搜索 slice 扩容策略很多都会说第 2、3 点但是没有说 1, 4 点就会造成一些困惑</p><h3 id="GDB-调试"><a href="#GDB-调试" class="headerlink" title="GDB 调试"></a>GDB 调试</h3><ul><li>mac 下安装使用 gdb 比较麻烦，建议使用 linux</li><li>一般情况下我们还是建议使用 dlv 进行调试，如果有 runtime 库的调试需求可以使用 gdb</li><li>学习了 gdb 的安装以及基本使用方式，你之前有类似的经历么？一般会在什么情况下使用 gdb 进行调试</li></ul><h3 id="问题-2-解答-在讲解-slice-初始化的过程中，为什么-s2-s3-打印的数组指针都是-0x587450"><a href="#问题-2-解答-在讲解-slice-初始化的过程中，为什么-s2-s3-打印的数组指针都是-0x587450" class="headerlink" title="问题 2 解答: 在讲解 slice 初始化的过程中，为什么 s2 , s3 打印的数组指针都是 0x587450 ?"></a>问题 2 解答: 在讲解 slice 初始化的过程中，为什么 <code>s2</code> , <code>s3</code> 打印的数组指针都是 <code>0x587450</code> ?</h3><p>在讲解 <code>makeslice</code>  的时候我们有说到最后一步会调用 <code>mallocgc</code>  分配内存，看这个函数的源码我们就能发现，有一步判断，如果容量为 0 会返回一个固定的地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zerobase)<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>算法</tag>
      
      <tag>Go</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据结构与算法02-数组上: 深入理解 slice</title>
    <link href="/post/array.html"/>
    <url>/post/array.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 数据结构与算法系列文章，本系列文章主要会包括常见的数据结构与算法实现，同时会包括 Go 标准库代码的分析理解，讲到对应章节的时候优先学习分析 Go 的源码实现，例如 slice、list、sort 等，然后可能会有一些常见的案例实现，同时这也是 <a href="https://time.geekbang.org/column/intro/126">极客时间-数据结构与算法之美</a> 的课程笔记</li><li><strong>本文代码仓库:</strong> <a href="https://github.com/mohuishou/go-algorithm">https://github.com/mohuishou/go-algorithm</a> 🌟🌟🌟🌟🌟</li><li><strong>RoadMap: </strong>持续更新中，预计一周更新 1 ~ 2 篇文章，预计到 202101 月底前更新完成</li><li><strong>获取更新:</strong> <a href="https://github.com/mohuishou">Github</a>、<a href="https://zhuanlan.zhihu.com/mohuishou">知乎</a>、<a href="https://lailin.xyz/atom.xml">RSS</a>、<a href="https://toutiao.io/subjects/387401?f=new">开发者头条</a></li><li>上一个系列刚刚完成了 <a href="https://lailin.xyz/post/go-design-pattern.html">Go 设计模式</a>，如果感兴趣也可以进行查看</li></ul><h2 id="上期答案"><a href="#上期答案" class="headerlink" title="上期答案"></a>上期答案</h2><h3 id="Q-通过-Element-节点中的-List-结构来判断节点是否属于当前链表的方式，在某些情况下会出现-bug"><a href="#Q-通过-Element-节点中的-List-结构来判断节点是否属于当前链表的方式，在某些情况下会出现-bug" class="headerlink" title="Q: 通过 Element 节点中的 List 结构来判断节点是否属于当前链表的方式，在某些情况下会出现  bug"></a>Q: 通过 Element 节点中的 List 结构来判断节点是否属于当前链表的方式，在某些情况下会出现  <code>bug</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">l := list.List&#123;&#125;<br>e := l.PushBack(<span class="hljs-number">10</span>)<br><br>l = list.List&#123;&#125;<br>l.Remove(e)<br>fmt.Println(<span class="hljs-string">&quot;list len: &quot;</span>, l.Len())<br></code></pre></td></tr></table></figure><p>接着看下面之前，先想一想，你觉得这段代码会输出什么？<br>这个问题来自: <a href="https://github.com/golang/go/issues/39014">https://github.com/golang/go/issues/39014</a><br>这段代码会输出 -1，但是我们期望的不应该是输出 0 么？<br>我们来看看发生了什么？<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1605409586875-e7ef8b69-b95a-4fb8-9d6a-27f33f8f689c.svg" alt="01_链表.drawio.svg"></p><ul><li>当我们执行完 <code>l.PushBack(10)</code>  这段代码直接，就如左图所示了，节点 e 指向了链表 l，链表 l 的值的长度是 1</li><li>但是当我们执行完 <code>l = list.List&#123;&#125;</code>  我们重置了链表 l 的值，并没有修改他的地址，所以 e 还是指向的链表 l，当执行 <code>Remove</code>  方法的时候，e 的链表和当前执行的 l 的地址判断是可以对应的上的，但是实际上链表的值已经发生了变化，链表的长度已经不为 1 的，并且新的链表的根节点也没有指向 e</li><li>所以最后得到的长度才是 -1</li><li>最后细心的同学应该已经发现，这里其实还可能存在内存泄漏的问题，元素 e -&gt; root(0x2) 其实已经没有用到了</li></ul><h2 id="什么是数组？"><a href="#什么是数组？" class="headerlink" title="什么是数组？"></a>什么是数组？</h2><ul><li>数组大家应该都非常属性我们来简单的回顾一下</li><li>数组是一个具有连续的内存空间和相同类型的数据的数据结构</li><li>我们随机访问任意一个下标的数据的时间复杂度都是 O(1)</li><li>但是正是由于这种特性，导致它插入和删除元素的效率比较低，是 O(n)</li></ul><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1605409904549-b00a01d7-340f-4101-9e11-cdcea25528e1.svg" alt="01_array.drawio.svg"></p><h2 id="Go-中的数组"><a href="#Go-中的数组" class="headerlink" title="Go 中的数组"></a>Go 中的数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 初始化数组</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-comment">// 查找元素</span><br>fmt.Printf(<span class="hljs-string">&quot;arr[1]: %d\n&quot;</span>, arr[<span class="hljs-number">1</span>])<br><span class="hljs-comment">// 删除元素</span><br>remove(&amp;arr, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// remove(&amp;arr, 3) // will panic</span><br>fmt.Println(arr)<br>&#125;<br><br><span class="hljs-comment">// 删除数组 arr 的某个元素</span><br><span class="hljs-comment">// index 为需要删除的索引</span><br><span class="hljs-comment">// 从需要删除的元素开始，依次将后面的元素往前移动一位即可</span><br><span class="hljs-comment">// 然后将最后一位修改为该类型的默认值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">(arr *[3]<span class="hljs-keyword">int</span>, index <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> index &gt;= <span class="hljs-built_in">len</span>(arr) &#123;<br>log.Panicf(<span class="hljs-string">&quot;%d remove out range arr&quot;</span>, index)<br>&#125;<br><span class="hljs-keyword">for</span> i := index; i &lt; <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>; i++ &#123;<br>arr[i] = arr[i+<span class="hljs-number">1</span>]<br>&#125;<br>arr[<span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Q-为什么我们在-remove-函数当中的参数使用的是指针"><a href="#Q-为什么我们在-remove-函数当中的参数使用的是指针" class="headerlink" title="Q: 为什么我们在 remove 函数当中的参数使用的是指针"></a>Q: 为什么我们在 remove 函数当中的参数使用的是指针</h3><p>这是因为在 go 中参数的传递都是值传递，如果不用指针的话，那么就会复制一份数据到函数中，这样就无法做到删除的作用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在函数 main 中</span><br>fmt.Printf(<span class="hljs-string">&quot;main: %p --&gt; %+v\n&quot;</span>, &amp;arr, arr)<br>p(arr)<br>p2(&amp;arr)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">p</span><span class="hljs-params">(arr [3]<span class="hljs-keyword">int</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;p: %p --&gt; %+v\n&quot;</span>, &amp;arr, arr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">p2</span><span class="hljs-params">(arr *[3]<span class="hljs-keyword">int</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;p2: %p --&gt; %+v\n&quot;</span>, arr, arr)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">main: <span class="hljs-number">0xc0000c2000</span> --&gt; [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span>]<br>p: <span class="hljs-number">0xc0000c2080</span> --&gt; [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span>]<br>p2: <span class="hljs-number">0xc0000c2000</span> --&gt; &amp;[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>通过上面的例子我们就可以发现，在函数 p 中我们直接传递的数组，最后打印的变量地址是和 main 中不同的，就印证了我们之前的说法<br>在实际使用过程中，我们其实是很少使用到固定长度的数组的，而是使用可以自动扩容的 slice，接下来我们就深入的看一下 slice 当中的一些细节</p><h2 id="深入理解-Slice"><a href="#深入理解-Slice" class="headerlink" title="深入理解 Slice"></a>深入理解 Slice</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化</span><br>s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>)<br>fmt.Printf(<span class="hljs-string">&quot;s1(%p): %v, len: %d, cap: %d\n&quot;</span>, &amp;s1, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<br><span class="hljs-comment">// s1(0xc00000c080): [0 0], len: 2, cap: 2</span><br><br><span class="hljs-comment">// 赋值</span><br>s1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>s1[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>fmt.Printf(<span class="hljs-string">&quot;s1(%p): %v, len: %d, cap: %d\n&quot;</span>, &amp;s1, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<br><span class="hljs-comment">//s1(0xc00000c080): [1 2], len: 2, cap: 2</span><br><br><span class="hljs-comment">// 扩容</span><br>s1 = <span class="hljs-built_in">append</span>(s1, <span class="hljs-number">3</span>)<br>fmt.Printf(<span class="hljs-string">&quot;s1(%p): %v, len: %d, cap: %d\n&quot;</span>, &amp;s1, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<br><span class="hljs-comment">// s1(0xc00000c080): [1 2 3], len: 3, cap: 4</span><br><br><span class="hljs-comment">// 删除元素</span><br>s1 = <span class="hljs-built_in">append</span>(s1[:<span class="hljs-number">1</span>], s1[<span class="hljs-number">2</span>:]...)<br>fmt.Printf(<span class="hljs-string">&quot;s1(%p): %v, len: %d, cap: %d\n&quot;</span>, &amp;s1, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<br><span class="hljs-comment">// s1(0xc00000c080): [1 3], len: 2, cap: 4</span><br></code></pre></td></tr></table></figure><ul><li>可以发现，通过 append 之后 s1 的容量和长度都发生了变化，说明完成了自动扩容</li><li>删除元素之后我们的长度发生了变化，但是容量还是原本不变</li></ul><h4 id="常见坑"><a href="#常见坑" class="headerlink" title="常见坑"></a>常见坑</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 复制一个 slice</span><br>s2 := s1[:<span class="hljs-number">2</span>]<br>fmt.Printf(<span class="hljs-string">&quot;s2(%p): %v, len: %d, cap: %d\n&quot;</span>, &amp;s2, s2, <span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">cap</span>(s2))<br><span class="hljs-comment">// s2(0xc00000c120): [1 3], len: 2, cap: 4</span><br><br>s1[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span> <span class="hljs-comment">// 这里可以发现，s1[0] s2[0] 都被修改为了 10</span><br>fmt.Printf(<span class="hljs-string">&quot;s1(%p): %v, len: %d, cap: %d\n&quot;</span>, &amp;s1, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<br><span class="hljs-comment">// s1(0xc00000c080): [10 3], len: 2, cap: 4</span><br>fmt.Printf(<span class="hljs-string">&quot;s2(%p): %v, len: %d, cap: %d\n&quot;</span>, &amp;s2, s2, <span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">cap</span>(s2))<br><span class="hljs-comment">// s2(0xc00000c120): [10 3], len: 2, cap: 4</span><br><br>s1 = <span class="hljs-built_in">append</span>(s1, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>)<br>s1[<span class="hljs-number">0</span>] = <span class="hljs-number">11</span> <span class="hljs-comment">// 这里可以发现，s1[0] 被修改为了 11, s2[0] 还是10</span><br>fmt.Printf(<span class="hljs-string">&quot;s1(%p): %v, len: %d, cap: %d\n&quot;</span>, &amp;s1, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<br><span class="hljs-comment">// s1(0xc00011c020): [11 3 5 6 7 8], len: 6, cap: 8</span><br>fmt.Printf(<span class="hljs-string">&quot;s2(%p): %v, len: %d, cap: %d\n&quot;</span>, &amp;s2, s2, <span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">cap</span>(s2))<br><span class="hljs-comment">// s2(0xc00011c0c0): [10 3], len: 2, cap: 4</span><br></code></pre></td></tr></table></figure><ul><li>这是一个常见的例子，我们从 s1 复制了一个 s2</li><li>修改 s1 的第一个元素之后，s2 的一个元素也被修改了</li><li>但是我们触发了 s1 的自动扩容之后，s2 的第一个元素就不会随着 s1 的修改而变化了</li><li>这也是当函数的参数是 slice 时我们不允许直接修改，如果需要修改需要返回这个 slice 的原因，因为函数的参数也是值的复制</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sliceChange</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-comment">// 不允许直接这么操作</span><br>s[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>大家如果使用过一段时间 golang 应该知道 slice 的底层结构其实是一个 struct<br><a href="https://github.com/golang/go/blob/go1.15/src/runtime/slice.go">https://github.com/golang/go/blob/go1.15/src/runtime/slice.go</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>array unsafe.Pointer<br><span class="hljs-built_in">len</span>   <span class="hljs-keyword">int</span><br><span class="hljs-built_in">cap</span>   <span class="hljs-keyword">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1605449197795-9ca02de7-b129-4f7c-a0c3-930798b881c0.svg" alt="02_slice_struct.drawio.svg"></p><ul><li>如图所示我们可以发现，slice 的底层结构是一个结构体<ul><li>它包含了一个指向一个数组的指针，数据实际上存储在这个指针指向的数组上</li><li>len 表示当前 slice 使用到的长度</li><li>cap 表示当前 slice 的容量，同时也是底层数组 array 的长度</li></ul></li><li>这也就回答了我们上面的发现的现象，在复制 slice 的时候，slice 中数组的指针也被复制了，在出发扩容逻辑之前，两个 slice 指向的是相同的数组，出发扩容逻辑之后指向的就是不同的数组了</li><li>同时因为结构体中 array 是一个指针所以在 slice 作为参数传递的时候，这个指针也会被复制一份，所以也会有相同的问题</li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个 slice</span><br><span class="hljs-comment">// et: 数据的类型</span><br><span class="hljs-comment">// len: slice 长度</span><br><span class="hljs-comment">// cap: slice 容量</span><br><span class="hljs-comment">// 返回一个指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeslice</span><span class="hljs-params">(et *_type, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;<br>    <span class="hljs-comment">// 通过 cap 计算当前类型的 slice 需要的内存容量以及是否超出最大容量</span><br>mem, overflow := math.MulUintptr(et.size, <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">cap</span>))<br>    <span class="hljs-comment">// 异常情况判断</span><br><span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc || <span class="hljs-built_in">len</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span> &gt; <span class="hljs-built_in">cap</span> &#123;<br><span class="hljs-comment">// 通过 len 计算当前类型的 slice 需要的内存容量以及是否超出最大容量</span><br>        <span class="hljs-comment">// 如果是 len 超过限制则抛出 len 的相关异常，否则抛出 cap 异常</span><br>mem, overflow := math.MulUintptr(et.size, <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">len</span>))<br><span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc || <span class="hljs-built_in">len</span> &lt; <span class="hljs-number">0</span> &#123;<br>panicmakeslicelen()<br>&#125;<br>panicmakeslicecap()<br>&#125;<br><br><span class="hljs-keyword">return</span> mallocgc(mem, et, <span class="hljs-literal">true</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一个 64 位的</p><ul><li>64 位对比默认的只是进行了一下数据格式转换，但是这个转换的对比还是很有意思的</li><li>如果是在 64 位的机器上，那么 int == int64 的</li><li>如果是在 32 位的机器上，那么 int == int32，如果 int64(int(len64)) != len64，那么就说明这个长度超出了当前机器的内存位数，直接抛出异常错误就好了</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeslice64</span><span class="hljs-params">(et *_type, len64, cap64 <span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;<br><span class="hljs-built_in">len</span> := <span class="hljs-keyword">int</span>(len64)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">int64</span>(<span class="hljs-built_in">len</span>) != len64 &#123;<br>panicmakeslicelen()<br>&#125;<br><br><span class="hljs-built_in">cap</span> := <span class="hljs-keyword">int</span>(cap64)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">int64</span>(<span class="hljs-built_in">cap</span>) != cap64 &#123;<br>panicmakeslicecap()<br>&#125;<br><br><span class="hljs-keyword">return</span> makeslice(et, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 当 append 需要扩容的时候会调用这个函数</span><br><span class="hljs-comment">// et 是当前 slice 的类型</span><br><span class="hljs-comment">// old 是原有的 slice</span><br><span class="hljs-comment">// cap 是满足扩容所需的最小容量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">growslice</span><span class="hljs-params">(et *_type, old slice, <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">slice</span></span> &#123;<br><span class="hljs-comment">// ... 一些校验逻辑，略过</span><br><br>    <span class="hljs-comment">// 下面这个就是扩容算法</span><br>newcap := old.<span class="hljs-built_in">cap</span><br>doublecap := newcap + newcap<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;<br>newcap = <span class="hljs-built_in">cap</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> old.<span class="hljs-built_in">len</span> &lt; <span class="hljs-number">1024</span> &#123;<br>newcap = doublecap<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span><br><span class="hljs-comment">// and prevent an infinite loop.</span><br><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;<br>newcap += newcap / <span class="hljs-number">4</span><br>&#125;<br><span class="hljs-comment">// Set newcap to the requested cap when</span><br><span class="hljs-comment">// the newcap calculation overflowed.</span><br><span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;<br>newcap = <span class="hljs-built_in">cap</span><br>&#125;<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 下面去计算新的数组所需要的内存</span><br>    <span class="hljs-comment">// 通过 old.len, cap, 以及 newcap 计算</span><br><span class="hljs-keyword">var</span> overflow <span class="hljs-keyword">bool</span><br><span class="hljs-keyword">var</span> lenmem, newlenmem, capmem <span class="hljs-keyword">uintptr</span><br><span class="hljs-comment">// Specialize for common values of et.size.</span><br><span class="hljs-comment">// For 1 we don&#x27;t need any division/multiplication.</span><br><span class="hljs-comment">// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.</span><br><span class="hljs-comment">// For powers of 2, use a variable shift.</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> et.size == <span class="hljs-number">1</span>:<br>lenmem = <span class="hljs-keyword">uintptr</span>(old.<span class="hljs-built_in">len</span>)<br>newlenmem = <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">cap</span>)<br>capmem = roundupsize(<span class="hljs-keyword">uintptr</span>(newcap))<br>overflow = <span class="hljs-keyword">uintptr</span>(newcap) &gt; maxAlloc<br>newcap = <span class="hljs-keyword">int</span>(capmem)<br><span class="hljs-comment">// ... 有好几个分支，看一个类似的就可以了</span><br>&#125;<br><br><span class="hljs-comment">// 检查是不是超过内存限制</span><br><span class="hljs-keyword">if</span> overflow || capmem &gt; maxAlloc &#123;<br><span class="hljs-built_in">panic</span>(errorString(<span class="hljs-string">&quot;growslice: cap out of range&quot;</span>))<br>&#125;<br><br>    <span class="hljs-comment">// 分配内存</span><br><span class="hljs-keyword">var</span> p unsafe.Pointer<br><span class="hljs-keyword">if</span> et.ptrdata == <span class="hljs-number">0</span> &#123;<br>p = mallocgc(capmem, <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>)<br><span class="hljs-comment">// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).</span><br><span class="hljs-comment">// Only clear the part that will not be overwritten.</span><br>memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Note: can&#x27;t use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span><br>p = mallocgc(capmem, et, <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">if</span> lenmem &gt; <span class="hljs-number">0</span> &amp;&amp; writeBarrier.enabled &#123;<br><span class="hljs-comment">// Only shade the pointers in old.array since we know the destination slice p</span><br><span class="hljs-comment">// only contains nil pointers because it has been cleared during alloc.</span><br>bulkBarrierPreWriteSrcOnly(<span class="hljs-keyword">uintptr</span>(p), <span class="hljs-keyword">uintptr</span>(old.array), lenmem-et.size+et.ptrdata)<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 将原本的数组复制到新数组上</span><br>memmove(p, old.array, lenmem)<br><br><span class="hljs-keyword">return</span> slice&#123;p, old.<span class="hljs-built_in">len</span>, newcap&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们重点看一下扩容的算法，可以发现有三种逻辑</p><ul><li>如果需要的最小容量比两倍原有容量大，那么就取需要的容量</li><li>如果原有 slice 长度小于 1024 那么每次就扩容为原来的两倍</li><li>如果原 slice 大于等于 1024 那么每次扩容就扩为原来的 1.25 倍</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">newcap := old.<span class="hljs-built_in">cap</span><br>doublecap := newcap + newcap<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;<br>    newcap = <span class="hljs-built_in">cap</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> old.<span class="hljs-built_in">len</span> &lt; <span class="hljs-number">1024</span> &#123;<br>        newcap = doublecap<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span><br>        <span class="hljs-comment">// and prevent an infinite loop.</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;<br>            newcap += newcap / <span class="hljs-number">4</span><br>        &#125;<br>        <span class="hljs-comment">// Set newcap to the requested cap when</span><br>        <span class="hljs-comment">// the newcap calculation overflowed.</span><br>        <span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;<br>            newcap = <span class="hljs-built_in">cap</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="空-Slice"><a href="#空-Slice" class="headerlink" title="空 Slice"></a>空 Slice</h3><p>我们先看一下 Slice 初始化的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s1 []<span class="hljs-keyword">int</span><br>s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">uint</span>, <span class="hljs-number">0</span>)<br>s3 := []<span class="hljs-keyword">int</span>&#123;&#125;<br><span class="hljs-comment">// fmt.Printf(&quot;%p: %v, len: %d, cap: %d\n&quot;, s1, s1, len(s1), cap(s1))</span><br><span class="hljs-comment">// 0x0: [], len: 0, cap: 0</span><br><span class="hljs-comment">// 0x587450: [], len: 0, cap: 0</span><br><span class="hljs-comment">// 0x587450: [], len: 0, cap: 0</span><br></code></pre></td></tr></table></figure><ul><li>tips: <code>%p</code>  打印 slice 会打印 slice 底层指向的数组的地址</li><li>我们可以发现，第一种方式进行初始化，出现的也就是 slice 的零值，底层的数组指针是一个 nil</li><li>第二种和第三种的底层指针都有一个值，不过没有实际分配内存</li><li>这三种方式初始化出来的 cap、和 len 的长度都是 0</li></ul><h3 id="规范技巧"><a href="#规范技巧" class="headerlink" title="规范技巧"></a>规范技巧</h3><ol><li>slice 作为参数时，不要直接存储它的引用，而是通过 <code>copy</code>  复制一份<ol><li>原因请查看上文，Slice 的结构</li><li>示例：<a href="https://github.com/xxjwxc/uber_go_guide_cn#nil-%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9C%89%E6%95%88%E7%9A%84-slice">Uber Go 规范: nil-是一个有效的-slice</a></li></ol></li><li>要检查切片是否为空，请始终使用 <code>len(s) == 0</code> 。而非 <code>nil</code> 。<ol><li>原因请查看上文，Slice 初始化</li><li>示例：<a href="https://github.com/xxjwxc/uber_go_guide_cn#%E5%9C%A8%E8%BE%B9%E7%95%8C%E5%A4%84%E6%8B%B7%E8%B4%9D-Slices-%E5%92%8C-Maps">Uber Go 规范: 在边界处拷贝-Slices-和-Maps</a></li></ol></li></ol><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><ul><li>在讲解 slice 初始化的过程中，为什么 <code>s2</code> , <code>s3</code>  打印的数组指针都是 <code>0x587450</code> ?</li><li>请查看下面一段代码，会输出什么，为什么？<ul><li>A: 5 8 B: 8 8 C: 5 5 D: 5 6</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s))<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>算法</tag>
      
      <tag>Go</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据结构与算法01-链表: 深入理解container/list&amp;LRU缓存的实现</title>
    <link href="/post/list.html"/>
    <url>/post/list.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 数据结构与算法系列文章，本系列文章主要会包括常见的数据结构与算法实现，同时会包括 Go 标准库代码的分析理解，讲到对应章节的时候优先学习分析 Go 的源码实现，例如 slice、list、sort 等，然后可能会有一些常见的案例实现，同时这也是 <a href="https://time.geekbang.org/column/intro/126">极客时间-数据结构与算法之美</a> 的课程笔记</li><li><strong>本文代码仓库:</strong> <a href="https://github.com/mohuishou/go-algorithm">https://github.com/mohuishou/go-algorithm</a> 🌟🌟🌟🌟🌟</li><li><strong>RoadMap: </strong>持续更新中，预计一周更新 1 ~ 2 篇文章，预计到 202101 月底前更新完成</li><li><strong>获取更新:</strong> <a href="https://github.com/mohuishou/go-design-pattern">Github</a>、<a href="https://zhuanlan.zhihu.com/mohuishou">知乎</a>、<a href="https://lailin.xyz/atom.xml">RSS</a>、<a href="https://toutiao.io/subjects/387401?f=new">开发者头条</a></li><li>上一个系列刚刚完成了 <a href="https://lailin.xyz/post/go-design-pattern.html">Go 设计模式</a>，如果感兴趣也可以进行查看</li></ul><h2 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><ul><li>链表通过指针将零散的内存数据联系在一起</li><li>如下图所示，包含两个结构，一个是数据 data，另外一个是下一个节点的内存地址</li><li>最后一个节点指向 NULL</li></ul><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1604804227362-0a6030ac-cf14-4052-8a4b-87eec4e1a904.jpeg" alt="01_链表-单链表.jpg"></p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><ul><li>和单链表的区别就是，将尾节点指向的头结点，将整个链表组成了一个环状</li></ul><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1604804281440-be68f311-161b-42bf-b8ac-f48f917b8732.png" alt="01_链表-循环链表.png"></p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ul><li>和在单链表的基础之上添加了一个指向上一个节点的指针，这样我们知道任意一个节点就可以同时知道他们的上下两个节点</li><li>这是实际使用的时候最常用的</li></ul><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1604804268492-79fe5525-be57-4eb8-bee7-0900e041af66.jpeg" alt="01_链表-双向链表.jpg"></p><h3 id="和数组对比"><a href="#和数组对比" class="headerlink" title="和数组对比"></a>和数组对比</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>链表</strong></th><th style="text-align:center"><strong>数组</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>查找某个元素</strong></td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center"><strong>删除或者添加一个元素</strong></td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td></tr></tbody></table><h2 id="标准库-Container-list-的实现"><a href="#标准库-Container-list-的实现" class="headerlink" title="标准库 Container/list 的实现"></a>标准库 Container/list 的实现</h2><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Element 用于表示链表当中的节点</span><br><span class="hljs-keyword">type</span> Element <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// next, prev 分别表示上个节点和下个节点</span><br>next, prev *Element<br><br><span class="hljs-comment">// 表示节点所在的元素</span><br>list *List<br><br><span class="hljs-comment">// 节点所保存的数据，也就是上面图中的 data</span><br>Value <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// List 这是一个双向链表</span><br><span class="hljs-comment">// List 的零值是一个空链表</span><br><span class="hljs-keyword">type</span> List <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// 根节点，List 其实是一个双向循环链表，root， root.prev 是尾节点, 尾节点的下一个节点指向 root</span><br>    <span class="hljs-comment">// 根节点是一个哨兵节点，是为了用来简化节点操作使用的</span><br>root Element<br><br>    <span class="hljs-comment">// 链表的长度，不包括哨兵节点，也就是根节点</span><br><span class="hljs-built_in">len</span>  <span class="hljs-keyword">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里我下意识的会有两个问题：</p><ul><li>为什么在 <code>Element</code>  当中会持有一个 <code>List</code>  结构？</li><li>为什么需要一个单独的 <code>List</code>  结构体，直接要一个 <code>Root</code>  节点不就完事了么？</li></ul><h3 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">Remove(e *Element) <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 删除一个节点</span><br>PushFront(v <span class="hljs-keyword">interface</span>&#123;&#125;) *Element <span class="hljs-comment">// 将值插入到链表头部</span><br>PushBack(v <span class="hljs-keyword">interface</span>&#123;&#125;) *Element <span class="hljs-comment">// 将值插入到链表尾部</span><br>InsertBefore(v <span class="hljs-keyword">interface</span>&#123;&#125;, mark *Element) *Element <span class="hljs-comment">// 在 mark 节点之前插入值</span><br>InsertAfter(v <span class="hljs-keyword">interface</span>&#123;&#125;, mark *Element) *Element <span class="hljs-comment">// 在 mark 节点之后插入值</span><br>MoveToFront(e *Element) <span class="hljs-comment">// 将节点 e 移动至链表头部</span><br>MoveToBack(e *Element) <span class="hljs-comment">// 将节点 e 移动至链表尾部</span><br>MoveBefore(e, mark *Element) <span class="hljs-comment">// 将节点 e 移动到 mark 节点之前</span><br>MoveAfter(e, mark *Element) <span class="hljs-comment">// 将节点 e 移动到 mark 节点之后</span><br>PushBackList(other *List) <span class="hljs-comment">// 将链表 other 连接到当前链表之后</span><br>PushFrontList(other *List) <span class="hljs-comment">// 将链表 other 连接到当前链表之前</span><br></code></pre></td></tr></table></figure><p>看了暴露的方法集之后我们看一下这里面核心的几个方法，上诉暴露的方法实质上都是通过调用下面的方法实现的</p><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 将节点 e 插入 at 之后</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span> <span class="hljs-title">insert</span><span class="hljs-params">(e, at *Element)</span> *<span class="hljs-title">Element</span></span> &#123;<br>    <span class="hljs-comment">// 假设 at.next 为 nt</span><br>    <span class="hljs-comment">// 1. 将节点 e 的上一个节点指向 at</span><br>e.prev = at<br>    <span class="hljs-comment">// 2. 将节点 e 的下一个节点指向 nt</span><br>e.next = at.next<br>    <span class="hljs-comment">// 3. 这个时候  e.prev.next == at.next</span><br>    <span class="hljs-comment">// 其实就是本来 at --&gt; nt，修改为 at --&gt; e</span><br>e.prev.next = e<br>    <span class="hljs-comment">// 4. e.next.prev == nt.prev</span><br>    <span class="hljs-comment">// 本来 at &lt;--- nt，修改为 e &lt;--- nt</span><br>e.next.prev = e<br>e.list = l<br>l.<span class="hljs-built_in">len</span>++<br><span class="hljs-keyword">return</span> e<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// remove removes e from its list, decrements l.len, and returns e.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span> <span class="hljs-title">remove</span><span class="hljs-params">(e *Element)</span> *<span class="hljs-title">Element</span></span> &#123;<br>e.prev.next = e.next<br>e.next.prev = e.prev<br>    <span class="hljs-comment">// 这里为了避免内存泄漏的操作可以学习</span><br>e.next = <span class="hljs-literal">nil</span> <span class="hljs-comment">// avoid memory leaks</span><br>e.prev = <span class="hljs-literal">nil</span> <span class="hljs-comment">// avoid memory leaks</span><br>e.list = <span class="hljs-literal">nil</span><br>l.<span class="hljs-built_in">len</span>--<br><span class="hljs-keyword">return</span> e<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="move"><a href="#move" class="headerlink" title="move"></a>move</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// move moves e to next to at and returns e.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span> <span class="hljs-title">move</span><span class="hljs-params">(e, at *Element)</span> *<span class="hljs-title">Element</span></span> &#123;<br><span class="hljs-keyword">if</span> e == at &#123;<br><span class="hljs-keyword">return</span> e<br>&#125;<br>    <span class="hljs-comment">// 先把当前节点从原来的位置移除</span><br>e.prev.next = e.next<br>e.next.prev = e.prev<br><br>    <span class="hljs-comment">// 再将当前节点 e 插入到 at 节点之后</span><br>e.prev = at<br>e.next = at.next<br>e.prev.next = e<br>e.next.prev = e<br><br><span class="hljs-keyword">return</span> e<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h3><p>我们在看一下最开始的两个问题<br><strong>1. 为什么在 <code>Element</code> 当中会持有一个 <code>List</code> 结构？</strong></p><ul><li>查看上方的 move 方法我们就可以知道，list 提供了讲节点移动到某个节点之后的方法，通过 e.List 进行对比我们就可以知道需要移动的节点是不是属于当前这个链表了，这也是 <code>MoveToFront</code> 等方法的实现方式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span> <span class="hljs-title">MoveToFront</span><span class="hljs-params">(e *Element)</span></span> &#123;<br><span class="hljs-keyword">if</span> e.list != l || l.root.next == e &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// see comment in List.Remove about initialization of l</span><br>l.move(e, &amp;l.root)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. 为什么需要一个单独的 <code>List</code> 结构体，直接要一个 <code>Root</code>  节点不就完事了么？</strong></p><ul><li>看之前的 <code>List</code> 的结构我们可以发现，在结构体中包含了一个 <code>len</code> ，这样可以避免需要取长度的时候每次都需要从头到尾遍历一遍</li></ul><h2 id="如何实现一个并发安全的-Container-list？"><a href="#如何实现一个并发安全的-Container-list？" class="headerlink" title="如何实现一个并发安全的 Container/list？"></a>如何实现一个并发安全的 Container/list？</h2><p>接下来，我们使用 <code>go test -race .</code>  测试是否存在并发安全的问题</p><h3 id="标准库包"><a href="#标准库包" class="headerlink" title="标准库包"></a>标准库包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestList</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>l := list.New()<br>wg := sync.WaitGroup&#123;&#125;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>l.PushBack(i)<br>&#125;<br>wg.Done()<br>&#125;()<br>l.PushBack(<span class="hljs-number">11</span>)<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果如下，可以明显的看到存在并发问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-keyword">go</span> test  -v -timeout <span class="hljs-number">1</span>s -race -run ^TestList$ ./...<br>=== RUN   TestList<br>==================<br>WARNING: DATA RACE<br>Read at <span class="hljs-number">0x00c00006e330</span> by goroutine <span class="hljs-number">8</span>:<br>  container/list.(*List).lazyInit()<br>      /usr/local/<span class="hljs-keyword">go</span>/src/container/list/list.<span class="hljs-keyword">go</span>:<span class="hljs-number">86</span> +<span class="hljs-number">0xb2</span><br></code></pre></td></tr></table></figure><h3 id="稍作改造"><a href="#稍作改造" class="headerlink" title="稍作改造"></a>稍作改造</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// List 链表</span><br><span class="hljs-keyword">type</span> List <span class="hljs-keyword">struct</span> &#123;<br>*list.List<br>mu sync.Mutex<br>&#125;<br><br><span class="hljs-comment">// New 新建链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span> *<span class="hljs-title">List</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;List&#123;List: list.New()&#125;<br>&#125;<br><br><span class="hljs-comment">// PushBack 像链表尾部插入值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span> <span class="hljs-title">PushBack</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    <span class="hljs-comment">// 加锁</span><br>l.mu.Lock()<br><span class="hljs-keyword">defer</span> l.mu.Unlock()<br>l.List.PushBack(v)<br>&#125;<br></code></pre></td></tr></table></figure><p>问题解决</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> test  -v -timeout <span class="hljs-number">1</span>s -race -run ^TestList_PushBack$ ./...<br>=== RUN   TestList_PushBack<br>--- PASS: TestList_PushBack (<span class="hljs-number">0.00</span>s)<br>PASS<br>ok      github.com/mohuishou/<span class="hljs-keyword">go</span>-algorithm/<span class="hljs-number">01</span>_list/list  (cached)<br></code></pre></td></tr></table></figure><h2 id="如何实现一个-LRU-缓存？"><a href="#如何实现一个-LRU-缓存？" class="headerlink" title="如何实现一个 LRU 缓存？"></a>如何实现一个 LRU 缓存？</h2><p>LRU: Least Recently Used 最近最少使用策略</p><blockquote><p>这里为了训练一下代码，就没有直接使用标准库的包了</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> lru<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// Node 链表的节点</span><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>prev, next *Node<br><br>list *LRU<br><br>key   <span class="hljs-keyword">string</span><br>value <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// LRU 缓存</span><br><span class="hljs-keyword">type</span> LRU <span class="hljs-keyword">struct</span> &#123;<br>root *Node <span class="hljs-comment">// 根节点</span><br><span class="hljs-built_in">cap</span>  <span class="hljs-keyword">int</span>   <span class="hljs-comment">// 当前缓存容量</span><br><span class="hljs-built_in">len</span>  <span class="hljs-keyword">int</span>   <span class="hljs-comment">// 缓存的长度</span><br>&#125;<br><br><span class="hljs-comment">// NewLRU NewLRU</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLRU</span><span class="hljs-params">(<span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">LRU</span></span> &#123;<br>l := &amp;LRU&#123;<br>root: &amp;Node&#123;&#125;,<br><span class="hljs-built_in">cap</span>:  <span class="hljs-built_in">cap</span>,<br>&#125;<br>l.root.prev = l.root<br>l.root.next = l.root<br>l.root.list = l<br><span class="hljs-keyword">return</span> l<br>&#125;<br><br><span class="hljs-comment">// Get 获取缓存数据</span><br><span class="hljs-comment">// 如果获取到数据，就把这个节点移动到链表头部</span><br><span class="hljs-comment">// 如果没有获取到，就返回nil</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LRU)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">defer</span> l.debug()<br>n := l.get(key)<br><span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">return</span> n.value<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LRU)</span> <span class="hljs-title">get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">Node</span></span> &#123;<br><span class="hljs-keyword">for</span> n := l.root.next; n != l.root; n = n.next &#123;<br><span class="hljs-keyword">if</span> n.key == key &#123;<br>n.prev.next = n.next<br>n.next.prev = n.prev<br><br>n.next = l.root.next<br>l.root.next.prev = n<br>l.root.next = n<br>n.prev = l.root<br><span class="hljs-keyword">return</span> n<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Put 写入缓存数据</span><br><span class="hljs-comment">// 如果 key 已经存在，那么更新值</span><br><span class="hljs-comment">// 如果 key 不存在，那么插入到第一个节点</span><br><span class="hljs-comment">// 当缓存容量满了的时候，会自动删除最后的数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LRU)</span> <span class="hljs-title">Put</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">defer</span> l.debug()<br>n := l.get(key)<br><span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;<br>n.value = value<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 缓存满了</span><br><span class="hljs-keyword">if</span> l.<span class="hljs-built_in">len</span> == l.<span class="hljs-built_in">cap</span> &#123;<br>last := l.root.prev<br>last.prev.next = l.root<br>l.root.prev = last.prev<br>last.list = <span class="hljs-literal">nil</span><br>last.prev = <span class="hljs-literal">nil</span><br>last.next = <span class="hljs-literal">nil</span><br>l.<span class="hljs-built_in">len</span>--<br>&#125;<br><br>node := &amp;Node&#123;key: key, value: value&#125;<br>head := l.root.next<br>head.prev = node<br>node.next = head<br>node.prev = l.root<br>l.root.next = node<br>l.<span class="hljs-built_in">len</span>++<br>node.list = l<br>&#125;<br><br><span class="hljs-comment">// debug for debug</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LRU)</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;lru len: &quot;</span>, l.<span class="hljs-built_in">len</span>)<br>fmt.Println(<span class="hljs-string">&quot;lru cap: &quot;</span>, l.<span class="hljs-built_in">cap</span>)<br><span class="hljs-keyword">for</span> n := l.root.next; n != l.root; n = n.next &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s:%v -&gt; &quot;</span>, n.key, n.value)<br>&#125;<br>fmt.Println()<br>fmt.Println()<br>&#125;<br></code></pre></td></tr></table></figure><p>单元测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> lru<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewLRU</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>l := NewLRU(<span class="hljs-number">3</span>)<br>assert.Equal(t, l.Get(<span class="hljs-string">&quot;&quot;</span>), <span class="hljs-literal">nil</span>)<br><br>l.Put(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">1</span>)<br>l.Put(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">2</span>)<br>l.Put(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-number">3</span>)<br>assert.Equal(t, <span class="hljs-number">3</span>, l.Get(<span class="hljs-string">&quot;3&quot;</span>))<br>assert.Equal(t, <span class="hljs-number">1</span>, l.Get(<span class="hljs-string">&quot;1&quot;</span>))<br><br>l.Put(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-number">4</span>)<br>assert.Equal(t, <span class="hljs-literal">nil</span>, l.Get(<span class="hljs-string">&quot;2&quot;</span>))<br><br>l.Put(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-number">31</span>)<br>assert.Equal(t, <span class="hljs-number">31</span>, l.Get(<span class="hljs-string">&quot;3&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><ul><li>前面讲到的 通过 Element 节点中的 List 结构来判断节点是否属于当前链表的方式，在某些情况下会出现 <code>bug</code>  你发现了么？</li><li>LRU 缓存可以参考 leetcode 进行测试，<a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a>，文中的 LRU 缓存实现有许多值得优化的地方，你认为有哪些可以优化的地方？</li><li>问题可以回复在评论区，将在下一篇文章中解答</li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>算法</tag>
      
      <tag>Go</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式24-总结(更新完毕)</title>
    <link href="/post/go-design-pattern.html"/>
    <url>/post/go-design-pattern.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 24/24 </strong>这是该系列的最后一篇文章啦，后续看情况可能会不定期补充一些实战的内容，但是正文就这么多了</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原本预计是在十月底更新完毕这个系列，到今天是 11-05，晚了几天，不过也还好，这是第一次这么密集的去更新博客上的内容，更多的是以笔记的形式来呈现，加上这篇一共 24 篇文章差不多两个半月的时间，平均每周输出两篇，感觉还是不错。后续可能会视情况不定期的更新一些实战内容，也有可能没有。接下来下一个系列应该是数据结构与算法，包含对 Go 中一些底层数据和标准库包的学习，例如 slice, sort 等等。</p><p>话说回来，回头再看学习设计模式我们究竟需要学习一些什么？</p><ul><li>写 Go 需要使用到设计模式么？<ul><li>需要，但是切记请勿使用其他语言的方式来写 Go</li><li>如果看过之前的一些文章，就会发现类似 JAVA 的这些面向对象语言中的某些设计模式的写法在 Go 中会十分的别扭</li><li>但是 Go 不需要设计模式么？不是的，设计模式的思想是想通的，并且我们一直都在使用，例如我们常见的对象创建方式 <code>NewXXX</code>  这其实就是一个简单工厂</li></ul></li><li>设计模式学习的重点是什么？<ul><li>设计原则，以及设计模式的使用场景和优缺点，实现相对来说还没有那么重要</li><li>如果是常见的设计模式是武术招式，那么设计原则就是内功心法，没有内功心法那么招式套路也就是花架子</li><li>熟练掌握不同设计模式的使用场景可以帮助我们学会见招拆招，灵活应用而不是只会套路</li></ul></li><li><strong>最后设计模式不是银弹，不要拿着 🔨 就觉得哪里都像是钉子，不要过早优化，持续重构才是正道</strong></li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><blockquote><p>同时这也是 Code Review 的重要标准之一</p></blockquote><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154616603-6328f638-0536-407e-afdf-7f2b33a97f91.jpeg" alt=""></p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154618733-bb131bea-bf76-4244-bb78-8bed8bfdddf1.jpeg" alt=""></p><h2 id="Go-设计模式"><a href="#Go-设计模式" class="headerlink" title="Go 设计模式"></a>Go 设计模式</h2><ul><li>单例模式包含饿汉式和懒汉式两种实现</li><li>工厂模式包含简单工厂、工厂方法、抽象工厂、DI 容器</li><li>代理模式包含静态代理、动态代理（采用 go generate 模拟）</li><li>观察者模式包含观察者模式、eventbus</li></ul><table><thead><tr><th style="text-align:center"><strong>类型</strong></th><th style="text-align:center"><strong>设计模式（Github）</strong></th><th style="text-align:center"><strong>常用</strong></th><th style="text-align:center"><strong>博客</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>创建型</strong></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/01_singleton">单例模式(Singleton Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/singleton.html">Go 设计模式 01-单例模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/02_factory">工厂模式(Factory Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/factory.html">Go 设计模式 02-工厂模式&amp;DI 容器</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/03_builder">建造者模式(Builder Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/builder.html">Go 设计模式 03-建造者模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/04_prototype">原型模式(Prototype Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/prototype.html">Go 设计模式 04-原型模式</a></td></tr><tr><td style="text-align:center"><strong>结构型</strong></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/05_proxy">代理模式(Proxy Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/proxy.html">Go 设计模式 06-代理模式(generate 实现类似动态代理)</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/06_bridge">桥接模式(Bridge Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/bridge.html">Go 设计模式 07-桥接模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/07_decorator">装饰器模式(Decorator Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/decorator.html">Go 设计模式 08-装饰器模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/08_adapter">适配器模式(Adapter Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/adapter.html">Go 设计模式 09-适配器模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/09_facade">门面模式(Facade Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/facade.html">Go 设计模式 10-门面模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/10_composite">组合模式(Composite Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/composite.html">Go 设计模式 11-组合模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/11_flyweight">享元模式(Flyweight Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/flyweight.html">Go 设计模式 12-享元模式</a></td></tr><tr><td style="text-align:center"><strong>行为型</strong></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/12_observer">观察者模式(Observer Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/observer.html">Go 设计模式 13-观察者模式(实现简单的 EventBus)</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/13_template">模板模式(Template Method Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/template.html">Go 模板模式 14-模板模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/14_strategy">策略模式(Strategy Method Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/strategy.html">Go 设计模式 15-策略模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/15_chain">职责链模式(Chain Of Responsibility Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/chain.html">Go 设计模式 16-职责链模式(Gin 的中间件实现)</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/16_state">状态模式(State Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/state.html">Go 设计模式 17-状态模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/17_iterator">迭代器模式(Iterator Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/iterator.html">Go 设计模式 18-迭代器模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/18_visitor/visitor.go">访问者模式(Visitor Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/visitor.html">Go 设计模式 19-访问者模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/19_memento">备忘录模式(Memento Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/memento.html">Go 设计模式 20-备忘录模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/20_command">命令模式(Command Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/command.html">Go 设计模式 21-命令模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/21_interpreter">解释器模式(Interpreter Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/interpreter.html">Go 设计模式 22-解释器模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/22_mediator">中介模式(Mediator Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/mediator.html">Go 设计模式 23-中介模式</a></td></tr></tbody></table><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式23-中介模式</title>
    <link href="/post/mediator.html"/>
    <url>/post/mediator.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/226710">73 | 中介模式：什么时候用中介模式？什么时候用观察者模式？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 23/24 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154460349-be763ff7-4247-4a3e-adaa-68da5146d4e9.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package mediator 中介模式</span><br><span class="hljs-comment">// 采用原课程的示例，并且做了一些裁剪</span><br><span class="hljs-comment">// 假设我们现在有一个较为复杂的对话框，里面包括，登录组件，注册组件，以及选择框</span><br><span class="hljs-comment">// 当选择框选择“登录”时，展示登录相关组件</span><br><span class="hljs-comment">// 当选择框选择“注册”时，展示注册相关组件</span><br><span class="hljs-keyword">package</span> mediator<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-comment">// Input 假设这表示一个输入框</span><br><span class="hljs-keyword">type</span> Input <span class="hljs-keyword">string</span><br><br><span class="hljs-comment">// String String</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i Input)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(i)<br>&#125;<br><br><span class="hljs-comment">// Selection 假设这表示一个选择框</span><br><span class="hljs-keyword">type</span> Selection <span class="hljs-keyword">string</span><br><br><span class="hljs-comment">// Selected 当前选中的对象</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Selection)</span> <span class="hljs-title">Selected</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(s)<br>&#125;<br><br><span class="hljs-comment">// Button 假设这表示一个按钮</span><br><span class="hljs-keyword">type</span> Button <span class="hljs-keyword">struct</span> &#123;<br>onClick <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">// SetOnClick 添加点击事件回调</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Button)</span> <span class="hljs-title">SetOnClick</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span> &#123;<br>b.onClick = f<br>&#125;<br><br><span class="hljs-comment">// IMediator 中介模式接口</span><br><span class="hljs-keyword">type</span> IMediator <span class="hljs-keyword">interface</span> &#123;<br>HandleEvent(component <span class="hljs-keyword">interface</span>&#123;&#125;)<br>&#125;<br><br><span class="hljs-comment">// Dialog 对话框组件</span><br><span class="hljs-keyword">type</span> Dialog <span class="hljs-keyword">struct</span> &#123;<br>LoginButton         *Button<br>RegButton           *Button<br>Selection           *Selection<br>UsernameInput       *Input<br>PasswordInput       *Input<br>RepeatPasswordInput *Input<br>&#125;<br><br><span class="hljs-comment">// HandleEvent HandleEvent</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dialog)</span> <span class="hljs-title">HandleEvent</span><span class="hljs-params">(component <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> reflect.DeepEqual(component, d.Selection):<br><span class="hljs-keyword">if</span> d.Selection.Selected() == <span class="hljs-string">&quot;登录&quot;</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;select login&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;show: %s\n&quot;</span>, d.UsernameInput)<br>fmt.Printf(<span class="hljs-string">&quot;show: %s\n&quot;</span>, d.PasswordInput)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> d.Selection.Selected() == <span class="hljs-string">&quot;注册&quot;</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;select register&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;show: %s\n&quot;</span>, d.UsernameInput)<br>fmt.Printf(<span class="hljs-string">&quot;show: %s\n&quot;</span>, d.PasswordInput)<br>fmt.Printf(<span class="hljs-string">&quot;show: %s\n&quot;</span>, d.RepeatPasswordInput)<br>&#125;<br><span class="hljs-comment">// others, 如果点击了登录按钮，注册按钮</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> mediator<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>usernameInput := Input(<span class="hljs-string">&quot;username input&quot;</span>)<br>passwordInput := Input(<span class="hljs-string">&quot;password input&quot;</span>)<br>repeatPwdInput := Input(<span class="hljs-string">&quot;repeat password input&quot;</span>)<br><br>selection := Selection(<span class="hljs-string">&quot;登录&quot;</span>)<br>d := &amp;Dialog&#123;<br>Selection:           &amp;selection,<br>UsernameInput:       &amp;usernameInput,<br>PasswordInput:       &amp;passwordInput,<br>RepeatPasswordInput: &amp;repeatPwdInput,<br>&#125;<br>d.HandleEvent(&amp;selection)<br><br>regSelection := Selection(<span class="hljs-string">&quot;注册&quot;</span>)<br>d.Selection = &amp;regSelection<br>d.HandleEvent(&amp;regSelection)<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>行为型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式22-解释器模式</title>
    <link href="/post/interpreter.html"/>
    <url>/post/interpreter.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/225904">72 | 解释器模式：如何设计实现一个自定义接口告警规则功能？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 22/24 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154449974-ca9fbc7c-7cbc-4753-ad43-776dedf33c3b.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package interpreter 解释器模式</span><br><span class="hljs-comment">// 采用原课程的示例, 并且做了一下简化</span><br><span class="hljs-comment">// 假设我们现在有一个监控系统</span><br><span class="hljs-comment">// 现在需要实现一个告警模块，可以根据输入的告警规则来决定是否触发告警</span><br><span class="hljs-comment">// 告警规则支持 &amp;&amp;、&gt;、&lt; 3种运算符</span><br><span class="hljs-comment">// 其中 &gt;、&lt; 优先级比  &amp;&amp; 更高</span><br><span class="hljs-keyword">package</span> interpreter<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;regexp&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-comment">// AlertRule 告警规则</span><br><span class="hljs-keyword">type</span> AlertRule <span class="hljs-keyword">struct</span> &#123;<br>expression IExpression<br>&#125;<br><br><span class="hljs-comment">// NewAlertRule NewAlertRule</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAlertRule</span><span class="hljs-params">(rule <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*AlertRule, error)</span></span> &#123;<br>exp, err := NewAndExpression(rule)<br><span class="hljs-keyword">return</span> &amp;AlertRule&#123;expression: exp&#125;, err<br>&#125;<br><br><span class="hljs-comment">// Interpret 判断告警是否触发</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r AlertRule)</span> <span class="hljs-title">Interpret</span><span class="hljs-params">(stats <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> r.expression.Interpret(stats)<br>&#125;<br><br><span class="hljs-comment">// IExpression 表达式接口</span><br><span class="hljs-keyword">type</span> IExpression <span class="hljs-keyword">interface</span> &#123;<br>Interpret(stats <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>) <span class="hljs-keyword">bool</span><br>&#125;<br><br><span class="hljs-comment">// GreaterExpression &gt;</span><br><span class="hljs-keyword">type</span> GreaterExpression <span class="hljs-keyword">struct</span> &#123;<br>key   <span class="hljs-keyword">string</span><br>value <span class="hljs-keyword">float64</span><br>&#125;<br><br><span class="hljs-comment">// Interpret Interpret</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g GreaterExpression)</span> <span class="hljs-title">Interpret</span><span class="hljs-params">(stats <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>v, ok := stats[g.key]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> v &gt; g.value<br>&#125;<br><br><span class="hljs-comment">// NewGreaterExpression NewGreaterExpression</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGreaterExpression</span><span class="hljs-params">(exp <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*GreaterExpression, error)</span></span> &#123;<br>data := regexp.MustCompile(<span class="hljs-string">`\s+`</span>).Split(strings.TrimSpace(exp), <span class="hljs-number">-1</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) != <span class="hljs-number">3</span> || data[<span class="hljs-number">1</span>] != <span class="hljs-string">&quot;&gt;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;exp is invalid: %s&quot;</span>, exp)<br>&#125;<br><br>val, err := strconv.ParseFloat(data[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;exp is invalid: %s&quot;</span>, exp)<br>&#125;<br><br><span class="hljs-keyword">return</span> &amp;GreaterExpression&#123;<br>key:   data[<span class="hljs-number">0</span>],<br>value: val,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// LessExpression &lt;</span><br><span class="hljs-keyword">type</span> LessExpression <span class="hljs-keyword">struct</span> &#123;<br>key   <span class="hljs-keyword">string</span><br>value <span class="hljs-keyword">float64</span><br>&#125;<br><br><span class="hljs-comment">// Interpret Interpret</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g LessExpression)</span> <span class="hljs-title">Interpret</span><span class="hljs-params">(stats <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>v, ok := stats[g.key]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> v &lt; g.value<br>&#125;<br><br><span class="hljs-comment">// NewLessExpression NewLessExpression</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLessExpression</span><span class="hljs-params">(exp <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*LessExpression, error)</span></span> &#123;<br>data := regexp.MustCompile(<span class="hljs-string">`\s+`</span>).Split(strings.TrimSpace(exp), <span class="hljs-number">-1</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) != <span class="hljs-number">3</span> || data[<span class="hljs-number">1</span>] != <span class="hljs-string">&quot;&lt;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;exp is invalid: %s&quot;</span>, exp)<br>&#125;<br><br>val, err := strconv.ParseFloat(data[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;exp is invalid: %s&quot;</span>, exp)<br>&#125;<br><br><span class="hljs-keyword">return</span> &amp;LessExpression&#123;<br>key:   data[<span class="hljs-number">0</span>],<br>value: val,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// AndExpression &amp;&amp;</span><br><span class="hljs-keyword">type</span> AndExpression <span class="hljs-keyword">struct</span> &#123;<br>expressions []IExpression<br>&#125;<br><br><span class="hljs-comment">// Interpret Interpret</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e AndExpression)</span> <span class="hljs-title">Interpret</span><span class="hljs-params">(stats <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">for</span> _, expression := <span class="hljs-keyword">range</span> e.expressions &#123;<br><span class="hljs-keyword">if</span> !expression.Interpret(stats) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// NewAndExpression NewAndExpression</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAndExpression</span><span class="hljs-params">(exp <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*AndExpression, error)</span></span> &#123;<br>exps := strings.Split(exp, <span class="hljs-string">&quot;&amp;&amp;&quot;</span>)<br>expressions := <span class="hljs-built_in">make</span>([]IExpression, <span class="hljs-built_in">len</span>(exps))<br><br><span class="hljs-keyword">for</span> i, e := <span class="hljs-keyword">range</span> exps &#123;<br><span class="hljs-keyword">var</span> expression IExpression<br><span class="hljs-keyword">var</span> err error<br><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> strings.Contains(e, <span class="hljs-string">&quot;&gt;&quot;</span>):<br>expression, err = NewGreaterExpression(e)<br><span class="hljs-keyword">case</span> strings.Contains(e, <span class="hljs-string">&quot;&lt;&quot;</span>):<br>expression, err = NewLessExpression(e)<br><span class="hljs-keyword">default</span>:<br>err = fmt.Errorf(<span class="hljs-string">&quot;exp is invalid: %s&quot;</span>, exp)<br>&#125;<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>expressions[i] = expression<br>&#125;<br><br><span class="hljs-keyword">return</span> &amp;AndExpression&#123;expressions: expressions&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> interpreter<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br><span class="hljs-string">&quot;github.com/stretchr/testify/require&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAlertRule_Interpret</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>stats := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>&#123;<br><span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>,<br><span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-string">&quot;c&quot;</span>: <span class="hljs-number">3</span>,<br>&#125;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name  <span class="hljs-keyword">string</span><br>stats <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span><br>rule  <span class="hljs-keyword">string</span><br>want  <span class="hljs-keyword">bool</span><br>&#125;&#123;<br>&#123;<br>name:  <span class="hljs-string">&quot;case1&quot;</span>,<br>stats: stats,<br>rule:  <span class="hljs-string">&quot;a &gt; 1 &amp;&amp; b &gt; 10 &amp;&amp; c &lt; 5&quot;</span>,<br>want:  <span class="hljs-literal">false</span>,<br>&#125;,<br>&#123;<br>name:  <span class="hljs-string">&quot;case2&quot;</span>,<br>stats: stats,<br>rule:  <span class="hljs-string">&quot;a &lt; 2 &amp;&amp; b &gt; 10 &amp;&amp; c &lt; 5&quot;</span>,<br>want:  <span class="hljs-literal">false</span>,<br>&#125;,<br>&#123;<br>name:  <span class="hljs-string">&quot;case3&quot;</span>,<br>stats: stats,<br>rule:  <span class="hljs-string">&quot;a &lt; 5 &amp;&amp; b &gt; 1 &amp;&amp; c &lt; 10&quot;</span>,<br>want:  <span class="hljs-literal">false</span>,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>r, err := NewAlertRule(tt.rule)<br>require.NoError(t, err)<br>assert.Equal(t, tt.want, r.Interpret(tt.stats))<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>行为型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式21-命令模式</title>
    <link href="/post/command.html"/>
    <url>/post/command.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/224549">71 | 命令模式：如何利用命令模式实现一个手游后端架构？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 21/24 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154439561-d9919c73-0afb-467d-bd0b-70708362b923.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>接下来会有两个例子，第一个是按照原文定义的方式，将函数封装成对象，第二个例子我们直接将函数作为参数传递。</p><h3 id="将函数封装为对象"><a href="#将函数封装为对象" class="headerlink" title="将函数封装为对象"></a>将函数封装为对象</h3><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package command 命令模式</span><br><span class="hljs-comment">// Blog: https://lailin.xyz/post/command.html</span><br><span class="hljs-comment">// 这是示例一，采用将函数封装为对象的方式实现，</span><br><span class="hljs-comment">// 示例说明:</span><br><span class="hljs-comment">// 假设现在有一个游戏服务，我们正在实现一个游戏后端</span><br><span class="hljs-comment">// 使用一个 goroutine 不断接收来自客户端请求的命令，并且将它放置到一个队列当中</span><br><span class="hljs-comment">// 然后我们在另外一个 goroutine 中来执行它</span><br><span class="hljs-keyword">package</span> command<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// ICommand 命令</span><br><span class="hljs-keyword">type</span> ICommand <span class="hljs-keyword">interface</span> &#123;<br>Execute() error<br>&#125;<br><br><span class="hljs-comment">// StartCommand 游戏开始运行</span><br><span class="hljs-keyword">type</span> StartCommand <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// NewStartCommand NewStartCommand</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStartCommand</span><span class="hljs-params">( /*正常情况下这里会有一些参数*/ )</span> *<span class="hljs-title">StartCommand</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;StartCommand&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// Execute Execute</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *StartCommand)</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;game start&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// ArchiveCommand 游戏存档</span><br><span class="hljs-keyword">type</span> ArchiveCommand <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// NewArchiveCommand NewArchiveCommand</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewArchiveCommand</span><span class="hljs-params">( /*正常情况下这里会有一些参数*/ )</span> *<span class="hljs-title">ArchiveCommand</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;ArchiveCommand&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// Execute Execute</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ArchiveCommand)</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;game archive&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> command<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-comment">// 用于测试，模拟来自客户端的事件</span><br>eventChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>events := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;archive&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;archive&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>&#125;<br><span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> events &#123;<br>eventChan &lt;- e<br>&#125;<br>&#125;()<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(eventChan)<br><br><span class="hljs-comment">// 使用命令队列缓存命令</span><br>commands := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> ICommand, <span class="hljs-number">1000</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(commands)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 从请求或者其他地方获取相关事件参数</span><br>event, ok := &lt;-eventChan<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">var</span> command ICommand<br><span class="hljs-keyword">switch</span> event &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;start&quot;</span>:<br>command = NewStartCommand()<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;archive&quot;</span>:<br>command = NewArchiveCommand()<br>&#125;<br><br><span class="hljs-comment">// 将命令入队</span><br>commands &lt;- command<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> c := &lt;-commands:<br>c.Execute()<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">1</span> * time.Second):<br>fmt.Println(<span class="hljs-string">&quot;timeout 1s&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="将函数直接作为参数"><a href="#将函数直接作为参数" class="headerlink" title="将函数直接作为参数"></a>将函数直接作为参数</h3><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package command 命令模式</span><br><span class="hljs-comment">// Blog: https://lailin.xyz/post/command.html</span><br><span class="hljs-comment">// 这是示例二，采用将直接返回一个函数，不用对象</span><br><span class="hljs-comment">// 示例说明:</span><br><span class="hljs-comment">// 假设现在有一个游戏服务，我们正在实现一个游戏后端</span><br><span class="hljs-comment">// 使用一个 goroutine 不断接收来自客户端请求的命令，并且将它放置到一个队列当中</span><br><span class="hljs-comment">// 然后我们在另外一个 goroutine 中来执行它</span><br><span class="hljs-keyword">package</span> command<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// Command 命令</span><br><span class="hljs-keyword">type</span> Command <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span><br><br><span class="hljs-comment">// StartCommandFunc 返回一个 Command 命令</span><br><span class="hljs-comment">// 是因为正常情况下不会是这么简单的函数</span><br><span class="hljs-comment">// 一般都会有一些参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StartCommandFunc</span><span class="hljs-params">()</span> <span class="hljs-title">Command</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;game start&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// ArchiveCommandFunc ArchiveCommandFunc</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ArchiveCommandFunc</span><span class="hljs-params">()</span> <span class="hljs-title">Command</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;game archive&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> command<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemoFunc</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-comment">// 用于测试，模拟来自客户端的事件</span><br>eventChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>events := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;archive&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;archive&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>&#125;<br><span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> events &#123;<br>eventChan &lt;- e<br>&#125;<br><br>&#125;()<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(eventChan)<br><br><span class="hljs-comment">// 使用命令队列缓存命令</span><br>commands := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Command, <span class="hljs-number">1000</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(commands)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 从请求或者其他地方获取相关事件参数</span><br>event, ok := &lt;-eventChan<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">var</span> command Command<br><span class="hljs-keyword">switch</span> event &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;start&quot;</span>:<br>command = StartCommandFunc()<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;archive&quot;</span>:<br>command = ArchiveCommandFunc()<br>&#125;<br><br><span class="hljs-comment">// 将命令入队</span><br>commands &lt;- command<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> c := &lt;-commands:<br>c()<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">1</span> * time.Second):<br>fmt.Println(<span class="hljs-string">&quot;timeout 1s&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>行为型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式20-备忘录模式</title>
    <link href="/post/memento.html"/>
    <url>/post/memento.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/223947">70 | 备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 20/24 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154429386-ecc22950-5378-4064-a658-109b323a3a0f.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package memento 备忘录模式</span><br><span class="hljs-comment">// 下面这个例子采用原课程的例子，一个输入程序</span><br><span class="hljs-comment">// 如果输入 :list 则显示当前保存的内容</span><br><span class="hljs-comment">// 如果输入 :undo 则删除上一次的输入</span><br><span class="hljs-comment">// 如果输入其他的内容则追加保存</span><br><span class="hljs-keyword">package</span> memento<br><br><span class="hljs-comment">// InputText 用于保存数据</span><br><span class="hljs-keyword">type</span> InputText <span class="hljs-keyword">struct</span> &#123;<br>content <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// Append 追加数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *InputText)</span> <span class="hljs-title">Append</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>)</span></span> &#123;<br>in.content += content<br>&#125;<br><br><span class="hljs-comment">// GetText 获取数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *InputText)</span> <span class="hljs-title">GetText</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> in.content<br>&#125;<br><br><span class="hljs-comment">// Snapshot 创建快照</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *InputText)</span> <span class="hljs-title">Snapshot</span><span class="hljs-params">()</span> *<span class="hljs-title">Snapshot</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;Snapshot&#123;content: in.content&#125;<br>&#125;<br><br><span class="hljs-comment">// Restore 从快照中恢复</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *InputText)</span> <span class="hljs-title">Restore</span><span class="hljs-params">(s *Snapshot)</span></span> &#123;<br>in.content = s.GetText()<br>&#125;<br><br><span class="hljs-comment">// Snapshot 快照，用于存储数据快照</span><br><span class="hljs-comment">// 对于快照来说，只能不能被外部（不同包）修改，只能获取数据，满足封装的特性</span><br><span class="hljs-keyword">type</span> Snapshot <span class="hljs-keyword">struct</span> &#123;<br>content <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// GetText GetText</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Snapshot)</span> <span class="hljs-title">GetText</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> s.content<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> memento<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>in := &amp;InputText&#123;&#125;<br>snapshots := []*Snapshot&#123;&#125;<br><br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>input <span class="hljs-keyword">string</span><br>want  <span class="hljs-keyword">string</span><br>&#125;&#123;<br>&#123;<br>input: <span class="hljs-string">&quot;:list&quot;</span>,<br>want:  <span class="hljs-string">&quot;&quot;</span>,<br>&#125;,<br>&#123;<br>input: <span class="hljs-string">&quot;hello&quot;</span>,<br>want:  <span class="hljs-string">&quot;&quot;</span>,<br>&#125;,<br>&#123;<br>input: <span class="hljs-string">&quot;:list&quot;</span>,<br>want:  <span class="hljs-string">&quot;hello&quot;</span>,<br>&#125;,<br>&#123;<br>input: <span class="hljs-string">&quot;world&quot;</span>,<br>want:  <span class="hljs-string">&quot;&quot;</span>,<br>&#125;,<br>&#123;<br>input: <span class="hljs-string">&quot;:list&quot;</span>,<br>want:  <span class="hljs-string">&quot;helloworld&quot;</span>,<br>&#125;,<br>&#123;<br>input: <span class="hljs-string">&quot;:undo&quot;</span>,<br>want:  <span class="hljs-string">&quot;&quot;</span>,<br>&#125;,<br>&#123;<br>input: <span class="hljs-string">&quot;:list&quot;</span>,<br>want:  <span class="hljs-string">&quot;hello&quot;</span>,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.input, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">switch</span> tt.input &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;:list&quot;</span>:<br>assert.Equal(t, tt.want, in.GetText())<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;:undo&quot;</span>:<br>in.Restore(snapshots[<span class="hljs-built_in">len</span>(snapshots)<span class="hljs-number">-1</span>])<br>snapshots = snapshots[:<span class="hljs-built_in">len</span>(snapshots)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">default</span>:<br>snapshots = <span class="hljs-built_in">append</span>(snapshots, in.Snapshot())<br>in.Append(tt.input)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>行为型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式19-访问者模式</title>
    <link href="/post/visitor.html"/>
    <url>/post/visitor.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/221852">68 | 访问者模式（上）：手把手带你还原访问者模式诞生的思维过程</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 19/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154416485-f2ea2728-3c85-49e3-99e5-1058c9a9f062.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>原课程中讲解访问者模式的时候用到了继承和函数重载这两个 Go 中没有的特性，接下来的呢，会通过继承实现。<br><strong>注意由于没有函数重载，所以我们并不知道传递过来的对象是什么类型，这个时候只能采用类型断言的方式来对不同的类型做不同的操作，但是正式由于没有函数重载，所以其实完全可以不用访问者模式直接传入参数就好了。</strong><br>以前我们经常说不要用写其他语言的方式来写 Go，Go 不需要太多的设计模式，这个就是一个比较鲜明的例子</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> visitor<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;path&quot;</span><br>)<br><br><span class="hljs-comment">// Visitor 访问者</span><br><span class="hljs-keyword">type</span> Visitor <span class="hljs-keyword">interface</span> &#123;<br>Visit(IResourceFile) error<br>&#125;<br><br><span class="hljs-comment">// IResourceFile IResourceFile</span><br><span class="hljs-keyword">type</span> IResourceFile <span class="hljs-keyword">interface</span> &#123;<br>Accept(Visitor) error<br>&#125;<br><br><span class="hljs-comment">// NewResourceFile NewResourceFile</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewResourceFile</span><span class="hljs-params">(filepath <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(IResourceFile, error)</span></span> &#123;<br><span class="hljs-keyword">switch</span> path.Ext(filepath) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;.ppt&quot;</span>:<br><span class="hljs-keyword">return</span> &amp;PPTFile&#123;path: filepath&#125;, <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;.pdf&quot;</span>:<br><span class="hljs-keyword">return</span> &amp;PdfFile&#123;path: filepath&#125;, <span class="hljs-literal">nil</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;not found file type: %s&quot;</span>, filepath)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// PdfFile PdfFile</span><br><span class="hljs-keyword">type</span> PdfFile <span class="hljs-keyword">struct</span> &#123;<br>path <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// Accept Accept</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *PdfFile)</span> <span class="hljs-title">Accept</span><span class="hljs-params">(visitor Visitor)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> visitor.Visit(f)<br>&#125;<br><br><span class="hljs-comment">// PPTFile PPTFile</span><br><span class="hljs-keyword">type</span> PPTFile <span class="hljs-keyword">struct</span> &#123;<br>path <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// Accept Accept</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *PPTFile)</span> <span class="hljs-title">Accept</span><span class="hljs-params">(visitor Visitor)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> visitor.Visit(f)<br>&#125;<br><br><span class="hljs-comment">// Compressor 实现压缩功能</span><br><span class="hljs-keyword">type</span> Compressor <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Visit 实现访问者模式方法</span><br><span class="hljs-comment">// 我们可以发现由于没有函数重载，我们只能通过断言来根据不同的类型调用不同函数</span><br><span class="hljs-comment">// 但是我们即使不采用访问者模式，我们其实也是可以这么操作的</span><br><span class="hljs-comment">// 并且由于采用了类型断言，所以如果需要操作的对象比较多的话，这个函数其实也会膨胀的比较厉害</span><br><span class="hljs-comment">// 后续可以考虑按照命名约定使用 generate 自动生成代码</span><br><span class="hljs-comment">// 或者是使用反射简化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Compressor)</span> <span class="hljs-title">Visit</span><span class="hljs-params">(r IResourceFile)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">switch</span> f := r.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *PPTFile:<br><span class="hljs-keyword">return</span> c.VisitPPTFile(f)<br><span class="hljs-keyword">case</span> *PdfFile:<br><span class="hljs-keyword">return</span> c.VisitPDFFile(f)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;not found resource typr: %#v&quot;</span>, r)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// VisitPPTFile VisitPPTFile</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Compressor)</span> <span class="hljs-title">VisitPPTFile</span><span class="hljs-params">(f *PPTFile)</span> <span class="hljs-title">error</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;this is ppt file&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// VisitPDFFile VisitPDFFile</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Compressor)</span> <span class="hljs-title">VisitPDFFile</span><span class="hljs-params">(f *PdfFile)</span> <span class="hljs-title">error</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;this is pdf file&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> visitor<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/require&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCompressor_Visit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name    <span class="hljs-keyword">string</span><br>path    <span class="hljs-keyword">string</span><br>wantErr <span class="hljs-keyword">string</span><br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;pdf&quot;</span>,<br>path: <span class="hljs-string">&quot;./xx.pdf&quot;</span>,<br>&#125;,<br>&#123;<br>name: <span class="hljs-string">&quot;ppt&quot;</span>,<br>path: <span class="hljs-string">&quot;./xx.ppt&quot;</span>,<br>&#125;,<br>&#123;<br>name:    <span class="hljs-string">&quot;404&quot;</span>,<br>path:    <span class="hljs-string">&quot;./xx.xx&quot;</span>,<br>wantErr: <span class="hljs-string">&quot;not found file type&quot;</span>,<br>&#125;,<br>&#125;<br><br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>f, err := NewResourceFile(tt.path)<br><span class="hljs-keyword">if</span> tt.wantErr != <span class="hljs-string">&quot;&quot;</span> &#123;<br>require.Error(t, err)<br>require.Contains(t, err.Error(), tt.wantErr)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>require.NoError(t, err)<br>compressor := &amp;Compressor&#123;&#125;<br>f.Accept(compressor)<br>&#125;)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 不用 Accept 其实也是可以的</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCompressor_Visit2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name    <span class="hljs-keyword">string</span><br>path    <span class="hljs-keyword">string</span><br>wantErr <span class="hljs-keyword">string</span><br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;pdf&quot;</span>,<br>path: <span class="hljs-string">&quot;./xx.pdf&quot;</span>,<br>&#125;,<br>&#123;<br>name: <span class="hljs-string">&quot;ppt&quot;</span>,<br>path: <span class="hljs-string">&quot;./xx.ppt&quot;</span>,<br>&#125;,<br>&#123;<br>name:    <span class="hljs-string">&quot;404&quot;</span>,<br>path:    <span class="hljs-string">&quot;./xx.xx&quot;</span>,<br>wantErr: <span class="hljs-string">&quot;not found file type&quot;</span>,<br>&#125;,<br>&#125;<br><br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>f, err := NewResourceFile(tt.path)<br><span class="hljs-keyword">if</span> tt.wantErr != <span class="hljs-string">&quot;&quot;</span> &#123;<br>require.Error(t, err)<br>require.Contains(t, err.Error(), tt.wantErr)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>require.NoError(t, err)<br>compressor := &amp;Compressor&#123;&#125;<br>compressor.Visit(f)<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>行为型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式18-迭代器模式</title>
    <link href="/post/iterator.html"/>
    <url>/post/iterator.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/219290">65 | 迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些优势？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 18/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154405094-ece2ac1d-0998-404e-8b2c-d4d897eea149.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面是一个简单的自定义数组类型的例子</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> iterator<br><br><span class="hljs-comment">// Iterator 迭代器接口</span><br><span class="hljs-keyword">type</span> Iterator <span class="hljs-keyword">interface</span> &#123;<br>HasNext() <span class="hljs-keyword">bool</span><br>Next()<br><span class="hljs-comment">// 获取当前元素，由于 Go 1.15 中还没有泛型，所以我们直接返回 interface&#123;&#125;</span><br>CurrentItem() <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// ArrayInt 数组</span><br><span class="hljs-keyword">type</span> ArrayInt []<span class="hljs-keyword">int</span><br><br><span class="hljs-comment">// Iterator 返回迭代器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a ArrayInt)</span> <span class="hljs-title">Iterator</span><span class="hljs-params">()</span> <span class="hljs-title">Iterator</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;ArrayIntIterator&#123;<br>arrayInt: a,<br>index:    <span class="hljs-number">0</span>,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// ArrayIntIterator 数组迭代</span><br><span class="hljs-keyword">type</span> ArrayIntIterator <span class="hljs-keyword">struct</span> &#123;<br>arrayInt ArrayInt<br>index    <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// HasNext 是否有下一个</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iter *ArrayIntIterator)</span> <span class="hljs-title">HasNext</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> iter.index &lt; <span class="hljs-built_in">len</span>(iter.arrayInt)<span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-comment">// Next 游标加一</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iter *ArrayIntIterator)</span> <span class="hljs-title">Next</span><span class="hljs-params">()</span></span> &#123;<br>iter.index++<br>&#125;<br><br><span class="hljs-comment">// CurrentItem 获取当前元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iter *ArrayIntIterator)</span> <span class="hljs-title">CurrentItem</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> iter.arrayInt[iter.index]<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> iterator<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestArrayInt_Iterator</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>data := ArrayInt&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;<br>iterator := data.Iterator()<br><span class="hljs-comment">// i 用于测试</span><br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> iterator.HasNext() &#123;<br>assert.Equal(t, data[i], iterator.CurrentItem())<br>iterator.Next()<br>i++<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>行为型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式17-状态模式</title>
    <link href="/post/state.html"/>
    <url>/post/state.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/218375">64 | 状态模式：游戏、工作流引擎中常用的状态机是如何实现的？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 17/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154394191-56852903-913e-4937-a049-f5d0d832841b.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>通过下面的例子可以发现，引入状态模式来写状态机会有引入比较多的结构体，并且改动代码的时候如果要新增或者是删除某一个状态的话，修改也需要在其他状态的结构体方法中修改，所以这个不太适合状态经常变更或者是状态很多的情况</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package state 状态模式</span><br><span class="hljs-comment">// 笔记请查看: https://lailin.xyz/state.html</span><br><span class="hljs-comment">// 这是一个工作流的例子，在企业内部或者是学校我们经常会看到很多审批流程</span><br><span class="hljs-comment">// 假设我们有一个报销的流程: 员工提交报销申请 -&gt; 直属部门领导审批 -&gt; 财务审批 -&gt; 结束</span><br><span class="hljs-comment">// 在这个审批流中，处在不同的环节就是不同的状态</span><br><span class="hljs-comment">// 而流程的审批、驳回就是不同的事件</span><br><span class="hljs-keyword">package</span> state<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// Machine 状态机</span><br><span class="hljs-keyword">type</span> Machine <span class="hljs-keyword">struct</span> &#123;<br>state IState<br>&#125;<br><br><span class="hljs-comment">// SetState 更新状态</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Machine)</span> <span class="hljs-title">SetState</span><span class="hljs-params">(state IState)</span></span> &#123;<br>m.state = state<br>&#125;<br><br><span class="hljs-comment">// GetStateName 获取当前状态</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Machine)</span> <span class="hljs-title">GetStateName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> m.state.GetName()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Machine)</span> <span class="hljs-title">Approval</span><span class="hljs-params">()</span></span> &#123;<br>m.state.Approval(m)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Machine)</span> <span class="hljs-title">Reject</span><span class="hljs-params">()</span></span> &#123;<br>m.state.Reject(m)<br>&#125;<br><br><span class="hljs-comment">// IState 状态</span><br><span class="hljs-keyword">type</span> IState <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// 审批通过</span><br>Approval(m *Machine)<br><span class="hljs-comment">// 驳回</span><br>Reject(m *Machine)<br><span class="hljs-comment">// 获取当前状态名称</span><br>GetName() <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// leaderApproveState 直属领导审批</span><br><span class="hljs-keyword">type</span> leaderApproveState <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Approval 获取状态名字</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(leaderApproveState)</span> <span class="hljs-title">Approval</span><span class="hljs-params">(m *Machine)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;leader 审批成功&quot;</span>)<br>m.SetState(GetFinanceApproveState())<br>&#125;<br><br><span class="hljs-comment">// GetName 获取状态名字</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(leaderApproveState)</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;LeaderApproveState&quot;</span><br>&#125;<br><br><span class="hljs-comment">// Reject 获取状态名字</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(leaderApproveState)</span> <span class="hljs-title">Reject</span><span class="hljs-params">(m *Machine)</span></span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetLeaderApproveState</span><span class="hljs-params">()</span> <span class="hljs-title">IState</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;leaderApproveState&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// financeApproveState 财务审批</span><br><span class="hljs-keyword">type</span> financeApproveState <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Approval 审批通过</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f financeApproveState)</span> <span class="hljs-title">Approval</span><span class="hljs-params">(m *Machine)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;财务审批成功&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;出发打款操作&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 拒绝</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f financeApproveState)</span> <span class="hljs-title">Reject</span><span class="hljs-params">(m *Machine)</span></span> &#123;<br>m.SetState(GetLeaderApproveState())<br>&#125;<br><br><span class="hljs-comment">// GetName 获取名字</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f financeApproveState)</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FinanceApproveState&quot;</span><br>&#125;<br><br><span class="hljs-comment">// GetFinanceApproveState GetFinanceApproveState</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetFinanceApproveState</span><span class="hljs-params">()</span> <span class="hljs-title">IState</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;financeApproveState&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> state<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMachine_GetStateName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>m := &amp;Machine&#123;state: GetLeaderApproveState()&#125;<br>assert.Equal(t, <span class="hljs-string">&quot;LeaderApproveState&quot;</span>, m.GetStateName())<br>m.Approval()<br>assert.Equal(t, <span class="hljs-string">&quot;FinanceApproveState&quot;</span>, m.GetStateName())<br>m.Reject()<br>assert.Equal(t, <span class="hljs-string">&quot;LeaderApproveState&quot;</span>, m.GetStateName())<br>m.Approval()<br>assert.Equal(t, <span class="hljs-string">&quot;FinanceApproveState&quot;</span>, m.GetStateName())<br>m.Approval()<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>行为型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式16-职责链模式(Gin的中间件实现)</title>
    <link href="/post/chain.html"/>
    <url>/post/chain.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/216278">62 | 职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框架？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 16/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154384873-d9ff58d7-c0f7-49af-90d4-26e8e256e504.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先我们看一下一个简单的实现模板，然后我们再看看实际上我们常用 web 框架 gin 当中是如何处理请求的</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package chain 职责链模式</span><br><span class="hljs-comment">// 🌰 假设我们现在有个校园论坛，由于社区规章制度、广告、法律法规的原因需要对用户的发言进行敏感词过滤</span><br><span class="hljs-comment">//    如果被判定为敏感词，那么这篇帖子将会被封禁</span><br><span class="hljs-keyword">package</span> chain<br><br><span class="hljs-comment">// SensitiveWordFilter 敏感词过滤器，判定是否是敏感词</span><br><span class="hljs-keyword">type</span> SensitiveWordFilter <span class="hljs-keyword">interface</span> &#123;<br>Filter(content <span class="hljs-keyword">string</span>) <span class="hljs-keyword">bool</span><br>&#125;<br><br><span class="hljs-comment">// SensitiveWordFilterChain 职责链</span><br><span class="hljs-keyword">type</span> SensitiveWordFilterChain <span class="hljs-keyword">struct</span> &#123;<br>filters []SensitiveWordFilter<br>&#125;<br><br><span class="hljs-comment">// AddFilter 添加一个过滤器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *SensitiveWordFilterChain)</span> <span class="hljs-title">AddFilter</span><span class="hljs-params">(filter SensitiveWordFilter)</span></span> &#123;<br>c.filters = <span class="hljs-built_in">append</span>(c.filters, filter)<br>&#125;<br><br><span class="hljs-comment">// Filter 执行过滤</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *SensitiveWordFilterChain)</span> <span class="hljs-title">Filter</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">for</span> _, filter := <span class="hljs-keyword">range</span> c.filters &#123;<br><span class="hljs-comment">// 如果发现敏感直接返回结果</span><br><span class="hljs-keyword">if</span> filter.Filter(content) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// AdSensitiveWordFilter 广告</span><br><span class="hljs-keyword">type</span> AdSensitiveWordFilter <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Filter 实现过滤算法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *AdSensitiveWordFilter)</span> <span class="hljs-title">Filter</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 实现算法</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// PoliticalWordFilter 政治敏感</span><br><span class="hljs-keyword">type</span> PoliticalWordFilter <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Filter 实现过滤算法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *PoliticalWordFilter)</span> <span class="hljs-title">Filter</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 实现算法</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> chain<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSensitiveWordFilterChain_Filter</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>chain := &amp;SensitiveWordFilterChain&#123;&#125;<br>chain.AddFilter(&amp;AdSensitiveWordFilter&#123;&#125;)<br>assert.Equal(t, <span class="hljs-literal">false</span>, chain.Filter(<span class="hljs-string">&quot;test&quot;</span>))<br><br>chain.AddFilter(&amp;PoliticalWordFilter&#123;&#125;)<br>assert.Equal(t, <span class="hljs-literal">true</span>, chain.Filter(<span class="hljs-string">&quot;test&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Gin-的中间件实现"><a href="#Gin-的中间件实现" class="headerlink" title="Gin 的中间件实现"></a>Gin 的中间件实现</h3><p>我们直接看一下 <code>gin Context</code>  的实现，其中 <code>Next()</code>  方法就是主要的执行方法，这里其实就是我们最上面说到的职责链模式的变体，因为它会在每一个处理函数中进行处理，而不是第一个接收到就停止了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// handlers 是一个包含执行函数的数组</span><br>    <span class="hljs-comment">// type HandlersChain []HandlerFunc</span><br>handlers HandlersChain<br>    <span class="hljs-comment">// index 表示当前执行到哪个位置了</span><br>index    <span class="hljs-keyword">int8</span><br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// Next 会按照顺序将一个个中间件执行完毕</span><br><span class="hljs-comment">// 并且 Next 也可以在中间件中进行调用，达到请求前以及请求后的处理</span><br><span class="hljs-comment">// Next should be used only inside middleware.</span><br><span class="hljs-comment">// It executes the pending handlers in the chain inside the calling handler.</span><br><span class="hljs-comment">// See example in GitHub.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span> <span class="hljs-title">Next</span><span class="hljs-params">()</span></span> &#123;<br>c.index++<br><span class="hljs-keyword">for</span> c.index &lt; <span class="hljs-keyword">int8</span>(<span class="hljs-built_in">len</span>(c.handlers)) &#123;<br>c.handlers[c.index](c)<br>c.index++<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>行为型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式15-策略模式</title>
    <link href="/post/strategy.html"/>
    <url>/post/strategy.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/214014">60 | 策略模式（上）：如何避免冗长的 if-else/switch 分支判断代码？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 15/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154375192-13015b66-5328-4c36-a494-9e083de2021b.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>来个 🌰，我们在保存文件的时候，由于政策或者其他的原因可能需要选择不同的存储方式，敏感数据我们需要加密存储，不敏感的数据我们可以直接明文保存。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> strategy<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">// StorageStrategy 存储策略</span><br><span class="hljs-keyword">type</span> StorageStrategy <span class="hljs-keyword">interface</span> &#123;<br>Save(name <span class="hljs-keyword">string</span>, data []<span class="hljs-keyword">byte</span>) error<br>&#125;<br><br><span class="hljs-keyword">var</span> strategys = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]StorageStrategy&#123;<br><span class="hljs-string">&quot;file&quot;</span>:         &amp;fileStorage&#123;&#125;,<br><span class="hljs-string">&quot;encrypt_file&quot;</span>: &amp;encryptFileStorage&#123;&#125;,<br>&#125;<br><br><span class="hljs-comment">// NewStorageStrategy NewStorageStrategy</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStorageStrategy</span><span class="hljs-params">(t <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(StorageStrategy, error)</span></span> &#123;<br>s, ok := strategys[t]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;not found StorageStrategy: %s&quot;</span>, t)<br>&#125;<br><br><span class="hljs-keyword">return</span> s, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// FileStorage 保存到文件</span><br><span class="hljs-keyword">type</span> fileStorage <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Save Save</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *fileStorage)</span> <span class="hljs-title">Save</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> ioutil.WriteFile(name, data, os.ModeAppend)<br>&#125;<br><br><span class="hljs-comment">// encryptFileStorage 加密保存到文件</span><br><span class="hljs-keyword">type</span> encryptFileStorage <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Save Save</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *encryptFileStorage)</span> <span class="hljs-title">Save</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-comment">// 加密</span><br>data, err := encrypt(data)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">return</span> ioutil.WriteFile(name, data, os.ModeAppend)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">encrypt</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<br><span class="hljs-comment">// 这里实现加密算法</span><br><span class="hljs-keyword">return</span> data, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> strategy<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_demo</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-comment">// 假设这里获取数据，以及数据是否敏感</span><br>data, sensitive := getData()<br>strategyType := <span class="hljs-string">&quot;file&quot;</span><br><span class="hljs-keyword">if</span> sensitive &#123;<br>strategyType = <span class="hljs-string">&quot;encrypt_file&quot;</span><br>&#125;<br><br>storage, err := NewStorageStrategy(strategyType)<br>assert.NoError(t, err)<br>assert.NoError(t, storage.Save(<span class="hljs-string">&quot;./test.txt&quot;</span>, data))<br>&#125;<br><br><span class="hljs-comment">// getData 获取数据的方法</span><br><span class="hljs-comment">// 返回数据，以及数据是否敏感</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, <span class="hljs-keyword">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;test data&quot;</span>), <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>行为型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go模板模式14-模板模式</title>
    <link href="/post/template.html"/>
    <url>/post/template.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/212049">58 | 模板模式（上）：剖析模板模式在 JDK、Servlet、JUnit 等中的应用</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 14/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154364395-c5c6468a-ba2c-4a51-bea4-3bcf1fe87d0d.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>举个 🌰，假设我现在要做一个短信推送的系统，那么需要</p><ol><li>检查短信字数是否超过限制</li><li>检查手机号是否正确</li><li>发送短信</li><li>返回状态</li></ol><p>我们可以发现，在发送短信的时候由于不同的供应商调用的接口不同，所以会有一些实现上的差异，但是他的算法（业务逻辑）是固定的</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> template<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// ISMS ISMS</span><br><span class="hljs-keyword">type</span> ISMS <span class="hljs-keyword">interface</span> &#123;<br>send(content <span class="hljs-keyword">string</span>, phone <span class="hljs-keyword">int</span>) error<br>&#125;<br><br><span class="hljs-comment">// SMS 短信发送基类</span><br><span class="hljs-keyword">type</span> sms <span class="hljs-keyword">struct</span> &#123;<br>ISMS<br>&#125;<br><br><span class="hljs-comment">// Valid 校验短信字数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sms)</span> <span class="hljs-title">Valid</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(content) &gt; <span class="hljs-number">63</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;content is too long&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Send 发送短信</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sms)</span> <span class="hljs-title">Send</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>, phone <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">if</span> err := s.Valid(content); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// 调用子类的方法发送短信</span><br><span class="hljs-keyword">return</span> s.send(content, phone)<br>&#125;<br><br><span class="hljs-comment">// TelecomSms 走电信通道</span><br><span class="hljs-keyword">type</span> TelecomSms <span class="hljs-keyword">struct</span> &#123;<br>*sms<br>&#125;<br><br><span class="hljs-comment">// NewTelecomSms NewTelecomSms</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTelecomSms</span><span class="hljs-params">()</span> *<span class="hljs-title">TelecomSms</span></span> &#123;<br>tel := &amp;TelecomSms&#123;&#125;<br><span class="hljs-comment">// 这里有点绕，是因为 go 没有继承，用嵌套结构体的方法进行模拟</span><br><span class="hljs-comment">// 这里将子类作为接口嵌入父类，就可以让父类的模板方法 Send 调用到子类的函数</span><br><span class="hljs-comment">// 实际使用中，我们并不会这么写，都是采用组合+接口的方式完成类似的功能</span><br>tel.sms = &amp;sms&#123;ISMS: tel&#125;<br><span class="hljs-keyword">return</span> tel<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tel *TelecomSms)</span> <span class="hljs-title">send</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>, phone <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;send by telecom success&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> template<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_sms_Send</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tel := NewTelecomSms()<br>err := tel.Send(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">1239999</span>)<br>assert.NoError(t, err)<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>行为型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式13-观察者模式(实现简单的EventBus)</title>
    <link href="/post/observer.html"/>
    <url>/post/observer.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/210170">56 | 观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 13/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a> **</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154349618-498355aa-3d37-4e65-a532-3aa5e1a336dd.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> observer<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// ISubject subject</span><br><span class="hljs-keyword">type</span> ISubject <span class="hljs-keyword">interface</span> &#123;<br>Register(observer IObsever)<br>Remove(observer IObsever)<br>Notify(observer IObsever)<br>&#125;<br><br><span class="hljs-comment">// IObsever 观察者</span><br><span class="hljs-keyword">type</span> IObsever <span class="hljs-keyword">interface</span> &#123;<br>Update(msg <span class="hljs-keyword">string</span>)<br>&#125;<br><br><span class="hljs-comment">// Subject Subject</span><br><span class="hljs-keyword">type</span> Subject <span class="hljs-keyword">struct</span> &#123;<br>observers []IObsever<br>&#125;<br><br><span class="hljs-comment">// Register 注册</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sub *Subject)</span> <span class="hljs-title">Register</span><span class="hljs-params">(observer IObsever)</span></span> &#123;<br>sub.observers = <span class="hljs-built_in">append</span>(sub.observers, observer)<br>&#125;<br><br><span class="hljs-comment">// Remove 移除观察者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sub *Subject)</span> <span class="hljs-title">Remove</span><span class="hljs-params">(observer IObsever)</span></span> &#123;<br><span class="hljs-keyword">for</span> i, ob := <span class="hljs-keyword">range</span> sub.observers &#123;<br><span class="hljs-keyword">if</span> ob == observer &#123;<br>sub.observers = <span class="hljs-built_in">append</span>(sub.observers[:i], sub.observers[i+<span class="hljs-number">1</span>:]...)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Notify 通知</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sub *Subject)</span> <span class="hljs-title">Notify</span><span class="hljs-params">(msg <span class="hljs-keyword">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> sub.observers &#123;<br>o.Update(msg)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Obsever1 Obsever1</span><br><span class="hljs-keyword">type</span> Obsever1 <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Update 实现观察者接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Obsever1)</span> <span class="hljs-title">Update</span><span class="hljs-params">(msg <span class="hljs-keyword">string</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Obsever1: %s&quot;</span>, msg)<br>&#125;<br><br><span class="hljs-comment">// Obsever2 Obsever2</span><br><span class="hljs-keyword">type</span> Obsever2 <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Update 实现观察者接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Obsever2)</span> <span class="hljs-title">Update</span><span class="hljs-params">(msg <span class="hljs-keyword">string</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Obsever2: %s&quot;</span>, msg)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> observer<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSubject_Notify</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>sub := &amp;Subject&#123;&#125;<br>sub.Register(&amp;Obsever1&#123;&#125;)<br>sub.Register(&amp;Obsever2&#123;&#125;)<br>sub.Notify(<span class="hljs-string">&quot;hi&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-Golang-实现-EventBus"><a href="#使用-Golang-实现-EventBus" class="headerlink" title="使用 Golang 实现 EventBus"></a>使用 Golang 实现 EventBus</h3><p>我们实现一个支持以下功能的事件总线</p><ol><li>异步不阻塞</li><li>支持任意参数值</li></ol><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eventbus<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// Bus Bus</span><br><span class="hljs-keyword">type</span> Bus <span class="hljs-keyword">interface</span> &#123;<br>Subscribe(topic <span class="hljs-keyword">string</span>, handler <span class="hljs-keyword">interface</span>&#123;&#125;) error<br>Publish(topic <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br>&#125;<br><br><span class="hljs-comment">// AsyncEventBus 异步事件总线</span><br><span class="hljs-keyword">type</span> AsyncEventBus <span class="hljs-keyword">struct</span> &#123;<br>handlers <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]reflect.Value<br>lock     sync.Mutex<br>&#125;<br><br><span class="hljs-comment">// NewAsyncEventBus new</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAsyncEventBus</span><span class="hljs-params">()</span> *<span class="hljs-title">AsyncEventBus</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;AsyncEventBus&#123;<br>handlers: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]reflect.Value&#123;&#125;,<br>lock:     sync.Mutex&#123;&#125;,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Subscribe 订阅</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bus *AsyncEventBus)</span> <span class="hljs-title">Subscribe</span><span class="hljs-params">(topic <span class="hljs-keyword">string</span>, f <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<br>bus.lock.Lock()<br><span class="hljs-keyword">defer</span> bus.lock.Unlock()<br><br>v := reflect.ValueOf(f)<br><span class="hljs-keyword">if</span> v.Type().Kind() != reflect.Func &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;handler is not a function&quot;</span>)<br>&#125;<br><br>handler, ok := bus.handlers[topic]<br><span class="hljs-keyword">if</span> !ok &#123;<br>handler = []reflect.Value&#123;&#125;<br>&#125;<br>handler = <span class="hljs-built_in">append</span>(handler, v)<br>bus.handlers[topic] = handler<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Publish 发布</span><br><span class="hljs-comment">// 这里异步执行，并且不会等待返回结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bus *AsyncEventBus)</span> <span class="hljs-title">Publish</span><span class="hljs-params">(topic <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>handlers, ok := bus.handlers[topic]<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;not found handlers in topic:&quot;</span>, topic)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>params := <span class="hljs-built_in">make</span>([]reflect.Value, <span class="hljs-built_in">len</span>(args))<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args &#123;<br>params[i] = reflect.ValueOf(arg)<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> handlers &#123;<br><span class="hljs-keyword">go</span> handlers[i].Call(params)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eventbus<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub1</span><span class="hljs-params">(msg1, msg2 <span class="hljs-keyword">string</span>)</span></span> &#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Microsecond)<br>fmt.Printf(<span class="hljs-string">&quot;sub1, %s %s\n&quot;</span>, msg1, msg2)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub2</span><span class="hljs-params">(msg1, msg2 <span class="hljs-keyword">string</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;sub2, %s %s\n&quot;</span>, msg1, msg2)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAsyncEventBus_Publish</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>bus := NewAsyncEventBus()<br>bus.Subscribe(<span class="hljs-string">&quot;topic:1&quot;</span>, sub1)<br>bus.Subscribe(<span class="hljs-string">&quot;topic:1&quot;</span>, sub2)<br>bus.Publish(<span class="hljs-string">&quot;topic:1&quot;</span>, <span class="hljs-string">&quot;test1&quot;</span>, <span class="hljs-string">&quot;test2&quot;</span>)<br>bus.Publish(<span class="hljs-string">&quot;topic:1&quot;</span>, <span class="hljs-string">&quot;testA&quot;</span>, <span class="hljs-string">&quot;testB&quot;</span>)<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">=== RUN   TestAsyncEventBus_Publish<br>sub2, testA testB<br>sub2, test1 test2<br>sub1, testA testB<br>sub1, test1 test2<br>--- PASS: TestAsyncEventBus_Publish (<span class="hljs-number">1.01</span>s)<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>行为型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式12-享元模式</title>
    <link href="/post/flyweight.html"/>
    <url>/post/flyweight.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/208572">54 | 享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 12/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154335161-74381c22-12a0-4878-8665-fd94e4bb7d27.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>复用课程中的 🌰，如果我们现在正在做一个棋牌类的游戏，例如象棋，无论是什么对局，棋子的基本属性其实是固定的，并不会因为随着下棋的过程变化。那我们就可以把棋子变为享元，让所有的对局都共享这些对象，以此达到节省内存的目的。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> flyweight<br><br><span class="hljs-keyword">var</span> units = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*ChessPieceUnit&#123;<br><span class="hljs-number">1</span>: &#123;<br>ID:    <span class="hljs-number">1</span>,<br>Name:  <span class="hljs-string">&quot;車&quot;</span>,<br>Color: <span class="hljs-string">&quot;red&quot;</span>,<br>&#125;,<br><span class="hljs-number">2</span>: &#123;<br>ID:    <span class="hljs-number">2</span>,<br>Name:  <span class="hljs-string">&quot;炮&quot;</span>,<br>Color: <span class="hljs-string">&quot;red&quot;</span>,<br>&#125;,<br><span class="hljs-comment">// ... 其他棋子</span><br>&#125;<br><br><span class="hljs-comment">// ChessPieceUnit 棋子享元</span><br><span class="hljs-keyword">type</span> ChessPieceUnit <span class="hljs-keyword">struct</span> &#123;<br>ID    <span class="hljs-keyword">uint</span><br>Name  <span class="hljs-keyword">string</span><br>Color <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// NewChessPieceUnit 工厂</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewChessPieceUnit</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ChessPieceUnit</span></span> &#123;<br><span class="hljs-keyword">return</span> units[id]<br>&#125;<br><br><span class="hljs-comment">// ChessPiece 棋子</span><br><span class="hljs-keyword">type</span> ChessPiece <span class="hljs-keyword">struct</span> &#123;<br>Unit *ChessPieceUnit<br>X    <span class="hljs-keyword">int</span><br>Y    <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// ChessBoard 棋局</span><br><span class="hljs-keyword">type</span> ChessBoard <span class="hljs-keyword">struct</span> &#123;<br>chessPieces <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*ChessPiece<br>&#125;<br><br><span class="hljs-comment">// NewChessBoard 初始化棋盘</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewChessBoard</span><span class="hljs-params">()</span> *<span class="hljs-title">ChessBoard</span></span> &#123;<br>board := &amp;ChessBoard&#123;chessPieces: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*ChessPiece&#123;&#125;&#125;<br><span class="hljs-keyword">for</span> id := <span class="hljs-keyword">range</span> units &#123;<br>board.chessPieces[id] = &amp;ChessPiece&#123;<br>Unit: NewChessPieceUnit(id),<br>X:    <span class="hljs-number">0</span>,<br>Y:    <span class="hljs-number">0</span>,<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> board<br>&#125;<br><br><span class="hljs-comment">// Move 移动棋子</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ChessBoard)</span> <span class="hljs-title">Move</span><span class="hljs-params">(id, x, y <span class="hljs-keyword">int</span>)</span></span> &#123;<br>c.chessPieces[id].X = x<br>c.chessPieces[id].Y = y<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> flyweight<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewChessBoard</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>board1 := NewChessBoard()<br>board1.Move(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>board2 := NewChessBoard()<br>board2.Move(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br>assert.Equal(t, board1.chessPieces[<span class="hljs-number">1</span>].Unit, board2.chessPieces[<span class="hljs-number">1</span>].Unit)<br>assert.Equal(t, board1.chessPieces[<span class="hljs-number">2</span>].Unit, board2.chessPieces[<span class="hljs-number">2</span>].Unit)<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>结构型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式11-组合模式</title>
    <link href="/post/composite.html"/>
    <url>/post/composite.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/207456">53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 11/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154326470-badb82c8-7938-4201-b024-c3dcd033f593.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>公司的人员组织就是一个典型的树状的结构，现在假设我们现在有部分，和员工，两种角色，一个部门下面可以存在子部门和员工，员工下面不能再包含其他节点。<br>我们现在要实现一个统计一个部门下员工数量的功能</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> composite<br><br><span class="hljs-comment">// IOrganization 组织接口，都实现统计人数的功能</span><br><span class="hljs-keyword">type</span> IOrganization <span class="hljs-keyword">interface</span> &#123;<br>Count() <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// Employee 员工</span><br><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// Count 人数统计</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Employee)</span> <span class="hljs-title">Count</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// Department 部门</span><br><span class="hljs-keyword">type</span> Department <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-keyword">string</span><br><br>SubOrganizations []IOrganization<br>&#125;<br><br><span class="hljs-comment">// Count 人数统计</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Department)</span> <span class="hljs-title">Count</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>c := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, org := <span class="hljs-keyword">range</span> d.SubOrganizations &#123;<br>c += org.Count()<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// AddSub 添加子节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Department)</span> <span class="hljs-title">AddSub</span><span class="hljs-params">(org IOrganization)</span></span> &#123;<br>d.SubOrganizations = <span class="hljs-built_in">append</span>(d.SubOrganizations, org)<br>&#125;<br><br><span class="hljs-comment">// NewOrganization 构建组织架构 demo</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewOrganization</span><span class="hljs-params">()</span> <span class="hljs-title">IOrganization</span></span> &#123;<br>root := &amp;Department&#123;Name: <span class="hljs-string">&quot;root&quot;</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>root.AddSub(&amp;Employee&#123;&#125;)<br>root.AddSub(&amp;Department&#123;Name: <span class="hljs-string">&quot;sub&quot;</span>, SubOrganizations: []IOrganization&#123;&amp;Employee&#123;&#125;&#125;&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> composite<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewOrganization</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>got := NewOrganization().Count()<br>assert.Equal(t, <span class="hljs-number">20</span>, got)<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>结构型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式10-门面模式</title>
    <link href="/post/facade.html"/>
    <url>/post/facade.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/206409">52 | 门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: /22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154318152-556e1feb-221d-43cb-8e67-3457a27956af.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设现在我有一个网站，以前有登录和注册的流程，登录的时候调用用户的查询接口，注册时调用用户的创建接口。为了简化用户的使用流程，我们现在提供直接验证码登录/注册的功能，如果该手机号已注册那么我们就走登录流程，如果该手机号未注册，那么我们就创建一个新的用户。</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> facade<br><br><span class="hljs-comment">// IUser 用户接口</span><br><span class="hljs-keyword">type</span> IUser <span class="hljs-keyword">interface</span> &#123;<br>Login(phone <span class="hljs-keyword">int</span>, code <span class="hljs-keyword">int</span>) (*User, error)<br>Register(phone <span class="hljs-keyword">int</span>, code <span class="hljs-keyword">int</span>) (*User, error)<br>&#125;<br><br><span class="hljs-comment">// IUserFacade 门面模式</span><br><span class="hljs-keyword">type</span> IUserFacade <span class="hljs-keyword">interface</span> &#123;<br>LoginOrRegister(phone <span class="hljs-keyword">int</span>, code <span class="hljs-keyword">int</span>) error<br>&#125;<br><br><span class="hljs-comment">// User 用户</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// UserService UserService</span><br><span class="hljs-keyword">type</span> UserService <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-comment">// Login 登录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u UserService)</span> <span class="hljs-title">Login</span><span class="hljs-params">(phone <span class="hljs-keyword">int</span>, code <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*User, error)</span></span> &#123;<br><span class="hljs-comment">// 校验操作 ...</span><br><span class="hljs-keyword">return</span> &amp;User&#123;Name: <span class="hljs-string">&quot;test login&quot;</span>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Register 注册</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u UserService)</span> <span class="hljs-title">Register</span><span class="hljs-params">(phone <span class="hljs-keyword">int</span>, code <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*User, error)</span></span> &#123;<br><span class="hljs-comment">// 校验操作 ...</span><br><span class="hljs-comment">// 创建用户</span><br><span class="hljs-keyword">return</span> &amp;User&#123;Name: <span class="hljs-string">&quot;test register&quot;</span>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// LoginOrRegister 登录或注册</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u UserService)</span><span class="hljs-title">LoginOrRegister</span><span class="hljs-params">(phone <span class="hljs-keyword">int</span>, code <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*User, error)</span></span> &#123;<br>user, err := u.Login(phone, code)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">if</span> user != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> user, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">return</span> u.Register(phone, code)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> facade<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestUserService_Login</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>service := UserService&#123;&#125;<br>user, err := service.Login(<span class="hljs-number">13001010101</span>, <span class="hljs-number">1234</span>)<br>assert.NoError(t, err)<br>assert.Equal(t, &amp;User&#123;Name: <span class="hljs-string">&quot;test login&quot;</span>&#125;, user)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestUserService_LoginOrRegister</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>service := UserService&#123;&#125;<br>user, err := service.LoginOrRegister(<span class="hljs-number">13001010101</span>, <span class="hljs-number">1234</span>)<br>assert.NoError(t, err)<br>assert.Equal(t, &amp;User&#123;Name: <span class="hljs-string">&quot;test login&quot;</span>&#125;, user)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestUserService_Register</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>service := UserService&#123;&#125;<br>user, err := service.Register(<span class="hljs-number">13001010101</span>, <span class="hljs-number">1234</span>)<br>assert.NoError(t, err)<br>assert.Equal(t, &amp;User&#123;Name: <span class="hljs-string">&quot;test register&quot;</span>&#125;, user)<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>结构型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式09-适配器模式</title>
    <link href="/post/adapter.html"/>
    <url>/post/adapter.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/205912">51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 09/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154310450-6522fa7f-2807-4f79-8cc7-9c95d848bb25.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我现在有一个运维系统，需要分别调用阿里云和 AWS 的 SDK 创建主机，两个 SDK 提供的创建主机的接口不一致，此时就可以通过适配器模式，将两个接口统一。<br><strong>PS：AWS 和 阿里云的接口纯属虚构，没有直接用原始的 SDK，只是举个例子</strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> adapter<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// ICreateServer 创建云主机</span><br><span class="hljs-keyword">type</span> ICreateServer <span class="hljs-keyword">interface</span> &#123;<br>CreateServer(cpu, mem <span class="hljs-keyword">float64</span>) error<br>&#125;<br><br><span class="hljs-comment">// AWSClient aws sdk</span><br><span class="hljs-keyword">type</span> AWSClient <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// RunInstance 启动实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *AWSClient)</span> <span class="hljs-title">RunInstance</span><span class="hljs-params">(cpu, mem <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;aws client run success, cpu： %f, mem: %f&quot;</span>, cpu, mem)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// AwsClientAdapter 适配器</span><br><span class="hljs-keyword">type</span> AwsClientAdapter <span class="hljs-keyword">struct</span> &#123;<br>Client AWSClient<br>&#125;<br><br><span class="hljs-comment">// CreateServer 启动实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AwsClientAdapter)</span> <span class="hljs-title">CreateServer</span><span class="hljs-params">(cpu, mem <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>a.Client.RunInstance(cpu, mem)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// AliyunClient aliyun sdk</span><br><span class="hljs-keyword">type</span> AliyunClient <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// CreateServer 启动实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *AliyunClient)</span> <span class="hljs-title">CreateServer</span><span class="hljs-params">(cpu, mem <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;aws client run success, cpu： %d, mem: %d&quot;</span>, cpu, mem)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// AliyunClientAdapter 适配器</span><br><span class="hljs-keyword">type</span> AliyunClientAdapter <span class="hljs-keyword">struct</span> &#123;<br>Client AliyunClient<br>&#125;<br><br><span class="hljs-comment">// CreateServer 启动实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AliyunClientAdapter)</span> <span class="hljs-title">CreateServer</span><span class="hljs-params">(cpu, mem <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>a.Client.CreateServer(<span class="hljs-keyword">int</span>(cpu), <span class="hljs-keyword">int</span>(mem))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> adapter<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAliyunClientAdapter_CreateServer</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-comment">// 确保 adapter 实现了目标接口</span><br><span class="hljs-keyword">var</span> a ICreateServer = &amp;AliyunClientAdapter&#123;<br>Client: AliyunClient&#123;&#125;,<br>&#125;<br><br>a.CreateServer(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAwsClientAdapter_CreateServer</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-comment">// 确保 adapter 实现了目标接口</span><br><span class="hljs-keyword">var</span> a ICreateServer = &amp;AwsClientAdapter&#123;<br>Client: AWSClient&#123;&#125;,<br>&#125;<br><br>a.CreateServer(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>结构型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式08-装饰器模式</title>
    <link href="/post/decorator.html"/>
    <url>/post/decorator.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/204845">50 | 装饰器模式：通过剖析 Java IO 类库源码学习装饰器模式</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 08/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154301481-9e70e78b-03b0-45a4-b33d-e2f972d100e5.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面是一个简单的画画的例子，默认的 <code>Square</code>  只有基础的画画功能， <code>ColorSquare</code>  为他加上了颜色</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> decorator<br><br><span class="hljs-comment">// IDraw IDraw</span><br><span class="hljs-keyword">type</span> IDraw <span class="hljs-keyword">interface</span> &#123;<br>Draw() <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// Square 正方形</span><br><span class="hljs-keyword">type</span> Square <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Draw Draw</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Square)</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is a square&quot;</span><br>&#125;<br><br><span class="hljs-comment">// ColorSquare 有颜色的正方形</span><br><span class="hljs-keyword">type</span> ColorSquare <span class="hljs-keyword">struct</span> &#123;<br>square IDraw<br>color  <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// NewColorSquare NewColorSquare</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewColorSquare</span><span class="hljs-params">(square IDraw, color <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">ColorSquare</span></span> &#123;<br><span class="hljs-keyword">return</span> ColorSquare&#123;color: color, square: square&#125;<br>&#125;<br><br><span class="hljs-comment">// Draw Draw</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c ColorSquare)</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> c.square.Draw() + <span class="hljs-string">&quot;, color is &quot;</span> + c.color<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestColorSquare_Draw</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>sq := Square&#123;&#125;<br>csq := NewColorSquare(sq, <span class="hljs-string">&quot;red&quot;</span>)<br>got := csq.Draw()<br>assert.Equal(t, <span class="hljs-string">&quot;this is a square, color is red&quot;</span>, got)<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>结构型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式07-桥接模式</title>
    <link href="/post/bridge.html"/>
    <url>/post/bridge.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/202786">49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 07/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154283457-c3b8b276-b7d3-4615-b6c2-b5f67860ed01.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> bridge<br><br><span class="hljs-comment">// IMsgSender IMsgSender</span><br><span class="hljs-keyword">type</span> IMsgSender <span class="hljs-keyword">interface</span> &#123;<br>Send(msg <span class="hljs-keyword">string</span>) error<br>&#125;<br><br><span class="hljs-comment">// EmailMsgSender 发送邮件</span><br><span class="hljs-comment">// 可能还有 电话、短信等各种实现</span><br><span class="hljs-keyword">type</span> EmailMsgSender <span class="hljs-keyword">struct</span> &#123;<br>emails []<span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// NewEmailMsgSender NewEmailMsgSender</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewEmailMsgSender</span><span class="hljs-params">(emails []<span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">EmailMsgSender</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;EmailMsgSender&#123;emails: emails&#125;<br>&#125;<br><br><span class="hljs-comment">// Send Send</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *EmailMsgSender)</span> <span class="hljs-title">Send</span><span class="hljs-params">(msg <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-comment">// 这里去发送消息</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// INotification 通知接口</span><br><span class="hljs-keyword">type</span> INotification <span class="hljs-keyword">interface</span> &#123;<br>Notify(msg <span class="hljs-keyword">string</span>) error<br>&#125;<br><br><span class="hljs-comment">// ErrorNotification 错误通知</span><br><span class="hljs-comment">// 后面可能还有 warning 各种级别</span><br><span class="hljs-keyword">type</span> ErrorNotification <span class="hljs-keyword">struct</span> &#123;<br>sender IMsgSender<br>&#125;<br><br><span class="hljs-comment">// NewErrorNotification NewErrorNotification</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewErrorNotification</span><span class="hljs-params">(sender IMsgSender)</span> *<span class="hljs-title">ErrorNotification</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;ErrorNotification&#123;sender: sender&#125;<br>&#125;<br><br><span class="hljs-comment">// Notify 发送通知</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *ErrorNotification)</span> <span class="hljs-title">Notify</span><span class="hljs-params">(msg <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> n.sender.Send(msg)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestErrorNotification_Notify</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>sender := NewEmailMsgSender([]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;test@test.com&quot;</span>&#125;)<br>n := NewErrorNotification(sender)<br>err := n.Notify(<span class="hljs-string">&quot;test msg&quot;</span>)<br><br>assert.Nil(t, err)<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>结构型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式06-代理模式(generate实现类似动态代理)</title>
    <link href="/post/proxy.html"/>
    <url>/post/proxy.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/201823">48 | 代理模式：代理在 RPC、缓存、监控等场景中的应用</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 06/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154274933-9fbee90c-d205-4651-9c8d-73b60fe63e1b.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>接下来会通过 golang 实现静态代理，有 Golang 和 java 的差异性，我们无法比较方便的利用反射实现动态代理，但是我们可以利用<strong> go generate </strong>实现类似的效果，并且这样实现有两个比较大的好处，一个是有静态代码检查，我们在编译期间就可以及早发现问题，第二个是性能会更好。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> proxy<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// IUser IUser</span><br><span class="hljs-keyword">type</span> IUser <span class="hljs-keyword">interface</span> &#123;<br>Login(username, password <span class="hljs-keyword">string</span>) error<br>&#125;<br><br><span class="hljs-comment">// User 用户</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// Login 用户登录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span> <span class="hljs-title">Login</span><span class="hljs-params">(username, password <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-comment">// 不实现细节</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// UserProxy 代理类</span><br><span class="hljs-keyword">type</span> UserProxy <span class="hljs-keyword">struct</span> &#123;<br>user *User<br>&#125;<br><br><span class="hljs-comment">// NewUserProxy NewUserProxy</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUserProxy</span><span class="hljs-params">(user *User)</span> *<span class="hljs-title">UserProxy</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;UserProxy&#123;<br>user: user,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Login 登录，和 user 实现相同的接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *UserProxy)</span> <span class="hljs-title">Login</span><span class="hljs-params">(username, password <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-comment">// before 这里可能会有一些统计的逻辑</span><br>start := time.Now()<br><br><span class="hljs-comment">// 这里是原有的业务逻辑</span><br><span class="hljs-keyword">if</span> err := p.user.Login(username, password); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// after 这里可能也有一些监控统计的逻辑</span><br>log.Printf(<span class="hljs-string">&quot;user login cost time: %s&quot;</span>, time.Now().Sub(start))<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> proxy<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/require&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestUserProxy_Login</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>proxy := NewUserProxy(&amp;User&#123;&#125;)<br><br>err := proxy.Login(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>)<br><br>require.Nil(t, err)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Go-Generate-实现-“动态代理”"><a href="#Go-Generate-实现-“动态代理”" class="headerlink" title="Go Generate 实现 “动态代理”"></a>Go Generate 实现 “动态代理”</h3><p>关于 go generate 之前已经写过一篇入门的介绍文章: <a href="https://lailin.xyz/post/41140.html">go generate and ast</a>，这里就不再赘述了，如果对相关的知识点不太清楚，可以先看前面的那篇文章。<br><strong>注意: 在真实的项目中并不推荐这么做，因为有点得不偿失，本文只是在探讨一种可能性，并且可以复习一下 go 语法树先关的知识点</strong><br>接下来我们先来看看需求。</p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>动态代理相比静态代理主要就是为了解决生产力，将我们从繁杂的重复劳动中解放出来，正好，在 Go 中 Generate 也是干这个活的<br>如下面的代码所示，我们的 generate 会读取 struct 上的注释，如果出现 <code>@proxy 接口名</code>  的注释，我们就会为这个 struct 生成一个 proxy 类，同时实现相同的接口，这个接口就是在注释中指定的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User 用户</span><br><span class="hljs-comment">// @proxy IUser</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><p>接来下我们会简单的实现这个需求，由于篇幅和时间的关系，我们会略过一些检查之类的代码，例如 <code>User</code>  是否真正实现了 <code>IUser</code>  这种情况。<br><strong>代码有点长，主要思路:</strong></p><ul><li>读取文件, 获取文件的 ast 语法树</li><li>通过 NewCommentMap 构建 node 和 comment 的关系</li><li>通过 comment 是否包含 <code>@proxy 接口名</code>  的接口，判断该节点是否需要生成代理类</li><li>通过 Lookup 方法找到接口</li><li>循环获取接口的每个方法的，方法名、参数、返回值信息</li><li>将方法信息，包名、需要代理类名传递给构建好的模板文件，生成代理类</li><li>最后用 format 包的方法格式化源代码</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> proxy<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go/ast&quot;</span><br><span class="hljs-string">&quot;go/format&quot;</span><br><span class="hljs-string">&quot;go/parser&quot;</span><br><span class="hljs-string">&quot;go/token&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;text/template&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generate</span><span class="hljs-params">(file <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br>fset := token.NewFileSet() <span class="hljs-comment">// positions are relative to fset</span><br>f, err := parser.ParseFile(fset, file, <span class="hljs-literal">nil</span>, parser.ParseComments)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><br><span class="hljs-comment">// 获取代理需要的数据</span><br>data := proxyData&#123;<br>Package: f.Name.Name,<br>&#125;<br><br><span class="hljs-comment">// 构建注释和 node 的关系</span><br>cmap := ast.NewCommentMap(fset, f, f.Comments)<br><span class="hljs-keyword">for</span> node, group := <span class="hljs-keyword">range</span> cmap &#123;<br><span class="hljs-comment">// 从注释 @proxy 接口名，获取接口名称</span><br>name := getProxyInterfaceName(group)<br><span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// 获取代理的类名</span><br>data.ProxyStructName = node.(*ast.GenDecl).Specs[<span class="hljs-number">0</span>].(*ast.TypeSpec).Name.Name<br><br><span class="hljs-comment">// 从文件中查找接口</span><br>obj := f.Scope.Lookup(name)<br><br><span class="hljs-comment">// 类型转换，注意: 这里没有对断言进行判断，可能会导致 panic</span><br>t := obj.Decl.(*ast.TypeSpec).Type.(*ast.InterfaceType)<br><br><span class="hljs-keyword">for</span> _, field := <span class="hljs-keyword">range</span> t.Methods.List &#123;<br>fc := field.Type.(*ast.FuncType)<br><br><span class="hljs-comment">// 代理的方法</span><br>method := &amp;proxyMethod&#123;<br>Name: field.Names[<span class="hljs-number">0</span>].Name,<br>&#125;<br><br><span class="hljs-comment">// 获取方法的参数和返回值</span><br>method.Params, method.ParamNames = getParamsOrResults(fc.Params)<br>method.Results, method.ResultNames = getParamsOrResults(fc.Results)<br><br>data.Methods = <span class="hljs-built_in">append</span>(data.Methods, method)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 生成文件</span><br>tpl, err := template.New(<span class="hljs-string">&quot;&quot;</span>).Parse(proxyTpl)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><br>buf := &amp;bytes.Buffer&#123;&#125;<br><span class="hljs-keyword">if</span> err := tpl.Execute(buf, data); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><br><span class="hljs-comment">// 使用 go fmt 对生成的代码进行格式化</span><br>src, err := format.Source(buf.Bytes())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(src), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// getParamsOrResults 获取参数或者是返回值</span><br><span class="hljs-comment">// 返回带类型的参数，以及不带类型的参数，以逗号间隔</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getParamsOrResults</span><span class="hljs-params">(fields *ast.FieldList)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, <span class="hljs-keyword">string</span>)</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>params     []<span class="hljs-keyword">string</span><br>paramNames []<span class="hljs-keyword">string</span><br>)<br><br><span class="hljs-keyword">for</span> i, param := <span class="hljs-keyword">range</span> fields.List &#123;<br><span class="hljs-comment">// 循环获取所有的参数名</span><br><span class="hljs-keyword">var</span> names []<span class="hljs-keyword">string</span><br><span class="hljs-keyword">for</span> _, name := <span class="hljs-keyword">range</span> param.Names &#123;<br>names = <span class="hljs-built_in">append</span>(names, name.Name)<br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(names) == <span class="hljs-number">0</span> &#123;<br>names = <span class="hljs-built_in">append</span>(names, fmt.Sprintf(<span class="hljs-string">&quot;r%d&quot;</span>, i))<br>&#125;<br><br>paramNames = <span class="hljs-built_in">append</span>(paramNames, names...)<br><br><span class="hljs-comment">// 参数名加参数类型组成完整的参数</span><br>param := fmt.Sprintf(<span class="hljs-string">&quot;%s %s&quot;</span>,<br>strings.Join(names, <span class="hljs-string">&quot;,&quot;</span>),<br>param.Type.(*ast.Ident).Name,<br>)<br>params = <span class="hljs-built_in">append</span>(params, strings.TrimSpace(param))<br>&#125;<br><br><span class="hljs-keyword">return</span> strings.Join(params, <span class="hljs-string">&quot;,&quot;</span>), strings.Join(paramNames, <span class="hljs-string">&quot;,&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getProxyInterfaceName</span><span class="hljs-params">(groups []*ast.CommentGroup)</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">for</span> _, commentGroup := <span class="hljs-keyword">range</span> groups &#123;<br><span class="hljs-keyword">for</span> _, comment := <span class="hljs-keyword">range</span> commentGroup.List &#123;<br><span class="hljs-keyword">if</span> strings.Contains(comment.Text, <span class="hljs-string">&quot;@proxy&quot;</span>) &#123;<br>interfaceName := strings.TrimLeft(comment.Text, <span class="hljs-string">&quot;// @proxy &quot;</span>)<br><span class="hljs-keyword">return</span> strings.TrimSpace(interfaceName)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 生成代理类的文件模板</span><br><span class="hljs-keyword">const</span> proxyTpl = <span class="hljs-string">`</span><br><span class="hljs-string">package &#123;&#123;.Package&#125;&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">type &#123;&#123; .ProxyStructName &#125;&#125;Proxy struct &#123;</span><br><span class="hljs-string">child *&#123;&#123; .ProxyStructName &#125;&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">func New&#123;&#123; .ProxyStructName &#125;&#125;Proxy(child *&#123;&#123; .ProxyStructName &#125;&#125;) *&#123;&#123; .ProxyStructName &#125;&#125;Proxy &#123;</span><br><span class="hljs-string">return &amp;&#123;&#123; .ProxyStructName &#125;&#125;Proxy&#123;child: child&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#123;&#123; range .Methods &#125;&#125;</span><br><span class="hljs-string">func (p *&#123;&#123;$.ProxyStructName&#125;&#125;Proxy) &#123;&#123; .Name &#125;&#125; (&#123;&#123; .Params &#125;&#125;) (&#123;&#123; .Results &#125;&#125;) &#123;</span><br><span class="hljs-string">// before 这里可能会有一些统计的逻辑</span><br><span class="hljs-string">start := time.Now()</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#123;&#123; .ResultNames &#125;&#125; = p.child.&#123;&#123; .Name &#125;&#125;(&#123;&#123; .ParamNames &#125;&#125;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">// after 这里可能也有一些监控统计的逻辑</span><br><span class="hljs-string">log.Printf(&quot;user login cost time: %s&quot;, time.Now().Sub(start))</span><br><span class="hljs-string"></span><br><span class="hljs-string">return &#123;&#123; .ResultNames &#125;&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#123;&#123; end &#125;&#125;</span><br><span class="hljs-string">`</span><br><br><span class="hljs-keyword">type</span> proxyData <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 包名</span><br>Package <span class="hljs-keyword">string</span><br><span class="hljs-comment">// 需要代理的类名</span><br>ProxyStructName <span class="hljs-keyword">string</span><br><span class="hljs-comment">// 需要代理的方法</span><br>Methods []*proxyMethod<br>&#125;<br><br><span class="hljs-comment">// proxyMethod 代理的方法</span><br><span class="hljs-keyword">type</span> proxyMethod <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 方法名</span><br>Name <span class="hljs-keyword">string</span><br><span class="hljs-comment">// 参数，含参数类型</span><br>Params <span class="hljs-keyword">string</span><br><span class="hljs-comment">// 参数名</span><br>ParamNames <span class="hljs-keyword">string</span><br><span class="hljs-comment">// 返回值</span><br>Results <span class="hljs-keyword">string</span><br><span class="hljs-comment">// 返回值名</span><br>ResultNames <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> proxy<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br><span class="hljs-string">&quot;github.com/stretchr/testify/require&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_generate</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>want := <span class="hljs-string">`package proxy</span><br><span class="hljs-string"></span><br><span class="hljs-string">type UserProxy struct &#123;</span><br><span class="hljs-string">child *User</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">func NewUserProxy(child *User) *UserProxy &#123;</span><br><span class="hljs-string">return &amp;UserProxy&#123;child: child&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">func (p *UserProxy) Login(username, password string) (r0 error) &#123;</span><br><span class="hljs-string">// before 这里可能会有一些统计的逻辑</span><br><span class="hljs-string">start := time.Now()</span><br><span class="hljs-string"></span><br><span class="hljs-string">r0 = p.child.Login(username, password)</span><br><span class="hljs-string"></span><br><span class="hljs-string">// after 这里可能也有一些监控统计的逻辑</span><br><span class="hljs-string">log.Printf(&quot;user login cost time: %s&quot;, time.Now().Sub(start))</span><br><span class="hljs-string"></span><br><span class="hljs-string">return r0</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br>got, err := generate(<span class="hljs-string">&quot;./static_proxy.go&quot;</span>)<br>require.Nil(t, err)<br>assert.Equal(t, want, got)<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>结构型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式05-创建型模式总结</title>
    <link href="/post/go-design-pattern-create.html"/>
    <url>/post/go-design-pattern-create.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含 23 种常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 05/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>耗时 2 周更新完了创建型的设计模式，回头思考一下，学习设计模式我们关注的是什么，如何实现么？是也不是。我认为比了解如何实现设计模式更重要的是这些设计模式的应用场景，什么场景下我们该用这种设计模式；以及这些设计模式所包含的思想，最终帮助我们把代码写“好”，可以帮助我们满足一系列的设计原则：</p><ul><li>单一职责</li><li>开闭原则</li><li>里式替换</li><li>接口隔离</li><li>依赖倒置</li><li>KISS</li><li>DRY：不要重复</li><li>高内聚、松耦合</li><li>迪米特法则: 不要依赖类，依赖接口</li><li><p>……<br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1599038480370-ac7b0eef-eaf3-4f6b-bd53-0b464aa591da.png" alt=""><strong>具体实现可以查看之前更新的文章</strong></p></li><li><p><a href="https://lailin.xyz/post/singleton.html">单例模式</a></p><ul><li>饿汉式</li><li>懒汉式</li></ul></li><li><a href="https://lailin.xyz/post/factory.html">工厂模式</a><ul><li>简单工厂</li><li>工厂方法</li><li>抽象工厂</li><li>DI 容器</li></ul></li><li><a href="https://lailin.xyz/post/builder.html">建造者模式</a></li><li><a href="https://lailin.xyz/post/prototype.html">原型模式</a></li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>创建型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式04-原型模式</title>
    <link href="/post/prototype.html"/>
    <url>/post/prototype.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/200786">47 | 原型模式：如何最快速地 clone 一个 HashMap 散列表？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 04/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154244534-22c36924-2fcc-493b-82dd-386dc02dbcd1.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li>这个模式在 Java、C++ 这种面向对象的语言不太常用，但是如果大家使用过 javascript 的话就会非常熟悉了，因为 js 本身是基于原型的面向对象语言，所以原型模式在 js 中应用非常广泛。</li><li>接下来会按照一个类似课程中的例子使用深拷贝和浅拷贝结合的方式进行实现</li><li>需求: 假设现在数据库中有大量数据，包含了关键词，关键词被搜索的次数等信息，模块 A 为了业务需要<ul><li>会在启动时加载这部分数据到内存中</li><li>并且需要定时更新里面的数据</li><li>同时展示给用户的数据每次必须要是相同版本的数据，不能一部分数据来自版本 1 一部分来自版本 2</li></ul></li></ul><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> prototype<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// Keyword 搜索关键字</span><br><span class="hljs-keyword">type</span> Keyword <span class="hljs-keyword">struct</span> &#123;<br>word      <span class="hljs-keyword">string</span><br>visit     <span class="hljs-keyword">int</span><br>UpdatedAt *time.Time<br>&#125;<br><br><span class="hljs-comment">// Clone 这里使用序列化与反序列化的方式深拷贝</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k *Keyword)</span> <span class="hljs-title">Clone</span><span class="hljs-params">()</span> *<span class="hljs-title">Keyword</span></span> &#123;<br><span class="hljs-keyword">var</span> newKeyword Keyword<br>b, _ := json.Marshal(k)<br>json.Unmarshal(b, &amp;newKeyword)<br><span class="hljs-keyword">return</span> &amp;newKeyword<br>&#125;<br><br><span class="hljs-comment">// Keywords 关键字 map</span><br><span class="hljs-keyword">type</span> Keywords <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*Keyword<br><br><span class="hljs-comment">// Clone 复制一个新的 keywords</span><br><span class="hljs-comment">// updatedWords: 需要更新的关键词列表，由于从数据库中获取数据常常是数组的方式</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(words Keywords)</span> <span class="hljs-title">Clone</span><span class="hljs-params">(updatedWords []*Keyword)</span> <span class="hljs-title">Keywords</span></span> &#123;<br>newKeywords := Keywords&#123;&#125;<br><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> words &#123;<br><span class="hljs-comment">// 这里是浅拷贝，直接拷贝了地址</span><br>newKeywords[k] = v<br>&#125;<br><br><span class="hljs-comment">// 替换掉需要更新的字段，这里用的是深拷贝</span><br><span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> updatedWords &#123;<br>newKeywords[word.word] = word.Clone()<br>&#125;<br><br><span class="hljs-keyword">return</span> newKeywords<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> prototype<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestKeywords_Clone</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>updateAt, _ := time.Parse(<span class="hljs-string">&quot;2006&quot;</span>, <span class="hljs-string">&quot;2020&quot;</span>)<br>words := Keywords&#123;<br><span class="hljs-string">&quot;testA&quot;</span>: &amp;Keyword&#123;<br>word:      <span class="hljs-string">&quot;testA&quot;</span>,<br>visit:     <span class="hljs-number">1</span>,<br>UpdatedAt: &amp;updateAt,<br>&#125;,<br><span class="hljs-string">&quot;testB&quot;</span>: &amp;Keyword&#123;<br>word:      <span class="hljs-string">&quot;testB&quot;</span>,<br>visit:     <span class="hljs-number">2</span>,<br>UpdatedAt: &amp;updateAt,<br>&#125;,<br><span class="hljs-string">&quot;testC&quot;</span>: &amp;Keyword&#123;<br>word:      <span class="hljs-string">&quot;testC&quot;</span>,<br>visit:     <span class="hljs-number">3</span>,<br>UpdatedAt: &amp;updateAt,<br>&#125;,<br>&#125;<br><br>now := time.Now()<br>updatedWords := []*Keyword&#123;<br>&#123;<br>word:      <span class="hljs-string">&quot;testB&quot;</span>,<br>visit:     <span class="hljs-number">10</span>,<br>UpdatedAt: &amp;now,<br>&#125;,<br>&#125;<br><br>got := words.Clone(updatedWords)<br><br>assert.Equal(t, words[<span class="hljs-string">&quot;testA&quot;</span>], got[<span class="hljs-string">&quot;testA&quot;</span>])<br>assert.NotEqual(t, words[<span class="hljs-string">&quot;testB&quot;</span>], got[<span class="hljs-string">&quot;testB&quot;</span>])<br>assert.NotEqual(t, updatedWords[<span class="hljs-number">0</span>], got[<span class="hljs-string">&quot;testB&quot;</span>])<br>assert.Equal(t, words[<span class="hljs-string">&quot;testC&quot;</span>], got[<span class="hljs-string">&quot;testC&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>创建型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式03-建造者模式</title>
    <link href="/post/builder.html"/>
    <url>/post/builder.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/199674">46 | 建造者模式：详解构造函数、set 方法、建造者模式三种对象创建方式</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 03/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>关注我，获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154226181-c4b56fbc-6a50-4c21-9d50-d9ce1c999a49.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>其实在 Golang 中对于创建类参数比较多的对象的时候，我们常见的做法是必填参数直接传递，可选参数通过传递可变的方法进行创建。<br>本文会先实现课程中的建造者模式，然后再实现我们常用的方式。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>通过下面可以看到，使用 Go 编写建造者模式的代码其实会很长，这些是它的一个缺点，所以如果不是参数的校验逻辑很复杂的情况下一般我们在 Go 中不会采用这种方式，而会采用后面的另外一种方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> builder<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">const</span> (<br>defaultMaxTotal = <span class="hljs-number">10</span><br>defaultMaxIdle  = <span class="hljs-number">9</span><br>defaultMinIdle  = <span class="hljs-number">1</span><br>)<br><br><span class="hljs-comment">// ResourcePoolConfig resource pool</span><br><span class="hljs-keyword">type</span> ResourcePoolConfig <span class="hljs-keyword">struct</span> &#123;<br>name     <span class="hljs-keyword">string</span><br>maxTotal <span class="hljs-keyword">int</span><br>maxIdle  <span class="hljs-keyword">int</span><br>minIdle  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// ResourcePoolConfigBuilder 用于构建 ResourcePoolConfig</span><br><span class="hljs-keyword">type</span> ResourcePoolConfigBuilder <span class="hljs-keyword">struct</span> &#123;<br>name     <span class="hljs-keyword">string</span><br>maxTotal <span class="hljs-keyword">int</span><br>maxIdle  <span class="hljs-keyword">int</span><br>minIdle  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// SetName SetName</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span> <span class="hljs-title">SetName</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;name can not be empty&quot;</span>)<br>&#125;<br>b.name = name<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// SetMinIdle SetMinIdle</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span> <span class="hljs-title">SetMinIdle</span><span class="hljs-params">(minIdle <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">if</span> minIdle &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;max tatal cannot &lt; 0, input: %d&quot;</span>, minIdle)<br>&#125;<br>b.minIdle = minIdle<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// SetMaxIdle SetMaxIdle</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span> <span class="hljs-title">SetMaxIdle</span><span class="hljs-params">(maxIdle <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">if</span> maxIdle &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;max tatal cannot &lt; 0, input: %d&quot;</span>, maxIdle)<br>&#125;<br>b.maxIdle = maxIdle<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// SetMaxTotal SetMaxTotal</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span> <span class="hljs-title">SetMaxTotal</span><span class="hljs-params">(maxTotal <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">if</span> maxTotal &lt;= <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;max tatal cannot &lt;= 0, input: %d&quot;</span>, maxTotal)<br>&#125;<br>b.maxTotal = maxTotal<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Build Build</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span> <span class="hljs-title">Build</span><span class="hljs-params">()</span> <span class="hljs-params">(*ResourcePoolConfig, error)</span></span> &#123;<br><span class="hljs-keyword">if</span> b.name == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;name can not be empty&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 设置默认值</span><br><span class="hljs-keyword">if</span> b.minIdle == <span class="hljs-number">0</span> &#123;<br>b.minIdle = defaultMinIdle<br>&#125;<br><br><span class="hljs-keyword">if</span> b.maxIdle == <span class="hljs-number">0</span> &#123;<br>b.maxIdle = defaultMaxIdle<br>&#125;<br><br><span class="hljs-keyword">if</span> b.maxTotal == <span class="hljs-number">0</span> &#123;<br>b.maxTotal = defaultMaxTotal<br>&#125;<br><br><span class="hljs-keyword">if</span> b.maxTotal &lt; b.maxIdle &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;max total(%d) cannot &lt; max idle(%d)&quot;</span>, b.maxTotal, b.maxIdle)<br>&#125;<br><br><span class="hljs-keyword">if</span> b.minIdle &gt; b.maxIdle &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;max idle(%d) cannot &lt; min idle(%d)&quot;</span>, b.maxIdle, b.minIdle)<br>&#125;<br><br><span class="hljs-keyword">return</span> &amp;ResourcePoolConfig&#123;<br>name:     b.name,<br>maxTotal: b.maxTotal,<br>maxIdle:  b.maxIdle,<br>minIdle:  b.minIdle,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> builder<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br><span class="hljs-string">&quot;github.com/stretchr/testify/require&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestResourcePoolConfigBuilder_Build</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name    <span class="hljs-keyword">string</span><br>builder *ResourcePoolConfigBuilder<br>want    *ResourcePoolConfig<br>wantErr <span class="hljs-keyword">bool</span><br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;name empty&quot;</span>,<br>builder: &amp;ResourcePoolConfigBuilder&#123;<br>name:     <span class="hljs-string">&quot;&quot;</span>,<br>maxTotal: <span class="hljs-number">0</span>,<br>&#125;,<br>want:    <span class="hljs-literal">nil</span>,<br>wantErr: <span class="hljs-literal">true</span>,<br>&#125;,<br>&#123;<br>name: <span class="hljs-string">&quot;maxIdle &lt; minIdle&quot;</span>,<br>builder: &amp;ResourcePoolConfigBuilder&#123;<br>name:     <span class="hljs-string">&quot;test&quot;</span>,<br>maxTotal: <span class="hljs-number">0</span>,<br>maxIdle:  <span class="hljs-number">10</span>,<br>minIdle:  <span class="hljs-number">20</span>,<br>&#125;,<br>want:    <span class="hljs-literal">nil</span>,<br>wantErr: <span class="hljs-literal">true</span>,<br>&#125;,<br>&#123;<br>name: <span class="hljs-string">&quot;success&quot;</span>,<br>builder: &amp;ResourcePoolConfigBuilder&#123;<br>name: <span class="hljs-string">&quot;test&quot;</span>,<br>&#125;,<br>want: &amp;ResourcePoolConfig&#123;<br>name:     <span class="hljs-string">&quot;test&quot;</span>,<br>maxTotal: defaultMaxTotal,<br>maxIdle:  defaultMaxIdle,<br>minIdle:  defaultMinIdle,<br>&#125;,<br>wantErr: <span class="hljs-literal">false</span>,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>got, err := tt.builder.Build()<br>require.Equalf(t, tt.wantErr, err != <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;Build() error = %v, wantErr %v&quot;</span>, err, tt.wantErr)<br>assert.Equal(t, tt.want, got)<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Go-常用的参数传递方法"><a href="#Go-常用的参数传递方法" class="headerlink" title="Go 常用的参数传递方法"></a>Go 常用的参数传递方法</h3><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> builder<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// ResourcePoolConfigOption option</span><br><span class="hljs-keyword">type</span> ResourcePoolConfigOption <span class="hljs-keyword">struct</span> &#123;<br>maxTotal <span class="hljs-keyword">int</span><br>maxIdle  <span class="hljs-keyword">int</span><br>minIdle  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// ResourcePoolConfigOptFunc to set option</span><br><span class="hljs-keyword">type</span> ResourcePoolConfigOptFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(option *ResourcePoolConfigOption)</span></span><br><br><span class="hljs-comment">// NewResourcePoolConfig NewResourcePoolConfig</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewResourcePoolConfig</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, opts ...ResourcePoolConfigOptFunc)</span> <span class="hljs-params">(*ResourcePoolConfig, error)</span></span> &#123;<br><span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;name can not be empty&quot;</span>)<br>&#125;<br><br>option := &amp;ResourcePoolConfigOption&#123;<br>maxTotal: <span class="hljs-number">10</span>,<br>maxIdle:  <span class="hljs-number">9</span>,<br>minIdle:  <span class="hljs-number">1</span>,<br>&#125;<br><br><span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> opts &#123;<br>opt(option)<br>&#125;<br><br><span class="hljs-keyword">if</span> option.maxTotal &lt; <span class="hljs-number">0</span> || option.maxIdle &lt; <span class="hljs-number">0</span> || option.minIdle &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;args err, option: %v&quot;</span>, option)<br>&#125;<br><br><span class="hljs-keyword">if</span> option.maxTotal &lt; option.maxIdle || option.minIdle &gt; option.maxIdle &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;args err, option: %v&quot;</span>, option)<br>&#125;<br><br><span class="hljs-keyword">return</span> &amp;ResourcePoolConfig&#123;<br>name:     name,<br>maxTotal: option.maxTotal,<br>maxIdle:  option.maxIdle,<br>minIdle:  option.minIdle,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> builder<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br><span class="hljs-string">&quot;github.com/stretchr/testify/require&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewResourcePoolConfig</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>opts []ResourcePoolConfigOptFunc<br>&#125;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name    <span class="hljs-keyword">string</span><br>args    args<br>want    *ResourcePoolConfig<br>wantErr <span class="hljs-keyword">bool</span><br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;name empty&quot;</span>,<br>args: args&#123;<br>name: <span class="hljs-string">&quot;&quot;</span>,<br>&#125;,<br>want:    <span class="hljs-literal">nil</span>,<br>wantErr: <span class="hljs-literal">true</span>,<br>&#125;,<br>&#123;<br>name: <span class="hljs-string">&quot;success&quot;</span>,<br>args: args&#123;<br>name: <span class="hljs-string">&quot;test&quot;</span>,<br>opts: []ResourcePoolConfigOptFunc&#123;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(option *ResourcePoolConfigOption)</span></span> &#123;<br>option.minIdle = <span class="hljs-number">2</span><br>&#125;,<br>&#125;,<br>&#125;,<br>want: &amp;ResourcePoolConfig&#123;<br>name:     <span class="hljs-string">&quot;test&quot;</span>,<br>maxTotal: <span class="hljs-number">10</span>,<br>maxIdle:  <span class="hljs-number">9</span>,<br>minIdle:  <span class="hljs-number">2</span>,<br>&#125;,<br>wantErr: <span class="hljs-literal">false</span>,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>got, err := NewResourcePoolConfig(tt.args.name, tt.args.opts...)<br>require.Equalf(t, tt.wantErr, err != <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;error = %v, wantErr %v&quot;</span>, err, tt.wantErr)<br>assert.Equal(t, tt.want, got)<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实可以看到，绝大多数情况下直接使用后面的这种方式就可以了，并且在编写公共库的时候，<strong>强烈建议</strong>入口的参数都可以这么传递，这样可以最大程度的保证我们公共库的兼容性，避免在后续的更新的时候出现破坏性的更新的情况。</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>创建型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式02-工厂模式&amp;DI容器</title>
    <link href="/post/factory.html"/>
    <url>/post/factory.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>注意：这篇文章代码比较多，包含了 简单工厂、工厂方法、抽象工厂、DI 容器的实现，由于内容具有关联性就不进行拆分了</li><li>Go 设计模式实现，包含 23 种常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/197254">44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 02/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a><br><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154206593-589dd3c8-561e-4c96-9268-490b1a5221da.jpeg" alt=""></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>由于 Go 本身是没有构造函数的，一般而言我们采用 <code>NewName</code>  的方式创建对象/接口，当它返回的是接口的时候，其实就是简单工厂模式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> factory<br><br><span class="hljs-comment">// IRuleConfigParser IRuleConfigParser</span><br><span class="hljs-keyword">type</span> IRuleConfigParser <span class="hljs-keyword">interface</span> &#123;<br>Parse(data []<span class="hljs-keyword">byte</span>)<br>&#125;<br><br><span class="hljs-comment">// jsonRuleConfigParser jsonRuleConfigParser</span><br><span class="hljs-keyword">type</span> jsonRuleConfigParser <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// Parse Parse</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(J jsonRuleConfigParser)</span> <span class="hljs-title">Parse</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span></span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;implement me&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// yamlRuleConfigParser yamlRuleConfigParser</span><br><span class="hljs-keyword">type</span> yamlRuleConfigParser <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// Parse Parse</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Y yamlRuleConfigParser)</span> <span class="hljs-title">Parse</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span></span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;implement me&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// NewIRuleConfigParser NewIRuleConfigParser</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewIRuleConfigParser</span><span class="hljs-params">(t <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">IRuleConfigParser</span></span> &#123;<br><span class="hljs-keyword">switch</span> t &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;json&quot;</span>:<br><span class="hljs-keyword">return</span> jsonRuleConfigParser&#123;&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;yaml&quot;</span>:<br><span class="hljs-keyword">return</span> yamlRuleConfigParser&#123;&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> factory<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewIRuleConfigParser</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;<br>t <span class="hljs-keyword">string</span><br>&#125;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>args args<br>want IRuleConfigParser<br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;json&quot;</span>,<br>args: args&#123;t: <span class="hljs-string">&quot;json&quot;</span>&#125;,<br>want: jsonRuleConfigParser&#123;&#125;,<br>&#125;,<br>&#123;<br>name: <span class="hljs-string">&quot;yaml&quot;</span>,<br>args: args&#123;t: <span class="hljs-string">&quot;yaml&quot;</span>&#125;,<br>want: yamlRuleConfigParser&#123;&#125;,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> got := NewIRuleConfigParser(tt.args.t); !reflect.DeepEqual(got, tt.want) &#123;<br>t.Errorf(<span class="hljs-string">&quot;NewIRuleConfigParser() = %v, want %v&quot;</span>, got, tt.want)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// IRuleConfigParserFactory 工厂方法接口</span><br><span class="hljs-keyword">type</span> IRuleConfigParserFactory <span class="hljs-keyword">interface</span> &#123;<br>CreateParser() IRuleConfigParser<br>&#125;<br><br><span class="hljs-comment">// yamlRuleConfigParserFactory yamlRuleConfigParser 的工厂类</span><br><span class="hljs-keyword">type</span> yamlRuleConfigParserFactory <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// CreateParser CreateParser</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(y yamlRuleConfigParserFactory)</span> <span class="hljs-title">CreateParser</span><span class="hljs-params">()</span> <span class="hljs-title">IRuleConfigParser</span></span> &#123;<br><span class="hljs-keyword">return</span> yamlRuleConfigParser&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// jsonRuleConfigParserFactory jsonRuleConfigParser 的工厂类</span><br><span class="hljs-keyword">type</span> jsonRuleConfigParserFactory <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// CreateParser CreateParser</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonRuleConfigParserFactory)</span> <span class="hljs-title">CreateParser</span><span class="hljs-params">()</span> <span class="hljs-title">IRuleConfigParser</span></span> &#123;<br><span class="hljs-keyword">return</span> jsonRuleConfigParser&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// NewIRuleConfigParserFactory 用一个简单工厂封装工厂方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewIRuleConfigParserFactory</span><span class="hljs-params">(t <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">IRuleConfigParserFactory</span></span> &#123;<br><span class="hljs-keyword">switch</span> t &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;json&quot;</span>:<br><span class="hljs-keyword">return</span> jsonRuleConfigParserFactory&#123;&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;yaml&quot;</span>:<br><span class="hljs-keyword">return</span> yamlRuleConfigParserFactory&#123;&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> factory<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewIRuleConfigParserFactory</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;<br>t <span class="hljs-keyword">string</span><br>&#125;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>args args<br>want IRuleConfigParserFactory<br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;json&quot;</span>,<br>args: args&#123;t: <span class="hljs-string">&quot;json&quot;</span>&#125;,<br>want: jsonRuleConfigParserFactory&#123;&#125;,<br>&#125;,<br>&#123;<br>name: <span class="hljs-string">&quot;yaml&quot;</span>,<br>args: args&#123;t: <span class="hljs-string">&quot;yaml&quot;</span>&#125;,<br>want: yamlRuleConfigParserFactory&#123;&#125;,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> got := NewIRuleConfigParserFactory(tt.args.t); !reflect.DeepEqual(got, tt.want) &#123;<br>t.Errorf(<span class="hljs-string">&quot;NewIRuleConfigParserFactory() = %v, want %v&quot;</span>, got, tt.want)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> factory<br><br><span class="hljs-comment">// IRuleConfigParser IRuleConfigParser</span><br><span class="hljs-keyword">type</span> IRuleConfigParser <span class="hljs-keyword">interface</span> &#123;<br>Parse(data []<span class="hljs-keyword">byte</span>)<br>&#125;<br><br><span class="hljs-comment">// jsonRuleConfigParser jsonRuleConfigParser</span><br><span class="hljs-keyword">type</span> jsonRuleConfigParser <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Parse Parse</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonRuleConfigParser)</span> <span class="hljs-title">Parse</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span></span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;implement me&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// ISystemConfigParser ISystemConfigParser</span><br><span class="hljs-keyword">type</span> ISystemConfigParser <span class="hljs-keyword">interface</span> &#123;<br>ParseSystem(data []<span class="hljs-keyword">byte</span>)<br>&#125;<br><br><span class="hljs-comment">// jsonSystemConfigParser jsonSystemConfigParser</span><br><span class="hljs-keyword">type</span> jsonSystemConfigParser <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Parse Parse</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonSystemConfigParser)</span> <span class="hljs-title">ParseSystem</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span></span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;implement me&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// IConfigParserFactory 工厂方法接口</span><br><span class="hljs-keyword">type</span> IConfigParserFactory <span class="hljs-keyword">interface</span> &#123;<br>CreateRuleParser() IRuleConfigParser<br>CreateSystemParser() ISystemConfigParser<br>&#125;<br><br><span class="hljs-keyword">type</span> jsonConfigParserFactory <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonConfigParserFactory)</span> <span class="hljs-title">CreateRuleParser</span><span class="hljs-params">()</span> <span class="hljs-title">IRuleConfigParser</span></span> &#123;<br><span class="hljs-keyword">return</span> jsonRuleConfigParser&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonConfigParserFactory)</span> <span class="hljs-title">CreateSystemParser</span><span class="hljs-params">()</span> <span class="hljs-title">ISystemConfigParser</span></span> &#123;<br><span class="hljs-keyword">return</span> jsonSystemConfigParser&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单元测试-2"><a href="#单元测试-2" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> factory<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_jsonConfigParserFactory_CreateRuleParser</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>want IRuleConfigParser<br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;json&quot;</span>,<br>want: jsonRuleConfigParser&#123;&#125;,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>j := jsonConfigParserFactory&#123;&#125;<br><span class="hljs-keyword">if</span> got := j.CreateRuleParser(); !reflect.DeepEqual(got, tt.want) &#123;<br>t.Errorf(<span class="hljs-string">&quot;CreateRuleParser() = %v, want %v&quot;</span>, got, tt.want)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_jsonConfigParserFactory_CreateSystemParser</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>want ISystemConfigParser<br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;json&quot;</span>,<br>want: jsonSystemConfigParser&#123;&#125;,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>j := jsonConfigParserFactory&#123;&#125;<br><span class="hljs-keyword">if</span> got := j.CreateSystemParser(); !reflect.DeepEqual(got, tt.want) &#123;<br>t.Errorf(<span class="hljs-string">&quot;CreateSystemParser() = %v, want %v&quot;</span>, got, tt.want)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DI-容器"><a href="#DI-容器" class="headerlink" title="DI 容器"></a>DI 容器</h3><p>golang 现有的依赖注入框架:</p><ul><li>使用反射实现的: <a href="https://github.com/uber-go/dig">https://github.com/uber-go/dig</a></li><li>使用 generate 实现的: <a href="https://github.com/google/wire">https://github.com/google/wire</a></li></ul><p>下文将通过反射实现一个类似 dig 简单的 demo，在课程里面的例子是读取配置文件，然后进行生成，下面提供是通过 provider 进行构建依赖关系。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> di<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-comment">// Container DI 容器</span><br><span class="hljs-keyword">type</span> Container <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 假设一种类型只能有一个 provider 提供</span><br>providers <span class="hljs-keyword">map</span>[reflect.Type]provider<br><br><span class="hljs-comment">// 缓存以生成的对象</span><br>results <span class="hljs-keyword">map</span>[reflect.Type]reflect.Value<br>&#125;<br><br><span class="hljs-keyword">type</span> provider <span class="hljs-keyword">struct</span> &#123;<br>value reflect.Value<br><br>params []reflect.Type<br>&#125;<br><br><span class="hljs-comment">// New 创建一个容器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span> *<span class="hljs-title">Container</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;Container&#123;<br>providers: <span class="hljs-keyword">map</span>[reflect.Type]provider&#123;&#125;,<br>results:   <span class="hljs-keyword">map</span>[reflect.Type]reflect.Value&#123;&#125;,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// isError 判断是否是 error 类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isError</span><span class="hljs-params">(t reflect.Type)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> t.Kind() != reflect.Interface &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> t.Implements(reflect.TypeOf(reflect.TypeOf((*error)(<span class="hljs-literal">nil</span>)).Elem()))<br>&#125;<br><br><span class="hljs-comment">// Provide 对象提供者，需要传入一个对象的工厂方法，后续会用于对象的创建</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Container)</span> <span class="hljs-title">Provide</span><span class="hljs-params">(constructor <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<br>v := reflect.ValueOf(constructor)<br><br><span class="hljs-comment">// 仅支持函数 provider</span><br><span class="hljs-keyword">if</span> v.Kind() != reflect.Func &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;constructor must be a func&quot;</span>)<br>&#125;<br><br>vt := v.Type()<br><br><span class="hljs-comment">// 获取参数</span><br>params := <span class="hljs-built_in">make</span>([]reflect.Type, vt.NumIn())<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; vt.NumIn(); i++ &#123;<br>params[i] = vt.In(i)<br>&#125;<br><br><span class="hljs-comment">// 获取返回值</span><br>results := <span class="hljs-built_in">make</span>([]reflect.Type, vt.NumOut())<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; vt.NumOut(); i++ &#123;<br>results[i] = vt.Out(i)<br>&#125;<br><br>provider := provider&#123;<br>value:  v,<br>params: params,<br>&#125;<br><br><span class="hljs-comment">// 保存不同类型的 provider</span><br><span class="hljs-keyword">for</span> _, result := <span class="hljs-keyword">range</span> results &#123;<br><span class="hljs-comment">// 判断返回值是不是 error</span><br><span class="hljs-keyword">if</span> isError(result) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-keyword">if</span> _, ok := c.providers[result]; ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s had a provider&quot;</span>, result)<br>&#125;<br><br>c.providers[result] = provider<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Invoke 函数执行入口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Container)</span> <span class="hljs-title">Invoke</span><span class="hljs-params">(function <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<br>v := reflect.ValueOf(function)<br><br><span class="hljs-comment">// 仅支持函数 provider</span><br><span class="hljs-keyword">if</span> v.Kind() != reflect.Func &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;constructor must be a func&quot;</span>)<br>&#125;<br><br>vt := v.Type()<br><br><span class="hljs-comment">// 获取参数</span><br><span class="hljs-keyword">var</span> err error<br>params := <span class="hljs-built_in">make</span>([]reflect.Value, vt.NumIn())<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; vt.NumIn(); i++ &#123;<br>params[i], err = c.buildParam(vt.In(i))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><br>v.Call(params)<br><br><span class="hljs-comment">// 获取 providers</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// buildParam 构建参数</span><br><span class="hljs-comment">// 1. 从容器中获取 provider</span><br><span class="hljs-comment">// 2. 递归获取 provider 的参数值</span><br><span class="hljs-comment">// 3. 获取到参数之后执行函数</span><br><span class="hljs-comment">// 4. 将结果缓存并且返回结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Container)</span> <span class="hljs-title">buildParam</span><span class="hljs-params">(param reflect.Type)</span> <span class="hljs-params">(val reflect.Value, err error)</span></span> &#123;<br><span class="hljs-keyword">if</span> result, ok := c.results[param]; ok &#123;<br><span class="hljs-keyword">return</span> result, <span class="hljs-literal">nil</span><br>&#125;<br><br>provider, ok := c.providers[param]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> reflect.Value&#123;&#125;, fmt.Errorf(<span class="hljs-string">&quot;can not found provider: %s&quot;</span>, param)<br>&#125;<br><br>params := <span class="hljs-built_in">make</span>([]reflect.Value, <span class="hljs-built_in">len</span>(provider.params))<br><span class="hljs-keyword">for</span> i, p := <span class="hljs-keyword">range</span> provider.params &#123;<br>params[i], err = c.buildParam(p)<br>&#125;<br><br>results := provider.value.Call(params)<br><span class="hljs-keyword">for</span> _, result := <span class="hljs-keyword">range</span> results &#123;<br><span class="hljs-comment">// 判断是否报错</span><br><span class="hljs-keyword">if</span> isError(result.Type()) &amp;&amp; !result.IsNil() &#123;<br><span class="hljs-keyword">return</span> reflect.Value&#123;&#125;, fmt.Errorf(<span class="hljs-string">&quot;%s call err: %+v&quot;</span>, provider, result)<br>&#125;<br><br><span class="hljs-keyword">if</span> !isError(result.Type()) &amp;&amp; !result.IsNil() &#123;<br>c.results[result.Type()] = result<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> c.results[param], <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里的实现比较粗糙，但是作为一个 demo 理解 di 容器也足够了，和 dig 相比还缺少很多东西，并且有许多的问题，例如 依赖关系，一种类型如果有多个 provider 如何处理等等等等。<br>可以看到我们总共就三个函数</p><ul><li>Provide: 获取对象工厂，并且使用一个 map 将对象工厂保存</li><li>Invoke: 执行入口</li><li>buildParam: 核心逻辑，构建参数<ul><li>从容器中获取 provider</li><li>递归获取 provider 的参数值</li><li>获取到参数之后执行函数</li><li>将结果缓存并且返回结果</li></ul></li></ul><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br>di <span class="hljs-string">&quot;github.com/mohuishou/go-design-pattern/02_factory/024_di&quot;</span><br>)<br><br><span class="hljs-comment">// A 依赖关系 A -&gt; B -&gt; C</span><br><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;<br>B *B<br>&#125;<br><br><span class="hljs-comment">// NewA NewA</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewA</span><span class="hljs-params">(b *B)</span> *<span class="hljs-title">A</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;A&#123;<br>B: b,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// B B</span><br><span class="hljs-keyword">type</span> B <span class="hljs-keyword">struct</span> &#123;<br>C *C<br>&#125;<br><br><span class="hljs-comment">// NewB NewB</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewB</span><span class="hljs-params">(c *C)</span> *<span class="hljs-title">B</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;B&#123;C: c&#125;<br>&#125;<br><br><span class="hljs-comment">// C C</span><br><span class="hljs-keyword">type</span> C <span class="hljs-keyword">struct</span> &#123;<br>Num <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// NewC NewC</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewC</span><span class="hljs-params">()</span> *<span class="hljs-title">C</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;C&#123;<br>Num: <span class="hljs-number">1</span>,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>container := di.New()<br><span class="hljs-keyword">if</span> err := container.Provide(NewA); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := container.Provide(NewB); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := container.Provide(NewC); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>err := container.Invoke(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a *A)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%+v: %d&quot;</span>, a, a.B.C.Num)<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>创建型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记-让你最快速地改善代码质量的20条编程规范</title>
    <link href="/post/fe1ma9.html"/>
    <url>/post/fe1ma9.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含 23 种常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/188622">31 | 理论五：让你最快速地改善代码质量的 20 条编程规范（上）</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li></ul><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ul><li>命名的关键是能<strong>准确达意</strong>。对于不同作用域的命名，我们可以适当地选择不同的长度。</li><li>我们<strong>可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名</strong>。</li><li><strong>命名要可读、可搜索</strong>。不要使用生僻的、不好读的英文单词来命名。命名要符合项目的统一规范，也不要用些反直觉的命名。</li><li><strong>接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”</strong>。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li><strong>注释的内容主要包含这样三个方面：做什么、为什么、怎么做</strong>。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</li><li><strong>类和函数一定要写注释，而且要写得尽可能全面详细</strong>。<strong>函数内部的注释要相对少一些</strong>，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。</li></ul><h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><ul><li>函数、类多大才合适？<strong>函数的代码行数不要超过一屏幕的大小，比如 50 行</strong>。类的大小限制比较难确定。</li><li><strong>一行代码多长最合适？最好不要超过 IDE 的显示宽度</strong>。当然，也不能太小，否则会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</li><li><strong>善用空行分割单元块</strong>。对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。</li><li>四格缩进还是两格缩进？我个人比较推荐使用两格缩进，这样可以节省空间，尤其是在代码嵌套层次比较深的情况下。不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进。<em>(PS: Golang 没有这个问题，默认使用 Tab 缩进)</em></li><li>大括号是否要另起一行？将大括号放到跟上一条语句同一行，可以节省代码行数。但是将大括号另起新的一行的方式，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。<em>(PS: Golang 没有这个问题）</em></li><li>类中成员怎么排列？在 Google Java 编程规范中，<strong>依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列</strong>。</li></ul><h3 id="编码技巧"><a href="#编码技巧" class="headerlink" title="编码技巧"></a>编码技巧</h3><ul><li><strong>将复杂的逻辑提炼拆分成函数和类。</strong></li><li><strong>通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况</strong>。</li><li><strong>函数中不要使用参数来做代码执行逻辑的控制</strong>。</li><li><strong>函数设计要职责单一</strong>。</li><li><strong>移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数</strong>。</li><li>用字面常量取代魔法数。</li><li>用解释性变量来解释复杂表达式，以此提高代码可读性。</li></ul><h3 id="统一编码规范"><a href="#统一编码规范" class="headerlink" title="统一编码规范"></a>统一编码规范</h3><ul><li>除了这三节讲到的比较细节的知识点之外，最后，<strong>还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范</strong>，并且通过 Code Review 督促执行，这对提高代码质量有立竿见影的效果。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码规范很多情况下都是见仁见智的看法，我认为最主要的是统一，个人风格要统一，团队风格也需要统一，然后依靠工具进行管理。我常用的 Golang 代码风格工具：</p><ul><li>format: <a href="https://godoc.org/golang.org/x/tools/cmd/goimports">https://godoc.org/golang.org/x/tools/cmd/goimports</a></li><li>lint: <a href="https://github.com/golang/lint">https://github.com/golang/lint</a></li><li><strong>ci:</strong> <a href="https://golangci-lint.run/">https://golangci-lint.run/</a> 这个支持多个静态扫描工具，上面两种也是支持的，不在 ide 直接使用的主要原因是，插件开启较多的时候会比较慢，不太适合随时运行，但是 ci 上是需要的</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="golangci-lint-gitlab-ci-yml-配置"><a href="#golangci-lint-gitlab-ci-yml-配置" class="headerlink" title="golangci-lint .gitlab-ci.yml 配置"></a>golangci-lint .gitlab-ci.yml 配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">lint:</span><br>  <span class="hljs-attr">stage:</span> <span class="hljs-string">lint</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">$CI_REGISTRY/library/golangci-lint:v1.27-alpine</span><br>  <span class="hljs-attr">script:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">golangci-lint</span> <span class="hljs-string">run</span> <span class="hljs-string">./...</span><br>  <span class="hljs-attr">retry:</span><br>    <span class="hljs-attr">max:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">when:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">runner_system_failure</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">stuck_or_timeout_failure</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">job_execution_timeout</span><br>  <span class="hljs-attr">tags:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">test</span><br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式01-单例模式</title>
    <link href="/post/singleton.html"/>
    <url>/post/singleton.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含 23 种常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/194035">41 | 单例模式（上为什么说支持懒加载的双重检测不比饿汉式更优？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 01/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new"><strong>开发者头条</strong></a></li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1612154194185-d6422000-58c5-493c-9008-a4dc52cd9251.jpeg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>单例模式采用了 饿汉式 和 懒汉式 两种实现，个人其实更倾向于饿汉式的实现，简单，并且可以将问题及早暴露，懒汉式虽然支持延迟加载，但是这只是把冷启动时间放到了第一次使用的时候，并没有本质上解决问题，并且为了实现懒汉式还不可避免的需要加锁。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>代码实现:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-comment">// Singleton 饿汉式单例</span><br><span class="hljs-keyword">type</span> Singleton <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-keyword">var</span> singleton *Singleton<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>singleton = &amp;Singleton&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// GetInstance 获取实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> *<span class="hljs-title">Singleton</span></span> &#123;<br><span class="hljs-keyword">return</span> singleton<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>单元测试:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton_test<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br>singleton <span class="hljs-string">&quot;github.com/mohuishou/go-design-pattern/01_singleton&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetInstance</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert.Equal(t, singleton.GetInstance(), singleton.GetInstance())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkGetInstanceParallel</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> &#123;<br><span class="hljs-keyword">for</span> pb.Next() &#123;<br><span class="hljs-keyword">if</span> singleton.GetInstance() != singleton.GetInstance() &#123;<br>b.Errorf(<span class="hljs-string">&quot;test fail&quot;</span>)<br>&#125;<br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="懒汉式（双重检测）"><a href="#懒汉式（双重检测）" class="headerlink" title="懒汉式（双重检测）"></a>懒汉式（双重检测）</h3><p><strong>代码实现:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>lazySingleton *Singleton<br>once          = &amp;sync.Once&#123;&#125;<br>)<br><br><span class="hljs-comment">// GetLazyInstance 懒汉式</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetLazyInstance</span><span class="hljs-params">()</span> *<span class="hljs-title">Singleton</span></span> &#123;<br><span class="hljs-keyword">if</span> lazySingleton == <span class="hljs-literal">nil</span> &#123;<br>once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>lazySingleton = &amp;Singleton&#123;&#125;<br>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> lazySingleton<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>单元测试:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton_test<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br>singleton <span class="hljs-string">&quot;github.com/mohuishou/go-design-pattern/01_singleton&quot;</span><br><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetLazyInstance</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert.Equal(t, singleton.GetLazyInstance(), singleton.GetLazyInstance())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkGetLazyInstanceParallel</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> &#123;<br><span class="hljs-keyword">for</span> pb.Next() &#123;<br><span class="hljs-keyword">if</span> singleton.GetLazyInstance() != singleton.GetLazyInstance() &#123;<br>b.Errorf(<span class="hljs-string">&quot;test fail&quot;</span>)<br>&#125;<br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><blockquote><p>感谢 <a href="https://github.com/scuplus/blogComment/issues/231#issuecomment-706009469">@lixianyang</a> 的指正</p></blockquote><p>可以看到直接 init 获取的性能要好一些</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">▶ C:\Users\laili\sdk\go1.15\bin\go.exe <span class="hljs-built_in">test</span> -benchmem -bench=<span class="hljs-string">&quot;.&quot;</span> -v<br>=== RUN   TestGetLazyInstance<br>--- PASS: TestGetLazyInstance (0.00s)<br>=== RUN   TestGetInstance<br>--- PASS: TestGetInstance (0.00s)<br>goos: windows<br>goarch: amd64<br>pkg: github.com/mohuishou/go-design-pattern/01_singleton<br>BenchmarkGetLazyInstanceParallel<br>BenchmarkGetLazyInstanceParallel-4      535702941                2.24 ns/op           0 B/op<br>      0 allocs/op<br>BenchmarkGetInstanceParallel<br>BenchmarkGetInstanceParallel-4          1000000000               0.586 ns/op          0 B/op<br>      0 allocs/op<br>PASS<br>ok      github.com/mohuishou/go-design-pattern/01_singleton     3.161s<br></code></pre></td></tr></table></figure><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week4-clean-arch.html">Week04: Go工程化(一) 架构整洁之道阅读笔记</a></li><li><a href="https://lailin.xyz/post/go-training-week3-sum.html">Week03: Go并发编程(十一) 总结</a></li><li><a href="https://lailin.xyz/post/go-training-week3-channel.html">Week03: Go并发编程(十) 深入理解 Channel</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go设计模式</category>
      
      <category>创建型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一点拙见-如何写好一个技术预研报告?</title>
    <link href="/post/how-to-write-a-pre-research-report.html"/>
    <url>/post/how-to-write-a-pre-research-report.html</url>
    
    <content type="html"><![CDATA[<p>最近做了一些预研的工作，主要是一些技术调研，报告呈现的过程当中收到了许多建设性的建议，同时包含一点自己的拙见，如果能给你带来一些思考，那最好不过。</p><h2 id="明确面向对象"><a href="#明确面向对象" class="headerlink" title="明确面向对象"></a>明确面向对象</h2><p>一篇好的文章，一份好的报告一定要考虑一下的你面向对象，如何能够让他可以随着你的思路快速简要的理解你想要传达的内容。那么，技术预研报告一般是给谁看的呢？请注意，我们这里说的报告是<strong>内部的调研报告</strong>，而不是例如一些专门做咨询的公司，提供给外部公司购买使用。这种报告的面向对象一般而言是你的上级，或者是上上级，或者是更高层级的领导。<br>这个时候分为两种情况，他懂技术，但是可能不了解细节，需要一些数据帮助他做决策，还有一种是他没有太多的技术背景，不是特别了解。</p><ul><li>如果是不太了解技术的领导，要注意不能用过多的专业术语，在报告里面可以适当的添加一些说明，类比辅助理解，这个篇幅需要注意，也不能过长。</li><li>如果是比较了解的，可以更多的从技术方面进行分析，可以添加一些技术指标的对比。对于技术预研这种情况，一般还是这种情况居多。</li></ul><p>接下来我就会从技术预研报告的一个最基础的模板说明每个部分需要有哪些内容，这个不是标准答案，这是我认为的一个报告当中必要的一些元素。</p><h2 id="预研报告模板"><a href="#预研报告模板" class="headerlink" title="预研报告模板"></a>预研报告模板</h2><h3 id="理清现状"><a href="#理清现状" class="headerlink" title="理清现状"></a>理清现状</h3><p>技术预研一般是用来解决当下我们需要解决的一些问题的，可能这些问题用已有的系统或者技术暂时无法解决，或者是解决方法不够优雅，不够简洁等等。所以首先我们需要的是从现状出发，理清需求找准目标。问题来了怎么描述现状呢？我们先来看一个例子<em>（注意本文所有示例数据均来源于虚构）</em>:</p><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子:"></a>一个例子:</h4><ul><li><strong>反面教材: </strong>集群内应用的资源设置不合理</li><li><strong>正面教材: </strong>最近一个月某区域集群节点 NotReady 告警次数超过 200 次，导致 30 多个应用 POD 漂移。其原因是由于应用超配比例过高，配置不合理<ul><li>数据说话: 最近一个月某区域集群节点 NotReady 告警次数超过 200 次</li><li>影响范围: 导致 30 多个应用 POD 漂移</li><li>原因: 应用超配比例过高，配置不合理</li></ul></li></ul><p>上面这个示例是一个最常见的错误案例，在现状分析当中，经常<strong>喜欢直接说问题的原因，不说这个问题导致的现象，以及影响范围。</strong>我们需要明白查看我们调研报告的观看对象是谁？往往是我们的上级或者是上上级领导，他们管理的产品比较多，不一定能够理解到十分细节。所以我们要<strong>从场景触发，首先降低沟通成本，罗列历史数据，增强说服力的同时可以帮助他们了解当前产品的现状。</strong></p><h4 id="如何说明现状"><a href="#如何说明现状" class="headerlink" title="如何说明现状?"></a>如何说明现状?</h4><ul><li>从实际的场景出发，简明扼要的说明曾今出现过或者当前存在着的问题</li><li>用数据说话，统计历史数据，包含但不限于，影响范围，出现的次数，反馈用户人次等等</li></ul><h3 id="畅想未来"><a href="#畅想未来" class="headerlink" title="畅想未来"></a>畅想未来</h3><p>了解了现状之后，我们需要有一个心理预期的结果，我们期望理想状态下，能够达到什么程度，这一部分可以脑洞大一些，期望高一点，不要局限在眼前。</p><h4 id="一个例子-1"><a href="#一个例子-1" class="headerlink" title="一个例子"></a>一个例子</h4><ul><li><strong>反面教材: </strong>集群内应用随意漂移，可以减少集群中节点故障次数</li><li><strong>正面教材: </strong>为业务应用提供安全、可靠、稳定、舒心的服务，业务高峰时资源及时扩容，洪峰来临时，优先确保核心应用稳定，力争做到让开发早下班，运维不加班，周末无告警，假期无负担。</li></ul><p>这两个例子里面，反面教材太过于务实了，这个只能说是居于现状的改进，不能说是对未来场景的想象，另一个是一个常见的场景加上一些形而上的想象。</p><h4 id="如何畅享未来？"><a href="#如何畅享未来？" class="headerlink" title="如何畅享未来？"></a>如何畅享未来？</h4><ul><li>从场景出发，描绘理想状态下可以达到的状态</li><li>结合现状，切忌跑题，这是展望未来的时候，我最容易犯的一个错误，共勉。</li></ul><h3 id="行业实践"><a href="#行业实践" class="headerlink" title="行业实践"></a>行业实践</h3><p>站在巨人的肩膀上可以让我们看的更远，绝大部分的情况下调研时候的需求都会有一些业界的实践案例，甚至有一些开源的社区方案，例如 Google、亚马逊、阿里、腾讯等，这是说他们的方案是否适合我们，能否落地。<br>对于行业的实践这一块的内容，建议<strong>采用表格的方式进行对比</strong>，如果可以的话还可以做一些<strong>现场演示</strong>，或者是<strong>录制视频。</strong></p><table><thead><tr><th>维度</th><th>现状</th><th>方案 A</th><th>方案 B</th><th>方案 C</th></tr></thead><tbody><tr><td>维度 1</td><td>现状 1</td><td>❌ 方案 A</td><td>方案 B</td><td>✅ 方案 C</td></tr><tr><td>维度 2</td><td>现状 1</td><td>✅ 方案 A</td><td>❌ 方案 B</td><td>方案 C</td></tr></tbody></table><p>如上表所示，就是一个十分常见的一个对比表格，这里需要注意的是，一定<strong>不要忘记我们当前的现状是什么</strong>，最后可以有一个总结，说明不同方案的优劣之处，如果采用某个方案，后续是否需要更加深入的调研等等。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>调研一定要有结论!</strong><br>这里结论不是决策，也不是一定是方案，由于时间、精力以及了解到的信息等等限制，可能导致我们当下是无法得出一个决策，是否采用某个方案，但是一定要有结论，这个结论，既可以是一个方向上的建议，也可以是需要继续深入调研。切记不能仅为了调研而调研。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>“没有反思和进步的人生不值得一过”，最近挺喜欢这句 Slogan，我觉得反思和总结可以进步更快，我的一点拙见或许由于我的视野原因，会比较狭隘，但是如果你如果看了这篇文章能有一些思考，无论认同与否，那都很值得。</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/22757.html">2018年的一些小目标</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>反思</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</title>
    <link href="/post/auxvv1.html"/>
    <url>/post/auxvv1.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在更新内部的工具库的时候发现，工具仓库中其实包含了很多的模块，但是现在的版本发布都是合并在在一起发的，为了管理更加细致和直观，所以想要在一个仓库中实现实现多个模块的发布。<a id="more"></a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>单个仓库中包含多个 go module 模块</li><li>版本发布可以根据模块来发版，而不是整个仓库进行发版</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="仓库结构"><a href="#仓库结构" class="headerlink" title="仓库结构"></a>仓库结构</h3><p>假设我们现在有一个仓库 <code>github.com/mohuishou/go-test-multi-module</code>  目录结构如下图所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── a<br>│   ├── a.go<br>│   └── go.mod<br>└── b<br>    ├── b.go<br>    └── go.mod<br></code></pre></td></tr></table></figure><p>其中 <code>a/go.mod</code>  使用如下命令生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod init github.com/mohuishou/go-test-multi-module/a<br></code></pre></td></tr></table></figure><h3 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h3><p>对模块进行发版时，只需打上 <code>[模块名]/版本号</code>  即可<br>以我们的示例为例，对模块 <code>a</code>  进行发版时我们只需要打上 tag <code>a/v1.0.0</code> ，同理对模块 b 进行发版时，需要打上 tag <code>b/v1.0.0</code>  即可</p><h3 id="用户使用"><a href="#用户使用" class="headerlink" title="用户使用"></a>用户使用</h3><p>用户在安装的时候只需要和普通模块一样执行命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get -u github.com/mohuishou/go-test-multi-module/a<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般情况下不推荐采用这种方式，还是一个仓库一个模块比较好，便于管理，但是对于一些工具库里面包含了较多的工具，想要不同类型单独发版也可以采用本文提到的方式</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/mohuishou/go-test-multi-module">本文的示例仓库</a></li><li><a href="https://github.com/golang/tools/releases">golang/tools</a> [官方的 gopls 也是这么发布版本的]</li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li><li><a href="https://lailin.xyz/post/38237.html">Go Web 小技巧（一）简化Gin接口代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>小技巧</tag>
      
      <tag>go mod</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Web 小技巧（三）Gin 参数绑定</title>
    <link href="/post/11996.html"/>
    <url>/post/11996.html</url>
    
    <content type="html"><![CDATA[<h2 id="楔-xie-子"><a href="#楔-xie-子" class="headerlink" title="楔(xiē)子"></a>楔(xiē)子</h2><p>在第一篇文章 <a href="https://lailin.xyz/post/38237.html">简化 Gin 接口代码</a> 当中为大家提供了一种抽象 <code>gin</code> 接口代码的思路，而这篇文章会为大家带来参数绑定的一些技巧。</p><p>在我们写的绝大部分的 API 代码当中，其实都是需要传递参数的，无论是通过 <code>path</code>、<code>query string</code> 还是 <code>body</code>，在 <code>gin</code> 当中，为我们提供了一系列的 <code>binding</code> 方法让我们可以把这些参数绑定到一个对象中，通过还可以通过 <code>struct tag</code> 来对参数进行校验，不知道到大家曾今是否和遇到过相同的困惑：</p><ul><li>我创建/更新接口有时候就仅仅只相差一个 id，我是不是可以复用代码？</li><li>是否可以直接用 model 层的 struct 绑定参数？</li></ul><p>接下来本文就从这些问题出发，利用 go 的组合特点，介绍一些参数绑定上的小技巧</p><a id="more"></a><h2 id="参数绑定技巧"><a href="#参数绑定技巧" class="headerlink" title="参数绑定技巧"></a>参数绑定技巧</h2><h3 id="1-复用创建-更新时的参数"><a href="#1-复用创建-更新时的参数" class="headerlink" title="1. 复用创建/更新时的参数"></a>1. 复用创建/更新时的参数</h3><pre><code class="hljs go"><span class="hljs-comment">// UserParams 用户参数</span><span class="hljs-keyword">type</span> UserParams <span class="hljs-keyword">struct</span> &#123;Name     <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;name&quot; binding:&quot;required&quot;`</span>Password <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;password&quot; binding:&quot;required&quot;`</span>&#125;<span class="hljs-comment">// CreateUserParams 创建用户</span><span class="hljs-keyword">type</span> CreateUserParams <span class="hljs-keyword">struct</span> &#123;UserParams&#125;<span class="hljs-comment">// UpdateUserParams 更新用户</span><span class="hljs-keyword">type</span> UpdateUserParams <span class="hljs-keyword">struct</span> &#123;UserParamsID <span class="hljs-keyword">uint</span> <span class="hljs-string">`json:&quot;id&quot; binding:&quot;required&quot;`</span>&#125;</code></pre><h3 id="2-用-model-层的-struct-绑定参数"><a href="#2-用-model-层的-struct-绑定参数" class="headerlink" title="2. 用 model 层的 struct 绑定参数"></a>2. 用 model 层的 struct 绑定参数</h3><p>如果我们在参数绑定的时候，向上面那样，每个参数单独创建一个绑定，这样在 Model 层创建数据库记录的时候就需要去手动的转换一道了，如果每个都需要这么写，会感觉很麻烦。</p><p>这是原本的 <code>user</code> 表</p><pre><code class="hljs go"><span class="hljs-comment">// model/model.go</span><span class="hljs-comment">// Model default model</span><span class="hljs-keyword">type</span> Model <span class="hljs-keyword">struct</span> &#123;ID        <span class="hljs-keyword">uint</span>       <span class="hljs-string">`json:&quot;id&quot; gorm:&quot;primary_key&quot;`</span>CreatedAt time.Time  <span class="hljs-string">`json:&quot;created_at&quot;`</span>UpdatedAt time.Time  <span class="hljs-string">`json:&quot;updated_at&quot;`</span>DeletedAt *time.Time <span class="hljs-string">`json:&quot;deleted_at&quot; sql:&quot;index&quot;`</span>&#125;<span class="hljs-comment">// model/user.go</span><span class="hljs-comment">// User 用户表</span><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;    ModelName     <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span>Password <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;password&quot;`</span>&#125;</code></pre><p>这时我们可以稍微改造一下, 利用 <code>binding:&quot;-&quot;</code> 忽略字段的功能，和 <code>struct</code> 组合，将 api 的参数和 model 关联在一起，减少一些结构体转换的代码</p><pre><code class="hljs go"><span class="hljs-comment">// model/model.go</span><span class="hljs-comment">// Model default model</span><span class="hljs-keyword">type</span> Model <span class="hljs-keyword">struct</span> &#123;    ID        <span class="hljs-keyword">uint</span>       <span class="hljs-string">`json:&quot;id&quot; gorm:&quot;primary_key&quot;`</span>CreatedAt time.Time  <span class="hljs-string">`json:&quot;created_at&quot; binding:&quot;-&quot;`</span>UpdatedAt time.Time  <span class="hljs-string">`json:&quot;updated_at&quot; binding:&quot;-&quot;`</span>DeletedAt *time.Time <span class="hljs-string">`json:&quot;deleted_at&quot; sql:&quot;index&quot; binding:&quot;-&quot;`</span>&#125;<span class="hljs-comment">// model/user.go</span><span class="hljs-comment">// User 用户表</span><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;    ModelName     <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;name&quot; binding:&quot;required&quot;`</span>Password <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;password&quot; binding:&quot;required&quot;`</span>&#125;<span class="hljs-comment">// api/user.go</span><span class="hljs-comment">// UserParams 用户参数</span><span class="hljs-keyword">type</span> UserParams <span class="hljs-keyword">struct</span> &#123;    model.User&#125;<span class="hljs-comment">// CreateUserParams 创建用户</span><span class="hljs-keyword">type</span> CreateUserParams <span class="hljs-keyword">struct</span> &#123;UserParams    ID    <span class="hljs-keyword">uint</span>    <span class="hljs-string">`json:&quot;id&quot; gorm:&quot;primary_key&quot; binding:&quot;-&quot;`</span>&#125;<span class="hljs-comment">// UpdateUserParams 更新用户</span><span class="hljs-keyword">type</span> UpdateUserParams <span class="hljs-keyword">struct</span> &#123;UserParams&#125;</code></pre><h3 id="3-使用-ShouldBind-而不是-Bind"><a href="#3-使用-ShouldBind-而不是-Bind" class="headerlink" title="3. 使用 ShouldBind 而不是 Bind"></a>3. 使用 <code>ShouldBind</code> 而不是 <code>Bind</code></h3><p><code>Bind</code> 方法会自动将 http status 设置为 400, 然后报错，但是我们往往会需要携带更多的信息返回，或者返回不同的 <code>status</code> 这时候往往会出现下面这样的警告，而使用 <code>ShouldBind</code> 可以避免此类问题</p><pre><code class="hljs bash">[WARNING] Headers were already written. Wanted to override status code 400 with 200</code></pre><h3 id="4-多次绑定-request-body-数据"><a href="#4-多次绑定-request-body-数据" class="headerlink" title="4. 多次绑定 request body 数据"></a>4. 多次绑定 request body 数据</h3><p>这是官方文档的一个示例，一般情况第二次读取 request body 的数据就会出现 EOF 的错误，因为 <code>c.Request.Body</code> 不可以重用</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> formA <span class="hljs-keyword">struct</span> &#123;  Foo <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;foo&quot; binding:&quot;required&quot;`</span>&#125;<span class="hljs-keyword">type</span> formB <span class="hljs-keyword">struct</span> &#123;  Bar <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;bar&quot; binding:&quot;required&quot;`</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SomeHandler</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;  objA := formA&#123;&#125;  objB := formB&#123;&#125;  <span class="hljs-comment">// c.ShouldBind 使用了 c.Request.Body，不可重用。</span>  <span class="hljs-keyword">if</span> errA := c.ShouldBind(&amp;objA); errA == <span class="hljs-literal">nil</span> &#123;    c.String(http.StatusOK, <span class="hljs-string">`the body should be formA`</span>)  <span class="hljs-comment">// 因为现在 c.Request.Body 是 EOF，所以这里会报错。</span>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> errB := c.ShouldBind(&amp;objB); errB == <span class="hljs-literal">nil</span> &#123;    c.String(http.StatusOK, <span class="hljs-string">`the body should be formB`</span>)  &#125; <span class="hljs-keyword">else</span> &#123;    ...  &#125;&#125;</code></pre><p>gin 1.4 之后官方提供了一个 <code>ShouldBindBodyWith</code> 的方法，可以支持重复绑定，原理就是将 body 的数据缓存了下来，但是二次取数据的时候还是得用 <code>ShouldBindBodyWith</code> 才行，直接用 <code>ShouldBind</code> 还是会报错的。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SomeHandler</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;  objA := formA&#123;&#125;  objB := formB&#123;&#125;  <span class="hljs-comment">// 读取 c.Request.Body 并将结果存入上下文。</span>  <span class="hljs-keyword">if</span> errA := c.ShouldBindBodyWith(&amp;objA, binding.JSON); errA == <span class="hljs-literal">nil</span> &#123;    c.String(http.StatusOK, <span class="hljs-string">`the body should be formA`</span>)  <span class="hljs-comment">// 这时, 复用存储在上下文中的 body。</span>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> errB := c.ShouldBindBodyWith(&amp;objB, binding.JSON); errB == <span class="hljs-literal">nil</span> &#123;    c.String(http.StatusOK, <span class="hljs-string">`the body should be formB JSON`</span>)  <span class="hljs-comment">// 可以接受其他格式</span>  &#125; <span class="hljs-keyword">else</span> &#123;    ...  &#125;&#125;</code></pre><p>这种方式其实有个问题，什么情况下我们会去多次读取 <code>body</code> 的数据，其实在中间件中我们是需要用到，有的中间件需要读取参数做一些处理，例如权限中间件需要获取当前资源的 id，判断当前用户是否有权限，如果这个时候直接使用 <code>ShouldBindBodyWith</code> 会导致之后的所有的接口都修改才行，十分的不优雅，下面提供一种不用影响后续使用的方法</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startPage</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<span class="hljs-keyword">var</span> (p1 Personp2 Person)buf := &amp;bytes.Buffer&#123;&#125;tea := io.TeeReader(c.Request.Body, buf)body, err := ioutil.ReadAll(tea)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Panicf(<span class="hljs-string">&quot;read body err: %+v&quot;</span>, err)&#125;c.Request.Body = ioutil.NopCloser(buf)<span class="hljs-comment">// read buf ...</span><span class="hljs-keyword">if</span> err := binding.JSON.BindBody(body, &amp;p1); err != <span class="hljs-literal">nil</span> &#123;log.Panic(<span class="hljs-string">&quot;p1&quot;</span>, err)&#125;log.Println(<span class="hljs-string">&quot;p1&quot;</span>, p1)<span class="hljs-comment">// use ShouldBind again ..</span><span class="hljs-keyword">if</span> err := c.ShouldBind(&amp;p2); err != <span class="hljs-literal">nil</span> &#123;log.Panic(<span class="hljs-string">&quot;p2&quot;</span>, err)&#125;log.Println(<span class="hljs-string">&quot;p2&quot;</span>, p2)c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;Success&quot;</span>)&#125;<span class="hljs-comment">// output</span><span class="hljs-comment">// 2019/11/06 23:10:04 p1 &#123;hello world&#125;</span><span class="hljs-comment">// 2019/11/06 23:10:04 p2 &#123;hello world&#125;</span><span class="hljs-comment">// [GIN] 2019/11/06 - 23:10:04 | 200 |   27.0400917s |             ::1 | POST     /testing</span></code></pre><p>这三行也适用于其他需要多次读取 <code>io.Reader</code> 的情况</p><pre><code class="hljs go">buf := &amp;bytes.Buffer&#123;&#125;tea := io.TeeReader(c.Request.Body, buf)body, err := ioutil.ReadAll(tea)</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章从参数绑定的问题出发，为大家介绍了两种组合参数的小技巧，提供了使用参数绑定的时候的一个建议，并且提出了非官方，侵入性小的的多次读取 request body 的方式。</p><p>下一篇文章给大家介绍 gorm 事务的一些小技巧</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://gin-gonic.com/zh-cn/">gin 官方文档</a></p></li><li><p><a href="https://stackoverflow.com/questions/39791021/how-to-read-multiple-times-from-same-io-reader">How to read multiple times from same io.Reader</a></p></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li><li><a href="https://lailin.xyz/post/38237.html">Go Web 小技巧（一）简化Gin接口代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>api</tag>
      
      <tag>小技巧</tag>
      
      <tag>gin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Web 小技巧（二）GORM 使用自定义类型</title>
    <link href="/post/17394.html"/>
    <url>/post/17394.html</url>
    
    <content type="html"><![CDATA[<p>不知道大家在使用 Gorm 的时候，是否有遇到过复杂类型 ( map, struct…) 如何映射到数据库的字段上的问题？</p><p>本文分别介绍通过实现通用接口和 Hook 的方式绑定复杂的数据类型。</p><a id="more"></a><h2 id="一、GORM-模型定义"><a href="#一、GORM-模型定义" class="headerlink" title="一、GORM 模型定义"></a>一、GORM 模型定义</h2><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;  gorm.Model  Name         <span class="hljs-keyword">string</span>  Age          sql.NullInt64  Birthday     *time.Time  Email        <span class="hljs-keyword">string</span>  <span class="hljs-string">`gorm:&quot;type:varchar(100);unique_index&quot;`</span>  Role         <span class="hljs-keyword">string</span>  <span class="hljs-string">`gorm:&quot;size:255&quot;`</span> <span class="hljs-comment">// 设置字段大小为255</span>  MemberNumber *<span class="hljs-keyword">string</span> <span class="hljs-string">`gorm:&quot;unique;not null&quot;`</span> <span class="hljs-comment">// 设置会员号（member number）唯一并且不为空</span>  Num          <span class="hljs-keyword">int</span>     <span class="hljs-string">`gorm:&quot;AUTO_INCREMENT&quot;`</span> <span class="hljs-comment">// 设置 num 为自增类型</span>  Address      <span class="hljs-keyword">string</span>  <span class="hljs-string">`gorm:&quot;index:addr&quot;`</span> <span class="hljs-comment">// 给address字段创建名为addr的索引</span>  IgnoreMe     <span class="hljs-keyword">int</span>     <span class="hljs-string">`gorm:&quot;-&quot;`</span> <span class="hljs-comment">// 忽略本字段</span>&#125;</code></pre><p>这是 GORM 官方文档当中模型定义的一个例子，但是我们在实际使用过程当中往往会遇到需要复杂类型例如 <code>map</code> 或者是一些自定义的类型进行绑定。</p><p>我们在文档的描述当中可以看到这么一段话：</p><blockquote><p>模型（Models）通常只是正常的 golang structs、基本的 go 类型或它们的指针。 同时也支持<a href="https://golang.org/pkg/database/sql/#Scanner"><code>sql.Scanner</code></a>及<a href="https://golang.org/pkg/database/sql/driver/#Valuer"><code>driver.Valuer</code></a> 接口（interfaces）。</p></blockquote><p>自已的数据类型只需要实现这两个接口就可以实现数据绑定了，文档只有一句话我们看看具体怎么做。</p><h2 id="二、通过实现-sql-Scanner-driver-Valuer-接口实现数据绑定"><a href="#二、通过实现-sql-Scanner-driver-Valuer-接口实现数据绑定" class="headerlink" title="二、通过实现 sql.Scanner,driver.Valuer 接口实现数据绑定"></a>二、通过实现 <code>sql.Scanner,driver.Valuer</code> 接口实现数据绑定</h2><h3 id="2-1-接口文档"><a href="#2-1-接口文档" class="headerlink" title="2.1 接口文档"></a>2.1 接口文档</h3><pre><code class="hljs go"><span class="hljs-comment">// sql.Scanner</span><span class="hljs-keyword">type</span> Scanner <span class="hljs-keyword">interface</span> &#123;    <span class="hljs-comment">// Scan assigns a value from a database driver.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// The src value will be of one of the following types:</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">//    int64</span>    <span class="hljs-comment">//    float64</span>    <span class="hljs-comment">//    bool</span>    <span class="hljs-comment">//    []byte</span>    <span class="hljs-comment">//    string</span>    <span class="hljs-comment">//    time.Time</span>    <span class="hljs-comment">//    nil - for NULL values</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// An error should be returned if the value cannot be stored</span>    <span class="hljs-comment">// without loss of information.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Reference types such as []byte are only valid until the next call to Scan</span>    <span class="hljs-comment">// and should not be retained. Their underlying memory is owned by the driver.</span>    <span class="hljs-comment">// If retention is necessary, copy their values before the next call to Scan.</span>    Scan(src <span class="hljs-keyword">interface</span>&#123;&#125;) error&#125;<span class="hljs-comment">// driver.Valuer</span><span class="hljs-keyword">type</span> Valuer <span class="hljs-keyword">interface</span> &#123;    <span class="hljs-comment">// Value returns a driver Value.</span>    <span class="hljs-comment">// Value must not panic.</span>    Value() (Value, error)&#125;</code></pre><p>我们可以发现 <code>Valuer</code> 用于保存数据的时候，<code>Scaner</code> 用于数据从数据库映射到 model 的时候</p><h3 id="2-2-实现接口"><a href="#2-2-实现接口" class="headerlink" title="2.2 实现接口"></a>2.2 实现接口</h3><p>下面我们来一个实际的例子</p><pre><code class="hljs go"><span class="hljs-comment">// Args 参数</span><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span><span class="hljs-comment">// Scan Scanner</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(args Args)</span> <span class="hljs-title">Scan</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> value == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;b, ok := value.([]<span class="hljs-keyword">byte</span>)<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;value is not []byte, value: %v&quot;</span>, value)&#125;<span class="hljs-keyword">return</span> json.Unmarshal(b, &amp;args)&#125;<span class="hljs-comment">// Value Valuer</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(args Args)</span> <span class="hljs-title">Value</span><span class="hljs-params">()</span> <span class="hljs-params">(driver.Value, error)</span></span> &#123;<span class="hljs-keyword">if</span> args == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> json.Marshal(args)&#125;</code></pre><p>在使用的时候我们只要再加上一个数据类型就 OK 了</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Data <span class="hljs-keyword">struct</span> &#123;  Args Args <span class="hljs-string">`json:&quot;args&quot; gorm:&quot;type:text&quot;`</span>&#125;</code></pre><h3 id="2-3-抽象通用工具函数"><a href="#2-3-抽象通用工具函数" class="headerlink" title="2.3 抽象通用工具函数"></a>2.3 抽象通用工具函数</h3><p>在实际的使用中我们可能会有许多的类型的需要这样存储，所以我们直接抽象一个公用的工具函数</p><pre><code class="hljs go"><span class="hljs-comment">// scan for scanner helper</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scan</span><span class="hljs-params">(data <span class="hljs-keyword">interface</span>&#123;&#125;, value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> value == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">switch</span> value.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> []<span class="hljs-keyword">byte</span>:<span class="hljs-keyword">return</span> json.Unmarshal(value.([]<span class="hljs-keyword">byte</span>), data)<span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:<span class="hljs-keyword">return</span> json.Unmarshal([]<span class="hljs-keyword">byte</span>(value.(<span class="hljs-keyword">string</span>)), data)<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;val type is valid, is %+v&quot;</span>, value)&#125;&#125;<span class="hljs-comment">// for valuer helper</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">(data <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;vi := reflect.ValueOf(data)<span class="hljs-comment">// 判断是否为 0 值</span><span class="hljs-keyword">if</span> vi.IsZero() &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> json.Marshal(data)&#125;</code></pre><p>使用的时候只需要调用一下</p><pre><code class="hljs go"><span class="hljs-comment">// Args 参数</span><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span><span class="hljs-comment">// Scan Scanner</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(args Args)</span> <span class="hljs-title">Scan</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> scan(&amp;args, value)&#125;<span class="hljs-comment">// Value Valuer</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(args Args)</span> <span class="hljs-title">Value</span><span class="hljs-params">()</span> <span class="hljs-params">(driver.Value, error)</span></span> &#123;<span class="hljs-keyword">return</span> value(args)&#125;</code></pre><h2 id="三、通过-hook-实现数据绑定"><a href="#三、通过-hook-实现数据绑定" class="headerlink" title="三、通过 hook 实现数据绑定"></a>三、通过 hook 实现数据绑定</h2><p>除了上面的这种方法有没有其他的实现方式呢？</p><p>当然是有的，从上面的例子我们可以发现，实现方式就是保存数据的时候将数据转换为基本类型，然后在取出来绑定数据的时候再转换一下，这个过程我们也可以通过 <a href="http://gorm.io/docs/hooks.html">GORM 的 Hook</a> 实现。利用 <code>BeforeSave</code> 在数据保存前转换，再利用 <code>AfterFind</code> 在数据取出来之后转换即可。但是这种方式我们需要在 struct 中定义一个用于实际映射数据库数据的字段。</p><pre><code class="hljs go"><span class="hljs-comment">// Data Data</span><span class="hljs-keyword">type</span> Data <span class="hljs-keyword">struct</span> &#123;Args    <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-string">`json:&quot;args&quot; gorm:&quot;-&quot;`</span>ArgsStr <span class="hljs-keyword">string</span>                 <span class="hljs-string">`json:&quot;-&quot; gorm:&quot;column:args&quot;`</span>&#125;<span class="hljs-comment">// BeforeSave 数据保存前</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(data *Data)</span> <span class="hljs-title">BeforeSave</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> data.Args == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;b, err := json.Marshal(&amp;data.Args)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;data.ArgsStr = <span class="hljs-keyword">string</span>(b)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// AfterFind 查询之后</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(data *Data)</span> <span class="hljs-title">AfterFind</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> data.ArgsStr == <span class="hljs-string">&quot;&quot;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> json.Unmarshal([]<span class="hljs-keyword">byte</span>(data.ArgsStr), &amp;data.Args)&#125;</code></pre><p>这样同样可以达到相似的效果</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章介绍了两种通用数据类型在 GORM 中的绑定方式：</p><ul><li>通过实现相关的接口实现，并且抽象了一个通用的辅助函数</li><li>通过 hook 实现</li></ul><p>一般推荐使用第一种方法，只是需要单独定义数据类型，第二种方法需要多一个辅助字段，这种方式如果相关的字段过多会很不优雅。</p><p>感谢阅读，这是 Go Web 小技巧系列的第二篇文章，下一篇为大家介绍参数绑定当中的一些小技巧</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/38237.html">Go Web 小技巧（一）简化Gin接口代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>gorm</tag>
      
      <tag>小技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Web 小技巧（一）简化Gin接口代码</title>
    <link href="/post/38237.html"/>
    <url>/post/38237.html</url>
    
    <content type="html"><![CDATA[<p>不知道大家在使用 Gin 构建 API 服务时有没有这样的问题:</p><ol><li>参数绑定的环节可不可以自动处理？</li><li>错误可不可以直接返回，不想写空 <code>return</code>, 漏写就是 <code>bug</code></li></ol><p>本文通过简单地封装，利用 go 的接口特性，提供一个解决上述两个问题的思路</p><a id="more"></a><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h3 id="刚开始时写-API-服务时"><a href="#刚开始时写-API-服务时" class="headerlink" title="刚开始时写 API 服务时"></a>刚开始时写 API 服务时</h3><p>我们刚开始使用 Gin 写 API 服务时，一般会按照官方文档上的 🌰 这么写</p><pre><code class="hljs go"><span class="hljs-comment">// User 用户结构</span><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;UserName <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// CreateUser 创建用户</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateUser</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<span class="hljs-keyword">var</span> params User<span class="hljs-keyword">if</span> err := ctx.ShouldBind(&amp;params); err != <span class="hljs-literal">nil</span> &#123;ctx.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">400</span>,<span class="hljs-string">&quot;msg&quot;</span>:  <span class="hljs-string">&quot;参数错误&quot;</span>,&#125;)logrus.Errorf(<span class="hljs-string">&quot;params err, %v&quot;</span>, params)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 一些其他的业务逻辑 ...</span>ctx.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">0</span>,<span class="hljs-string">&quot;msg&quot;</span>:  <span class="hljs-string">&quot;创建成功&quot;</span>,&#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;r := gin.Default()r.POST(<span class="hljs-string">&quot;user&quot;</span>, CreateUser)<span class="hljs-keyword">if</span> err := r.Run(<span class="hljs-string">&quot;:8080&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;logrus.Fatalf(<span class="hljs-string">&quot;can not start serve: %v&quot;</span>, err)&#125;&#125;</code></pre><h3 id="封装返回值"><a href="#封装返回值" class="headerlink" title="封装返回值"></a>封装返回值</h3><p>我们写了一段时间之后，会发现，我们的返回值的结构是固定的，为什么不抽象一下呢，所以我们创建了一个结构体 <code>Resp</code> ，并且封装了两个方法用于成功和失败这两种状态的返回</p><pre><code class="hljs go"><span class="hljs-comment">// resp.go</span><span class="hljs-comment">// Resp 返回</span><span class="hljs-keyword">type</span> Resp <span class="hljs-keyword">struct</span> &#123;Code <span class="hljs-keyword">int</span>Msg  <span class="hljs-keyword">string</span>Data <span class="hljs-keyword">interface</span>&#123;&#125;&#125;<span class="hljs-comment">// ErrorResp 错误返回值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ErrorResp</span><span class="hljs-params">(ctx *gin.Context, code <span class="hljs-keyword">int</span>, msg <span class="hljs-keyword">string</span>, data ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;resp(ctx, code, msg, data...)&#125;<span class="hljs-comment">// SuccessResp 正确返回值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SuccessResp</span><span class="hljs-params">(ctx *gin.Context, msg <span class="hljs-keyword">string</span>, data ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;resp(ctx, <span class="hljs-number">0</span>, msg, data...)&#125;<span class="hljs-comment">// resp 返回</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resp</span><span class="hljs-params">(ctx *gin.Context, code <span class="hljs-keyword">int</span>, msg <span class="hljs-keyword">string</span>, data ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;resp := Resp&#123;Code: code,Msg:  msg,Data: data,&#125;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">1</span> &#123;resp.Data = data[<span class="hljs-number">0</span>]&#125;ctx.JSON(http.StatusOK, resp)&#125;</code></pre><p>添加这个方法之后，我们再看一下 <code>CreateUser</code> 这个方法，成功的从 16 行变到了 12 行</p><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><span class="hljs-comment">// CreateUser 创建用户</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateUser</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<span class="hljs-keyword">var</span> params User<span class="hljs-keyword">if</span> err := ctx.ShouldBind(&amp;params); err != <span class="hljs-literal">nil</span> &#123;ErrorResp(ctx, <span class="hljs-number">400</span>, <span class="hljs-string">&quot;参数错误&quot;</span>)logrus.Errorf(<span class="hljs-string">&quot;params err, %v&quot;</span>, params)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 一些其他的业务逻辑 ...</span>SuccessResp(ctx, <span class="hljs-string">&quot;创建成功&quot;</span>)&#125;</code></pre><h3 id="两个痛点"><a href="#两个痛点" class="headerlink" title="两个痛点"></a>两个痛点</h3><p>上面的方法还不够完整，我们还是有许多重复的逻辑，可以发现我们在写的绝大多数 API 大概都是这样：</p><ol><li>参数绑定 &amp; 校验</li><li>业务逻辑</li><li>返回</li></ol><p>这里面有两个痛点：</p><ol><li>参数绑定的环节可不可以自动处理？</li><li><p>错误可不可以直接返回，不想写空 <code>return</code>, 漏写就是 <code>bug</code></p><pre><code class="hljs go"><span class="hljs-comment">// 不想写大量这种重复的代码</span><span class="hljs-keyword">var</span> params User<span class="hljs-keyword">if</span> err := ctx.ShouldBind(&amp;params); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// 下面这三行是不是可以合并成一行</span>ErrorResp(ctx, <span class="hljs-number">400</span>, <span class="hljs-string">&quot;参数错误&quot;</span>)logrus.Errorf(<span class="hljs-string">&quot;params err, %v&quot;</span>, params)<span class="hljs-keyword">return</span>&#125;</code></pre><h3 id="使用接口封装请求"><a href="#使用接口封装请求" class="headerlink" title="使用接口封装请求"></a>使用接口封装请求</h3></li></ol><p>上面的这两个痛点我们可以通过一个辅助函数解决</p><pre><code class="hljs go"><span class="hljs-comment">// Requester 请求</span><span class="hljs-keyword">type</span> Requester <span class="hljs-keyword">interface</span> &#123;Request(ctx *gin.Context) (*Resp, error)&#125;<span class="hljs-comment">// Handle 请求</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handle</span><span class="hljs-params">(r Requester)</span> <span class="hljs-title">gin</span>.<span class="hljs-title">HandlerFunc</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;resp, err := request(r, ctx)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">var</span> code *errcode.Error<span class="hljs-keyword">if</span> !errors.As(err, &amp;code) &#123;code = errcode.Unknown.Wrap(err)&#125;resp = &amp;Resp&#123;Code: code.Code,Msg:  code.String(),&#125;_ = ctx.Error(err)&#125;ctx.JSON(http.StatusOK, resp)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">request</span><span class="hljs-params">(r Requester, ctx *gin.Context)</span> <span class="hljs-params">(*controller.Resp, error)</span></span> &#123;<span class="hljs-comment">// 参数绑定</span><span class="hljs-keyword">if</span> err := ctx.ShouldBind(r); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errcode.ErrParams.Wrap(err)&#125;<span class="hljs-keyword">return</span> r.Request(ctx)&#125;</code></pre><p>这样我们只需要实现这个 <code>Requester</code>, 写 API 时只需要关注业务逻辑就可以了</p><pre><code class="hljs go"><span class="hljs-comment">// CreateUser 创建用户</span><span class="hljs-keyword">type</span> CreateUser <span class="hljs-keyword">struct</span> &#123;UserName <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span> <span class="hljs-title">Request</span><span class="hljs-params">(ctx *gin.Context)</span> <span class="hljs-params">(*Resp, error)</span></span> &#123;<span class="hljs-comment">// 业务逻辑</span><span class="hljs-comment">// 返回成功值</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;r := gin.Default()r.POST(<span class="hljs-string">&quot;user&quot;</span>, Handle(&amp;CreateUser))<span class="hljs-keyword">if</span> err := r.Run(<span class="hljs-string">&quot;:8080&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;logrus.Fatalf(<span class="hljs-string">&quot;can not start serve: %v&quot;</span>, err)&#125;&#125;</code></pre><p>上面的代码有一个 bug 不知道大家发现没有，我们上一次请求的参数会被带到下一次请求当中</p><pre><code class="hljs go"><span class="hljs-comment">// Handle 请求</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handle</span><span class="hljs-params">(r Requester)</span> <span class="hljs-title">gin</span>.<span class="hljs-title">HandlerFunc</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<span class="hljs-comment">// 创建一个新的 Requester, 避免将上一次的参数带到下一次当中</span><span class="hljs-keyword">if</span> reflect.TypeOf(r).Kind() != reflect.Ptr &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;must be a pointer&quot;</span>)&#125;req := reflect.New(reflect.ValueOf(r).Elem().Type()).Interface().(Requester)resp, err := request(req, ctx)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">var</span> code *errcode.Error<span class="hljs-keyword">if</span> !errors.As(err, &amp;code) &#123;code = errcode.Unknown.Wrap(err)&#125;resp = &amp;Resp&#123;Code: code.Code,Msg:  code.String(),&#125;_ = ctx.Error(err)&#125;ctx.JSON(http.StatusOK, resp)&#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大概这样差不多就 ok 了，还有很多可以完善的点，这里有一些思路，有的已经做了，有的还在路上</p><ol><li><p>每次注册都写 <code>Handle(&amp;CreateUser)</code> 还是有点麻烦?</p><p>可以封装一下 <code>gin.IRouter</code> 这个接口，这样注册接口就可以和原来一样了</p></li><li><p>参数绑定如果我需要多次绑定怎么办?</p><p>可以添加一个接口，如果实现了这个接口就执行以下，对于有特殊的参数校验之类的也可以采用类似的方式处理</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Binder <span class="hljs-keyword">interface</span> &#123;Bind(ctx *gin.Context) error&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">request</span><span class="hljs-params">(r Requester, ctx *gin.Context)</span> <span class="hljs-params">(*controller.Resp, error)</span></span> &#123;<span class="hljs-comment">// 参数绑定</span><span class="hljs-keyword">if</span> err := ctx.ShouldBind(r); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errcode.ErrParams.Wrap(err)&#125;<span class="hljs-comment">// 其余参数绑定</span><span class="hljs-keyword">if</span> b, ok := r.(Binder); ok &#123;<span class="hljs-keyword">if</span> err := b.Bind(api); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errcode.ErrParams.Wrap(err)&#125;&#125;<span class="hljs-keyword">return</span> r.Request(ctx)&#125;</code></pre></li><li><p>怎么输出 API 文档？</p><p>可以和 <code>swagger</code> 之类的 API 文档结合, 利用 <code>go generate</code> 自动生成，顺便可以连接口注册都不用了，添加一行注释，自动注册接口，并且输出接口文档</p><pre><code class="hljs go"><span class="hljs-comment">// @Router put /api/v1/user</span><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u *User)</span> <span class="hljs-title">Request</span><span class="hljs-params">(ctx *gin.Context)</span> <span class="hljs-params">(*Resp, error)</span></span></code></pre></li><li><p>能不能减少 CURD 代码?</p><p>可以实现，只需要采用约定的项目接口，可以 利用 <code>go generate</code> 直接自动生成简单的 CURD 代码</p></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>api</tag>
      
      <tag>小技巧</tag>
      
      <tag>gin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>善用工具之postman高级用法概述</title>
    <link href="/post/45050.html"/>
    <url>/post/45050.html</url>
    
    <content type="html"><![CDATA[<p>POSTMAN 是我在开发过程当中最常用到的 API 测试工具之一，虽然并不完美，但也是目前个人认为在 API 测试时最好用的客户端工具之一。</p><p>本文适用于后端，前端，移动端以及测试的同学，分三大部分从最简单的界面操作开讲，然后涉及到变量、脚本以及一些云服务相关的功能，最后将适配几个案例讲解怎么使用 POSTMAN 提高我们的工作效率。本文前半部分包含较多基础功能讲解，对已经比较熟悉使用的同学，可以选择性的跳过部分内容。</p><a id="more"></a><blockquote><p>PS: 本文包含大量示例图片，大屏食用效果最佳，postman 看这一篇文章就够用了</p></blockquote><h2 id="零、序"><a href="#零、序" class="headerlink" title="零、序"></a>零、序</h2><p>我所有的文章基本都来自平时开发中的需求，前段时间在公司通过网关调用接口，测试很麻烦，然后就想使用在本地直接调用，由于有签名机制，所以需要通过 SDK 进行调用，后面比较完整的看了一下<code>postman</code>的文档，感觉发现了新大陆。</p><blockquote><p>注: 本文会介绍 postman 的常用以及不太常用的高级用法，但是不会所有方面都去做细节介绍，希望可以起到的抛砖引玉的作用</p></blockquote><h2 id="一、简要介绍"><a href="#一、简要介绍" class="headerlink" title="一、简要介绍"></a>一、简要介绍</h2><p><code>postman</code>是一款强大的 API 接口测试工具，有 chrome app、chrome 扩展、桌面版，推荐使用最新最强大的桌面版本。主要包括以下功能，本文也会围绕以下功能点展开讲解:</p><blockquote><p>有 ☁ 标识表示为云服务</p></blockquote><ol><li>API 测试</li><li>变量</li><li>代码生成</li><li><strong>Script</strong></li><li>API 代理</li><li>☁️ API 文档</li><li>☁️ Mock Server</li><li>☁️ 接口监控</li><li>☁️ Postman API</li></ol><h2 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h2><h3 id="2-1、使用简介"><a href="#2-1、使用简介" class="headerlink" title="2.1、使用简介"></a>2.1、使用简介</h3><p>如下图所示，postman 界面十分丰富，基本上所有常用的功能都能一览无余</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/Snipaste_2019-06-04_01-25-22.png" alt=""></p><h3 id="2-2、API-测试"><a href="#2-2、API-测试" class="headerlink" title="2.2、API 测试"></a>2.2、API 测试</h3><p>如下图所示，API 测试页面十分的易用，操作界面一目了然。</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190605235605.png" alt=""></p><h4 id="2-2-1、认证"><a href="#2-2-1、认证" class="headerlink" title="2.2.1、认证"></a>2.2.1、认证</h4><p>接口的调用常常需要通过登录，postman 预设一些常见的认证方式，比较常用的 Basic Auth, OAuth2.0 等，这些预设的协议在实际使用过程中会十分的有用。</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190605235911.png" alt=""></p><p>通过上图我们可以发现，默认选项是从父目录中继承，所以如下图所示，其实我们可以在一个 Collection 或者是下面的文件夹中设置认证方式，这时候整个目录下的所有的 API 默认都可以通过认证</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606000414.png" alt=""></p><h4 id="2-2-2、参数"><a href="#2-2-2、参数" class="headerlink" title="2.2.2、参数"></a>2.2.2、参数</h4><p>所有 K-V 模式的参数都可以批量编辑, 包括 QueryString, Body, Header, 批量编辑的功能可以快速复制浏览器中的请求参数信息到 postman 中</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/1559750920570.png" alt=""></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606001204.png" alt=""></p><h3 id="2-3、变量"><a href="#2-3、变量" class="headerlink" title="2.3、变量"></a>2.3、变量</h3><p>postman 中一共存在五种变量类型， 全局变量，Collection/文件夹中的变量，环境变量，数据变量，本地变量</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606001837.png" alt=""></p><p>如图所有变量层级从外到内，如果出现重复的变量名，里面的会覆盖外部的变量</p><h4 id="2-3-2、变量设置"><a href="#2-3-2、变量设置" class="headerlink" title="2.3.2、变量设置"></a>2.3.2、变量设置</h4><h5 id="2-3-2-1、Collection-变量"><a href="#2-3-2-1、Collection-变量" class="headerlink" title="2.3.2.1、Collection 变量"></a>2.3.2.1、Collection 变量</h5><p>点击编辑 Collection，如图所示</p><p>INITIAL VALUE: 这个值是用于分享给团队的成员的时候展示的值</p><p>CURRENT VALUE: 表示当前实际的值</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606002811.png" alt=""></p><h5 id="2-3-2-2、环境变量-amp-全局变量"><a href="#2-3-2-2、环境变量-amp-全局变量" class="headerlink" title="2.3.2.2、环境变量 &amp; 全局变量"></a>2.3.2.2、环境变量 &amp; 全局变量</h5><p>环境变量和全局变量的设置在 postman 的右上角，设置界面和上图的 Collection 界面类似</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606003057.png" alt=""></p><h4 id="2-3-2、变量的使用"><a href="#2-3-2、变量的使用" class="headerlink" title="2.3.2、变量的使用"></a>2.3.2、变量的使用</h4><p>变量通过 <code>&#123;&#123;VAR_NAME&#125;&#125;</code>, 在实际请求的时候变量可以设置为实际的值，变量也可以被脚本设置, 修改, 读取, 这个特性能够让我们有了很多可能</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606002133.png" alt=""></p><h4 id="2-3-3、动态变量"><a href="#2-3-3、动态变量" class="headerlink" title="2.3.3、动态变量"></a>2.3.3、动态变量</h4><p>postman 预设了几个动态变量<code>&#123;&#123;$guid&#125;&#125;</code>, 可以获取当前的时间戳等信息</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606002440.png" alt=""></p><h3 id="2-4、代码生成"><a href="#2-4、代码生成" class="headerlink" title="2.4、代码生成"></a>2.4、代码生成</h3><p>如图所示，postman 提供了很多语言以及一些常用框架的代码，我们在实际使用的过程中，可以直接复制代码节约许多时间</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606003416.png" alt=""></p><h3 id="2-5、Script-划重点"><a href="#2-5、Script-划重点" class="headerlink" title="2.5、Script(划重点)"></a>2.5、Script(划重点)</h3><h4 id="2-5-1、简介"><a href="#2-5-1、简介" class="headerlink" title="2.5.1、简介"></a>2.5.1、简介</h4><p>在 POSTMAN 中，你可以通过编写 JavaScript 脚本增强其功能，POSTMAN 的脚本运行在其提供的沙盒环境中，如下图所示，点击左下角按钮可以出现调试窗口，会显示脚本的 debug 信息</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190618000158.png" alt=""></p><p>在 postman 中一共支持两种脚本，分别是 Pre Request Script, Test Script，这两种脚本分别在请求前以及请求后生效，第一种我常用于生成各种签名或者是需要提前请求获取一些 token，后面一种更常见于集成测试中，用于控制测试的前后顺序，例如后面会讲到的案例，在 CD 前集成接口回归测试，确保主流程无误再上线等。</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190618000827.png" alt=""></p><h4 id="2-5-2、API"><a href="#2-5-2、API" class="headerlink" title="2.5.2、API"></a>2.5.2、API</h4><p>postman 提供了一些 API，<code>pm.*</code>, 例如:</p><pre><code class="hljs bash">pm.global.* <span class="hljs-comment"># 全局变量相关</span>pm.environment.* <span class="hljs-comment"># 环境变量相关</span>pm.request.* <span class="hljs-comment"># 请求相关, 注意请求相关的信息时只读的不能修改</span>pm.sendRequest() <span class="hljs-comment"># 发送请求</span><span class="hljs-comment"># 下面这些只能用于 test script</span>pm.response.* <span class="hljs-comment"># 返回值相关</span>pm.cookies.* <span class="hljs-comment"># cookies</span>pm.test() <span class="hljs-comment"># 执行测试</span>...</code></pre><p>除此之外还内置了一些常用的 npm 包可以直接使用，例如:</p><pre><code class="hljs bash">ajv → v6.6.2atob → v2.1.2btoa → v1.2.1chai → v4.2.0cheerio → v0.22.0...</code></pre><p>更多 API 信息可以访问官方文档查看: <a href="https://learning.getpostman.com/docs/postman/scripts/postman_sandbox_api_reference">Postman Sandbox API reference</a></p><h4 id="2-5-3、Pre-Request-Script"><a href="#2-5-3、Pre-Request-Script" class="headerlink" title="2.5.3、Pre Request Script"></a>2.5.3、Pre Request Script</h4><p>请求前执行该脚本，一般用于提前设置一些签名信息，上文提到过虽然 postman 将请求的信息暴露给了我们，但是我们并不能修改，那我们要如何才能够将我们生成的值放在请求之中呢？</p><p>答案是： 变量，如果签名信息仅在 header 之中使用，也可以直接插入新的 header 信息</p><p>下面我们来看一个例子</p><p>调用第三方服务的时候往往需要生成一个 Token 进行鉴权，这个示例会分别生成一个时间戳，以及利用自带的<code>CryptoJS</code>库进行<code>AES</code>加密签名，并且分别使用设置环境变量，新增 header 的方式注入到请求之中</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710224627.png" alt=""></p><pre><code class="hljs javascript"><span class="hljs-comment">// 从环境变量中获取密钥与appid</span><span class="hljs-keyword">let</span> secret = pm.environment.get(<span class="hljs-string">&quot;secret&quot;</span>);<span class="hljs-keyword">let</span> appid = pm.environment.get(<span class="hljs-string">&quot;appid&quot;</span>);<span class="hljs-comment">// 获取当前时间戳</span><span class="hljs-keyword">let</span> time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;time:&quot;</span>, time + <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// 直接向 Header 中插入一条新的记录</span>pm.request.headers.upsert(&#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;time&quot;</span>, <span class="hljs-attr">value</span>: time &#125;);<span class="hljs-comment">// 签名</span><span class="hljs-keyword">let</span> sign = CryptoJS.AES.encrypt(time + appid, secret);<span class="hljs-comment">// 设置环境变量</span>pm.environment.set(<span class="hljs-string">&quot;sign&quot;</span>, sign.ciphertext.toString().toUpperCase());</code></pre><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710224357.png" alt=""></p><h4 id="2-5-4、Test-Script"><a href="#2-5-4、Test-Script" class="headerlink" title="2.5.4、Test Script"></a>2.5.4、Test Script</h4><p>测试脚本和一半的单元测试大同小异，这里简要介绍比较常用和重要的两个功能，详细了解可以<a href="https://learning.getpostman.com/docs/postman/scripts/test_examples/">点击查看文档</a></p><ul><li><p>基本的测试语句</p><pre><code class="hljs javascript">pm.test(<span class="hljs-string">&quot;测试名称&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 断言</span>  pm.expect(pm.response.responseTime).to.be.below(<span class="hljs-number">200</span>);&#125;);</code></pre></li><li><p>流程控制，可以对 API 测试的顺序进行控制</p><pre><code class="hljs javascript"><span class="hljs-comment">// 设置下一个会被执行的请求</span>postman.setNextRequest(<span class="hljs-string">&quot;request_name&quot;</span>);<span class="hljs-comment">// 终端流程</span>postman.setNextRequest(<span class="hljs-literal">null</span>);</code></pre><p>运行一共有两种方式，分别是 Collection Run 以及 newman cli 执行， newman 会在后文的案例之中提到</p></li></ul><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190712004751.png" alt=""></p><p>可以看到执行结果详细的信息，也可以导出</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190712005755.png" alt=""></p><h3 id="2-6、API-代理"><a href="#2-6、API-代理" class="headerlink" title="2.6、API 代理"></a>2.6、API 代理</h3><blockquote><p>这个功能对于客户端调试的同学十分有用，可以通过 POSTMAN 提供的代理功能，将客户端的请求保存在历史记录或者是一个 Collection 中</p></blockquote><p>首先我们在 POSTMAN 进行如下设置，点击 Filters 还可以对请求的方法，URL 进行一些过滤的操作</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710225227.png" alt=""></p><p>接下来，以安卓手机为例，我们需要和电脑处于同一网段，并且在 WIFI 设置里加上代理</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/Screenshot_2019-07-11-23-43-13-112_com.android.se.png?x-oss-process=image/resize,h_600" alt=""></p><p>然后再到我们之前设置的 Collection 中就可以看到请求的记录了，如下图所示在手机上设置了代理之后访问了一下百度，所有的请求链接以及参数都会展示在 postman 中</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190711234614.png" alt=""></p><h3 id="2-7、☁️-API-文档"><a href="#2-7、☁️-API-文档" class="headerlink" title="2.7、☁️ API 文档"></a>2.7、☁️ API 文档</h3><blockquote><p>接下来，将会是云服务相关的功能，如果不能使用云服务这一趴可以跳过</p></blockquote><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710231728.png" alt=""></p><p>如图所示文档发布成功之后，即可看到文档的详情，已经 API 详情，并且右侧有代码生成器，可以直接复制对应的代码，十分方便</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710231917.png" alt=""></p><p>详细示例可以点击查看 <a href="https://documenter.getpostman.com/view/364695/RWaGUpsy?version=latest">We 川大 API</a> ，需要注意的是截止到文章发布时，postman 对免费账户文档有一定的限制每月公开文档只能有 1000 的访问</p><h3 id="2-8、☁️-Mock-Server"><a href="#2-8、☁️-Mock-Server" class="headerlink" title="2.8、☁️ Mock Server"></a>2.8、☁️ Mock Server</h3><p>同样十分的简单，右键 Collection 点击 mock 并按照如图所示，进行一些简单的配置即可，注意 mock server 的数据是请求的时候 save example 的数据，并且同样免费账户，一个月只能调用 1000 次 API，可以点击查看 <a href="https://documenter.getpostman.com/view/364695/RWaGUpsy?version=latest">We 川大 API</a> ，里面的文档示例就是使用的 Mock Server</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710232547.png" alt=""></p><h3 id="2-9、☁️-接口监控"><a href="#2-9、☁️-接口监控" class="headerlink" title="2.9、☁️ 接口监控"></a>2.9、☁️ 接口监控</h3><p>同样十分的简单，右键 Collection 点击 monitor collection 并按照如图所示进行一些配置，可以选择 频率，接口监控的位置，触发时间等字段</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710232823.png" alt=""></p><h3 id="2-10、☁️-Postman-API"><a href="#2-10、☁️-Postman-API" class="headerlink" title="2.10、☁️ Postman API"></a>2.10、☁️ Postman API</h3><p>除此之外 POSTMAN 还提供开放的 API 使其有更多的可能，如图所示获取 API Key，具体的使用请点<a href="https://docs.api.getpostman.com/?_ga=2.113542607.916957680.1562768130-1454391695.1559579723&amp;version=latest">击查看 API 文档</a>， 通过 API 我们可以实现一些自动化的操作，也可以自动生成文档，然后用 github pages 进行部署，不受账户限制等等，由于文章篇幅有限，这里就不展开讲了。</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710233355.png" alt=""></p><h2 id="三、使用案例"><a href="#三、使用案例" class="headerlink" title="三、使用案例"></a>三、使用案例</h2><h3 id="3-1、和-CI-CD-联动，进行接口自动化测试"><a href="#3-1、和-CI-CD-联动，进行接口自动化测试" class="headerlink" title="3.1、和 CI/CD 联动，进行接口自动化测试"></a>3.1、和 CI/CD 联动，进行接口自动化测试</h3><blockquote><p>postman 提供了一个命名行工具，newman, 通过它我们可以在我们的 CI /CD 的流程上加入接口自动化回归的流程，确保服务的稳定性</p></blockquote><p>接下来，我们以 gitlab ci/cd 为例，配置一个简单的接口回归</p><p>newman 具体的使用方法可以查看官方的文档或者是<a href="https://github.com/postmanlabs/newman">github 仓库</a>的介绍, 这里不再赘述，我们直接看一下简单的使用</p><p>首先是 <code>.gitlab-ci.yml</code> 的配置</p><pre><code class="hljs yaml"><span class="hljs-attr">stages:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">test</span><span class="hljs-attr">api_test:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">test</span>  <span class="hljs-attr">image:</span> <span class="hljs-string">node:11.15.0</span>  <span class="hljs-attr">before_script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">-g</span> <span class="hljs-string">newman</span>  <span class="hljs-attr">script:</span>    <span class="hljs-comment"># 此处执行的是官方的一个例子，run 后面可以是导出的Collection的文件，也可以是分享出来的Collection</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">newman</span> <span class="hljs-string">run</span> <span class="hljs-string">&quot;https://www.getpostman.com/collections/631643-f695cab7-6878-eb55-7943-ad88e1ccfd65-JsLv&quot;</span>  <span class="hljs-attr">tags:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">gitlab-org</span></code></pre><p>如下图所示我们可以看到具体的执行结果，返回的信息也比较详细，和上文的 Test Script 脚本结合就可以达到我们想要的接口回归测试的效果</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190712002216.png" alt=""></p><p><a href="https://gitlab.com/mohuishou/postman-ci/pipelines">点击可以查看这个 demo</a></p><h3 id="3-2、本地接口文档"><a href="#3-2、本地接口文档" class="headerlink" title="3.2、本地接口文档"></a>3.2、本地接口文档</h3><p>在上文我们有提到过，postman 的云文档比较好用，但是免费账户的限制比较大，并且很多时候在公司我们不能使用一些云的功能，这个时候，我们就可以通过导出 postman collection 并且使用一些第三方的工具，或者是自己实现一个接口文档的生成功能，来达到输出本地文档的目的</p><p>这里我们借助 <a href="https://github.com/thedevsaddam/docgen">docgen</a> 这个轮子来输出一份本地的文档，类似的工具还有许多，实现上也不复杂，如果有格式上的一些需求完全可以一两个小时的功夫造出一个还能用的小工具</p><pre><code class="hljs bash"><span class="hljs-comment"># 只需要导出json文件，就可以输出在线文档，或者是生成html，markdown 文件了</span>$ ./docgen.exe server -f We川大.postman_collection.json2019/07/12 00:30:51 Listening on port:  90002019/07/12 00:30:51 Web Server is available at http://localhost:9000/</code></pre><p>生成的效果如下图所示：</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190712003222.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章拖的稍微有点点久，内容有点超出最开始的预计，写的稍稍有点点多了，POSTMAN 还有需要有用的玩法，大家可以探索一下，除了上文讲到的之外，说一些我常用到的方式</p><ul><li>利用 collection run 批量提交请求，做一些批处理的工作</li><li>利用 pre request script 设置在 Collection 中，然后用不同的环境变量区分不同的项目，这种用在网关类的测试十分有</li></ul><p>文章比较长，感谢你的阅读</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://learning.getpostman.com/docs">Postman 官方文档，很全面，基本上所有的操作都能在上面找到</a></li><li><a href="https://haofly.net/postman/">Postman 高级用法</a></li><li><a href="https://www.twblogs.net/a/5bddb8542b717720b51ab853/zh-cn">Postman 高级应用（9）：API 收集神器——请求拦截</a></li><li><a href="https://documenter.getpostman.com/view/364695/RWaGUpsy?version=latest">We 川大 API</a></li><li><a href="https://github.com/postmanlabs/newman">newman</a></li><li><a href="https://gitlab.com/mohuishou/postman-ci/pipelines">gitlab ci demo</a></li><li><a href="https://github.com/thedevsaddam/docgen">docgen</a></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/38237.html">Go Web 小技巧（一）简化Gin接口代码</a></li><li><a href="https://lailin.xyz/post/41140.html">go generate and ast</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>tool</tag>
      
      <tag>postman</tag>
      
      <tag>api</tag>
      
      <tag>rest</tag>
      
      <tag>test</tag>
      
      <tag>gatway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go generate and ast</title>
    <link href="/post/41140.html"/>
    <url>/post/41140.html</url>
    
    <content type="html"><![CDATA[<h2 id="楔-xie-子"><a href="#楔-xie-子" class="headerlink" title="楔(xiē)子"></a>楔(xiē)子</h2><p>最近写<code>API CURD</code>比较多，为了结构清晰，返回值需要统一错误码，所以在一个统一的<code>errcode</code>包中定义错误码常量，以及其错误信息.</p><a id="more"></a><p>如下图所示，由于常量是导出字符 -&gt; <code>golint</code> 检测需要编写注释 -&gt; 注释信息其实就是错误信息，已经在下文的<code>msg map[int]string</code>中定义，如果在写就得写两遍</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/assets/20190507235621.png" alt=""></p><p>不写，就满屏波浪线，不能忍！</p><p>写了，就得<code>Copy</code>一份，还不利于维护，不能忍！</p><p>能不能只写一份注释，剩下的<code>msg</code>通过读取注释信息自动生成，将我们宝(hua)贵(diao)的生命，从这些重复繁杂无意义的劳动中解放出来。</p><p>为了实现这个<del>伟大的目标</del>, 需要以下两个关键的数据:</p><ol><li>解析源代码获取常量与注释之间的关系 -&gt; 🌲Go 抽象语法树: AST<sup><a href="https://golang.org/pkg/go/ast">[3]</a></sup></li><li>从 Go 源码生成 Go 代码 -&gt; 👏 go generate<sup><a href="https://blog.golang.org/generate">[5]</a></sup></li></ol><h2 id="👏-go-generate"><a href="#👏-go-generate" class="headerlink" title="👏 go generate"></a>👏 go generate</h2><p><code>golang</code>在<code>1.4</code>版本中引入了<code>go generate</code>命令，常用于文件生成，例如在 Golang 官方博客<sup><a href="https://blog.golang.org/generate">[5]</a></sup>中介绍的<a href="https://golang.org/x/tools/cmd/stringer">Stringer</a>可以为枚举自动实现<code>Stringer</code>的方法，从业务代码中解放出来</p><h3 id="💻-命令文档"><a href="#💻-命令文档" class="headerlink" title="💻 命令文档"></a>💻 命令文档</h3><p>使用<code>go help generate</code>我们可以查看一下命令的帮助文档</p><pre><code class="hljs bash">▶ go <span class="hljs-built_in">help</span> generateusage: go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]...</code></pre><p>解释很长，就不贴上来了，简要的概括一下:</p><ol><li><p>参数说明</p><ul><li>-run 正则表达式匹配命令行，仅执行匹配的命令(和<code>go test -run</code>类似)</li><li>-v 打印  已被检索处理的文件。</li><li>-n 打印出将被执行的命令，此时将不真实执行命令</li><li>-x 打印已执行的命令</li></ul></li><li><p>举个栗子</p><pre><code class="hljs bash"><span class="hljs-comment"># 对当前包下的Go文件进行处理, 并打印已被检索处理的文件。</span>go generate -v<span class="hljs-comment"># 打印当前目录下所有文件中将要被执行的命令(实际不会执行)</span>go generate -n ./...</code></pre></li><li><p><code>go generate</code>会扫描<code>.go</code>源码文件中的注释<code>//go:generate command args...</code>， 并且执行其命令，注意:</p><ul><li>这些命令是为了更新或者创建 Go 源文件</li><li><code>command</code>必须是可执行的指令，例如在 PATH 中或者使用绝对路径</li><li><code>arg</code>如果带引号会被识别成一个参数, 例如: <code>//go:generate command &quot;x1 x2&quot;</code>, 这条语句执行的命令只有一个参数</li><li><strong>注释中<code>//</code>和<code>go</code>之间没有空格</strong></li></ul></li><li><p><code>go generate</code>必须手动执行，如果想等着<code>go build</code>, <code>go test</code>, <code>go run</code> 命令执行的时候自动执行，可以洗洗睡了</p></li><li><p>为了让别人或者是 IDE 识别代码是通过<code>go generate</code>生成的，请在生成的代码中添加注释(一般放在文件开头)</p><pre><code class="hljs bash"><span class="hljs-comment"># PS: 这是一个正则表达式</span>^// Code generated .* DO NOT EDIT\.$</code></pre><p>举个栗子:</p><pre><code class="hljs go"><span class="hljs-comment">// Code generated by mohuishou DO NOT EDIT</span><span class="hljs-keyword">package</span> painkiller</code></pre></li><li><p><code>go generate</code>在执行的时候会自动注入以下环境变量:</p><pre><code class="hljs bash"><span class="hljs-variable">$GOARCH</span>系统架构: arm, amd64 等<span class="hljs-variable">$GOOS</span>操作系统: linux, windows 等<span class="hljs-variable">$GOFILE</span>当前执行的命令所处的文件名<span class="hljs-variable">$GOLINE</span>当前执行的命令在文件中的行号<span class="hljs-variable">$GOPACKAGE</span>执行的命令所处的文件的包名<span class="hljs-variable">$DOLLAR</span>$ 符号</code></pre><h3 id="🌰-Go-官方博客中给出的栗子"><a href="#🌰-Go-官方博客中给出的栗子" class="headerlink" title="🌰 Go 官方博客中给出的栗子"></a>🌰 Go 官方博客中给出的栗子</h3></li></ol><p>源文件: <code>painkiller.go</code></p><pre><code class="hljs go"><span class="hljs-comment">//go:generate stringer -type=Pill</span><span class="hljs-keyword">package</span> painkiller<span class="hljs-keyword">type</span> Pill <span class="hljs-keyword">int</span><span class="hljs-keyword">const</span> (    Placebo Pill = <span class="hljs-literal">iota</span>    Aspirin    Ibuprofen    Paracetamol    Acetaminophen = Paracetamol)</code></pre><p>执行命令</p><pre><code class="hljs bash">go generate</code></pre><p>生成文件: <code>painkiller_stringer.go</code></p><pre><code class="hljs go"><span class="hljs-comment">// generated by stringer -type Pill pill.go; DO NOT EDIT</span><span class="hljs-keyword">package</span> painkiller<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">const</span> _Pill_name = <span class="hljs-string">&quot;PlaceboAspirinIbuprofenParacetamol&quot;</span><span class="hljs-keyword">var</span> _Pill_index = [...]<span class="hljs-keyword">uint8</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">14</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i Pill)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || i+<span class="hljs-number">1</span> &gt;= Pill(<span class="hljs-built_in">len</span>(_Pill_index)) &#123;        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Pill(%d)&quot;</span>, i)    &#125;    <span class="hljs-keyword">return</span> _Pill_name[_Pill_index[i]:_Pill_index[i+<span class="hljs-number">1</span>]]&#125;</code></pre><p>从上面的 🌰，我们可以发现，在<code>.go</code>源文件中，添加了一行注释<code>go:generate stringer -type=Pill</code>, 执行命令<code>go generate</code>就调用<code>stringer</code>命令在同目录下生成了一个新的<code>_stringer.go</code>的文件</p><p>回想一下上文提到的需求，是不是感觉很类似，从 Go 源文件中，生成了一些不想重复写的业务逻辑</p><h2 id="🌲-AST"><a href="#🌲-AST" class="headerlink" title="🌲 AST"></a>🌲 AST</h2><p>回到前面的需求，我们需要从源代码中获取常量和注释之前的关系，这时就需要我们的 🌲AST 隆重登场了。</p><p>本文不对 AST 过多介绍，可以阅读参考资料中的 AST 标准库文档<sup><a href="https://golang.org/pkg/go/ast">[3]</a></sup>，Go 的 AST(抽象语法树)<sup><a href="https://zhuanlan.zhihu.com/p/28516587">[4]</a></sup></p><h3 id="简要介绍一下-AST-包"><a href="#简要介绍一下-AST-包" class="headerlink" title="简要介绍一下 AST 包"></a>简要介绍一下 AST 包</h3><p>基础的接口类型</p><pre><code class="hljs go"><span class="hljs-comment">// Node AST树节点</span><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">interface</span> &#123;  Pos() token.Pos  End() token.Pos&#125;<span class="hljs-comment">// Expr 所有的表达式都需要实现Expr接口</span><span class="hljs-keyword">type</span> Expr <span class="hljs-keyword">interface</span> &#123;  Node  exprNode()&#125;<span class="hljs-comment">// Stmt 所有的语句都需要实现Stmt接口</span><span class="hljs-keyword">type</span> Stmt <span class="hljs-keyword">interface</span> &#123;  Node  stmtNode()&#125;<span class="hljs-comment">// Decl 所有的声明都需要实现Decl接口</span><span class="hljs-keyword">type</span> Decl <span class="hljs-keyword">interface</span> &#123;  Node  declNode()&#125;</code></pre><p>等会儿可能会用到的<code>ValueSpec</code></p><pre><code class="hljs go"><span class="hljs-comment">// ValueSpec 表示常量声明或者变量声明</span><span class="hljs-keyword">type</span> ValueSpec <span class="hljs-keyword">struct</span> &#123;        Doc     *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span>        Names   []*Ident      <span class="hljs-comment">// value names (len(Names) &gt; 0)</span>        Type    Expr          <span class="hljs-comment">// value type; or nil</span>        Values  []Expr        <span class="hljs-comment">// initial values; or nil</span>        Comment *CommentGroup <span class="hljs-comment">// line comments; or nil</span>&#125;</code></pre><h3 id="CommentMap"><a href="#CommentMap" class="headerlink" title="CommentMap"></a>CommentMap</h3><p>在 godoc<sup><a href="https://golang.org/pkg/go/ast">[3]</a></sup>的 Example 中可以发现有一个<a href="https://golang.org/pkg/go/ast/#example_CommentMap">CommentMap</a>例子</p><pre><code class="hljs go"><span class="hljs-comment">// CommentMap把AST节点和其关联的注释列表进行映射</span><span class="hljs-keyword">type</span> CommentMap <span class="hljs-keyword">map</span>[Node][]*CommentGroup</code></pre><ol><li><p>通过<code>parse</code>读取源码创建一个 AST</p><pre><code class="hljs go">fset := token.NewFileSet() <span class="hljs-comment">// positions are relative to fset</span>f, err := parser.ParseFile(fset, <span class="hljs-string">&quot;src.go&quot;</span>, src, parser.ParseComments)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;</code></pre></li><li><p>从 AST 中新建一个<code>CommentMap</code></p><pre><code class="hljs go">cmap := ast.NewCommentMap(fset, f, f.Comments)</code></pre><h2 id="需求实现"><a href="#需求实现" class="headerlink" title="需求实现"></a>需求实现</h2></li></ol><h3 id="1-获取常量和注释的关联关系"><a href="#1-获取常量和注释的关联关系" class="headerlink" title="1. 获取常量和注释的关联关系"></a>1. 获取常量和注释的关联关系</h3><pre><code class="hljs go">file := os.Getenv(<span class="hljs-string">&quot;GOFILE&quot;</span>)<span class="hljs-comment">// 保存注释信息</span><span class="hljs-keyword">var</span> comments = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)<span class="hljs-comment">// 解析代码源文件，获取常量和注释之间的关系</span>fset := token.NewFileSet()f, err := parser.ParseFile(fset, file, <span class="hljs-literal">nil</span>, parser.ParseComments)checkErr(err)<span class="hljs-comment">// Create an ast.CommentMap from the ast.File&#x27;s comments.</span><span class="hljs-comment">// This helps keeping the association between comments</span><span class="hljs-comment">// and AST nodes.</span>cmap := ast.NewCommentMap(fset, f, f.Comments)<span class="hljs-keyword">for</span> node := <span class="hljs-keyword">range</span> cmap &#123;  <span class="hljs-comment">// 仅支持一条声明语句，一个常量的情况</span>  <span class="hljs-keyword">if</span> spec, ok := node.(*ast.ValueSpec); ok &amp;&amp; <span class="hljs-built_in">len</span>(spec.Names) == <span class="hljs-number">1</span> &#123;    <span class="hljs-comment">// 仅提取常量的注释</span>    ident := spec.Names[<span class="hljs-number">0</span>]    <span class="hljs-keyword">if</span> ident.Obj.Kind == ast.Con &#123;      <span class="hljs-comment">// 获取注释信息</span>      comments[ident.Name] = getComment(ident.Name, spec.Doc)    &#125;  &#125;&#125;</code></pre><h3 id="2-获取注释信息"><a href="#2-获取注释信息" class="headerlink" title="2. 获取注释信息"></a>2. 获取注释信息</h3><pre><code class="hljs go"><span class="hljs-comment">// getComment 获取注释信息，来自AST标准库的summary方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getComment</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, group *ast.CommentGroup)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">var</span> buf bytes.Buffer<span class="hljs-keyword">for</span> _, comment := <span class="hljs-keyword">range</span> group.List &#123;    <span class="hljs-comment">// 注释信息会以 // 参数名，开始，我们实际使用时不需要，去掉</span>text := strings.TrimSpace(strings.TrimPrefix(comment.Text, fmt.Sprintf(<span class="hljs-string">&quot;// %s&quot;</span>, name)))buf.WriteString(text)&#125;<span class="hljs-comment">// replace any invisibles with blanks</span>bytes := buf.Bytes()<span class="hljs-keyword">for</span> i, b := <span class="hljs-keyword">range</span> bytes &#123;<span class="hljs-keyword">switch</span> b &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\t&#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;\r&#x27;</span>:bytes[i] = <span class="hljs-string">&#x27; &#x27;</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(bytes)&#125;</code></pre><h3 id="3-生成代码"><a href="#3-生成代码" class="headerlink" title="3. 生成代码"></a>3. 生成代码</h3><pre><code class="hljs go"><span class="hljs-keyword">const</span> suffix = <span class="hljs-string">&quot;_msg_gen.go&quot;</span><span class="hljs-comment">// tpl 生成代码需要用到模板</span><span class="hljs-keyword">const</span> tpl = <span class="hljs-string">`</span><span class="hljs-string">// Code generated by github.com/mohuishou/gen-const-msg DO NOT EDIT</span><span class="hljs-string"></span><span class="hljs-string">// &#123;&#123;.pkg&#125;&#125; const code comment msg</span><span class="hljs-string">package &#123;&#123;.pkg&#125;&#125;</span><span class="hljs-string"></span><span class="hljs-string">// noErrorMsg if code is not found, GetMsg will return this</span><span class="hljs-string">const noErrorMsg = &quot;unknown error&quot;</span><span class="hljs-string"></span><span class="hljs-string">// messages get msg from const comment</span><span class="hljs-string">var messages = map[int]string&#123;</span><span class="hljs-string">&#123;&#123;range $key, $value := .comments&#125;&#125;</span><span class="hljs-string">&#123;&#123;$key&#125;&#125;: &quot;&#123;&#123;$value&#125;&#125;&quot;,&#123;&#123;end&#125;&#125;</span><span class="hljs-string">&#125;</span><span class="hljs-string"></span><span class="hljs-string">// GetMsg get error msg</span><span class="hljs-string">func GetMsg(code int) string &#123;</span><span class="hljs-string">var (</span><span class="hljs-string">msg string</span><span class="hljs-string">ok  bool</span><span class="hljs-string">)</span><span class="hljs-string">if msg, ok = messages[code]; !ok &#123;</span><span class="hljs-string">msg = noErrorMsg</span><span class="hljs-string">&#125;</span><span class="hljs-string">return msg</span><span class="hljs-string">&#125;</span><span class="hljs-string">`</span><span class="hljs-comment">// gen 生成代码</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gen</span><span class="hljs-params">(comments <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;  <span class="hljs-keyword">var</span> buf = bytes.NewBufferString(<span class="hljs-string">&quot;&quot;</span>)  data := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;    <span class="hljs-string">&quot;pkg&quot;</span>:      os.Getenv(<span class="hljs-string">&quot;GOPACKAGE&quot;</span>),    <span class="hljs-string">&quot;comments&quot;</span>: comments,  &#125;  t, err := template.New(<span class="hljs-string">&quot;&quot;</span>).Parse(tpl)  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.Wrapf(err, <span class="hljs-string">&quot;template init err&quot;</span>)  &#125;  err = t.Execute(buf, data)  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.Wrapf(err, <span class="hljs-string">&quot;template data err&quot;</span>)  &#125;  <span class="hljs-keyword">return</span> format.Source(buf.Bytes())&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从一个简单的效率需求引申到<code>go generate</code>和<code>ast</code>的使用，顺便阅读了一下<code>ast</code>的源码，花费的时间其实可能是这个工具节约的时间的几倍了，但是收获也是之前没有想到的。</p><ol><li>使用了这么久的<code>go</code>命令，详细的阅读了<code>go help command</code>的说明之后，发现之前可能连了解都算不上</li><li>标准库的<code>godoc</code>是最好的使用说明，第二好的是它的源代码</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://github.com/mohuishou/go-const-msg">go-const-msg 本文实现的源代码</a></p></li><li><p><a href="https://yushuangqi.com/blog/2017/go-command-generate.html">Golang Generate 命令说明与使用</a></p></li><li><p><a href="https://golang.org/pkg/go/ast/">AST 标准库文档</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/28516587">Go 的 AST(抽象语法树)</a></p></li><li><p><a href="https://blog.golang.org/generate">GO 官方博客: Generating code</a></p></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>generate</tag>
      
      <tag>ast</tag>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo-next-algolia-search全文搜索</title>
    <link href="/post/27142.html"/>
    <url>/post/27142.html</url>
    
    <content type="html"><![CDATA[<p>在 hexo 中通过 algolia 实现全文搜索</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>The latest version of the Hexo-Algolia plugin removes the content indexing feature, given Algolia’s free account limitation.</p></blockquote><p>通过主题官方的<a href="https://theme-next.org/docs/third-party-services/search-services">文档</a>我们发现，全文索引的功能已经被移除了，原因是因为会出现<code>Record Too Big</code>的报错，查阅 algolia 的<a href="https://www.algolia.com/doc/faq/basics/is-there-a-size-limit-for-my-index-records">文档</a>我们可以发现免费账号，单条索引的上限为<code>10kB</code>, 商业版用户的索引上限为<code>20KB</code></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><blockquote><p>请先按照上文提到的主题配置说明配置之后进行如下操作</p></blockquote><ol><li><p>替换插件</p><p>在<code>package.json</code>中替换下面这一行</p><pre><code class="hljs json">&quot;hexo-algolia&quot;: &quot;https://github.com/mohuishou/hexo-algolia&quot;</code></pre></li><li><p>修改主题文件<code>themes\next\source\js\algolia-search.js</code></p><p>将<code>instantsearch.widgets.hits</code>方法中, item 对应的返回值替换为以下内容</p><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> (  <span class="hljs-string">&#x27;&lt;a href=&quot;&#x27;</span> +  link +  <span class="hljs-string">&#x27;&quot; class=&quot;algolia-hit-item-link&quot;&gt;&#x27;</span> +  <span class="hljs-string">&#x27;&lt;div class=&quot;algolia-hit-item-title&quot;&gt;&#x27;</span> +  data._highlightResult.title.value +  <span class="hljs-string">&quot;&lt;/div&gt;&quot;</span> +  <span class="hljs-string">&#x27;&lt;div class=&quot;algolia-hit-item-content&quot;&gt;&#x27;</span> +  data._snippetResult.raw.value +  <span class="hljs-string">&quot;&lt;/div&gt;&quot;</span> +  <span class="hljs-string">&quot;&lt;/a&gt;&quot;</span>);</code></pre><p>这两步做完其实就已经完成的了全文索引，但是搜索结果会把所有内容返回，我们其实只需要匹配关键词附近的结果</p></li><li><p>开启 Attributes to snippet 特性</p><p>如下图所示点击索引-&gt;配置， 然后再到左侧列表中选中<code>Snippeting</code></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190410234147.png" alt=""></p><p>然后如图所示添加字段<code>raw</code>, 右侧为显示的字符数，可以根据需求修改</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190410234453.png" alt=""></p><p>到这里就大功告成了，但是关键词还不够突出，可以再做一些美化</p></li><li><p>美化搜索结果</p><p>在<code>source/_data</code>中新增<code>styles.styl</code>文件</p><pre><code class="hljs css"><span class="hljs-selector-tag">em</span> &#123;  <span class="hljs-attribute">color</span>: red;  <span class="hljs-attribute">font-style</span>: normal;&#125;<span class="hljs-selector-class">.algolia-hit-item-title</span> &#123;  <span class="hljs-attribute">font-weight</span>: bold;&#125;<span class="hljs-selector-class">.algolia-hit-item-content</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.8em</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#555</span>;&#125;</code></pre><p>修改<code>_config.yml</code></p><pre><code class="hljs yaml"><span class="hljs-attr">theme_config:</span>  <span class="hljs-attr">custom_file_path:</span>    <span class="hljs-attr">styles:</span> <span class="hljs-string">source/_data/styles.styl</span></code></pre><p>ok! 大功告成</p></li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ol><li><p>优化前:</p><blockquote><p>随意找了一个博客的截图，显示只有标题，没有的高亮以及详情<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190411000323.png" alt=""></p></blockquote></li><li><p>优化后:<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190410235215.png" alt=""></p></li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>原理其实很简单，获取文章原始<code>markdown</code>内容，判断大小如果超过指定大小(默认 8K)就进行截断</p><pre><code class="hljs javascript"><span class="hljs-comment">// 获取原始内容</span><span class="hljs-keyword">var</span> rawBuf = <span class="hljs-keyword">new</span> Buffer(data.raw);<span class="hljs-comment">// 获取大小限制</span><span class="hljs-keyword">var</span> rowSize = options.maxRawSize * <span class="hljs-number">1024</span>;<span class="hljs-keyword">if</span> (rawBuf.length &gt; rowSize) &#123;  <span class="hljs-comment">// 超出限制，进行截断</span>  storedPost.raw = rawBuf.toString(<span class="hljs-string">&quot;utf8&quot;</span>, <span class="hljs-number">0</span>, rowSize);  <span class="hljs-comment">// 去除最后一个字符</span>  <span class="hljs-comment">// 由于截断是按照字节截断的，但是一个中文字符不止一个字节，可能会导致最后一个字符乱码</span>  storedPost.raw = storedPost.raw.substring(<span class="hljs-number">0</span>, storedPost.raw.length - <span class="hljs-number">1</span>);&#125;</code></pre><p>详情可以查看 PR: <a href="https://github.com/oncletom/hexo-algolia/pull/39/files">Feature/add raw max len</a></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/51252.html">docker镜像瘦身&优化</a></li><li><a href="https://lailin.xyz/post/60163.html">GORM避坑指南之含关联关系的更新</a></li><li><a href="https://lailin.xyz/post/28054.html">Github Actions介绍&自动构建Github Pages博客</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
      <tag>next</tag>
      
      <tag>algolia</tag>
      
      <tag>search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker镜像瘦身&amp;优化</title>
    <link href="/post/51252.html"/>
    <url>/post/51252.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>为什么在存储如此便宜的今天我们仍然需要对 Docker 镜像进行瘦身?</p></blockquote><a id="more"></a><blockquote><p>PS: 本文篇幅较长，请酌情观看</p></blockquote><h2 id="小镜像的优点"><a href="#小镜像的优点" class="headerlink" title="小镜像的优点"></a>小镜像的优点</h2><ol><li><p>加速构建/部署</p><p>虽然存储资源较为廉价，但是网络 IO 是有限的，在带宽有限的情况下，部署一个 1G 的镜像和 10M 的镜像带来的时间差距可能就是分钟级和秒级的差距。特别是在<strong>出现故障</strong>，服务被调度到其他节点时，这个时间尤为宝贵。</p></li><li><p>提高安全性，减少攻击面积</p><p>越小的镜像表示无用的程序越少，可以大大的减少被攻击的目标</p></li><li><p>减少存储开销</p></li></ol><h2 id="小镜像的制作原则"><a href="#小镜像的制作原则" class="headerlink" title="小镜像的制作原则"></a>小镜像的制作原则</h2><ol><li><p>选用最小的基础镜像</p></li><li><p>减少层，去除非必要的文件</p><p>在实际制作镜像的过程中，一味的合并层不可取，需要学会充分的利用 Docker 的缓存机制，提取公共层，加速构建。</p><ul><li><strong>依赖文件和实际的代码文件单独分层</strong></li><li><strong>团队/公司采用公共的基础镜像等</strong></li></ul></li><li><p>使用多阶段构建</p><p>往往我们在构建阶段和实际运行阶段需要的依赖环境是不同的，例如<code>golang</code>编写的程序实际运行的时候仅仅需要一个二进制文件即可，对于<code>Node</code>来说，可能最后运行的只是一些打包之后的<code>js</code>文件而不需要包含<code>node_modules</code>里成千上万的依赖</p></li></ol><h2 id="基础镜像"><a href="#基础镜像" class="headerlink" title="基础镜像"></a>基础镜像</h2><ul><li><p><a href="https://github.com/GoogleCloudPlatform/distroless">distroless</a></p><blockquote><p>“Distroless” images contain only your application and its runtime dependencies. They do not contain package managers, shells or any other programs you would expect to find in a standard Linux distribution.</p></blockquote><p><code>distroless</code>是 Google 推出的一个仅仅包含运行时环境，不包含包管理器，<code>shell</code>等其他程序。如果你的程序没有其他依赖的话，这是一个不错的选择</p></li><li><p><a href="https://hub.docker.com/_/alpine">alpine</a></p><blockquote><p>Alpine Linux is a security-oriented, lightweight Linux distribution based on musl libc and busybox.</p></blockquote><p>alpine 是一个基于<code>musl</code>, <code>busybox</code>的安全的<code>linux</code>发行版。麻雀虽小五脏俱全，虽然不到 10M, 但是包含了一个包管理器和<code>shell</code>环境，这在我们实际的使用调试当中将非常有用。</p><p>但是请注意，由于<code>alpine</code>使用了更小的<code>muslc</code>替代<code>glibc</code>，会导致某些应用无法使用，需要重新编译</p></li><li><p><a href="https://hub.docker.com/_/scratch">scratch</a></p><p>scratch 是空白镜像，一般用于基础镜像构建，例如<code>alpine</code>镜像的<code>dockerfile</code>便是从<code>scratch</code>开始的</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> scratch<span class="hljs-keyword">ADD</span><span class="bash"> alpine-minirootfs-20190228-x86_64.tar.gz /</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/bin/sh&quot;</span>]</span></code></pre></li><li><a href="https://hub.docker.com/_/busybox">busybox</a></li></ul><p>一般而言，<code>distroless</code>相对会更加的安全，但是在实际使用的过程中可能会遇到添加依赖以及调试方面的问题，<code>alpine</code>更小，自带包管理器，更加贴合使用习惯，但是<code>muslc</code>可能会带来兼容性的问题，一般而言我会选择<code>alpine</code>作为基础镜像使用。</p><p>除此之外，在<a href="https://hub.docker.com">Docker Hub</a>当中我们可以发现常用的<code>Debian</code>的镜像也会提供的只包含基础功能的小镜像</p><h3 id="基础镜像对比"><a href="#基础镜像对比" class="headerlink" title="基础镜像对比"></a>基础镜像对比</h3><p>此处直接拉取基础镜像，查看镜像大小， 通过观察我们可以发现，<code>alpine</code>只有 5M 左右为<code>debian</code>的 20 分之一</p><pre><code class="hljs bash">alpine      latest    5cb3aa00f899        3 weeks ago         5.53MBdebian      latest    0af60a5c6dd0        3 weeks ago         101MBubuntu      18.04     47b19964fb50        7 weeks ago         88.1MBubuntu      latest    47b19964fb50        7 weeks ago         88.1MBalpine      3.8       3f53bb00af94        3 months ago        4.41MB</code></pre><p>似乎从上面看，感觉差距不大，实践中，不同语言的基础镜像都会提供一些采用不同基础镜像制作的 tag，下面我们以<code>ruby</code>的镜像为例，查看不同基础镜像的差异。可以看到默认的 latest 镜像<code>881MB</code>而<code>alpine</code>仅仅只有不到<code>50MB</code>这个差距就十分的可观了</p><pre><code class="hljs bash">ruby   latest   a5d26127d8d0        4 weeks ago         881MBruby   alpine   8d8f7d19d1fa        4 weeks ago         47.8MBruby   slim     58dd4d3c99da        4 weeks ago         125MB</code></pre><h2 id="减少层，去除非必要的文件"><a href="#减少层，去除非必要的文件" class="headerlink" title="减少层，去除非必要的文件"></a>减少层，去除非必要的文件</h2><ol><li>删除文件不要跨行</li></ol><pre><code class="hljs dockerfile"><span class="hljs-comment"># dockerfile 1</span><span class="hljs-keyword">FROM</span> alpine<span class="hljs-keyword">RUN</span><span class="bash"> wget https://github.com/mohuishou/scuplus-wechat/archive/1.0.0.zip</span><span class="hljs-comment"># dockerfile 2</span><span class="hljs-keyword">FROM</span> alpine<span class="hljs-keyword">RUN</span><span class="bash"> wget https://github.com/mohuishou/scuplus-wechat/archive/1.0.0.zip</span><span class="hljs-keyword">RUN</span><span class="bash"> rm 1.0.0.zip</span><span class="hljs-comment"># dockerfile 3</span><span class="hljs-keyword">FROM</span> alpine<span class="hljs-keyword">RUN</span><span class="bash"> wget https://github.com/mohuishou/scuplus-wechat/archive/1.0.0.zip &amp;&amp;  rm 1.0.0.zip</span></code></pre><pre><code class="hljs bash"><span class="hljs-built_in">test</span>   3  351a80e99c22        5 seconds ago        5.53MB<span class="hljs-built_in">test</span>   2  ad27e625b8e5        49 seconds ago       6.1MB<span class="hljs-built_in">test</span>   1  165e2e0df1d3        About a minute ago   6.1MB</code></pre><p>可以发现 1，2 两个大小一样，但是 3 小了 0.5MB，这是因为 docker 几乎每一行命令都会生成一个层，删除文件的时候：因为底下各层都是只读的，当需要删除这些层中的文件时，AUFS 使用 whiteout 机制，它的实现是通过在上层的可写的目录下建立对应的 whiteout 隐藏文件来实现的，所以在当前层去删除上一层的文件，只是会把这个文件隐藏掉罢了</p><ol start="2"><li>使用单行命令</li></ol><p>除了删除语句需要放在一行以外，由于层的机制，我们安装依赖的一些公共的语句最好也使用条<code>RUN</code>命令生成，减少最终的层数</p><ol start="3"><li><p>分离依赖包，以及源代码程序，充分利用层的缓存</p><p>这是一个<strong>最佳实践</strong>，在实际的开发过程中，我们的依赖包往往是变动不大的，但是我们正在开发的源码的变动是较为频繁，如果我们实际的代码只有<code>10M</code>，但是依赖项有<code>1G</code>, 如果在<code>COPY</code>的时候直接<code>COPY . .</code>会导致每次修改代码都会时这一层的缓存失效，导致浪费复制以及推送到镜像仓库的时间，将 COPY 语句分开，每次 push 就可以只变更我们频繁修改的代码层，而不是连着依赖一起</p></li><li><p>使用<code>.dockerignore</code></p><p>在使用<code>Git</code>时，我们可以通过<code>.gitignore</code>忽略文件，在 docker build 的时候也可以使用<code>.dockerignore</code>在 Docker 上下文中忽略文件，这样不仅可以减少一些非必要文件的导入，也可以提高安全性，避免将一些配置文件打包到镜像中</p></li></ol><h2 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h2><p>多阶段构建其实也是减少层的一种，通过多阶段构建，最终镜像可以仅包含最后生成的可执行文件，和必须的运行时依赖，大大减少镜像体积。</p><p>以<code>GO</code>语言为例，实际运行的过程中只需要最后编译生成的二进制文件即可，而<code>GO</code>语言本省以及扩展包，代码文件都是不必要的，但是我们在编译的时候这些依赖又是必须的，这时候就可以使用多阶段构建的方式，减少最终生成的镜像体积</p><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用golang镜像作为builder镜像</span><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.12</span> as builder<span class="hljs-keyword">WORKDIR</span><span class="bash"> /go/src/github.com/go/helloworld/</span><span class="hljs-keyword">COPY</span><span class="bash"> app.go .</span><span class="hljs-keyword">RUN</span><span class="bash"> go build -o app .</span><span class="hljs-comment"># 编译完成之后使用alpine镜像作为最终的基础镜像</span><span class="hljs-keyword">FROM</span> alpine:latest as prod<span class="hljs-keyword">RUN</span><span class="bash"> apk --no-cache add ca-certificates</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /root/</span><span class="hljs-comment"># 从builder中复制编译好的二进制文件</span><span class="hljs-keyword">COPY</span><span class="bash"> --from=builder /go/src/github.com/go/helloworld/app .</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;./app&quot;</span>]</span></code></pre><p>由于本文篇幅较长，这里不对多阶段构建展开讲解，详情可以参考<a href="https://yeasy.gitbooks.io/docker_practice/image/multistage-builds/#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">多阶段构建</a></p><h2 id="奇淫技巧"><a href="#奇淫技巧" class="headerlink" title="奇淫技巧"></a>奇淫技巧</h2><ol><li><p>使用<a href="https://github.com/wagoodman/dive">dive</a>查看 docker 镜像的层，可以帮助你分析减少镜像体积</p></li><li><p>使用<a href="https://github.com/docker-slim/docker-slim">docker-slim</a> 可以自动帮助你减少镜像体积，对于 Web 应用较为有用</p></li><li><p>安装软件时去除依赖</p></li></ol><pre><code class="hljs bash"><span class="hljs-comment"># ubuntu</span>apt-get install -y — no-install-recommends<span class="hljs-comment">#alpine</span>apk add --no-cache &amp;&amp;  apk del build-dependencies<span class="hljs-comment"># centos</span>yum install -y ... &amp;&amp; yum clean all</code></pre><ol start="4"><li><p>使用<code>--flatten</code>参数，减少层(不推荐)</p></li><li><p>使用<a href="https://github.com/jwilder/docker-squash">docker-squash</a>压缩层</p></li></ol><h2 id="不同语言的示例"><a href="#不同语言的示例" class="headerlink" title="不同语言的示例"></a>不同语言的示例</h2><blockquote><p>添加中……</p></blockquote><h3 id="Ruby-Rails"><a href="#Ruby-Rails" class="headerlink" title="Ruby(Rails)"></a>Ruby(Rails)</h3><ol><li><p>只安装生产所需的依赖</p></li><li><p>删除不需要的依赖文件</p></li></ol><pre><code class="hljs bash">bundle install --without development:<span class="hljs-built_in">test</span>:assets -j4 --retry 3 --path=vendor/bundle \    <span class="hljs-comment"># Remove unneeded files (cached *.gem, *.o, *.c)</span>    &amp;&amp; rm -rf vendor/bundle/ruby/2.5.0/cache/*.gem \    &amp;&amp; find vendor/bundle/ruby/2.5.0/gems/ -name <span class="hljs-string">&quot;*.c&quot;</span> -delete \    &amp;&amp; find vendor/bundle/ruby/2.5.0/gems/ -name <span class="hljs-string">&quot;*.o&quot;</span> -delete</code></pre><ol start="3"><li>删除前端的<code>node_modules</code>以及缓存文件</li></ol><pre><code class="hljs bash">rm -rf node_modules tmp/cache app/assets vendor/assets spec</code></pre><p>上述内容可以结合<strong>多阶段构建</strong>实现</p><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>Golang 在使用多阶段构建之后，只剩下了一个二进制文件，这时候再要优化，就只有使用<code>upx</code>之类的工具压缩二进制文件的体积了</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://dockone.io/article/8174">Docker 容器镜像瘦身的三个小窍门</a></li><li><a href="https://liulantao.com/docker-base-images.html">基础镜像 | 再谈 Docker 瘦身</a></li><li><a href="https://legacy.gitbook.com/book/yeasy/docker_practice/details">Docker —— 从入门到实践</a>这是一本很不错的 Docker 开源书</li><li><a href="https://jingwei.link/2018/07/18/docker-namespace-cgroups-aufs.html#aufs">Docker 基本原理简析</a></li><li><a href="https://medium.com/@lemuelbarango/ruby-on-rails-smaller-docker-images-bff240931332">Ruby on Rails — Smaller docker images</a></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/27142.html">hexo-next-algolia-search全文搜索</a></li><li><a href="https://lailin.xyz/post/60163.html">GORM避坑指南之含关联关系的更新</a></li><li><a href="https://lailin.xyz/post/28054.html">Github Actions介绍&自动构建Github Pages博客</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>docker</tag>
      
      <tag>cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GORM避坑指南之含关联关系的更新</title>
    <link href="/post/60163.html"/>
    <url>/post/60163.html</url>
    
    <content type="html"><![CDATA[<p>在 GORM 的<a href="http://gorm.io/docs/update.html">文档</a>当中有说明，使用<code>Update</code>, <code>Updates</code>时只会更新改变的字段，但是出现关联关系的时候情况似乎有了一些微妙的变化</p><blockquote><p>If you only want to update changed Fields, you could use <code>Update</code>, <code>Updates</code></p></blockquote><a id="more"></a><h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><p><code>db.Model(&amp;user).Update(&quot;name&quot;, &quot;hello&quot;)</code>如果<code>user</code>包含关联关系，<code>user</code>的关联关系将被自动更新</p><h2 id="避坑"><a href="#避坑" class="headerlink" title="避坑"></a>避坑</h2><p><strong>1.如果确认不会使用到关联相关的回调，可以直接使用<code>UpdateColumn</code>,<code>UpdateColumns</code>方法</strong></p><p>下面是来自<a href="http://gorm.io/docs/update.html#Update-Columns-w-o-Hooks">官方文档</a>的例子:</p><pre><code class="hljs go"><span class="hljs-comment">// Update single attribute, similar with `Update`</span>db.Model(&amp;user).UpdateColumn(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>)<span class="hljs-comment">//// UPDATE users SET name=&#x27;hello&#x27; WHERE id = 111;</span><span class="hljs-comment">// Update multiple attributes, similar with `Updates`</span>db.Model(&amp;user).UpdateColumns(User&#123;Name: <span class="hljs-string">&quot;hello&quot;</span>, Age: <span class="hljs-number">18</span>&#125;)<span class="hljs-comment">//// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id = 111;</span></code></pre><p><strong>2.如果需要用到相关的回调，可以手动指定<code>Model</code>里面的结构体</strong></p><pre><code class="hljs go">db.Model(&amp;User&#123;Model: Model&#123;ID: <span class="hljs-number">1</span>&#125;&#125;).UpdateColumn(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>)</code></pre><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>下面这一段是官方文档中的例子，只会更新更新<code>users</code>表的<code>name</code>字段</p><pre><code class="hljs go"><span class="hljs-comment">// Update single attribute if it is changed</span>db.Model(&amp;user).Update(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>)<span class="hljs-comment">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></code></pre><p>但是如果<code>Model(&amp;struct)</code>,<code>struct</code>包含关联关系时，<code>struct</code>关联关系将被更新，如以下所示:</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Product <span class="hljs-keyword">struct</span> &#123;gorm.ModelCode         <span class="hljs-keyword">string</span>Price        <span class="hljs-keyword">uint</span>Applications []Application&#125;<span class="hljs-keyword">type</span> Application <span class="hljs-keyword">struct</span> &#123;gorm.ModelName      <span class="hljs-keyword">string</span>ProductID <span class="hljs-keyword">uint</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// Migrate the schema</span>db.AutoMigrate(&amp;Product&#123;&#125;, &amp;Application&#123;&#125;)<span class="hljs-comment">// Create</span>db.Create(&amp;Product&#123;Code: <span class="hljs-string">&quot;L1212&quot;</span>, Price: <span class="hljs-number">1000</span>&#125;)<span class="hljs-comment">// Read</span><span class="hljs-keyword">var</span> product Productdb.First(&amp;product, <span class="hljs-number">1</span>) <span class="hljs-comment">// find product with id 1</span>product.Applications = []Application&#123;&#123;Name: <span class="hljs-string">&quot;test&quot;</span>,&#125;,&#125;<span class="hljs-comment">// Update - update product&#x27;s price to 2000</span>db.Model(&amp;product).Update(<span class="hljs-string">&quot;Price&quot;</span>, <span class="hljs-number">1000</span>)    <span class="hljs-comment">// UPDATE products SET price = &#x27;1000&#x27;, updated_at = &#x27;2019-01-29 21:58:52&#x27;  WHERE products.deleted_at IS NULL</span><span class="hljs-comment">// INSERT INTO applications (created_at,updated_at,deleted_at,name,product_id) VALUES (&#x27;2019-01-29 21:58:52&#x27;,&#x27;2019-01-29 21:58:52&#x27;,NULL,&#x27;test&#x27;,&#x27;0&#x27;)</span>&#125;</code></pre><h2 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h2><blockquote><p>该部分默认对 GORM 的源码有一定的了解</p></blockquote><p>查看<code>Model</code>相关的源码，我们可以发现<code>Model</code>其实就是<code>clone</code>了一个<code>DB</code>对象然后将传入的指针赋值给<code>Value</code></p><pre><code class="hljs go"><span class="hljs-comment">// Model specify the model you would like to run db operations</span><span class="hljs-comment">//    // update all users&#x27;s name to `hello`</span><span class="hljs-comment">//    db.Model(&amp;User&#123;&#125;).Update(&quot;name&quot;, &quot;hello&quot;)</span><span class="hljs-comment">//    // if user&#x27;s primary key is non-blank, will use it as condition, then will only update the user&#x27;s name to `hello`</span><span class="hljs-comment">//    db.Model(&amp;user).Update(&quot;name&quot;, &quot;hello&quot;)</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *DB)</span> <span class="hljs-title">Model</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> *<span class="hljs-title">DB</span></span> &#123;c := s.clone()c.Value = value<span class="hljs-keyword">return</span> c&#125;</code></pre><p>查看<code>Update/Updates</code>相关的源码我们可以发现，这里讲需要更新的字段通过<code>InstanceSet(&quot;gorm:update_interface&quot;, values)</code>保存了下来</p><pre><code class="hljs go"><span class="hljs-comment">// Update update attributes with callbacks, refer: https://jinzhu.github.io/gorm/crud.html#update</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *DB)</span> <span class="hljs-title">Update</span><span class="hljs-params">(attrs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> *<span class="hljs-title">DB</span></span> &#123;<span class="hljs-keyword">return</span> s.Updates(toSearchableMap(attrs...), <span class="hljs-literal">true</span>)&#125;<span class="hljs-comment">// Updates update attributes with callbacks, refer: https://jinzhu.github.io/gorm/crud.html#update</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *DB)</span> <span class="hljs-title">Updates</span><span class="hljs-params">(values <span class="hljs-keyword">interface</span>&#123;&#125;, ignoreProtectedAttrs ...<span class="hljs-keyword">bool</span>)</span> *<span class="hljs-title">DB</span></span> &#123;<span class="hljs-keyword">return</span> s.NewScope(s.Value).Set(<span class="hljs-string">&quot;gorm:ignore_protected_attrs&quot;</span>, <span class="hljs-built_in">len</span>(ignoreProtectedAttrs) &gt; <span class="hljs-number">0</span>).InstanceSet(<span class="hljs-string">&quot;gorm:update_interface&quot;</span>, values).callCallbacks(s.parent.callbacks.updates).db&#125;</code></pre><p>再看看关联关系更新的代码， 只有一个参数<code>scope</code>,<code>scope</code>哪儿来的呢，上面的<code>s.NewScope(s.Value)</code>,这个地方其实也是将最开始<code>Model</code>中的 <code>value</code>拷贝了一份</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">saveAfterAssociationsCallback</span><span class="hljs-params">(scope *Scope)</span></span> &#123;    <span class="hljs-comment">// 判断是否存在关系关系然后更新bala bala...</span>    <span class="hljs-keyword">for</span> _, field := <span class="hljs-keyword">range</span> scope.Fields() &#123;autoUpdate, autoCreate, saveReference, relationship := saveAssociationCheck(scope, field)        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-comment">//...</span>&#125;</code></pre><p>看到这个了差不多就可明白了，主要原因是因为<code>Model</code>的<code>value</code>一直跟随到了最后，导致最后执行关联关系更新回调的时候，检测到有关联数据数据表中不存在，就会自然的根据关联关系插入进去</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ol><li>目前还不清楚这是一个 bug 还是一个 feature，先提交了一个 issue: <a href="https://github.com/jinzhu/gorm/issues/2278">https://github.com/jinzhu/gorm/issues/2278</a></li><li><a href="https://lailin.xyz/post/notes/%E4%B8%80%E4%B8%AA%E5%8D%81%E5%88%86%E8%BE%B9%E7%BC%98%E7%9A%84gorm%E7%9A%84bug/">一个十分边缘的 gorm 的 bug</a></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>go</tag>
      
      <tag>note</tag>
      
      <tag>gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github Actions介绍&amp;自动构建Github Pages博客</title>
    <link href="/post/28054.html"/>
    <url>/post/28054.html</url>
    
    <content type="html"><![CDATA[<p>本文将主要讲述如何创建一个自定义的 Github Actions， 并且使用 Github Actions 完成 CI/CD 的操作</p><a id="more"></a><blockquote><p>故事的起因就是，github 的私有仓库免费了, 打算将 blog 仓库切换为私有仓库，这样可以同时将笔记和博客放在一块，利用 hugo 的 draft 功能，将不想发布的文章设置 true 即可。</p><p>修改之后由于之前使用 Travis CI 自动构建博客的静态页面，而 Travis CI 对于私有仓库只能试用 100 次，正好之前获得了 Github Actions 的测试资格，但是一直都还没有使用过，本次记录一下 Github Actions 的使用过程</p></blockquote><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>actions 可以用来作为 CI/CD 使用，但是它不只是 CI/CD，因为它其实是一组 docker 容器所组成的 Workflow，Workflow 的触发条件，公共仓库目前仅支持 push，私有仓库则支持 check_run、create、delete、issue comment， commit comment, pull request 等许多事件, 通过这些事件，可以完成除了 CI/CD 之外的许多自动化操作，例如接收到 issue comment 之后使用 telegram bot 发送通知等等</p><h3 id="创建一个-Workflow"><a href="#创建一个-Workflow" class="headerlink" title="创建一个 Workflow"></a>创建一个 Workflow</h3><p>如果你有权限的话，在你的仓库下应该可以看到一个 Actions 的菜单</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190115223805.png" alt=""></p><h3 id="Workflow-GUI"><a href="#Workflow-GUI" class="headerlink" title="Workflow GUI"></a>Workflow GUI</h3><p>如下图所示</p><ol><li>切换视图，从左到右分别是，GUI 的方式编辑，直接编辑文件，查看变动</li><li>workflow 区域，一个 main.workflow 文件下可以包含多个 workflow，每一个 workflow</li><li>每个 workflow 具体的编辑区域，每个 workflow 可以关联多个 action，每个 action 都有头尾两个点，点击下拉即可连接起来</li><li>保存提交按钮</li></ol><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190115224518.png" alt=""></p><h4 id="Workflow-edit"><a href="#Workflow-edit" class="headerlink" title="Workflow edit"></a>Workflow edit</h4><p>如下图所示，workflow 只有两个可选的修改项，分别是 Name 以及触发条件，触发条件公共仓库目前仅支持 push，私有仓库则支持 check_run、create、delete、issue comment， commit comment, pull request 等许多事件。完整的触发条件可以查看 <a href="https://developer.github.com/actions/creating-workflows/workflow-configuration-options/#events-supported-in-workflow-files">Events supported in workflow files</a></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190115230105.png" alt=""></p><h4 id="action-edit"><a href="#action-edit" class="headerlink" title="action edit"></a>action edit</h4><p>如下图所示</p><ol><li>uses 使用的 docker 镜像, 在 <a href="https://github.com/actions">https://github.com/actions</a> 提供了一些常用的 actions 可以直接使用<ol><li><code>&#123;user&#125;/&#123;repo&#125;/&#123;path&#125;@&#123;ref&#125;</code> 直接使用公开的仓库，仓库里必须包含 dockerfile, path 为可选项，没有 path 默认为根路径，e.g <code>actions/heroku@master</code>, <a href="mailto:`actions/aws/ec2@v2.0.1">`actions/aws/ec2@v2.0.1</a>`</li><li><code>./path/to/dir</code>当前仓库的相对路径</li><li><code>docker://&#123;host&#125;/&#123;image&#125;:&#123;tag&#125;</code> docker 镜像地址，host 为可选项，不填 host 默认从 dockerhub 拉取，e.g <code>docker://mohuishou/hugo:0.53</code>, <code>docker://gcr.io/cloud-builders/gradle</code></li></ol></li><li>label 就是标签</li><li>runs 覆盖 dockerfile 中的 entrypoint</li><li>args 覆盖 dockerfile 中的 cmd</li><li>secret 读取该仓库保存的秘密变量，将以环境变量的形式注入到运行的容器中</li><li>env 注入到运行的容器中的环境变量，是可见的</li></ol><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190116000345.png" alt=""></p><h3 id="创建-Action"><a href="#创建-Action" class="headerlink" title="创建 Action"></a>创建 Action</h3><p>Action 其实就是 Docker 镜像，按照 Docker 镜像的写法即可，需要关注以下几点</p><h4 id="1-Dockerfile-Lables"><a href="#1-Dockerfile-Lables" class="headerlink" title="1. Dockerfile Lables"></a>1. Dockerfile Lables</h4><p>github actions 会读取 dockerfile 的 label 在 Workflow GUI 上做一些展示</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">&quot;com.github.actions.name&quot;</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">#Github action 的名字</span></span><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">&quot;com.github.actions.description&quot;</span>=<span class="hljs-string">&quot;desc&quot;</span> <span class="hljs-comment">#说明</span></span><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">&quot;com.github.actions.icon&quot;</span>=<span class="hljs-string">&quot;mic&quot;</span> <span class="hljs-comment">#GUI上展示的图标</span></span><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">&quot;com.github.actions.color&quot;</span>=<span class="hljs-string">&quot;purple&quot;</span> <span class="hljs-comment"># GUI上展示的颜色</span></span><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">&quot;repository&quot;</span>=<span class="hljs-string">&quot;http://github.com/mohuishou/hugo-action&quot;</span> <span class="hljs-comment"># 仓库地址</span></span><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">&quot;homepage&quot;</span>=<span class="hljs-string">&quot;http://github.com/mohuishou&quot;</span> <span class="hljs-comment"># 主页</span></span><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">&quot;maintainer&quot;</span>=<span class="hljs-string">&quot;mohuishou &lt;1@lailin.xyz&gt;&quot;</span> <span class="hljs-comment"># 作者</span></span></code></pre><h4 id="2-Env"><a href="#2-Env" class="headerlink" title="2. Env"></a>2. Env</h4><p>默认的环境变量，以及如何读取</p><h5 id="默认环境变量"><a href="#默认环境变量" class="headerlink" title="默认环境变量"></a>默认环境变量</h5><p>所有的默认值可以参考这里 <a href="https://developer.github.com/actions/creating-github-actions/accessing-the-runtime-environment/#environment-variables">Environment variables</a></p><p>常用的主要有</p><table><thead><tr><th>Environment variable</th><th>Description</th></tr></thead><tbody><tr><td><code>GITHUB_ACTOR</code></td><td>用户的名字</td></tr><tr><td><code>GITHUB_REPOSITORY</code></td><td>用户和仓库的地址 例如 <code>mohuishou/hugo-action</code></td></tr><tr><td><code>GITHUB_WORKSPACE</code></td><td>github 的工作区， 默认值为 <code>/github/workspace</code></td></tr><tr><td><code>GITHUB_TOKEN</code></td><td>workflow 的 github token 可以用来 clone 拉取数据，但是没有 push 的权限</td></tr></tbody></table><h5 id="读取环境变量"><a href="#读取环境变量" class="headerlink" title="读取环境变量"></a>读取环境变量</h5><p>读取环境变量时需要注意，环境变量是在容器运行时注入的，所以在 dockerfile 里面没有办法直接使用</p><h2 id="使用-hugo-action-自动-build-amp-push-博客"><a href="#使用-hugo-action-自动-build-amp-push-博客" class="headerlink" title="使用 hugo-action 自动 build&amp;push 博客"></a>使用 hugo-action 自动 build&amp;push 博客</h2><p><a href="https://github.com/mohuishou/hugo-action">https://github.com/mohuishou/hugo-action</a></p><h3 id="遵循以下约定"><a href="#遵循以下约定" class="headerlink" title="遵循以下约定"></a>遵循以下约定</h3><ol><li>你的博客源代码地址和 github pages 地址不同</li><li>github pages 仓库地址为 <code>youname.github.io</code></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>创建文件 <code>.github/main.workflow</code></p><pre><code class="hljs bash">workflow <span class="hljs-string">&quot;blog ci/cd&quot;</span> &#123;  on = <span class="hljs-string">&quot;push&quot;</span>  resolves = [<span class="hljs-string">&quot;hugo&quot;</span>]&#125;action <span class="hljs-string">&quot;hugo&quot;</span> &#123;  uses = <span class="hljs-string">&quot;docker://mohuishou/hugo-action:0.53&quot;</span>  secrets = [    <span class="hljs-string">&quot;TOKEN&quot;</span>,  ]  env = &#123;    EMAIL = <span class="hljs-string">&quot;1@lailin.xyz&quot;</span>  &#125;&#125;</code></pre><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><table><thead><tr><th>Key</th><th>Value</th><th>Must</th></tr></thead><tbody><tr><td>TOKEN</td><td>你的 github token，需要有 push 权限，保存在密码变量中</td><td>yes</td></tr><tr><td>EMAIL</td><td>你的邮箱</td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://developer.github.com/actions/">官方文档</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/TODO1/introducing-github-actions.md">GitHub Actions 介绍，了解一下？</a></li><li><a href="https://github.com/actions">Github Actions Repo</a></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/27142.html">hexo-next-algolia-search全文搜索</a></li><li><a href="https://lailin.xyz/post/51252.html">docker镜像瘦身&优化</a></li><li><a href="https://lailin.xyz/post/60163.html">GORM避坑指南之含关联关系的更新</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在blog中内嵌在线PPT</title>
    <link href="/post/7944.html"/>
    <url>/post/7944.html</url>
    
    <content type="html"><![CDATA[<p>有时我们会做一些分享，分享之后可以把 PPT 脱敏之后放在博客上面，可以使用 office online 直接内嵌 PPT, 巨硬大法好</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>在线播放</li><li>支持动画</li><li>支持播放内嵌视频</li><li>自适应</li></ol><p>上面的需求, WPS 云文档支持 1, 以及一些简单的动画，Office online 支持 1,2,3 第四点我们可以通过一个简单 js 脚本解决</p><h2 id="获取分享链接"><a href="#获取分享链接" class="headerlink" title="获取分享链接"></a>获取分享链接</h2><p>1.登录 <a href="https://onedrive.live.com">https://onedrive.live.com</a> 上传需要分享的 PPT 2.如下图所示 打开刚刚上传的 PPT 文件<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/assets/20181208165037.png?x-oss-process=image/resize,w_800" alt=""></p><p>3.点击右上角的文件 -&gt; 共享 -&gt; 嵌入<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/assets/20181208170149.png?x-oss-process=image/resize,w_800" alt=""></p><p>4.获取分享链接，将代码中的分享链接复制<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/assets/20181208170334.png?x-oss-process=image/resize,w_800" alt=""></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;这里是你的分享链接&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;350px&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;221px&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span></span><span class="hljs-tag">  &gt;</span>这是嵌入  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://office.com&quot;</span>&gt;</span>Microsoft Office<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 演示文稿，由  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://office.com/webapps&quot;</span>&gt;</span>Office Online<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  支持。<span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></code></pre><p>5.修改代码自适应，将上一步获取到的链接替换到下方代码中，复制粘贴到博客中即可</p><pre><code class="hljs html">&lt;iframe  id=&quot;ppt&quot;  width=&quot;100%&quot;  onload=&quot;autoChange()&quot;  src=&quot;在此处替换为你的PPT链接&quot;  frameborder=&quot;0&quot;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">autoChange</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-keyword">let</span> ifm = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;ppt&quot;</span>);</span>    ifm.height = (ifm.clientWidth / 16) * 9 + 24;  &#125;<span class="javascript">  <span class="hljs-built_in">window</span>.onresize = autoChange;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="https://lailin.xyz/post/notes/pprof-go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/">https://lailin.xyz/post/notes/pprof-go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Office Online 对于 PPT 支持相当的好，唯一的缺点可能就是在国内有些的确被墙，可能需要 FQ 才能访问</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/27142.html">hexo-next-algolia-search全文搜索</a></li><li><a href="https://lailin.xyz/post/51252.html">docker镜像瘦身&优化</a></li><li><a href="https://lailin.xyz/post/60163.html">GORM避坑指南之含关联关系的更新</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次net http内存泄漏</title>
    <link href="/post/44107.html"/>
    <url>/post/44107.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>使用 gin 作为文件下载服务器，内存占用突然从几十 M 到了 10G 以上，导致服务被 kill 重启</p></blockquote><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><code>server.go</code></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;r := gin.Default()r.GET(<span class="hljs-string">&quot;/download&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;f, err := os.Open(<span class="hljs-string">&quot;./win7.iso&quot;</span>)log.Println(err)<span class="hljs-keyword">defer</span> f.Close()info, _ := f.Stat()b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, info.Size())f.Read(b)context.Data(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;application/octet-stream&quot;</span>, b)&#125;)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;log.Println(http.ListenAndServe(<span class="hljs-string">&quot;localhost:6060&quot;</span>, <span class="hljs-literal">nil</span>))&#125;()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;time.Sleep(time.Second * <span class="hljs-number">30</span>)runtime.GC()log.Println(<span class="hljs-string">&quot;gc&quot;</span>)&#125;&#125;()runtime.MemProfileRate = <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)&#125;</code></pre><p><code>client.go</code></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;resp, _ := http.Get(<span class="hljs-string">&quot;http://localhost:8080/download&quot;</span>)resp.Body.Close()log.Println(<span class="hljs-string">&quot;ok&quot;</span>)<span class="hljs-keyword">select</span> &#123;&#125;&#125;</code></pre><p>使用<code>pprof</code>我们可以发现内存占用高达<code>3GB</code>, 即使我主动调用了 GC 这个内存仍未释放</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/assets/profile001.gif" alt=""></p><h2 id="追溯"><a href="#追溯" class="headerlink" title="追溯"></a>追溯</h2><p>通过查看代码我们可以发现请求已经结束，代码并没有其他地方对<code>[]byte</code>引用，一直追溯到最低层也不见其他引用。</p><p>但是结束<code>client</code>进程之后会有一个神奇的发现，结束 client 之后这一块内存就可以被 GC 掉</p><p>通过这个现象自然而然的就想到可能是 TCP 链接没有断开，导致这一块内存的引用并没有被释放掉</p><p>http 是一个本身是短连接，但是为了复用 TCP 连接所以有了<code>keep-alive</code>，但是对于下载服务来说我们其实不用复用 TCP 连接，只需要在文件下载完毕之后主动关闭这个连接即可，所以我分别在 client 加上了一个 header</p><pre><code class="hljs pgsql"><span class="hljs-keyword">Connection</span>: <span class="hljs-keyword">close</span></code></pre><p>再次通过<code>pprof</code>查看内存占用发现内存仍未得到释放</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>通过 rfc 文档，我们可以发现规范并没有规定由谁来关闭链接，Go net/http 希望客户端关闭链接</p><p><a href="https://tools.ietf.org/html/rfc2616#page-117">https://tools.ietf.org/html/rfc2616#page-117</a></p><blockquote><p>HTTP/1.1 defines the “close” connection option for the sender to signal that the connection will be closed after completion of the response.</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li>使用流而不是直接读内存，在<code>gin</code>中不要直接使用<code>c.Data</code>而是使用<code>c.DataFromReader</code></li><li>使用 AWS S3 等存储服务下发文件，减轻服务压力</li><li>尽量不使用官方的<code>net/http</code>处理文件</li><li><a href="https://jiajunhuang.com">@jiajun 老师</a> 已经给 Go 官方提了一个 <a href="https://github.com/golang/go/pull/28936">PR</a>，等待 PR Merge</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://jiajunhuang.com/articles/2018_11_24-memory_leak_in_net_http.md.html">https://jiajunhuang.com/articles/2018_11_24-memory_leak_in_net_http.md.html</a></li><li><a href="https://tools.ietf.org/html/rfc2616">https://tools.ietf.org/html/rfc2616</a></li><li><a href="https://lailin.xyz/post/notes/pprof-go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/">https://lailin.xyz/post/notes/pprof-go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</a></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>notes</tag>
      
      <tag>内存泄漏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pprof go性能分析工具</title>
    <link href="/post/40393.html"/>
    <url>/post/40393.html</url>
    
    <content type="html"><![CDATA[<p>PPT 分享(可能需要 FQ 方能访问，需要可以访问, onedrive.live.com)</p><a id="more"></a><iframe id="ppt" width="100%" onload="changeFrameHeight()"  src="https://onedrive.live.com/embed?cid=9B44A0E26836C4FF&amp;resid=9B44A0E26836C4FF%211837&amp;authkey=AAoxyFlzZ39JQvM&amp;em=2&amp;wdAr=1.7777777777777777" frameborder="0">这是嵌入 <a target="_blank" href="https://office.com">Microsoft Office</a> 演示文稿，由 <a target="_blank" href="https://office.com/webapps">Office Online</a> 支持。</iframe><script>function changeFrameHeight(){    var ifm= document.getElementById("ppt");    console.log(ifm.width)    ifm.height=ifm.clientWidth / 16 * 9 + 24;}window.onresize = changeFrameHeight</script><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/27142.html">hexo-next-algolia-search全文搜索</a></li><li><a href="https://lailin.xyz/post/51252.html">docker镜像瘦身&优化</a></li><li><a href="https://lailin.xyz/post/60163.html">GORM避坑指南之含关联关系的更新</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用TravisCI自动部署Blog</title>
    <link href="/post/52061.html"/>
    <url>/post/52061.html</url>
    
    <content type="html"><![CDATA[<p>之前博客的更新一直都是在本地运行<code>hugo</code>然后手动 push 到 github 仓库，虽然写了一个小脚本，但是本地还是多了一个 public 文件夹，最近看了 travis ci 可以和 github 完美的结合。关于 travis ci 不过多介绍，感兴趣的可以直接看官方文档，写的非常详细</p><pre><code class="hljs yaml"><span class="hljs-comment"># 指定运行语言为go</span><span class="hljs-attr">language:</span> <span class="hljs-string">go</span><span class="hljs-comment"># 指定go语言版本</span><span class="hljs-attr">go:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;1.10.x&quot;</span><span class="hljs-comment"># 安装依赖，安装hugo</span><span class="hljs-attr">install:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">wget</span> <span class="hljs-string">https://github.com/gohugoio/hugo/releases/download/v0.49/hugo_0.49_Linux-64bit.tar.gz</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">tar</span> <span class="hljs-string">-xzvf</span> <span class="hljs-string">hugo_0.49_Linux-64bit.tar.gz</span><span class="hljs-comment"># 在script执行前执行，设置git用户名，邮箱，从github把blog文件拉下来</span><span class="hljs-attr">before_script:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.email</span> <span class="hljs-string">&quot;1@lailin.xyz&quot;</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.name</span> <span class="hljs-string">&quot;mohuishou&quot;</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">clone</span> <span class="hljs-string">https://$GITHUB_TOKEN@github.com/mohuishou/mohuishou.github.io.git</span> <span class="hljs-string">public</span>  <span class="hljs-comment"># clone 主题</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">clone</span> <span class="hljs-string">https://github.com/laozhu/hugo-nuo</span> <span class="hljs-string">themes/hugo-nuo</span><span class="hljs-comment"># 生成静态网页</span><span class="hljs-attr">script:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">./hugo</span><span class="hljs-comment"># 运行成功之后将页面推送到github上</span><span class="hljs-attr">after_success:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">public</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">add</span> <span class="hljs-string">.</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">commit</span> <span class="hljs-string">-m</span> <span class="hljs-string">&#x27;travis auto update&#x27;</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">-u</span> <span class="hljs-string">origin</span> <span class="hljs-string">master</span></code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/28054.html">Github Actions介绍&自动构建Github Pages博客</a></li><li><a href="https://lailin.xyz/post/44107.html">记一次net http内存泄漏</a></li><li><a href="https://lailin.xyz/post/37449.html">一个十分边缘的gorm的bug</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>notes</tag>
      
      <tag>ci</tag>
      
      <tag>hugo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Goland调试Go程序</title>
    <link href="/post/37623.html"/>
    <url>/post/37623.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>在上一篇 Blog 当中发现了一个十分边缘的 GORM 的 bug，由于不熟悉工具，bug 的调试过程还是比较麻烦，这一篇讲一讲如何使用 Goland 强大的 debug 功能调试 Go 程序</p></blockquote><a id="more"></a><h2 id="Goland"><a href="#Goland" class="headerlink" title="Goland"></a>Goland</h2><p>Goland 是 jb 公司的 Go 语言 IDE，和 jb 家族的其他 IDE 一样的强大并且吃内存</p><p>下载地址: <a href="https://www.jetbrains.com/go">https://www.jetbrains.com/go</a></p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>如下图所示，在<code>main</code>函数或者是单元测试函数的旁边会出现一个执行的按钮<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141140.jpg" alt=""><br>在屏幕的右上角也可以看见一个小虫子的按钮，点击就可以开始 debug<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141151.jpg" alt=""></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>如下图所示，点击 Edit 打开配置窗口<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141152.jpg" alt=""><br>如下图所示，可以对当前的运行命令进行配置，或者点击下方 templates，对模板配置，修改模板配置，在当前项目之后再点击 go run 时，会自动采用模板的配置<br>配置可以对文件，环境变量，运行命令等进行配置，一般用的比较多的就是环境变量<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141153.jpg" alt=""></p><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>如图所示点击行号和代码之间的空白即可添加断点<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141154.jpg" alt=""><br>如图所示，右键点击红点，可以对断点进行一些高级的设定<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141155.jpg" alt=""><br>点击 more 会出现如下弹窗<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141156.jpg" alt=""></p><h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>点击 Debug 开始运行之后，会出现一个 debug 窗口，当前的窗口是 console 窗口<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141157.jpg" alt=""><br>点击 debugger 可以看到整个程序的调用栈，点击相应的调用栈可以调转的相应的代码，并且显示当前的变量信息<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141158.jpg" alt=""><br>如图所示可以在当前栈，执行相应的命令，但是暂时还不支持执行方法，只能查看变量或者是调用变量的属性<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141159.jpg" alt=""></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个十分边缘的gorm的bug</title>
    <link href="/post/37449.html"/>
    <url>/post/37449.html</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="复现代码"><a href="#复现代码" class="headerlink" title="复现代码"></a>复现代码</h2><p>这个代码的触发条件比较严苛，首先必须要保证 gorm 执行的一行必须为<code>updates</code>语句，并且在<code>updates(struct)</code>,并且传入的这个<code>struct</code>必须要包含一个直接或者间接关联的一个多态表，这些条件缺一不可</p><a id="more"></a><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;gorm.ModelName <span class="hljs-keyword">string</span>B    B <span class="hljs-string">`gorm:&quot;polymorphic:Owner&quot;`</span>&#125;<span class="hljs-keyword">type</span> B <span class="hljs-keyword">struct</span> &#123;gorm.ModelOwnerID   <span class="hljs-keyword">uint</span>OwnerType <span class="hljs-keyword">string</span>&#125;a := A&#123;Name: <span class="hljs-string">&quot;test&quot;</span>&#125;db = db.Model(&amp;a)db.Where(a)db.Updates(A&#123;Name: <span class="hljs-string">&quot;test2&quot;</span>&#125;) <span class="hljs-comment">// panic</span></code></pre><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>先说现象，在一次代码联调的过程当中，发现调用一个更新接口的时候会报 500 错误（panic），但是在什么都不修改的情况下，再次调用接口，更新成功</p><p>错误日志如下，是由于一个空指针的调用:</p><pre><code class="hljs go"><span class="hljs-built_in">panic</span>: runtime error: invalid memory address or <span class="hljs-literal">nil</span> pointer dereferencegithub.com/jinzhu/gorm.(*DB).clone(<span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">715</span> +<span class="hljs-number">0x4e</span>github.com/jinzhu/gorm.(*DB).Model(<span class="hljs-number">0x0</span>, <span class="hljs-number">0x6cb460</span>, <span class="hljs-number">0xc00017c160</span>, <span class="hljs-number">0x0</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">445</span> +<span class="hljs-number">0x32</span>github.com/jinzhu/gorm.(*Scope).TableName(<span class="hljs-number">0xc000172100</span>, <span class="hljs-number">0xc00016c3c0</span>, <span class="hljs-number">0x6f894a</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.<span class="hljs-keyword">go</span>:<span class="hljs-number">325</span> +<span class="hljs-number">0x133</span>github.com/jinzhu/gorm.(*Scope).GetModelStruct.func2(<span class="hljs-number">0xc000170010</span>, <span class="hljs-number">0xc000172100</span>, <span class="hljs-number">0xc00017a050</span>, <span class="hljs-number">0xc0001749c0</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/model_struct.<span class="hljs-keyword">go</span>:<span class="hljs-number">420</span> +<span class="hljs-number">0x24c7</span>github.com/jinzhu/gorm.(*Scope).GetModelStruct(<span class="hljs-number">0xc000172100</span>, <span class="hljs-number">0xc00017a050</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/model_struct.<span class="hljs-keyword">go</span>:<span class="hljs-number">574</span> +<span class="hljs-number">0x140c</span>github.com/jinzhu/gorm.(*Scope).Fields(<span class="hljs-number">0xc000172100</span>, <span class="hljs-number">0xc000172100</span>, <span class="hljs-number">0x2030000</span>, <span class="hljs-number">0x2030000</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.<span class="hljs-keyword">go</span>:<span class="hljs-number">115</span> +<span class="hljs-number">0xaf</span>github.com/jinzhu/gorm.convertInterfaceToMap(<span class="hljs-number">0x6cb460</span>, <span class="hljs-number">0xc00017c160</span>, <span class="hljs-number">0xc00017c001</span>, <span class="hljs-number">0x199</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.<span class="hljs-keyword">go</span>:<span class="hljs-number">860</span> +<span class="hljs-number">0x4f8</span>github.com/jinzhu/gorm.(*Scope).updatedAttrsWithValues(<span class="hljs-number">0xc000172080</span>, <span class="hljs-number">0x6cb460</span>, <span class="hljs-number">0xc00017c160</span>, <span class="hljs-number">0x6cb460</span>, <span class="hljs-number">0xc00017c160</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.<span class="hljs-keyword">go</span>:<span class="hljs-number">877</span> +<span class="hljs-number">0x8b</span>github.com/jinzhu/gorm.assignUpdatingAttributesCallback(<span class="hljs-number">0xc000172080</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/callback_update.<span class="hljs-keyword">go</span>:<span class="hljs-number">25</span> +<span class="hljs-number">0x81</span>github.com/jinzhu/gorm.(*Scope).callCallbacks(<span class="hljs-number">0xc000172080</span>, <span class="hljs-number">0xc00012ff00</span>, <span class="hljs-number">0x9</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0xc00017c160</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.<span class="hljs-keyword">go</span>:<span class="hljs-number">831</span> +<span class="hljs-number">0x5c</span>github.com/jinzhu/gorm.(*DB).Updates(<span class="hljs-number">0xc00017e090</span>, <span class="hljs-number">0x6cb460</span>, <span class="hljs-number">0xc00017c160</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xc00017e090</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">383</span> +<span class="hljs-number">0x13b</span>main.main()E:/SoftFile/GOPATH/src/github.com/mohuishou/test/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">34</span> +<span class="hljs-number">0x269</span></code></pre><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>首先从 panic 的堆栈顶端往下看, 是调用<code>s.db</code>的时候报的错，推断应该是<code>s</code>的值为<code>nil</code>导致的错误</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *DB)</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span> *<span class="hljs-title">DB</span></span> &#123;db := &amp;DB&#123;db:                s.db, <span class="hljs-comment">// 从这一行开始panic</span>    &#125;&#125;</code></pre><p>接着往下看，这里的<code>s</code>应该也是一个<code>nil</code></p><pre><code class="hljs go"><span class="hljs-comment">// Model specify the model you would like to run db operations</span><span class="hljs-comment">//    // update all users&#x27;s name to `hello`</span><span class="hljs-comment">//    db.Model(&amp;User&#123;&#125;).Update(&quot;name&quot;, &quot;hello&quot;)</span><span class="hljs-comment">//    // if user&#x27;s primary key is non-blank, will use it as condition, then will only update the user&#x27;s name to `hello`</span><span class="hljs-comment">//    db.Model(&amp;user).Update(&quot;name&quot;, &quot;hello&quot;)</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *DB)</span> <span class="hljs-title">Model</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> *<span class="hljs-title">DB</span></span> &#123;c := s.clone() <span class="hljs-comment">// 从这里调用</span>c.Value = value<span class="hljs-keyword">return</span> c&#125;</code></pre><p>接着走, 在获取表名的时候，需要调用<code>scope.db.Model</code>， 这里的 db 应该是一个<code>nil</code>导致调用失败</p><pre><code class="hljs go"><span class="hljs-comment">// TableName return table name</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(scope *Scope)</span> <span class="hljs-title">TableName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;    <span class="hljs-comment">// ...</span><span class="hljs-keyword">return</span> scope.GetModelStruct().TableName(scope.db.Model(scope.Value))&#125;</code></pre><p>从下面的调用，可以看到，实在获取<code>Struct</code>的结构的时候，由于有多态关联(<code>polymorphic</code>)的 tag，所以需要获取多态表的<code>TableName</code></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(scope *Scope)</span> <span class="hljs-title">GetModelStruct</span><span class="hljs-params">()</span> *<span class="hljs-title">ModelStruct</span></span> &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> polymorphic := field.TagSettings[<span class="hljs-string">&quot;POLYMORPHIC&quot;</span>]; polymorphic != <span class="hljs-string">&quot;&quot;</span> &#123;        <span class="hljs-keyword">if</span> value, ok := field.TagSettings[<span class="hljs-string">&quot;POLYMORPHIC_VALUE&quot;</span>]; ok &#123;            relationship.PolymorphicValue = value        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 这里调用</span>            relationship.PolymorphicValue = scope.TableName()        &#125;    &#125;&#125;</code></pre><p>调用<code>GetModelStruct</code>的原因是因为需要获取<code>value</code>的所有字段，字段等于 nil 的时候，就会调用<code>GetModelStruct</code>去获取</p><pre><code class="hljs go"><span class="hljs-comment">// Fields get value&#x27;s fields</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(scope *Scope)</span> <span class="hljs-title">Fields</span><span class="hljs-params">()</span> []*<span class="hljs-title">Field</span></span> &#123;<span class="hljs-keyword">if</span> scope.fields == <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// ...</span><span class="hljs-keyword">for</span> _, structField := <span class="hljs-keyword">range</span> scope.GetModelStruct().StructFields &#123;            <span class="hljs-comment">// ...</span>        &#125;    &#125;&#125;</code></pre><p>看这个函数可以发现，会把<code>interface</code>转为<code>map</code>, 由于我们最开始传入的是<code>db.Updates(A&#123;Name: &quot;test2&quot;&#125;)</code>条件是一个 struct 所以会执行下面<code>case interface&#123;&#125; -&gt; default</code>分支。此时会调用<code>(&amp;Scope&#123;Value: values&#125;).Fields()</code>，这时候可以发现<code>Scope</code>这个对象在初始话的时候是没有<code>db</code>这个字段的，所以在获取 table name 的时候需要调用到<code>scope.db</code>这时候就会 panic</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convertInterfaceToMap</span><span class="hljs-params">(values <span class="hljs-keyword">interface</span>&#123;&#125;, withIgnoredField <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">map</span>[<span class="hljs-title">string</span>]<span class="hljs-title">interface</span></span>&#123;&#125; &#123;<span class="hljs-keyword">var</span> attrs = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;&#125;<span class="hljs-keyword">switch</span> value := values.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;:<span class="hljs-keyword">return</span> value<span class="hljs-keyword">case</span> []<span class="hljs-keyword">interface</span>&#123;&#125;:<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> value &#123;<span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> convertInterfaceToMap(v, withIgnoredField) &#123;attrs[key] = value&#125;&#125;<span class="hljs-keyword">case</span> <span class="hljs-keyword">interface</span>&#123;&#125;:reflectValue := reflect.ValueOf(values)<span class="hljs-keyword">switch</span> reflectValue.Kind() &#123;<span class="hljs-keyword">case</span> reflect.Map:<span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> reflectValue.MapKeys() &#123;attrs[ToDBName(key.Interface().(<span class="hljs-keyword">string</span>))] = reflectValue.MapIndex(key).Interface()&#125;<span class="hljs-keyword">default</span>:<span class="hljs-comment">// 在这里调用</span><span class="hljs-keyword">for</span> _, field := <span class="hljs-keyword">range</span> (&amp;Scope&#123;Value: values&#125;).Fields() &#123;<span class="hljs-keyword">if</span> !field.IsBlank &amp;&amp; (withIgnoredField || !field.IsIgnored) &#123;attrs[field.DBName] = field.Field.Interface()&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> attrs&#125;</code></pre><p>到这里这个 bug 就算结案了，但是接着看看，为什么会调用这个函数.</p><p>这个函数会获取需要更新的字段<code>map</code>,如果传入的是一个<code>struct</code>，会转换为<code>map</code></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(scope *Scope)</span> <span class="hljs-title">updatedAttrsWithValues</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(results <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, hasUpdate <span class="hljs-keyword">bool</span>)</span></span> &#123;<span class="hljs-keyword">if</span> scope.IndirectValue().Kind() != reflect.Struct &#123;<span class="hljs-keyword">return</span> convertInterfaceToMap(value, <span class="hljs-literal">false</span>), <span class="hljs-literal">true</span>&#125;results = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;&#125;<span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> convertInterfaceToMap(value, <span class="hljs-literal">true</span>) &#123;&#125;&#125;</code></pre><p>这个方法会把获取到需要更新的 map 保存下来</p><pre><code class="hljs go"><span class="hljs-comment">// assignUpdatingAttributesCallback assign updating attributes to model</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assignUpdatingAttributesCallback</span><span class="hljs-params">(scope *Scope)</span></span> &#123;<span class="hljs-keyword">if</span> attrs, ok := scope.InstanceGet(<span class="hljs-string">&quot;gorm:update_interface&quot;</span>); ok &#123;<span class="hljs-keyword">if</span> updateMaps, hasUpdate := scope.updatedAttrsWithValues(attrs); hasUpdate &#123;scope.InstanceSet(<span class="hljs-string">&quot;gorm:update_attrs&quot;</span>, updateMaps)&#125; <span class="hljs-keyword">else</span> &#123;scope.SkipLeft()&#125;&#125;&#125;</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><a href="https://github.com/jinzhu/gorm/pull/2105">https://github.com/jinzhu/gorm/pull/2105</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="GORM，使用-map-而不是-struct"><a href="#GORM，使用-map-而不是-struct" class="headerlink" title="GORM，使用 map 而不是 struct"></a>GORM，使用 map 而不是 struct</h3><p>在使用的 GORM 的时候，需要更新一些字段的时候<strong>最好使用 map 而不是 struct</strong>，因为如果使用 struct，gorm 最终会把这个 struct 转换为 map，并且如果这个 struct 包含一些关联关系，gorm 会一直递归的查找转换下去，如果整个表的关联关系比较复杂，会导致效率比较低下</p><h3 id="为什么不需要修改代码，第二次运行就不会-panic"><a href="#为什么不需要修改代码，第二次运行就不会-panic" class="headerlink" title="为什么不需要修改代码，第二次运行就不会 panic"></a>为什么不需要修改代码，第二次运行就不会 panic</h3><p>这是由于 GORM 会对 struct 的结构有一个全局的缓存<code>modelStructsMap</code>，由于这个是因为查找关联关系的时候报错，其本身已经新建了一个<code>modelstruct</code>并且缓存了下来，所以再次调用的时候就不会执行后面的代码了</p><pre><code class="hljs go"><span class="hljs-comment">// GetModelStruct get value&#x27;s model struct, relationships based on struct and tag definition</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(scope *Scope)</span> <span class="hljs-title">GetModelStruct</span><span class="hljs-params">()</span> *<span class="hljs-title">ModelStruct</span></span> &#123;<span class="hljs-comment">//...</span><span class="hljs-comment">// Get Cached model struct</span><span class="hljs-keyword">if</span> value := modelStructsMap.Get(reflectType); value != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> value&#125;<span class="hljs-comment">// ...</span>&#125;</code></pre><h3 id="调试总结"><a href="#调试总结" class="headerlink" title="调试总结"></a>调试总结</h3><p>调试的过程比写来的要艰辛很多，由于调试的时候是从自身的代码开始，通过<code>Goland</code>的 debug 不断的打断点，一遍一遍的执行，查找整个执行的过程，导致忽略了最直接找到错误代码的方式。</p><p>不过这也是一个宝贵的经历，这个 Bug 调试结束之后，<code>Goland</code>强大的调试功能已经可以玩的比较 6 了</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>gorm</tag>
      
      <tag>notes</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Httprouter介绍及源码阅读</title>
    <link href="/post/44029.html"/>
    <url>/post/44029.html</url>
    
    <content type="html"><![CDATA[<p>在上一篇文章当中阅读了 Go 语言的一个高性能的 Web 框架 Gin，Web 框架当中最重要的功能之一是路由，Gin 的路由就是由 httprouter 这个包实现的</p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><ul><li><a href="https://github.com/julienschmidt/httprouter">https://github.com/julienschmidt/httprouter</a></li><li><a href="https://godoc.org/github.com/julienschmidt/httprouter">https://godoc.org/github.com/julienschmidt/httprouter</a></li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>基于基数树实现的高性能路由框架</li><li>仅支持精确匹配</li><li>不必关心 URL 结尾的斜线</li><li>路径自动校正，例如在 url 路径当中有<code>../</code>,<code>//</code>的时候</li><li>可以在 URL 当中设置参数，例如<code>/user/:id</code></li><li>零内存分配</li><li>不存在服务器崩溃，可以通过设置<code>panic handler</code>使服务器从 panic 当中恢复</li><li>适合 API 构建</li></ul><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h3><p>解决两个问题，就基本明白了这个路由框架</p><ul><li>路由是是如何注册？如何保存的？</li><li>当请求到来之后，路由是如何匹配，如何查找的？</li></ul><h3 id="一个-Demo"><a href="#一个-Demo" class="headerlink" title="一个 Demo"></a>一个 Demo</h3><p>还是从一个<code>Hello World</code>讲起</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;r := httprouter.New()r.GET(<span class="hljs-string">&quot;/:name&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request, params httprouter.Params)</span></span> &#123;        fmt.Fprintf(writer, <span class="hljs-string">&quot;hello, %s!\n&quot;</span>, params.ByName(<span class="hljs-string">&quot;name&quot;</span>))&#125;)http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>,r)&#125;</code></pre><p><code>httprouter.New()</code>初始化了一个 Router，下面直接看一下 Router 的结构</p><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>在 Router 的源码当中有十分详尽的注释，这里按照我个人的理解注释一下</p><pre><code class="hljs go"><span class="hljs-comment">// Router实现了Http.Handler接口，用于注册分发路由</span><span class="hljs-keyword">type</span> Router <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// trees 是一个基数树集合，每一个HTTP方法对应一棵单独的路由树</span>    <span class="hljs-comment">// node是基数树的根节点</span>trees <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*node    <span class="hljs-comment">// 用于开启上文提到的自动处理URL尾部斜杆的特性</span>    <span class="hljs-comment">// 这个值为true时，如果/foo/没有被匹配到，会尝试匹配/foo</span>RedirectTrailingSlash <span class="hljs-keyword">bool</span><span class="hljs-comment">// 用于开启上文提到的路由校正的特性</span>    <span class="hljs-comment">// 这个值为true时，会对../和//这种路径进行校正</span>RedirectFixedPath <span class="hljs-keyword">bool</span>    <span class="hljs-comment">// 这个值为true时，如果当前方法的路由没有被匹配到，会尝试匹配其他方法的路由，</span>    <span class="hljs-comment">// 如果匹配到了则返回405，如果没有，就交给NotFound Handler处理</span>HandleMethodNotAllowed <span class="hljs-keyword">bool</span><span class="hljs-comment">// 这个值为true时，将开启OPTIONS自动匹配，注意: 手动匹配优先级更高</span>HandleOPTIONS <span class="hljs-keyword">bool</span>    <span class="hljs-comment">// 没有匹配到相应路由的时候会调用这个方法</span>    <span class="hljs-comment">// 如果没有注册这个方法会返回 NotFound</span>NotFound http.Handler<span class="hljs-comment">// 没有匹配到相应路由并且HandleMethodNotAllowed为true时会调用这个方法</span>MethodNotAllowed http.Handler    <span class="hljs-comment">// 用于从panic当中恢复</span>    <span class="hljs-comment">// 需要返回500错误，并且渲染相应的错误页面</span>PanicHandler <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request, <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>&#125;</code></pre><p>初始化 Router 之后看看路由是如何保存并且注册的</p><h3 id="路由是如何保存的"><a href="#路由是如何保存的" class="headerlink" title="路由是如何保存的?"></a>路由是如何保存的?</h3><p>这里以官方 Readme 当中的例子说明：<br>如果注册了以下路由</p><pre><code class="hljs go">r.GET(<span class="hljs-string">&quot;/&quot;</span>, f1)r.GET(<span class="hljs-string">&quot;/search/&quot;</span>, f2)r.GET(<span class="hljs-string">&quot;/support/&quot;</span>, f3)r.GET(<span class="hljs-string">&quot;/blog/&quot;</span>, f4)r.GET(<span class="hljs-string">&quot;/blog/:post/&quot;</span>, f5)r.GET(<span class="hljs-string">&quot;/about_us/&quot;</span>, f6)r.GET(<span class="hljs-string">&quot;/about_us/team/&quot;</span>, f7)r.GET(<span class="hljs-string">&quot;/contact/&quot;</span>, f8)</code></pre><p>那么这些路由会如下方所示，以一颗树的形式保存，并且这些路由的公共前缀会被抽离并且变为上一层节点<br>Priority 表示加上自身一共有多少个节点<br>Path 表示路径<br>Handle 表示路由注册的方法</p><pre><code class="hljs apache"><span class="hljs-attribute">Priority</span>   Path             Handle<span class="hljs-attribute">9</span>          \                *&lt;<span class="hljs-number">1</span>&gt;<span class="hljs-attribute">3</span>          ├s               nil<span class="hljs-attribute">2</span>          |├earch\         *&lt;<span class="hljs-number">2</span>&gt;<span class="hljs-attribute">1</span>          |└upport\        *&lt;<span class="hljs-number">3</span>&gt;<span class="hljs-attribute">2</span>          ├blog\           *&lt;<span class="hljs-number">4</span>&gt;<span class="hljs-attribute">1</span>          |    └:post      nil<span class="hljs-attribute">1</span>          |         └\     *&lt;<span class="hljs-number">5</span>&gt;<span class="hljs-attribute">2</span>          ├about-us\       *&lt;<span class="hljs-number">6</span>&gt;<span class="hljs-attribute">1</span>          |        └team\  *&lt;<span class="hljs-number">7</span>&gt;<span class="hljs-attribute">1</span>          └contact\        *&lt;<span class="hljs-number">8</span>&gt;</code></pre><h3 id="r-Handle"><a href="#r-Handle" class="headerlink" title="r.Handle"></a>r.Handle</h3><p><code>r.Get</code>, <code>r.Post</code>等方法实质都是通过调用 r.Handle 实现的</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Router)</span> <span class="hljs-title">Handle</span><span class="hljs-params">(method, path <span class="hljs-keyword">string</span>, handle Handle)</span></span> &#123;    <span class="hljs-comment">// 路径注册必须从/开始，否则直接报错</span><span class="hljs-keyword">if</span> path[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;/&#x27;</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;path must begin with &#x27;/&#x27; in path &#x27;&quot;</span> + path + <span class="hljs-string">&quot;&#x27;&quot;</span>)&#125;    <span class="hljs-comment">// 路由树map不存在需要新建</span><span class="hljs-keyword">if</span> r.trees == <span class="hljs-literal">nil</span> &#123;r.trees = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*node)&#125;    <span class="hljs-comment">// 获取当前方法所对应树的根节点，不存在则新建一个</span>root := r.trees[method]<span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;root = <span class="hljs-built_in">new</span>(node)r.trees[method] = root&#125;    <span class="hljs-comment">// 向路由树当中添加一条一条路由</span>root.addRoute(path, handle)&#125;</code></pre><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p>路由是注册到一颗路由树当中的，先看看节点的源码，再来分析，是如何添加路由的</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// 当前节点的路径</span>    path      <span class="hljs-keyword">string</span>    <span class="hljs-comment">// 是否为参数节点，参数节点用:name表示</span>    wildChild <span class="hljs-keyword">bool</span>    <span class="hljs-comment">// 当前节点类型， 一共有4种</span>    <span class="hljs-comment">// static: 静态节点，默认类型</span><span class="hljs-comment">// root: 根节点</span><span class="hljs-comment">// param: 其他节点</span><span class="hljs-comment">// catchAll: 带有*的节点，这里*的作用和正则当中的*一样</span>    nType     nodeType    <span class="hljs-comment">// 当前路径上最大参数的个数，不能超过255</span>    maxParams <span class="hljs-keyword">uint8</span>    <span class="hljs-comment">// 代表分支的首字母</span>    <span class="hljs-comment">// 上面的例子，当前节点为s</span>    <span class="hljs-comment">// 那么indices = eu</span>    <span class="hljs-comment">// ├s               nil</span>    <span class="hljs-comment">// |├earch\         *&lt;2&gt;</span>    <span class="hljs-comment">// |└upport\        *&lt;3&gt;</span>    indices   <span class="hljs-keyword">string</span>    <span class="hljs-comment">// 孩子节点</span>    children  []*node    <span class="hljs-comment">// 注册的路由</span>    handle    Handle    <span class="hljs-comment">// 权重，表示当前节点加上所有子节点的数目</span>priority  <span class="hljs-keyword">uint32</span>&#125;</code></pre><h3 id="路由树是如何生成的？"><a href="#路由树是如何生成的？" class="headerlink" title="路由树是如何生成的？"></a>路由树是如何生成的？</h3><p>未完待续</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin源码阅读 从0.1开始</title>
    <link href="/post/12338.html"/>
    <url>/post/12338.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近打算开始学习一下 Gin 的源代码，现在 Gin 已经是一个十分成熟的框架了，代码量也不少，阅读起来还是有一定的难度，所以我打算从 0.1 版本开始阅读学习，一直到最新的一个版本。跟随着 Gin 的源码一步一步的学习成长。</p></blockquote><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>Gin 0.1 的代码量十分的少, 主要代码一共也只有五个文件，代码中的注释也比较详细</p><pre><code class="hljs css">│  <span class="hljs-selector-tag">auth</span><span class="hljs-selector-class">.go</span>│  <span class="hljs-selector-tag">gin</span><span class="hljs-selector-class">.go</span>│  <span class="hljs-selector-tag">logger</span><span class="hljs-selector-class">.go</span>│  <span class="hljs-selector-tag">README</span><span class="hljs-selector-class">.md</span>│  <span class="hljs-selector-tag">recovery</span><span class="hljs-selector-class">.go</span>│  <span class="hljs-selector-tag">validation</span><span class="hljs-selector-class">.go</span></code></pre><h2 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h2><p>Gin 0.1 的代码量十分的少，但是还是先从<code>readme</code>的示例开始说起</p><p>首先下面这一段代码是直接跑不起来的，不知道是代码本身的 bug 还是因为 Go 语言的版本变化导致的，首先我们需要修改几个地方</p><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    r := gin.Default()    r.GET(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span>&#123;        c.String(<span class="hljs-string">&quot;pong&quot;</span>)    &#125;)    <span class="hljs-comment">// Listen and server on 0.0.0.0:8080</span>    r.Run(<span class="hljs-string">&quot;:80&quot;</span>)&#125;</code></pre><h3 id="第一次修改"><a href="#第一次修改" class="headerlink" title="第一次修改"></a>第一次修改</h3><p><code>main.go</code></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><span class="hljs-string">&quot;net/http&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    r := gin.Default()    <span class="hljs-comment">// 在这儿必须在ping，前加上/，不然会导致panic</span>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span>&#123;        <span class="hljs-comment">// String 方法接受两个参数，但是实例只写了一个</span>c.String(http.StatusOK,<span class="hljs-string">&quot;pong&quot;</span>)&#125;)<span class="hljs-comment">// Listen and server on 0.0.0.0:8080</span>r.Run(<span class="hljs-string">&quot;:80&quot;</span>)&#125;</code></pre><p><code>gin.go</code></p><pre><code class="hljs go"><span class="hljs-comment">// Returns a new blank Engine instance without any middleware attached.</span><span class="hljs-comment">// The most basic configuration</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span> *<span class="hljs-title">Engine</span></span> &#123;engine := &amp;Engine&#123;&#125;engine.RouterGroup = &amp;RouterGroup&#123;<span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">nil</span>, engine&#125;    engine.router = httprouter.New()    <span class="hljs-comment">// NotFound 是一个http.Handler的接口，但是源码当中赋值了一个方法给他</span>    engine.router.NotFound = engine    <span class="hljs-comment">// engine.router.NotFound = engine.handle404</span><span class="hljs-keyword">return</span> engine&#125;</code></pre><p>好了修改完成之后就可以运行, <code>go run main.go</code>成功运行了，但是还有一个 bug，只能访问一次，就会因为<code>stack overflow</code>退出</p><p>查看一下<code>gin.go</code>, <code>ServeHTTP</code>可以发现，gin 是直接调用了<code>httprouter</code>的<code>ServeHTTP</code>方法</p><pre><code class="hljs go"><span class="hljs-comment">// ServeHTTP makes the router implement the http.Handler interface.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;engine.router.ServeHTTP(w, req)&#125;</code></pre><p>继续追踪，可以发现在<code>httprouter</code>的<code>ServeHTTP</code>方法最后有一段判定 404 的代码，这时候就可以发现这是之前修改<code>gin.go`</code> engine.router.NotFound = engine <code>这段代码造成的，由于 Chrome 浏览器访问的时候会尝试访问</code>/favicon.ico<code>这个文件，然而我们在路由当中并没有定义，此时就是 404，这时候由于之前我们在初始化的时候，给</code>router<code>传递的</code>NotFound<code>为</code>engine<code>，而</code>engine.ServeHTTP<code>调用了</code>router.ServeHTTP`这时候就造成了无限递归，导致最后退出</p><pre><code class="hljs go"><span class="hljs-comment">// Handle 404</span><span class="hljs-keyword">if</span> r.NotFound != <span class="hljs-literal">nil</span> &#123;r.NotFound.ServeHTTP(w, req)&#125; <span class="hljs-keyword">else</span> &#123;http.NotFound(w, req)&#125;</code></pre><h3 id="第二次修改"><a href="#第二次修改" class="headerlink" title="第二次修改"></a>第二次修改</h3><p><code>gin.go</code></p><pre><code class="hljs go"><span class="hljs-comment">// Returns a new blank Engine instance without any middleware attached.</span><span class="hljs-comment">// The most basic configuration</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span> *<span class="hljs-title">Engine</span></span> &#123;engine := &amp;Engine&#123;&#125;engine.RouterGroup = &amp;RouterGroup&#123;<span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">nil</span>, engine&#125;    engine.router = httprouter.New()    <span class="hljs-comment">// NotFound 是一个http.Handler的接口，但是源码当中赋值了一个方法给他</span>    <span class="hljs-comment">// 注释掉即可</span>    <span class="hljs-comment">// engine.router.NotFound = engine.handle404</span><span class="hljs-keyword">return</span> engine&#125;</code></pre><p><code>go run main.go</code>成功运行，就没有问题了</p><h2 id="Gin-源码分析"><a href="#Gin-源码分析" class="headerlink" title="Gin 源码分析"></a>Gin 源码分析</h2><p>跑起来之后就具体看看源码,初始版本的 Gin 当中拥有三个比较重要的<code>struct</code>，也是核心的组成部分</p><p><code>Context</code></p><pre><code class="hljs go"><span class="hljs-comment">// Context是gin当中最为重要的一部分</span><span class="hljs-comment">// 它用于在中间件当中传递变量，管理流程。例如接受json请求，并返回json</span><span class="hljs-comment">// Context is the most important part of gin. It allows us to pass variables between middleware,</span><span class="hljs-comment">// manage the flow, validate the JSON of a request and render a JSON response for example.</span>Context <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// ServeHTTP 第二个参数，请求体</span>    Req      *http.Request    <span class="hljs-comment">// ServeHTTP 第一次参数，响应</span>    Writer   http.ResponseWriter    <span class="hljs-comment">// 可以设置的值</span>    Keys     <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;    <span class="hljs-comment">// 错误信息</span>    Errors   []ErrorMsg    <span class="hljs-comment">// 请求参数</span>    Params   httprouter.Params    <span class="hljs-comment">// = 中间件 + 请求处理函数(最后一个)</span>    handlers []HandlerFunc    <span class="hljs-comment">// Engine 实例</span>    engine   *Engine    <span class="hljs-comment">// 当前处理到的Handler下标</span>    index    <span class="hljs-keyword">int8</span>&#125;<span class="hljs-comment">// 下一个中间件</span>Next()<span class="hljs-comment">// 终止处理，直接返回</span>Abort(code <span class="hljs-keyword">int</span>)<span class="hljs-comment">// 添加错误信息，并且终止处理</span>Fail(code <span class="hljs-keyword">int</span>, err error)<span class="hljs-comment">// 添加错误信息</span>Error(err error, meta <span class="hljs-keyword">interface</span>&#123;&#125;)<span class="hljs-comment">// 给Context.Keys添加值</span>Set(key <span class="hljs-keyword">string</span>, item <span class="hljs-keyword">interface</span>&#123;&#125;)<span class="hljs-comment">// 获取Context.Keys的值，如果不存在会导致panic</span>Get(key <span class="hljs-keyword">string</span>) <span class="hljs-keyword">interface</span>&#123;&#125;<span class="hljs-comment">// 将请求体的参数作为json解析</span>ParseBody(item <span class="hljs-keyword">interface</span>&#123;&#125;) error<span class="hljs-comment">// 同ParseBody，但是如果不是一个可解析的json会调用Fail(400)终止请求</span>EnsureBody(item <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">bool</span><span class="hljs-comment">// 下面是和返回相关的函数，code 参数均表示http status</span><span class="hljs-comment">// 返回json</span>JSON(code <span class="hljs-keyword">int</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;)<span class="hljs-comment">// 返回xml</span>XML(code <span class="hljs-keyword">int</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;)<span class="hljs-comment">// HTML模板渲染，使用golang标准库的模板库</span>HTML(code <span class="hljs-keyword">int</span>, name <span class="hljs-keyword">string</span>, data <span class="hljs-keyword">interface</span>&#123;&#125;)<span class="hljs-comment">// 返回字符串</span>String(code <span class="hljs-keyword">int</span>, msg <span class="hljs-keyword">string</span>)<span class="hljs-comment">// 返回流数据</span>Data(code <span class="hljs-keyword">int</span>, data []<span class="hljs-keyword">byte</span>)</code></pre><p><code>RouterGroup</code></p><pre><code class="hljs go"><span class="hljs-comment">// RouterGroup用于管理路由，一个RouterGroup和一个前缀以及一组中间件关联</span><span class="hljs-comment">// Used internally to configure router, a RouterGroup is associated with a prefix</span><span class="hljs-comment">// and an array of handlers (middlewares)</span>RouterGroup <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// 中间件</span>    Handlers []HandlerFunc    <span class="hljs-comment">// 路径前缀</span>    prefix   <span class="hljs-keyword">string</span>    parent   *RouterGroup    <span class="hljs-comment">// Engine 实例</span>    engine   *Engine&#125;<span class="hljs-comment">// 新建一个Context，用于传递这个路由组的数据</span>createContext(w http.ResponseWriter, req *http.Request, params httprouter.Params, handlers []HandlerFunc) *Context<span class="hljs-comment">// 添加一个中间件到这个路由组</span>Use(middlewares ...HandlerFunc)<span class="hljs-comment">// 新建一个路由组</span>Group(component <span class="hljs-keyword">string</span>, handlers ...HandlerFunc) *RouterGroup<span class="hljs-comment">// 注册一个路由</span>Handle(method, p <span class="hljs-keyword">string</span>, handlers []HandlerFunc)<span class="hljs-comment">// 调用Handle方法注册一个POST路由</span>POST(path <span class="hljs-keyword">string</span>, handlers ...HandlerFunc)<span class="hljs-comment">// 调用Handle方法注册一个GET路由</span>GET(path <span class="hljs-keyword">string</span>, handlers ...HandlerFunc)<span class="hljs-comment">// 调用Handle方法注册一个DELETE路由</span>DELETE(path <span class="hljs-keyword">string</span>, handlers ...HandlerFunc)<span class="hljs-comment">// 调用Handle方法注册一个PATCH路由</span>PATCH(path <span class="hljs-keyword">string</span>, handlers ...HandlerFunc)<span class="hljs-comment">// 调用Handle方法注册一个PUT路由</span>PUT(path <span class="hljs-keyword">string</span>, handlers ...HandlerFunc)<span class="hljs-comment">// 组合中间件，将传入的Handlers放在已有的Handlers后面</span>combineHandlers(handlers []HandlerFunc) []HandlerFunc</code></pre><p><code>Engine</code></p><pre><code class="hljs go"><span class="hljs-comment">// 用于表示Web框架，包含了fast HTTProuter和一个全局的中间件列表</span><span class="hljs-comment">// Represents the web framework, it wrappers the blazing fast httprouter multiplexer and a list of global middlewares.</span>Engine <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// 路由组</span>    *RouterGroup    <span class="hljs-comment">// 404 处理</span>    handlers404   []HandlerFunc    <span class="hljs-comment">// http router 实例</span>    router        *httprouter.Router    <span class="hljs-comment">// 模板</span>    HTMLTemplates *template.Template&#125;<span class="hljs-comment">// 加载HTML模板</span>LoadHTMLTemplates(pattern <span class="hljs-keyword">string</span>)<span class="hljs-comment">// 设置404方法</span>NotFound404(handlers ...HandlerFunc)<span class="hljs-comment">// 默认的404方法，但是这个版本并没有使用上</span>handle404(w http.ResponseWriter, req *http.Request)<span class="hljs-comment">// 保存文件</span>ServeFiles(path <span class="hljs-keyword">string</span>, root http.FileSystem)<span class="hljs-comment">// 实现http.Handler接口</span>ServeHTTP(w http.ResponseWriter, req *http.Request)<span class="hljs-comment">// 调用http.ListenAndServe启动服务器</span>Run(addr <span class="hljs-keyword">string</span>)</code></pre><p>0.1 版本的 gin 只是一个极小，极为简单的工具箱，主要提供了一个简单的路由和简单的中间件实现，搞清楚下面这两个问题这个框架的也就明白了。</p><ol><li><p>一个使用了<code>Gin</code>的 Web 应用，从初始化到启动的流程？</p></li><li><p>一个请求从接收到返回经历了什么？</p></li></ol><h3 id="应用流程"><a href="#应用流程" class="headerlink" title="应用流程"></a>应用流程</h3><p>1.首先创建了一个<code>engine</code>实例，注册了两个两个基本的中间件</p><pre><code class="hljs go">gin.Default() -&gt; gin.New() -&gt; engine.Use(Recovery(), Logger())</code></pre><p>2.然后使用<code>group.Handle</code>方法注册路由, 关键代码如下，将路由添加到 http router 的树中，当执行 handler 方法的时候，会创建一个<code>Context</code>并且从头开始执行</p><pre><code class="hljs go">group.engine.router.Handle(method, p,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request, params httprouter.Params)</span></span> &#123;    group.createContext(w, req, params, handlers).Next()&#125;)</code></pre><p>3.调用<code>http.ListenAndServe</code>监听指定端口，启动服务器</p><h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><ol><li>当服务器收到请求时，会调用之前注册的<code>engine.ServeHTTP</code>方法，查找路由</li><li><code>engine.ServeHTTP</code>方法使用了<code>httprouter</code>的<code>ServeHTTP</code>方法，这是会通过请求的 path 从已注册的路由树上获取对应的路由，并且执行其 handler 方法，如上所示，handler 方法内部通过创建一个 router group 对应的 Context 从头开始执行所有的中间件以及注册路由时注册的请求处理函数</li><li>从请求处理函数中返回信息</li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>gin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>纯技术人员和投资者的一些区别</title>
    <link href="/post/61686.html"/>
    <url>/post/61686.html</url>
    
    <content type="html"><![CDATA[<p>以下都是流水账，感慨一下…</p><p>今天有幸参加了一位师兄的校友聚会，也很巧合，和很多大佬一起吃了一个饭，听大佬们聊天受益颇多。</p><p>今天有一位做技术很厉害的，专家级的师兄想创业，聊起了他的项目，另外几个做企业的师兄在旁边听并且给出建议。让我产生一种很强烈的对比，做技术的师兄考虑的最多的是技术十分的牛，技术拥有不可复制，或者说很高的复制成本。但是没有说到具体的牛在什么地方，而其他几个师兄在帮忙理清项目的思路，有没有做过市场调查，有没有成型的产品，产品具体的技术指标等等。</p><p>不同位置的人看问题的角度不一样，或许只有那个技术很牛的师兄一样才能把一门技术做到极致。</p><p>但是反过来思考一下做技术需不需要有一定的产品思维，需不需要了解市场动态，需不需要良好的一个语言表述和组织能力，虽然这些肯定不是最重要的，但是应该也是不可或缺的吧。</p><p>自勉</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/28054.html">Github Actions介绍&自动构建Github Pages博客</a></li><li><a href="https://lailin.xyz/post/44107.html">记一次net http内存泄漏</a></li><li><a href="https://lailin.xyz/post/52061.html">使用TravisCI自动部署Blog</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>notes</tag>
      
      <tag>杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018年的一些小目标</title>
    <link href="/post/22757.html"/>
    <url>/post/22757.html</url>
    
    <content type="html"><![CDATA[<p>时间过得很快，从一个学生到一个社会人只需要那么一瞬间，一个来不及反应的瞬间。虽然之前经历过大量的实习工作，也不是第一次只身一人千里迢迢来到这个陌生的城市，但是还是有那么一些的不适应。</p><p>开始工作了，时间变得少了，但是学习的紧迫性却是变得更高了</p><p>列一列剩下不到半年时间想要学习的东西吧，权当是一个备忘录</p><ul><li>阅读学习至少两个 Go Web 框架 <code>七八月</code><ul><li>Echo</li><li>Gin</li><li>Iris</li><li>Beego</li><li>…</li></ul></li><li>学习 Golang 调度源码 <code>七八月 or 九月</code></li><li>从零开始编写自己的第一个 Go Web 框架 <code>八九月</code></li><li>未完待续…</li></ul><p>希望能够养成记录学习过程的习惯，<code>好记性不如烂笔头</code></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/how-to-write-a-pre-research-report.html">一点拙见-如何写好一个技术预研报告?</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>规划总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>规划</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go标准库——ioutil.ReadAll的实现</title>
    <link href="/post/47700.html"/>
    <url>/post/47700.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>最近准备学习一下 golang 的标准库，详细的阅读部分源码，这个目录记录一下学习的过程和心得</p></blockquote><p>go 语言的<code>ioutil</code>包提供了很多方便的 io 操作的工具集，本文主要详细分析<code>ReadAll</code>方法的源码实现。</p><p><code>ReadAll</code>是很常用的一个方法，用来一次性的读取<code>io.Reader</code>当中的数据。</p><h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><h5 id="1-ReadAll"><a href="#1-ReadAll" class="headerlink" title="1. ReadAll"></a>1. ReadAll</h5><p>阅读下方的源码我们可以发现，<code>ReadAll</code>其实调用了一个非导出的方法，我们一步一步的追踪</p><pre><code class="hljs go"><span class="hljs-comment">// ReadAll reads from r until an error or EOF and returns the data it read.</span><span class="hljs-comment">// A successful call returns err == nil, not err == EOF. Because ReadAll is</span><span class="hljs-comment">// defined to read from src until EOF, it does not treat an EOF from Read</span><span class="hljs-comment">// as an error to be reported.</span><span class="hljs-comment">// ReadAll从r读取数据直到EOF或遇到error，返回读取的数据和遇到的错误。</span><span class="hljs-comment">// 成功的调用返回的err为nil而非EOF。</span><span class="hljs-comment">// 因为本函数定义为读取r直到EOF，它不会将读取返回的EOF视为应报告的错误。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadAll</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<span class="hljs-keyword">return</span> readAll(r, bytes.MinRead)&#125;</code></pre><h5 id="2-readAll"><a href="#2-readAll" class="headerlink" title="2. readAll"></a>2. readAll</h5><p>阅读这个函数代码，可以发现，<code>ioutil.ReadAll</code>实质上是使用<code>bytes.buffer</code>实现的，在这里面调用了两个<code>bytes.buffer</code>的方法，一个用来初始化<code>buffer</code>的容量，一个用于读取所有的<code>io.Reader</code>数据</p><p>除此之外我们还可以学习到 go 当中 panic recover 的使用方法，在<code>buffer</code>当中，如果无法分配足够的内存的时候，会直接<code>panic bytes.ErrTooLarge</code>的错误，但是，这个方法我们期望把这个错误给返回回来，这个时候就可以使用<code>defer recover</code>从<code>panic</code>当中恢复回来</p><pre><code class="hljs go"><span class="hljs-comment">// readAll reads from r until an error or EOF and returns the data it read</span><span class="hljs-comment">// from the internal buffer allocated with a specified capacity.</span><span class="hljs-comment">// readAll从r读取到一个错误或EOF，并返回从指定容量分配的内部缓冲区中读取的数据。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readAll</span><span class="hljs-params">(r io.Reader, capacity <span class="hljs-keyword">int64</span>)</span> <span class="hljs-params">(b []<span class="hljs-keyword">byte</span>, err error)</span></span> &#123;    <span class="hljs-comment">// 新建了一个buffer</span><span class="hljs-keyword">var</span> buf bytes.Buffer<span class="hljs-comment">// If the buffer overflows, we will get bytes.ErrTooLarge.</span>    <span class="hljs-comment">// Return that as an error. Any other panic remains.</span>    <span class="hljs-comment">// 如果buffer溢出了，会得到一个bytes.ErrTooLarge的错误</span>    <span class="hljs-comment">// 如果得到的是bytes.ErrTooLarge错误，将其返回，其他panic错误，仍然panic</span><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;e := <span class="hljs-built_in">recover</span>()<span class="hljs-keyword">if</span> e == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">if</span> panicErr, ok := e.(error); ok &amp;&amp; panicErr == bytes.ErrTooLarge &#123;err = panicErr&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">panic</span>(e)&#125;    &#125;()    <span class="hljs-comment">// 判断capacity的值是否超过了int类型的上限</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">int64</span>(<span class="hljs-keyword">int</span>(capacity)) == capacity &#123;<span class="hljs-comment">// 向buffer当中增加capacity的容量</span>buf.Grow(<span class="hljs-keyword">int</span>(capacity))    &#125;    <span class="hljs-comment">// 使用buffer ReadFrom 方法读取所有的io.Reader数据</span>_, err = buf.ReadFrom(r)<span class="hljs-keyword">return</span> buf.Bytes(), err&#125;</code></pre><h5 id="3-buffer"><a href="#3-buffer" class="headerlink" title="3. buffer"></a>3. buffer</h5><p>要看<code>buffer</code>相关函数的实现，先看看<code>buffer</code>的定义，不然到时候可能会懵 B</p><p>主要会用到两个字段，一个是<code>buf</code>,<code>buf</code>的内容是用<code>off</code>到<code>len(buf)</code>的，<code>off</code>之前的表示已经读取了数据，<code>off</code>表示当前位置，<code>buffer</code>的<code>write和read</code>方法都会从这个位置开始</p><pre><code class="hljs go"><span class="hljs-comment">// A Buffer is a variable-sized buffer of bytes with Read and Write methods.</span><span class="hljs-comment">// The zero value for Buffer is an empty buffer ready to use.</span><span class="hljs-comment">// Buffer是一个实现了读写方法的可变大小的字节缓冲。</span><span class="hljs-comment">// 本类型的零值是一个空的可用于读写的缓冲。</span><span class="hljs-keyword">type</span> Buffer <span class="hljs-keyword">struct</span> &#123;buf      []<span class="hljs-keyword">byte</span> <span class="hljs-comment">// contents are the bytes buf[off : len(buf)]</span>off      <span class="hljs-keyword">int</span>    <span class="hljs-comment">// read at &amp;buf[off], write at &amp;buf[len(buf)]</span>lastRead readOp <span class="hljs-comment">// last read operation, so that Unread* can work correctly.</span><span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> lastRead can fit in a single byte</span><span class="hljs-comment">// memory to hold first slice; helps small buffers avoid allocation.</span><span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> it would be advisable to align Buffer to cachelines to avoid false</span><span class="hljs-comment">// sharing.</span>bootstrap [<span class="hljs-number">64</span>]<span class="hljs-keyword">byte</span>&#125;</code></pre><h5 id="4-buffer-Grow"><a href="#4-buffer-Grow" class="headerlink" title="4. buffer.Grow"></a>4. buffer.Grow</h5><p>这个方法主要用来增加缓冲区的内存，实际还是调用了非导出的<code>grow</code>方法</p><pre><code class="hljs go"><span class="hljs-comment">// Grow grows the buffer&#x27;s capacity, if necessary, to guarantee space for</span><span class="hljs-comment">// another n bytes. After Grow(n), at least n bytes can be written to the</span><span class="hljs-comment">// buffer without another allocation.</span><span class="hljs-comment">// If n is negative, Grow will panic.</span><span class="hljs-comment">// If the buffer can&#x27;t grow it will panic with ErrTooLarge.</span><span class="hljs-comment">// 必要时会增加缓冲的容量，以保证n字节的剩余空间。</span><span class="hljs-comment">// 调用Grow(n)后至少可以向缓冲中写入n字节数据而无需申请内存。</span><span class="hljs-comment">// 如果n小于零或者不能增加容量都会panic ErrTooLarge 错误。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Buffer)</span> <span class="hljs-title">Grow</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;bytes.Buffer.Grow: negative count&quot;</span>)&#125;m := b.grow(n)b.buf = b.buf[<span class="hljs-number">0</span>:m]&#125;</code></pre><h5 id="5-buffer-ReadFrom"><a href="#5-buffer-ReadFrom" class="headerlink" title="5. buffer.ReadFrom"></a>5. buffer.ReadFrom</h5><p>主要看看这个方法的实现，实现了从<code>io.Reader</code>读取所有数据。</p><p>示意图:<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142743.png" alt="示意图"></p><pre><code class="hljs go"><span class="hljs-comment">// ReadFrom reads data from r until EOF and appends it to the buffer, growing</span><span class="hljs-comment">// the buffer as needed. The return value n is the number of bytes read. Any</span><span class="hljs-comment">// error except io.EOF encountered during the read is also returned. If the</span><span class="hljs-comment">// buffer becomes too large, ReadFrom will panic with ErrTooLarge.</span><span class="hljs-comment">// ReadFrom从r中读取数据直到结束并将读取的数据写入缓冲中，如必要会增加缓冲容量。</span><span class="hljs-comment">// 返回值n为从r读取并写入b的字节数；会返回读取时遇到的除了io.EOF之外的错误。</span><span class="hljs-comment">// 如果缓冲太大，ReadFrom会采用错误值ErrTooLarge引发panic。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Buffer)</span> <span class="hljs-title">ReadFrom</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(n <span class="hljs-keyword">int64</span>, err error)</span></span> &#123;    <span class="hljs-comment">// const opInvalid = 0  // Non-read operation. 表示之前没有读操作</span>b.lastRead = opInvalid    <span class="hljs-comment">// If buffer is empty, reset to recover space.</span>    <span class="hljs-comment">// 如果缓冲区为空，重置为恢复空间。</span><span class="hljs-keyword">if</span> b.off &gt;= <span class="hljs-built_in">len</span>(b.buf) &#123;b.Reset()    &#125;    <span class="hljs-comment">// 循环读取io.Reader 的数据</span><span class="hljs-keyword">for</span> &#123;        <span class="hljs-comment">// 判断当前剩余空间是否小于MinRead，MinRead = 512</span><span class="hljs-keyword">if</span> free := <span class="hljs-built_in">cap</span>(b.buf) - <span class="hljs-built_in">len</span>(b.buf); free &lt; MinRead &#123;            <span class="hljs-comment">// not enough space at end</span>            <span class="hljs-comment">// 空间不足</span>            <span class="hljs-comment">// 新建一个buf</span>            newBuf := b.buf            <span class="hljs-comment">// 判断实际剩余容量是否小于MinRead = 512</span><span class="hljs-keyword">if</span> b.off+free &lt; MinRead &#123;<span class="hljs-comment">// not enough space using beginning of buffer;</span>                <span class="hljs-comment">// double buffer capacity</span>                <span class="hljs-comment">// 实际剩余空间不足，分配双倍的缓冲空间，缓冲的最小值为MinRead所以加上一个MinRead，避免双倍之后仍然比MinRead小</span>                <span class="hljs-comment">// makeSlice函数用于分配缓冲空间，如果分配失败会panic ErrTooLarge 错误</span>newBuf = makeSlice(<span class="hljs-number">2</span>*<span class="hljs-built_in">cap</span>(b.buf) + MinRead)            &#125;            <span class="hljs-comment">// 将原有buf数据复制到新的buf</span>            <span class="hljs-built_in">copy</span>(newBuf, b.buf[b.off:])            <span class="hljs-comment">// len(b.buf)-b.off 就等于buf当前内容的长度</span>            <span class="hljs-comment">// 例子: a:=make([]byte,20)</span>            <span class="hljs-comment">//      b:=a[:10]</span>            <span class="hljs-comment">//      len(b) // 10</span>            <span class="hljs-comment">//      cap(b) //20</span>            b.buf = newBuf[:<span class="hljs-built_in">len</span>(b.buf)-b.off]            <span class="hljs-comment">// 将off置0</span>b.off = <span class="hljs-number">0</span>        &#125;        <span class="hljs-comment">// 从io.Reader当中读取数据，传入buf的剩余空间</span>        <span class="hljs-comment">// 第一种情况，数据读取完毕，返回读取长度m以及,io.EOF错误</span>        <span class="hljs-comment">// 第二种情况, 数据未读完，遇到错误</span>        <span class="hljs-comment">// 第三种情况，数据未读完，缓冲区容量不够，返回读取数据长度m以及nil</span>        m, e := r.Read(b.buf[<span class="hljs-built_in">len</span>(b.buf):<span class="hljs-built_in">cap</span>(b.buf)])        <span class="hljs-comment">// 只获取有数据的buf，无数据的空间转化为cap</span>b.buf = b.buf[<span class="hljs-number">0</span> : <span class="hljs-built_in">len</span>(b.buf)+m]        n += <span class="hljs-keyword">int64</span>(m)        <span class="hljs-comment">// 数据读取完毕跳出循环</span><span class="hljs-keyword">if</span> e == io.EOF &#123;<span class="hljs-keyword">break</span>        &#125;        <span class="hljs-comment">// 遇到错误返回</span><span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> n, e&#125;&#125;<span class="hljs-keyword">return</span> n, <span class="hljs-literal">nil</span> <span class="hljs-comment">// err is EOF, so return nil explicitly</span>&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>go标准库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用chromedp解决反爬虫问题</title>
    <link href="/post/5431.html"/>
    <url>/post/5431.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近 We 川大上的教务处公告新闻已经很久没有更新了，想到可能是 ip 被封了，查了一下 log，发现并不是，而是获取到的页面全变成了混淆过的 js，下面放两个格式化的函数</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_$Es</span>(<span class="hljs-params">_$Cu</span>) </span>&#123;  _$Cu[<span class="hljs-number">14</span>] = _$v9();  _$Cu[_$yf(_$ox(), <span class="hljs-number">16</span>)] = _$Dn();  <span class="hljs-keyword">var</span> _$cR = _$CR();  _$cR = _$iT();  <span class="hljs-keyword">return</span> _$DA();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_$Dk</span>(<span class="hljs-params">_$Cu</span>) </span>&#123;  <span class="hljs-keyword">var</span> _$x5 = _$Dv();  <span class="hljs-keyword">var</span> _$x5 = _$EB();  <span class="hljs-keyword">if</span> (_$Ex()) &#123;    _$w9 = _$Dw();  &#125;  _$Cu[_$yf(_$EJ(), <span class="hljs-number">16</span>)] = _$ED();  _$Cu[_$yf(_$Ep(), <span class="hljs-number">16</span>)] = _$EP();  _$w9 = _$EB();  <span class="hljs-keyword">return</span> _$Cu[_$yf(_$v9(), <span class="hljs-number">16</span>)];&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_$rK</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> _$aJ = _$c0(_$DN());  _$aJ = _$BC(_$aJ, <span class="hljs-number">2</span>);  <span class="hljs-keyword">var</span> _$Ce = _$yr(_$qt());  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _$Cu = <span class="hljs-number">0</span>; _$Cu &lt; _$aJ[_$gX()]; _$Cu++) &#123;    _$aJ[_$Cu] = _$Ce + _$aJ[_$Cu];  &#125;  <span class="hljs-keyword">return</span> _$aJ;&#125;</code></pre><p>看着这一堆就头大，但是本着只要是浏览器能够渲染出来的页面爬虫就可以爬到的原则，一步一步的解决</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>先使用 postman 发送了一下请求，发现返回了上面一堆乱码</li><li>复制了正常渲染页面 request header 重新发送请求，可以得到正常的页面。考虑两个可能一个是 header 有什么特殊的处理，一个是 cookie 上的问题。</li><li>header 其他内容不变，去掉 cookie 重新发送请求，再一次得到一堆乱码。问题定位成功，应该就是 cookie 的问题了</li><li>清空 chrome 的缓存，重新加载页面，查看请求记录，可以看到这个页面一共加载了两次<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141634.png" alt="第一次加载"><br>第一次加载没有返回 cookie<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141635.png" alt="第二次加载"><br>第二次加载返回了一个<code>JSESSIONID</code>，这个应该就是最终需要的 cookie 了</li><li>观察两次请求的中间，我们可以发现还有两个请求，这两个请求应该就是第二次返回 cookie 的原因了，第一个请求是页面内的外链 js 文件，第二个请求应该就是混淆过的 js 发出的请求了。</li><li>因为实力有限，分析了几个小时都没有分析出来这个逻辑是怎么加载的。但是想到了直接从浏览器把 cookie 复制下来给爬虫使用不就可以了？但是这样也还有一个问题，就是不可能每一次都手动的去获取 cookie 这样达不到想要的效果。然后看到 Python 有使用<code>Selenium</code>来完全模拟浏览器渲染然后解析页面的爬虫案例，找了一下 golang 有没有类似的浏览器渲染方案，在万能的 gayhub 上找到了<code>chromedp</code>。下面使用 chromedp 来解决这个问题。</li></ol><h2 id="chromedp"><a href="#chromedp" class="headerlink" title="chromedp"></a>chromedp</h2><blockquote><p>Package chromedp is a faster, simpler way to drive browsers (Chrome, Edge, Safari, Android, etc) without external dependencies (ie, Selenium, PhantomJS, etc) using the Chrome Debugging Protocol.</p></blockquote><h5 id="1-install（建议使用梯子）"><a href="#1-install（建议使用梯子）" class="headerlink" title="1.install（建议使用梯子）"></a>1.install（建议使用梯子）</h5><pre><code class="hljs bash">go get -u github.com/chromedp/chromedp</code></pre><h5 id="2-code"><a href="#2-code" class="headerlink" title="2.code"></a>2.code</h5><p>运行下面这一段代码可以看到 chrome 会弹出一个窗口并且运行网页，最后在 console 输出期望的 html，但是我们其实只需要得到正确的 cookie，用来之后爬取网页使用。如果所有的页面都需要等待 chrome 渲染结束之后爬取，那么效率实在是太低了</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;context&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;io/ioutil&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;time&quot;</span><span class="hljs-string">&quot;github.com/chromedp/cdproto/cdp&quot;</span><span class="hljs-string">&quot;github.com/chromedp/chromedp&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> err error<span class="hljs-comment">// create context</span>ctxt, cancel := context.WithCancel(context.Background())<span class="hljs-keyword">defer</span> cancel()<span class="hljs-comment">// create chrome instance</span>c, err := chromedp.New(ctxt, chromedp.WithLog(log.Printf))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-comment">// run task list</span><span class="hljs-keyword">var</span> res <span class="hljs-keyword">string</span>err = c.Run(ctxt, chromedp.Tasks&#123;        <span class="hljs-comment">// 访问教务处页面</span>chromedp.Navigate(<span class="hljs-string">`http://jwc.scu.edu.cn/jwc/moreNotice.action`</span>),        <span class="hljs-comment">// 等待table渲染成功，成功则说明已经获取到了正确的页面</span>        chromedp.WaitVisible(<span class="hljs-string">`table`</span>, chromedp.ByQuery),        <span class="hljs-comment">// 获取body标签的html字符</span>chromedp.OuterHTML(<span class="hljs-string">&quot;body&quot;</span>, &amp;res),&#125;)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-comment">// 关闭chrome实例</span>err = c.Shutdown(ctxt)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-comment">// 等待chrome实例关闭</span>err = c.Wait()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;    <span class="hljs-comment">// 输出html字符串</span>log.Printf(res)&#125;</code></pre><h5 id="3-获取-cookie"><a href="#3-获取-cookie" class="headerlink" title="3.获取 cookie"></a>3.获取 cookie</h5><p>修改第 2 步当中 task list 的代码获取 cookie，修改之后可以看到 console 当中输出了一段 cookie 字符串，使用这个 cookie 在 postman 当中测试可以发现，可以获取到正确的页面。到了这一步其实就应该算基本完成了，但是还是有一个缺点：每次运行的时候都会弹出一个 chrome 窗口，爬虫在服务器上运行是没有 gui 页面的，并且每次打开一个 chrome 实例的时间开销也比较大。</p><pre><code class="hljs go"><span class="hljs-comment">// 将chromedp.OuterHTML(&quot;body&quot;, &amp;res) 替换为下面的代码</span>chromedp.ActionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, h cdp.Executor)</span> <span class="hljs-title">error</span></span> &#123;    <span class="hljs-comment">// 获取cookie</span>    cookies, err := network.GetAllCookies().Do(ctx, h)    <span class="hljs-comment">// 将cookie拼接成header请求中cookie字段的模式</span>    <span class="hljs-keyword">var</span> c <span class="hljs-keyword">string</span>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> cookies &#123;        c = c + v.Name + <span class="hljs-string">&quot;=&quot;</span> + v.Value + <span class="hljs-string">&quot;;&quot;</span>    &#125;    log.Println(c)    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> err    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;),</code></pre><h5 id="5-使用-chrome-的-headless-模式"><a href="#5-使用-chrome-的-headless-模式" class="headerlink" title="5.使用 chrome 的 headless 模式"></a>5.使用 chrome 的 headless 模式</h5><p>a.使用 docker 运行一个 headless 模式的 chrome</p><pre><code class="hljs bash">docker run -d -p 9222:9222 --rm --name chrome-headless knqz/chrome-headless</code></pre><p>b.修改代码</p><p>可以看到主要的区别就在创建 chrome 实例的时候没有去启动一个 chrome，当然最后也不需要去关闭它</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;context&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;github.com/chromedp/chromedp/client&quot;</span><span class="hljs-string">&quot;github.com/chromedp/cdproto/network&quot;</span><span class="hljs-string">&quot;github.com/chromedp/cdproto/cdp&quot;</span><span class="hljs-string">&quot;github.com/chromedp/chromedp&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> err error<span class="hljs-comment">// create context</span>ctxt, cancel := context.WithCancel(context.Background())<span class="hljs-keyword">defer</span> cancel()<span class="hljs-comment">// create chrome instance</span>c, err := chromedp.New(ctxt, chromedp.WithTargets(client.New().WatchPageTargets(ctxt)), chromedp.WithLog(log.Printf))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-comment">// run task list</span>err = c.Run(ctxt, chromedp.Tasks&#123;        <span class="hljs-comment">// 访问教务处页面</span>chromedp.Navigate(<span class="hljs-string">`http://jwc.scu.edu.cn/jwc/moreNotice.action`</span>),        <span class="hljs-comment">// 等待table渲染成功，成功则说明已经获取到了正确的页面</span>        chromedp.WaitVisible(<span class="hljs-string">`table`</span>, chromedp.ByQuery),        <span class="hljs-comment">// 获取body标签的html字符</span>chromedp.ActionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, h cdp.Executor)</span> <span class="hljs-title">error</span></span> &#123;            <span class="hljs-comment">// 获取cookie</span>            cookies, err := network.GetAllCookies().Do(ctx, h)            <span class="hljs-comment">// 将cookie拼接成header请求中cookie字段的模式</span>            <span class="hljs-keyword">var</span> c <span class="hljs-keyword">string</span>            <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> cookies &#123;                c = c + v.Name + <span class="hljs-string">&quot;=&quot;</span> + v.Value + <span class="hljs-string">&quot;;&quot;</span>            &#125;            log.Println(c)            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;                <span class="hljs-keyword">return</span> err            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>        &#125;),&#125;)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;&#125;</code></pre><p>到这里基本就可以使用了，获取到 cookie 之后可以使用喜欢的方式去获取页面</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>爬虫</tag>
      
      <tag>chromedp</tag>
      
      <tag>四川大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>We川大开发笔记@0.2.0</title>
    <link href="/post/62925.html"/>
    <url>/post/62925.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>可以搜索小程序<code>we川大</code>直接体验</p><p>这不是刚刚发完 0.1.0 的笔记么？怎么 0.2.0 都出来了？</p><p>没有看错，效率就是那么高，上一篇也提到了 0.1.0 审核通过的时候 0.2.0 就基本已经完成了，而且现在已经上线了(准确的说是 0.2.1 版本)，这一次的审核快了许多，只用了不到两天就已经审核通过了</p><h2 id="功能预览"><a href="#功能预览" class="headerlink" title="功能预览"></a>功能预览</h2><p>这一版主要新增三个功能，然后就是一些优化：</p><p><strong>1.反馈</strong></p><p>参考 we 重邮，直接和 github 的 issue 关联，所有提交的反馈信息，都会新建一条 issue，为了防止滥用，每天的反馈次数做了一定的限制</p><p>这个后端上直接采用了 Google 的 go-github 包，开发起来十分的方便，只是文档资料不是特别的丰富，之后会专门总结一下</p><p><strong>2.空闲教室查询</strong></p><p>学校的空闲教室查询页面：<a href="http://cir.scu.edu.cn/cir/index.html">http://cir.scu.edu.cn/cir/index.html</a></p><p>这是学校难得做的比较友好的站点，对于这个需要后端做一次接口中转即可</p><p><strong>3.新闻 Tag 列表</strong></p><p>这一版可以直接通过点击列表的 tag，查看前 20 条包含该 tag 的新闻， 至于为什么是 20 条，因为一个很奇怪的 bug 现在还没有解决。</p><p>两个页面，A，B 包含了同一个模块 C，在模块 C 当中可以点击跳转到 B，现在的问题就是在 A 页面的 C 模块当中点击跳转到 B 页面之后，B 页面的 C 模块的 scroll-view 绑定的所有事件都会消失</p><h2 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h2><p><img src="https://user-images.githubusercontent.com/15172509/35327035-66a31fb8-0133-11e8-9694-862bb9580b95.png" alt="screenshot_2018-01-24-18-19-17-192_com tencent mm"><br><img src="https://user-images.githubusercontent.com/15172509/35327038-672fd782-0133-11e8-821d-5e280bade960.png" alt="screenshot_2018-01-24-18-18-56-360_com tencent mm"><br><img src="https://user-images.githubusercontent.com/15172509/35327040-67727a4c-0133-11e8-9173-7fcd92ff5c0a.png" alt="screenshot_2018-01-24-18-19-02-187_com tencent mm"></p><h2 id="博客原文-amp-amp-开源地址"><a href="#博客原文-amp-amp-开源地址" class="headerlink" title="博客原文&amp;&amp;开源地址"></a>博客原文&amp;&amp;开源地址</h2><p><a href="https://github.com/mohuishou/scuplus-wechat">https://github.com/mohuishou/scuplus-wechat</a><br><a href="http://lailin.xyz/post/We川大开发笔记@0.2.0/">http://lailin.xyz/post/We 川大开发笔记@0.2.0/</a></p><p>可以关注开发进度或者提交反馈或者是 PR，star 多多益善</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/62781.html">We川大开发笔记@0.1.0</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>we川大</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>We川大开发笔记@0.1.0</title>
    <link href="/post/62781.html"/>
    <url>/post/62781.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>微信小程序已经出来一年左右了，然后之前也写过一个 scuplus 的 web 项目，但是还没有正式上线就无疾而终了，当然也不是一点用处都没有，拆分出来了两个小的功能模块，一个是绩点计算器，一个快捷评教，绩点计算器的日 PV 快要破 3W 了，UV 已经破 1W 了，大家期末看成绩的心情依旧是那么的急迫。</p><p>按理来说，我即将毕业做这些其实不太好，毕业之后代码的维护以及运营都是一个大问题，但是川大一直缺少一个综合型的 APP 或者网站，学校官方的网站做的都及其的不友好，而且十分的分散，所以一直有这个想法，想做一个集新闻资讯、比赛资讯/找队友/拉票，教务查询，课程推荐/排名/评价/选课，书籍查询/借阅于一体的一个综合型网站。当然这个想法涉及到的东西有点多，吸取之前的教训，这次打算一步一步的来，前期做功能，后期做优化，分模块上线</p><p>使用微信小程序开发好处是不用考虑浏览器的兼容性也不用考虑去做两个 APP，以及各种型号的手机，但是不好的地方就是所有的界面都只能靠自己去实现，基本没有现成的 ui 框架，有时候写的有点蛋疼(PS 我是一个后端)。然后就是审核，微信的审核 0.1.0 版本用了 5 天才完成，这个时间我的 0.2.0 版本已经基本开发完成了</p><p>项目已经开源，可以关注开发进度或者提交反馈或者是 PR，star 多多益善<br><a href="https://github.com/mohuishou/scuplus-wechat">https://github.com/mohuishou/scuplus-wechat</a></p><h2 id="扫码体验"><a href="#扫码体验" class="headerlink" title="扫码体验"></a>扫码体验</h2><p><img src="https://scuplus.oss-cn-shenzhen.aliyuncs.com/qcode.jpg" alt=""></p><h2 id="功能预览"><a href="#功能预览" class="headerlink" title="功能预览"></a>功能预览</h2><p>0.1.0 版本只是完成了基本的框架，以及相对来说比较常用的功能：</p><ul><li>最新资讯（青春川大/scuinfo/教务处/学工部等）</li><li>成绩/GPA 查询</li><li>课表查询</li></ul><h2 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h2><p><img src="https://user-images.githubusercontent.com/15172509/34929988-07a91c84-fa02-11e7-9a67-c2399232f820.png" alt="index"><br><img src="https://user-images.githubusercontent.com/15172509/34929987-07640356-fa02-11e7-8197-6dbeb5ac1dc1.jpg" alt="grade"><br><img src="https://user-images.githubusercontent.com/15172509/34929989-07e6f7fc-fa02-11e7-9143-b7d9737b432d.png" alt="news"><br><img src="https://user-images.githubusercontent.com/15172509/34929990-08246a24-fa02-11e7-832c-fa3be2681ba9.png" alt="newslist"><br><img src="https://user-images.githubusercontent.com/15172509/34929991-085ae856-fa02-11e7-9fba-3355071ea3b5.png" alt="schedule"></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/62925.html">We川大开发笔记@0.2.0</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>we川大</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>招银网络面试总结</title>
    <link href="/post/1358.html"/>
    <url>/post/1358.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>三面同时进行，每一面间隔不超过五分钟，前面两面技术面最后一面 HR，完全不会 JAVA，结果一直问 JAVA 心态爆炸</p></blockquote><h2 id="一面-20min"><a href="#一面-20min" class="headerlink" title="一面(20min)"></a>一面(20min)</h2><h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h3><h3 id="2-JAVA-用过么？准备去什么地方？"><a href="#2-JAVA-用过么？准备去什么地方？" class="headerlink" title="2. JAVA 用过么？准备去什么地方？"></a>2. JAVA 用过么？准备去什么地方？</h3><p>用过一天写了一个小 APP</p><h3 id="3-JAVA-的-HashMap-怎么实现？PUT-一次做了什么操作"><a href="#3-JAVA-的-HashMap-怎么实现？PUT-一次做了什么操作" class="headerlink" title="3. JAVA 的 HashMap 怎么实现？PUT 一次做了什么操作"></a>3. JAVA 的 HashMap 怎么实现？PUT 一次做了什么操作</h3><p>不会</p><h3 id="4-JAVA-的-GC-怎么实现"><a href="#4-JAVA-的-GC-怎么实现" class="headerlink" title="4. JAVA 的 GC 怎么实现"></a>4. JAVA 的 GC 怎么实现</h3><p>不会，强行说了一波 PHP 的 GC</p><h3 id="5-Mysql-的锁"><a href="#5-Mysql-的锁" class="headerlink" title="5. Mysql 的锁"></a>5. Mysql 的锁</h3><p>Innodb 支持到行级锁，MyISAM 只支持到表</p><h3 id="6-求一个二叉树任意两节点的距离，时间复杂度是多少？"><a href="#6-求一个二叉树任意两节点的距离，时间复杂度是多少？" class="headerlink" title="6. 求一个二叉树任意两节点的距离，时间复杂度是多少？"></a>6. 求一个二叉树任意两节点的距离，时间复杂度是多少？</h3><h3 id="7-设计模式了解不？装饰器模式解释一下，写一个"><a href="#7-设计模式了解不？装饰器模式解释一下，写一个" class="headerlink" title="7. 设计模式了解不？装饰器模式解释一下，写一个"></a>7. 设计模式了解不？装饰器模式解释一下，写一个</h3><p>解释了一下，没有写，后面让写了一个工厂</p><blockquote><p>还有一些忘了</p></blockquote><h2 id="二面-15min"><a href="#二面-15min" class="headerlink" title="二面(15min)"></a>二面(15min)</h2><h3 id="1-自我介绍-1"><a href="#1-自我介绍-1" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h3><h3 id="2-JAVA-的-GC-怎么实现。。。又来了"><a href="#2-JAVA-的-GC-怎么实现。。。又来了" class="headerlink" title="2. JAVA 的 GC 怎么实现。。。又来了"></a>2. JAVA 的 GC 怎么实现。。。又来了</h3><h3 id="3-Mysql-去除重复项"><a href="#3-Mysql-去除重复项" class="headerlink" title="3. Mysql 去除重复项"></a>3. Mysql 去除重复项</h3><h3 id="4-Mysql-触发器机制"><a href="#4-Mysql-触发器机制" class="headerlink" title="4. Mysql 触发器机制"></a>4. Mysql 触发器机制</h3><h3 id="5-设计一个无限极分类的数据库表"><a href="#5-设计一个无限极分类的数据库表" class="headerlink" title="5. 设计一个无限极分类的数据库表"></a>5. 设计一个无限极分类的数据库表</h3><h3 id="6-怎么把去处来的数据树型结构化"><a href="#6-怎么把去处来的数据树型结构化" class="headerlink" title="6. 怎么把去处来的数据树型结构化"></a>6. 怎么把去处来的数据树型结构化</h3><h2 id="三面-35min"><a href="#三面-35min" class="headerlink" title="三面(35min)"></a>三面(35min)</h2><h3 id="1-拿了一波简历，成绩单，自我介绍"><a href="#1-拿了一波简历，成绩单，自我介绍" class="headerlink" title="1. 拿了一波简历，成绩单，自我介绍"></a>1. 拿了一波简历，成绩单，自我介绍</h3><h3 id="2-为什么不想留在成都"><a href="#2-为什么不想留在成都" class="headerlink" title="2. 为什么不想留在成都"></a>2. 为什么不想留在成都</h3><h3 id="3-成绩单上很多-60-分，飘过还是重修"><a href="#3-成绩单上很多-60-分，飘过还是重修" class="headerlink" title="3. 成绩单上很多 60 分，飘过还是重修"></a>3. 成绩单上很多 60 分，飘过还是重修</h3><p>飘过</p><h3 id="4-现在面试了哪些公司，有没有收到-offer-意向"><a href="#4-现在面试了哪些公司，有没有收到-offer-意向" class="headerlink" title="4. 现在面试了哪些公司，有没有收到 offer 意向"></a>4. 现在面试了哪些公司，有没有收到 offer 意向</h3><h3 id="5-简单的介绍了一个项目"><a href="#5-简单的介绍了一个项目" class="headerlink" title="5. 简单的介绍了一个项目"></a>5. 简单的介绍了一个项目</h3><h3 id="6-介绍了社团研发部部长和学院团副经历"><a href="#6-介绍了社团研发部部长和学院团副经历" class="headerlink" title="6. 介绍了社团研发部部长和学院团副经历"></a>6. 介绍了社团研发部部长和学院团副经历</h3><blockquote><p>还有一些记不住了</p></blockquote><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/56757.html">百度面试总结</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>秋招</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell排序</title>
    <link href="/post/27243.html"/>
    <url>/post/27243.html</url>
    
    <content type="html"><![CDATA[<h1 id="Shell-排序"><a href="#Shell-排序" class="headerlink" title="Shell 排序"></a>Shell 排序</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>设置间隔（传统间隔为 N/2）</li><li>插入排序</li></ol><h2 id="图片示例"><a href="#图片示例" class="headerlink" title="图片示例"></a>图片示例</h2><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142753.gif" alt=""></p><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><h3 id="传统实现"><a href="#传统实现" class="headerlink" title="传统实现"></a>传统实现</h3><pre><code class="hljs go"><span class="hljs-comment">//SortInt 传统shell排序,间隔为N/2</span><span class="hljs-comment">//相邻间隔可能不互质，可能会出现前置排序无用的情况</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SortInt</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;n := <span class="hljs-number">0</span>aLen := <span class="hljs-built_in">len</span>(a)<span class="hljs-comment">//定义间隔</span><span class="hljs-keyword">for</span> i := aLen / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i = i / <span class="hljs-number">2</span> &#123;<span class="hljs-comment">//插入排序</span><span class="hljs-keyword">for</span> j := i; j &lt; aLen; j++ &#123;tmp := a[j]k := j<span class="hljs-keyword">for</span> ; k &gt;= i &amp;&amp; tmp &lt; a[k-i]; k = k - i &#123;a[k] = a[k-i]n++&#125;a[k] = tmp&#125;&#125;<span class="hljs-keyword">return</span> a, n&#125;</code></pre><h3 id="Hibbard-算法"><a href="#Hibbard-算法" class="headerlink" title="Hibbard 算法"></a>Hibbard 算法</h3><pre><code class="hljs go"><span class="hljs-comment">//SortHibbardInt Hibbard算法，间隔为2^k-1</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SortHibbardInt</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;n, i := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>aLen := <span class="hljs-built_in">len</span>(a)<span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>; i &lt;= aLen<span class="hljs-number">-1</span>; i = i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span> &#123;&#125;<span class="hljs-comment">//定义间隔</span><span class="hljs-keyword">for</span> ; i &gt; <span class="hljs-number">0</span>; i = (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &#123;<span class="hljs-comment">// println(i)</span><span class="hljs-comment">//插入排序</span><span class="hljs-keyword">for</span> j := i; j &lt; aLen; j++ &#123;tmp := a[j]k := j<span class="hljs-keyword">for</span> ; k &gt;= i &amp;&amp; tmp &lt; a[k-i]; k = k - i &#123;a[k] = a[k-i]n++&#125;a[k] = tmp&#125;&#125;<span class="hljs-keyword">return</span> a, n&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-once.html">Week03: Go并发编程(八) 深入理解 sync.Once</a></li><li><a href="https://lailin.xyz/post/go-training-week3-errgroup.html">Week03: Go并发编程(七) 深入理解 errgroup</a></li><li><a href="https://lailin.xyz/post/go-training-week3-waitgroup.html">Week03: Go并发编程(六) 深入理解 WaitGroup</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/post/21238.html"/>
    <url>/post/21238.html</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><ol><li>比较相邻的元素（从后往前）。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>(<strong>如果这一步没有出现任何一次交换，那么说明所有的元素已经有序，不需要再进行下面的步骤了</strong>)</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h2 id="图片示例"><a href="#图片示例" class="headerlink" title="图片示例"></a>图片示例</h2><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142754.gif" alt=""></p><h2 id="程序示例（go）"><a href="#程序示例（go）" class="headerlink" title="程序示例（go）"></a>程序示例（go）</h2><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SortInt</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">//交换次数，计数</span>n := <span class="hljs-number">0</span>aLen := <span class="hljs-built_in">len</span>(a)<span class="hljs-keyword">for</span> i := aLen - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<span class="hljs-comment">//标记，如果flag一次冒泡之后没有改变，那么证明排序已完成，不需要再次排序，直接退出</span>flag := <span class="hljs-number">0</span><span class="hljs-comment">//一次冒泡</span><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<span class="hljs-keyword">if</span> a[j] &gt; a[j+<span class="hljs-number">1</span>] &#123;<span class="hljs-comment">//交换两个变量的值，无需引入临时变量</span>a[j], a[j+<span class="hljs-number">1</span>] = a[j+<span class="hljs-number">1</span>], a[j]n++<span class="hljs-comment">//有交换，flag=1</span>flag = <span class="hljs-number">1</span>&#125;&#125;<span class="hljs-comment">//判断一次冒泡，是否存在交换</span><span class="hljs-keyword">if</span> flag == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">break</span>&#125;&#125;<span class="hljs-keyword">return</span> a, n&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-once.html">Week03: Go并发编程(八) 深入理解 sync.Once</a></li><li><a href="https://lailin.xyz/post/go-training-week3-errgroup.html">Week03: Go并发编程(七) 深入理解 errgroup</a></li><li><a href="https://lailin.xyz/post/go-training-week3-waitgroup.html">Week03: Go并发编程(六) 深入理解 WaitGroup</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序</title>
    <link href="/post/46698.html"/>
    <url>/post/46698.html</url>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>堆积排序： 是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>建堆，建堆是不断调整堆的过程，从 len/2 处开始调整，一直到第一个节点，此处 len 是堆中元素的个数。建堆的过程是线性的过程，从 len/2 到 0 处一直调用调整堆的过程，相当于 o(h1)+o(h2)…+o(hlen/2) 其中 h 表示节点的深度，len/2 表示节点的个数，这是一个求和的过程，结果是线性的 O(n)。</li><li>调整堆：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点 i 和它的孩子节点 left(i),right(i)，选出三者最大(或者最小)者，如果最大（小）值不是节点 i 而是它的一个孩子节点，那边交互节点 i 和该节点，然后再调用调整堆过程，这是一个递归的过程。调整堆的过程时间复杂度与堆的深度有关系，是 lgn 的操作，因为是沿着深度方向进行调整的。</li><li>堆排序：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面 len-1 个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。堆排序过程的时间复杂度是 O(nlgn)。因为建堆的时间复杂度是 O(n)（调用一次）；调整堆的时间复杂度是 lgn，调用了 n-1 次，所以堆排序的时间复杂度是 O(nlgn)[2]</li></ul><p><em>注意: 根节点在数组当中存放的位置是 0，所以第 i 个节点的左孩子是 2i+1,右孩子是 2i+2</em></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141622.gif" alt="示例图片"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> HeapSort<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-comment">//HeapSort 堆排序</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;LEN := <span class="hljs-built_in">len</span>(arr)<span class="hljs-keyword">for</span> i := LEN/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;HeapAjust(arr, i, LEN)&#125;<span class="hljs-keyword">for</span> i := LEN - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;arr[i], arr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>], arr[i]HeapAjust(arr, <span class="hljs-number">0</span>, i)&#125;&#125;<span class="hljs-comment">//HeapAjust 堆调整</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HeapAjust</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, start <span class="hljs-keyword">int</span>, length <span class="hljs-keyword">int</span>)</span></span> &#123;tmp := arr[start]<span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>*start + <span class="hljs-number">1</span>; i &lt; length; i = i * <span class="hljs-number">2</span> &#123;<span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span> &lt; length &amp;&amp; arr[i] &lt; arr[i+<span class="hljs-number">1</span>] &#123;i++&#125;<span class="hljs-keyword">if</span> tmp &gt; arr[i] &#123;<span class="hljs-keyword">break</span>&#125;arr[start] = arr[i]start = i&#125;arr[start] = tmp&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-once.html">Week03: Go并发编程(八) 深入理解 sync.Once</a></li><li><a href="https://lailin.xyz/post/go-training-week3-errgroup.html">Week03: Go并发编程(七) 深入理解 errgroup</a></li><li><a href="https://lailin.xyz/post/go-training-week3-waitgroup.html">Week03: Go并发编程(六) 深入理解 WaitGroup</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/post/63711.html"/>
    <url>/post/63711.html</url>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>归并排序:是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤 3 直到某一指针达到序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141633.gif" alt="示例图片"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> merge<span class="hljs-comment">//INFINITY 一个比较大的值用作哨兵</span><span class="hljs-keyword">const</span> INFINITY = <span class="hljs-number">0xffff</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, start, end <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> start &lt; end &#123;<span class="hljs-comment">//从中间划分，分别左右两边排序</span>mid := (end + start) / <span class="hljs-number">2</span>merge(arr, start, mid)merge(arr, mid+<span class="hljs-number">1</span>, end)<span class="hljs-comment">//下面进行归并操作，将两个长度较小但是已经排序完成的数组合并成一个较长长度的排序数组</span><span class="hljs-comment">//新建一个数组用于存放左边的值</span>arr1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, mid-start+<span class="hljs-number">2</span>)<span class="hljs-built_in">copy</span>(arr1, arr[start:mid+<span class="hljs-number">1</span>])arr1[mid-start+<span class="hljs-number">1</span>] = INFINITY<span class="hljs-comment">//新建一个数组用于存放右边的值</span>arr2 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, end-mid+<span class="hljs-number">1</span>)<span class="hljs-built_in">copy</span>(arr2, arr[mid+<span class="hljs-number">1</span>:end+<span class="hljs-number">1</span>])arr2[end-mid] = INFINITY<span class="hljs-comment">//比较大小</span>j, k := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := start; i &lt;= end; i++ &#123;<span class="hljs-keyword">if</span> arr1[j] &lt;= arr2[k] &#123;arr[i] = arr1[j]j++&#125; <span class="hljs-keyword">else</span> &#123;arr[i] = arr2[k]k++&#125;&#125;&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-once.html">Week03: Go并发编程(八) 深入理解 sync.Once</a></li><li><a href="https://lailin.xyz/post/go-training-week3-errgroup.html">Week03: Go并发编程(七) 深入理解 errgroup</a></li><li><a href="https://lailin.xyz/post/go-training-week3-waitgroup.html">Week03: Go并发编程(六) 深入理解 WaitGroup</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/post/11306.html"/>
    <url>/post/11306.html</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/mohuishou/go-sort">https://github.com/mohuishou/go-sort</a></p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(n log n)次比较。在最坏状况下则需要 Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来，且在大部分真实世界的数据，可以决定设计的选择，减少所需时间的二次方项之可能性。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>从数列中挑出一个元素，称为 “基准”（pivot），</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p><em>注意: 基准点采用三元素原则法，三元素选择之后一头一尾就已经有序了</em></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141632.gif" alt="示例图片"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> quik<span class="hljs-comment">//Sort 快速排序</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;Quik(arr, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>)&#125;<span class="hljs-comment">//Quik 快速排序递归实现</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Quik</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, left <span class="hljs-keyword">int</span>, right <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> right-left &lt; <span class="hljs-number">2</span> &#123;<span class="hljs-keyword">return</span>&#125;p := middle3(arr, left, right)i := left + <span class="hljs-number">1</span>j := right - <span class="hljs-number">2</span><span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">for</span> arr[i] &lt; p &#123;i++&#125;<span class="hljs-keyword">for</span> arr[j] &gt; p &#123;j--&#125;<span class="hljs-keyword">if</span> i &lt; j &#123;arr[i], arr[j] = arr[j], arr[i]&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>&#125;&#125;arr[i], arr[right<span class="hljs-number">-1</span>] = arr[right<span class="hljs-number">-1</span>], arr[i]Quik(arr, left, i<span class="hljs-number">-1</span>)Quik(arr, i+<span class="hljs-number">1</span>, right)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middle3</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, left <span class="hljs-keyword">int</span>, right <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;center := (right + left) / <span class="hljs-number">2</span><span class="hljs-keyword">if</span> arr[left] &gt; arr[center] &#123;arr[left], arr[center] = arr[center], arr[left]&#125;<span class="hljs-keyword">if</span> arr[left] &gt; arr[right] &#123;arr[left], arr[right] = arr[right], arr[left]&#125;<span class="hljs-keyword">if</span> arr[center] &gt; arr[right] &#123;arr[center], arr[right] = arr[right], arr[center]&#125;arr[center], arr[right<span class="hljs-number">-1</span>] = arr[right<span class="hljs-number">-1</span>], arr[center]<span class="hljs-keyword">return</span> arr[right<span class="hljs-number">-1</span>]&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-once.html">Week03: Go并发编程(八) 深入理解 sync.Once</a></li><li><a href="https://lailin.xyz/post/go-training-week3-errgroup.html">Week03: Go并发编程(七) 深入理解 errgroup</a></li><li><a href="https://lailin.xyz/post/go-training-week3-waitgroup.html">Week03: Go并发编程(六) 深入理解 WaitGroup</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/post/50190.html"/>
    <url>/post/50190.html</url>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤 2~5</li></ol><h2 id="图片示例"><a href="#图片示例" class="headerlink" title="图片示例"></a>图片示例</h2><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141645.gif" alt=""></p><h2 id="程序示例（go）"><a href="#程序示例（go）" class="headerlink" title="程序示例（go）"></a>程序示例（go）</h2><pre><code class="hljs go"><span class="hljs-comment">//SortInt 插入排序</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SortInt</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;n := <span class="hljs-number">0</span>aLen := <span class="hljs-built_in">len</span>(a)<span class="hljs-comment">//从i=1开始，第一个数不用排序，一个数相当于已经有序了</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; aLen; i++ &#123;<span class="hljs-comment">//取出新数（类似摸牌）</span>tmp := a[i]<span class="hljs-comment">//将新数和之前的数从后往前（从大到小）一次比较，如果新数更小,就将以前的数往后移一位</span>j := i<span class="hljs-keyword">for</span> ; (j &gt; <span class="hljs-number">0</span>) &amp;&amp; (tmp &lt; a[j<span class="hljs-number">-1</span>]); j-- &#123;n++a[j] = a[j<span class="hljs-number">-1</span>] <span class="hljs-comment">//后移一位</span>&#125;<span class="hljs-comment">//新数插入</span>a[j] = tmp&#125;<span class="hljs-keyword">return</span> a, n&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-once.html">Week03: Go并发编程(八) 深入理解 sync.Once</a></li><li><a href="https://lailin.xyz/post/go-training-week3-errgroup.html">Week03: Go并发编程(七) 深入理解 errgroup</a></li><li><a href="https://lailin.xyz/post/go-training-week3-waitgroup.html">Week03: Go并发编程(六) 深入理解 WaitGroup</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/post/51203.html"/>
    <url>/post/51203.html</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/mohuishou/go-sort">https://github.com/mohuishou/go-sort</a></p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141643.gif" alt="示例图片"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> selection<span class="hljs-comment">//Sort 选择排序</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">var</span> LEN = <span class="hljs-built_in">len</span>(arr)minIndex := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; LEN; i++ &#123;minIndex = i<span class="hljs-keyword">for</span> j := i; j &lt; LEN; j++ &#123;<span class="hljs-keyword">if</span> arr[minIndex] &gt; arr[j] &#123;minIndex = j&#125;&#125;<span class="hljs-keyword">if</span> minIndex != i &#123;arr[minIndex], arr[i] = arr[i], arr[minIndex]&#125;&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-once.html">Week03: Go并发编程(八) 深入理解 sync.Once</a></li><li><a href="https://lailin.xyz/post/go-training-week3-errgroup.html">Week03: Go并发编程(七) 深入理解 errgroup</a></li><li><a href="https://lailin.xyz/post/go-training-week3-waitgroup.html">Week03: Go并发编程(六) 深入理解 WaitGroup</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百度面试总结</title>
    <link href="/post/56757.html"/>
    <url>/post/56757.html</url>
    
    <content type="html"><![CDATA[<h2 id="一面-40min"><a href="#一面-40min" class="headerlink" title="一面(40min)"></a>一面(40min)</h2><h3 id="0-自我介绍"><a href="#0-自我介绍" class="headerlink" title="0. 自我介绍"></a>0. 自我介绍</h3><h3 id="1-介绍-ImageOCR-的项目"><a href="#1-介绍-ImageOCR-的项目" class="headerlink" title="1. 介绍 ImageOCR 的项目"></a>1. 介绍 ImageOCR 的项目</h3><h3 id="2-知道有哪些排序算法？"><a href="#2-知道有哪些排序算法？" class="headerlink" title="2. 知道有哪些排序算法？"></a>2. 知道有哪些排序算法？</h3><p>冒泡、插入、shell、归并、快排、堆排序、选择排序等等</p><blockquote><p>有没有不会写的，排雷排掉了堆排序</p></blockquote><h3 id="3-手写插入排序并解释"><a href="#3-手写插入排序并解释" class="headerlink" title="3. 手写插入排序并解释"></a>3. 手写插入排序并解释</h3><h3 id="4-上面的排序算法哪些是稳定的，哪些是不稳定的"><a href="#4-上面的排序算法哪些是稳定的，哪些是不稳定的" class="headerlink" title="4. 上面的排序算法哪些是稳定的，哪些是不稳定的"></a>4. 上面的排序算法哪些是稳定的，哪些是不稳定的</h3><h3 id="还有一些忘了"><a href="#还有一些忘了" class="headerlink" title="还有一些忘了"></a>还有一些忘了</h3><h2 id="二面-1-2h"><a href="#二面-1-2h" class="headerlink" title="二面(1.2h)"></a>二面(1.2h)</h2><h3 id="0-介绍简历上的另外一个项目"><a href="#0-介绍简历上的另外一个项目" class="headerlink" title="0. 介绍简历上的另外一个项目"></a>0. 介绍简历上的另外一个项目</h3><h3 id="1-PHP-的基本数据类型以及基本数据类型内核如何实现"><a href="#1-PHP-的基本数据类型以及基本数据类型内核如何实现" class="headerlink" title="1. PHP 的基本数据类型以及基本数据类型内核如何实现?"></a>1. PHP 的基本数据类型以及基本数据类型内核如何实现?</h3><p><strong>基本数据类型</strong></p><pre><code class="hljs zephir"><span class="hljs-keyword">boolean</span>(布尔型)布尔型是最简单的数据类型，只有两个值 <span class="hljs-keyword">false</span>(假) 和<span class="hljs-keyword">true</span>(真)<span class="hljs-keyword">string</span>(字符串型)字符串就是连续的字符序列，如 ehco <span class="hljs-string">&quot;string&quot;</span>;<span class="hljs-keyword">integer</span>(整型)    整型数据类型只能包含整数，这些数据类型可以是负数或者正数folat(浮点型)浮点型类型用于存储数字，和整型不同的是浮点型可以有小数点<span class="hljs-keyword">array</span>（数组）一组相同类型的集合<span class="hljs-keyword">object</span>（对象）对象是一个实力，使用<span class="hljs-keyword">new</span>命令创建一个对象<span class="hljs-keyword">resource</span>（资源）资源是一种特殊的变量，保存在外部资源的一个应用，资源是通过函数来进行建立的<span class="hljs-keyword">null</span>（ 空白）特殊的值，表示变量没有值，任何变量的初始值都是<span class="hljs-keyword">null</span></code></pre><p><strong>变量的在内核当中的保存方式：</strong></p><ul><li>php5.3: <a href="http://blog.csdn.net/qq_28602957/article/details/52959132">http://blog.csdn.net/qq_28602957/article/details/52959132</a></li></ul><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> _<span class="hljs-title">zvalue_value</span> &#123;</span>    <span class="hljs-keyword">long</span> lval;                  <span class="hljs-comment">/* long value */</span>    <span class="hljs-keyword">double</span> dval;                <span class="hljs-comment">/* double value */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>        <span class="hljs-keyword">char</span> *val;        <span class="hljs-keyword">int</span> len;    &#125; str;    HashTable *ht;              <span class="hljs-comment">/* hash table value */</span>    zend_object_value obj;    zend_ast *ast;&#125; zvalue_value;<span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">zval_struct</span> &#123;</span>    <span class="hljs-comment">/* Variable information */</span>    zvalue_value value;     <span class="hljs-comment">/* value */</span>    zend_uint refcount__gc;    zend_uchar type;    <span class="hljs-comment">/* active type */</span>    zend_uchar is_ref__gc;&#125;;</code></pre><table><thead><tr><th style="text-align:center">PHP 语言层类型</th><th style="text-align:center">存在 zvalue_value 的成员变量</th></tr></thead><tbody><tr><td style="text-align:center">long,bool,resoure</td><td style="text-align:center">lval</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">dval</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center">str(len 保存字符串的长度，val 保存字符串的值)</td></tr><tr><td style="text-align:center">array</td><td style="text-align:center">ht（哈希表）</td></tr><tr><td style="text-align:center">object</td><td style="text-align:center">obj</td></tr></tbody></table><ul><li>php7: <a href="https://yq.aliyun.com/articles/27359">https://yq.aliyun.com/articles/27359</a></li></ul><pre><code class="hljs C"><span class="hljs-comment">//存储变量的结构</span><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">zval_struct</span> &#123;</span>    zend_value        value;            <span class="hljs-comment">/* value */</span>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>            ZEND_ENDIAN_LOHI_4(                zend_uchar    type,         <span class="hljs-comment">/* active type */</span>                zend_uchar    type_flags,                zend_uchar    const_flags,                zend_uchar    reserved)     <span class="hljs-comment">/* call info for EX(This) */</span>        &#125; v;        <span class="hljs-keyword">uint32_t</span> type_info;    &#125; u1;    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>        <span class="hljs-keyword">uint32_t</span>     var_flags;        <span class="hljs-keyword">uint32_t</span>     next;                 <span class="hljs-comment">/* hash collision chain */</span>        <span class="hljs-keyword">uint32_t</span>     cache_slot;           <span class="hljs-comment">/* literal cache slot */</span>        <span class="hljs-keyword">uint32_t</span>     lineno;               <span class="hljs-comment">/* line number (for ast nodes) */</span>        <span class="hljs-keyword">uint32_t</span>     num_args;             <span class="hljs-comment">/* arguments number for EX(This) */</span>        <span class="hljs-keyword">uint32_t</span>     fe_pos;               <span class="hljs-comment">/* foreach position */</span>        <span class="hljs-keyword">uint32_t</span>     fe_iter_idx;          <span class="hljs-comment">/* foreach iterator index */</span>    &#125; u2;&#125;;<span class="hljs-comment">//变量的值</span><span class="hljs-comment">//通过上面的代码我们可以看到。变量是通过一个_zval_struct结构体方式存储的。其中结构体中的value存储的是变量的值。这个成员是zend_value类型的。zend_value类型的定义如下：</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> _<span class="hljs-title">zend_value</span> &#123;</span>    zend_long         lval;             <span class="hljs-comment">/* long value */</span>    <span class="hljs-keyword">double</span>            dval;             <span class="hljs-comment">/* double value */</span>    zend_refcounted  *counted;    zend_string      *str;    zend_array       *arr;    zend_object      *obj;    zend_resource    *res;    zend_reference   *ref;    zend_ast_ref     *ast;    zval             *zv;    <span class="hljs-keyword">void</span>             *ptr;    zend_class_entry *ce;    zend_function    *func;    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>        <span class="hljs-keyword">uint32_t</span> w1;        <span class="hljs-keyword">uint32_t</span> w2;    &#125; ww;&#125; zend_value;</code></pre><h3 id="2-PHP-如何与-nginx-通信，通信方式有什么异同"><a href="#2-PHP-如何与-nginx-通信，通信方式有什么异同" class="headerlink" title="2. PHP 如何与 nginx 通信，通信方式有什么异同"></a>2. PHP 如何与 nginx 通信，通信方式有什么异同</h3><ul><li><a href="https://vsxen.github.io/2017/05/30/phpcgi-socks-vs-tcp/">https://vsxen.github.io/2017/05/30/phpcgi-socks-vs-tcp/</a></li></ul><h4 id="CGI-模式"><a href="#CGI-模式" class="headerlink" title="CGI 模式"></a>CGI 模式</h4><p>CGI CGI（common gateway interface）通常翻译为共同网关接口，是 HTTP 服务器与机器上的其他程序进行通信的一个接口，让 Web 服务器必要时启动额外的程序处理动态内容。CGI 是一种协议，它定义了 Webserver 与 CGI 程序的通信方式。Webserver 接受客户端的 HTTP 请求，然后建立进程执行 CGI 程序，客户端的请求被传递给 CGI 程序，CGI 执行后结果再返回 Webserver。 CGI 的出现让 WEB 从静态变为为动态，随着 Web 的越来越普及，很多的网站的都需要有动态的页面，以便与浏览者互交。随着网络技术的发展，CGI 方式的缺点也越来越突出。每次客户端请求都需要建立和销毁进程。因为 HTTP 要生成一个动态页面，系统就必须启动一个新的进程以运行 CGI 程序，不断地 fork 是一项很消耗时间和资源的工作。</p><h4 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h4><p>众所周知，CGI 解释器的反复加载是 CGI 性能低下的主要原因，如果 CGI 解释器保持在内存中 并接受 FastCGI 进程管理器调度，则可以提供良好的性能、伸缩性、Fail-Over 特性等等。</p><p>FastCGI 是一个常驻型的 CGI，可以一直执行，只要激活后，不会每次都花时间去 fork 一次，而且还支持分布式运算（使得 php 程序解释执行可以单独交给 php 服务器），即可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。</p><p>1、Web Server 启动时载入 FastCGI 进程管理器（IIS ISAPI 或 Apache Module）;<br>2、FastCGI 进程管理器自身初始化，启动多个 CGI 解释器进程 (在任务管理器中可见多个 php-cgi.exe)并等待来自 Web Server 的连接。<br>3、当客户端请求到达 Web Server 时，FastCGI 进程管理器选择并连接到一个 CGI 解释器。Web server 将 CGI 环境变量和标准输入发送到 FastCGI 子进程 php-cgi.exe。<br>4、FastCGI 子进程完成处理后将标准输出和错误信息从同一连接返回 Web Server。当 FastCGI 子进程关闭连接时，请求便告处理完成。FastCGI 子进程接着等待并处理来自 FastCGI 进程管理器（运行在 WebServer 中）的下一个连接。 在正常的 CGI 模式中，php-cgi.exe 在此便退出了</p><h4 id="Apache-模块"><a href="#Apache-模块" class="headerlink" title="Apache 模块"></a>Apache 模块</h4><p>MPM Multi Path Modules （多道处理模块）用于定义 apache 在响应多个用户请求时所工作的模型。有三种 MPM 模式：</p><p>prefork（一个请求一个进程响应）</p><p>worker（一个请求用一个线程响应，启动多个进程每个进程生成多个线程）</p><p>event（一个进程处理多个请求）</p><p>以模块安装的 php 没有独立的进程，是作为 apache 的模块和 apache 一起启动的。</p><p>以上三种 MPM 模式，worker 模式会比 prefork 模式占据更少的内存，高并发下的表现更好。而且使用多进程和多线程混合模式，即使有一个线程挂了，也只影响和该线程同进程的其他线程，不会影响到其他的进程。但是如果有特别多的线程都使用 keep-alive 的长连接方式，则线程会一直被占据直到超时才释放，导致在高并发场景下无可用线程。而 event 模式使用了一个专门的线程来处理这些 keep-alive 类线程，较好的解决了这个问题。</p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>Nginx 处理 PHP 文件 只有 FastCGI 一种<br>不过 Nginx 连接 fastcgi 的方式有 2 种：TCP 和 unix domain socket<br>Unix domain socket 或者 IPC socket 是一种终端，可以使同一台操作系统上的两个或多个进程进行数据通信。与管道相比，Unix domain sockets 既可以使用字节流和数据队列，而管道通信则只能通过字节流。Unix domain sockets 的接口和 Internet socket 很像，但它不使用网络底层协议来通信。Unix domain socket 的功能是 POSIX 操作系统里的一种组件。<br>Unix domain sockets 使用系统文件的地址来作为自己的身份。它可以被系统进程引用。所以两个进程可以同时打开一个 Unix domain sockets 来进行通信。不过这种通信方式是发生在系统内核里而不会在网络里传播。<br>TCP 和 unix domain socket 方式对比<br>TCP 是使用 TCP 端口连接 127.0.0.1:9000<br>Socket 是使用 unix domain socket 连接套接字/dev/shm/php-cgi.sock（很多教程使用路径/tmp，而路径/dev/shm 是个 tmpfs，速度比磁盘快得多）<br>测试机是个 1 核的 centos5.4，2 用户并发时系统资源消耗 50%左右，10 用户资源就跑得很满了</p><p>结论是在服务器压力不大的情况下，tcp 和 socket 差别不大，但在压力比较满的时候，用套接字方式，效果确实比较好。<br>下面是 php 5.3 以上版本将 TCP 改成 socket 方式的配置方法：<br>修改 php-fpm.conf（/usr/local/php/etc/php-fpm.conf）<br>;listen = 127.0.0.1:9000<br>listen = /dev/shm/php-cgi.sock<br>修改 nginx 配置文件 server 段的配置，将 http 的方式改为 socket 方式</p><p>从原理上来说，unix socket 方式肯定要比 tcp 的方式快而且消耗资源少，因为 socket 之间在 nginx 和 php-fpm 的进程之间通信，而 tcp 需要经过本地回环驱动，还要申请临时端口和 tcp 相关资源。<br>当然还是从原理上来说，unix socket 会显得不是那么稳定，当并发连接数爆发时，会产生大量的长时缓存，在没有面向连接协议支撑的情况下，大数据包很有可能就直接出错并不会返回异常。而 TCP 这样的面向连接的协议，多少可以保证通信的正确性和完整性。</p><h3 id="3-PHP-的执行模式有哪些"><a href="#3-PHP-的执行模式有哪些" class="headerlink" title="3. PHP 的执行模式有哪些"></a>3. PHP 的执行模式有哪些</h3><ul><li><a href="http://blog.csdn.net/xujingzhong0077/article/details/53316767">http://blog.csdn.net/xujingzhong0077/article/details/53316767</a></li></ul><h4 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h4><p>关于 PHP 目前比较常见的五大运行模式：<br>1）CGI（通用网关接口/ Common Gateway Interface）<br>2）FastCGI（常驻型 CGI / Long-Live CGI）<br>3）CLI（命令行运行 / Command Line Interface）<br>4）Web 模块模式（Apache 等 Web 服务器运行的模式）<br>5）ISAPI（Internet Server Application Program Interface）</p><p>备注：在 PHP5.3 以后，PHP 不再有 ISAPI 模式，安装后也不再有 php5isapi.dll 这个文件。要在 IIS6 上使用高版本 PHP，必须安装 FastCGI 扩展，然后使 IIS6 支持 FastCGI。</p><h4 id="1-1、CGI-模式"><a href="#1-1、CGI-模式" class="headerlink" title="1.1、CGI 模式"></a>1.1、CGI 模式</h4><p>CGI 即通用网关接口（Common Gateway Interface），它是一段程序，通俗的讲 CGI 就象是一座桥，把网页和 Web 服务器中的执行程序连接起来，它把 HTML 接收的指令传递给服务器的执行程序，再把服务器执行程序的结果返还给 HTML 页。CGI 的跨平台性能极佳，几乎可以在任何操作系统上实现。CGI 已经是比较老的模式了，这几年都很少用了。</p><p>每有一个用户请求，都会先要创建 CGI 的子进程，然后处理请求，处理完后结束这个子进程，这就是 Fork-And-Execute 模式。 当用户请求数量非常多时，会大量挤占系统的资源如内存，CPU 时间等，造成效能低下。所以用 CGI 方式的服务器有多少连接请求就会有多少 CGI 子进程，子进程反复加载是 CGI 性能低下的主要原因。</p><p>如果不想把 PHP 嵌入到服务器端软件（如 Apache）作为一个模块安装的话，可以选择以 CGI 的模式安装。或者把 PHP 用于不同的 CGI 封装以便为代码创建安全的 chroot 和 setuid 环境。这样每个客户机请求一个 PHP 文件，Web 服务器就调用 php.exe（win 下是 php.exe,linux 是 php）去解释这个文件，然后再把解释的结果以网页的形式返回给客户机。 这种安装方式通常会把 PHP 的可执行文件安装到 web 服务器的 cgi-bin 目录。CERT 建议书 CA-96.11 建议不要把任何的解释器放到 cgi-bin 目录。 这种方式的好处是把 Web Server 和具体的程序处理独立开来，结构清晰，可控性强，同时缺点就是如果在高访问需求的情况下，CGI 的进程 Fork 就会成为很大的服务器负担，想 象一下数百个并发请求导致服务器 Fork 出数百个进程就明白了。这也是为什么 CGI 一直背负性能低下，高资源消耗的恶名的原因。</p><h4 id="1-2、FastCGI-模式"><a href="#1-2、FastCGI-模式" class="headerlink" title="1.2、FastCGI 模式"></a>1.2、FastCGI 模式</h4><p>FastCGI 是 CGI 的升级版本，FastCGI 像是一个常驻 (long-live)型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去 Fork 一次 （这是 CGI 最为人诟病的 fork-and-execute 模式）。<br>FastCGI 是一个可伸缩地、高速地在 HTTP server 和动态脚本语言间通信的接口。多数流行的 HTTP server 都支持 FastCGI，包括 Apache、Nginx 和 lighttpd 等，同时，FastCGI 也被许多脚本语言所支持，其中就有 PHP。<br>FastCGI 接口方式采用 C/S 结构，可以将 HTTP 服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当 HTTP 服务器每次遇到动态程序时，可以将其直接交付给 FastCGI 进程来执行，然后将得到的结果返回给浏览器。这种方式可以让 HTTP 服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。</p><p>【原理】<br>1）Web Server 启动时载入 FastCGI 进程管理器（IIS ISAPI 或 Apache Module)；<br>2）FastCGI 进程管理器自身初始化，启动多个 CGI 解释器进程 (可见多个 php-cgi.exe 或 php-cig)并等待来自 Web Server 的连接；<br>3）当客户端请求到达 Web Server 时，FastCGI 进程管理器选择并连接到一个 CGI 解释器。Web server 将 CGI 环境变量和标准输入发送到 FastCGI 子进程 php-cgi；<br>4）FastCGI 子进程完成处理后将标准输出和错误信息从同一连接返回 Web Server。当 FastCGI 子进程关闭连接时，请求便告处理完成。FastCGI 子进程接着等待并处理来自 FastCGI 进程管理器（运行在 WebServer 中）的下一个连接。在正常的 CGI 模式中，php-cgi.exe 在此便退出了。<br>在 CGI 模式中，你可以想象 CGI 通常有多慢。每一个 Web 请求 PHP 都必须重新解析 php.ini、重新载入全部 dll 扩展并重初始化全部数据结构。使用 FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接（Persistent database connection）可以工作。</p><p>备注：PHP 的 FastCGI 进程管理器是 PHP-FPM（PHP-FastCGI Process Manager）<br>【优点】<br>1）从稳定性上看，FastCGI 是以独立的进程池来运行 CGI，单独一个进程死掉，系统可以很轻易的丢弃，然后重新分配新的进程来运行逻辑；<br>2）从安全性上看，FastCGI 支持分布式运算。FastCGI 和宿主的 Server 完全独立，FastCGI 怎么 down 也不会把 Server 搞垮；<br>3）从性能上看，FastCGI 把动态逻辑的处理从 Server 中分离出来，大负荷的 IO 处理还是留给宿主 Server，这样宿主 Server 可以一心一意作 IO，对于一个普通的动态网页来说, 逻辑处理可能只有一小部分，大量的是图片等静态。</p><p>【缺点】<br>说完了好处，也来说说缺点。从我的实际使用来看，用 FastCGI 模式更适合生产环境的服务器。但对于开发用机器来说就不太合适。因为当使用 Zend Studio 调试程序时，由于 FastCGI 会认为 PHP 进程超时，从而在页面返回 500 错误。这一点让人非常恼火，所以我在开发机器上还是换回了 ISAPI 模式。对某些服务器的新版本支持不好，对分布式负载均衡没要求的模块化安装是否是更好的选择。目前的 FastCGI 和 Server 沟通还不够智能，一个 FastCGI 进程如果执行时间过长会被当成是死进程杀掉重起，这样在处理长时间任务的时候很麻烦，这样做也使得 FastCGI 无法允许联机调试。因为是多进程，所以比 CGI 多线程消耗更多的服务器内存，PHP-CGI 解释器每进程消耗 7 至 25 兆内存，将这个数字乘以 50 或 100 就是很大的内存数。</p><h4 id="1-3-CLI-模式"><a href="#1-3-CLI-模式" class="headerlink" title="1.3 CLI 模式"></a>1.3 CLI 模式</h4><p>PHP-CLI 是 PHP Command Line Interface 的简称，如同它名字的意思，就是 PHP 在命令行运行的接口，区别于在 Web 服务器上运行的 PHP 环境（PHP-CGI，ISAPI 等）。 也就是说，PHP 不单可以写前台网页，它还可以用来写后台的程序。 PHP 的 CLI Shell 脚本适用于所有的 PHP 优势，使创建要么支持脚本或系统甚至与 GUI 应用程序的服务端，在 Windows 和 Linux 下都是支持 PHP-CLI 模式的。<br>【优点】<br>1）使用多进程，子进程结束以后，内核会负责回收资源；<br>2）使用多进程，子进程异常退出不会导致整个进程 Thread 退出，父进程还有机会重建流程；<br>3）一个常驻主进程，只负责任务分发，逻辑更清楚。<br>我们在 Linux 下经常使用”php –m”查找 PHP 安装了那些扩展就是 PHP 命令行运行模式；有兴趣的同学可以输入”php –h”去深入研究该运行模式。</p><h4 id="1-4-模块模式"><a href="#1-4-模块模式" class="headerlink" title="1.4 模块模式"></a>1.4 模块模式</h4><p>模块模式是以 mod_php5 模块的形式集成，此时 mod_php5 模块的作用是接收 Apache 传递过来的 PHP 文件请求，并处理这些请求，然后将处理后的结果返回给 Apache。如果我们在 Apache 启动前在其配置文件中配置好了 PHP 模块<br>（mod_php5）， PHP 模块通过注册 apache2 的 ap_hook_post_config 挂钩，在 Apache 启动的时候启动此模块以接受 PHP 文件的请求。<br>除了这种启动时的加载方式，Apache 的模块可以在运行的时候动态装载，这意味着对服务器可以进行功能扩展而不需要重新对源代码进行编译，甚至根本不需要停止服务器。我们所需要做的仅仅是给服务器发送信号 HUP 或者 AP_SIG_GRACEFUL 通知服务器重新载入模块。但是在动态加载之前，我们需要将模块编译成为动态链接库。此时的动态加载就是加载动态链接库。 Apache 中对动态链接库的处理是通过模块 mod_so 来完成的，因此 mod_so 模块不能被动态加载，它只能被静态编译进 Apache 的核心。这意味着它是随着 Apache 一起启动的。<br>Apache 是如何加载模块的呢？我们以前面提到的 mod_php5 模块为例。首先我们需要在 Apache 的配置文件 httpd.conf 中添加一行：<br>LoadModule php5_module modules/mod_php5.so</p><p>这里我们使用了 LoadModule 命令，该命令的第一个参数是模块的名称，名称可以在模块实现的源码中找到。第二个选项是该模块所处的路径。如果需要在服务器运行时加载模块，可以通过发送信号 HUP 或者 AP_SIG_GRACEFUL 给服务器，一旦接受到该信号，Apache 将重新装载模块，而不需要重新启动服务器。<br>该运行模式是我们以前在 windows 环境下使用 apache 服务器经常使用的，而在模块化（DLL）中，PHP 是与 Web 服务器一起启动并运行的。（它是 apache 在 CGI 的基础上进行的一种扩展，加快 PHP 的运行效率）。</p><h4 id="1-5-ISAPI-模式"><a href="#1-5-ISAPI-模式" class="headerlink" title="1.5 ISAPI 模式"></a>1.5 ISAPI 模式</h4><p>ISAPI（Internet Server Application Program Interface）是微软提供的一套面向 Internet 服务的 API 接口，一个 ISAPI 的 DLL，可以在被用户请求激活后长驻内存，等待用户的另一个请求，还可以在一个 DLL 里设置多个用户请求处理函数，此外，ISAPI 的 DLL 应用程序和 WWW 服务器处于同一个进程中，效率要显著高于 CGI。（由于微软的排他性，只能运行于 windows 环境）<br>PHP 作为 Apache 模块，Apache 服务器在系统启动后，预先生成多个进程副本驻留在内存中，一旦有请求出现，就立即使用这些空余的子进程进行处理，这样就不存在生成子进程造成的延迟了。这些服务器副本在处理完一次 HTTP 请求之后并不立即退出，而是停留在计算机中等待下次请求。对于客户浏览器的请求反应更快，性能较高。</p><h3 id="4-PHP-代码的执行流程"><a href="#4-PHP-代码的执行流程" class="headerlink" title="4. PHP 代码的执行流程"></a>4. PHP 代码的执行流程</h3><ul><li><a href="http://blog.csdn.net/a2534725767/article/details/55194582">http://blog.csdn.net/a2534725767/article/details/55194582</a></li></ul><pre><code class="hljs css">1<span class="hljs-selector-class">.Scanning</span>(<span class="hljs-selector-tag">Lexing</span>) ,将<span class="hljs-selector-tag">PHP</span>代码转换为语言片段(<span class="hljs-selector-tag">Tokens</span>)2<span class="hljs-selector-class">.Parsing</span>, 将<span class="hljs-selector-tag">Tokens</span>转换成简单而有意义的表达式3<span class="hljs-selector-class">.Compilation</span>, 将表达式编译成<span class="hljs-selector-tag">Opocdes</span>4<span class="hljs-selector-class">.Execution</span>, 顺次执行<span class="hljs-selector-tag">Opcodes</span>，每次一条，从而实现<span class="hljs-selector-tag">PHP</span>脚本的功能。</code></pre><h3 id="5-PHP-与-Golang-的区别"><a href="#5-PHP-与-Golang-的区别" class="headerlink" title="5. PHP 与 Golang 的区别"></a>5. PHP 与 Golang 的区别</h3><h4 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h4><ul><li><a href="http://www.yinwang.org/blog-cn/2014/04/18/golang">对 Go 语言的综合评价</a></li><li><a href="https://www.zhihu.com/question/21409296">Go 语言的优势在哪里？</a></li><li><a href="http://blog.csdn.net/liigo/article/details/23699459">我为什么放弃 Go 语言</a></li><li><a href="http://blog.csdn.net/a82168506/article/details/6664714">php 的优缺点</a></li><li><a href="http://www.cnblogs.com/xiaotaoing/p/6687418.html">php 优缺点</a></li></ul><blockquote><p>面试的时候基本上上面说到的都说到了一些但是面试的时候逻辑还是不够清晰</p></blockquote><h3 id="6-深度优先遍历与广度优先遍历"><a href="#6-深度优先遍历与广度优先遍历" class="headerlink" title="6. 深度优先遍历与广度优先遍历"></a>6. 深度优先遍历与广度优先遍历</h3><ul><li><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/18/2596983.html">http://www.cnblogs.com/biyeymyhjob/archive/2012/07/18/2596983.html</a></li></ul><h4 id="a-DFS"><a href="#a-DFS" class="headerlink" title="a. DFS"></a>a. DFS</h4><p>（1）访问顶点 v；<br>（2）从 v 的未被访问的邻接点中选取一个顶点 w，从 w 出发进行深度优先遍历；<br>（3）重复上述两步，直至图中所有和 v 有路径相通的顶点都被访问到。</p><h4 id="b-BFS"><a href="#b-BFS" class="headerlink" title="b. BFS"></a>b. BFS</h4><p>（1）顶点 v 入队列。<br>（2）当队列非空时则继续执行，否则算法结束。<br>（3）出队列取得队头顶点 v；访问顶点 v 并标记顶点 v 已被访问。<br>（4）查找顶点 v 的第一个邻接顶点 col。<br>（5）若 v 的邻接顶点 col 未被访问过的，则 col 入队列。<br>（6）继续查找顶点 v 的另一个新的邻接顶点 col，转到步骤（5）。<br>直到顶点 v 的所有未被访问过的邻接点处理完。转到步骤（2）。<br>广度优先遍历图是以顶点 v 为起始点，由近至远，依次访问和 v 有路径相通而且路径长度为 1，2，……的顶点。为了使“先被访问顶点的邻接点”先于“后被访问顶点的邻接点”被访问，需设置队列存储访问的顶点。</p><h3 id="7-浏览器输入一个-URL-之后发生了什么事情"><a href="#7-浏览器输入一个-URL-之后发生了什么事情" class="headerlink" title="7. 浏览器输入一个 URL 之后发生了什么事情"></a>7. 浏览器输入一个 URL 之后发生了什么事情</h3><ul><li><a href="http://www.cnblogs.com/wenanry/archive/2010/02/25/1673368.html">http://www.cnblogs.com/wenanry/archive/2010/02/25/1673368.html</a></li></ul><h3 id="8-遍历一个目录下面所有的文件以及文件夹"><a href="#8-遍历一个目录下面所有的文件以及文件夹" class="headerlink" title="8. 遍历一个目录下面所有的文件以及文件夹"></a>8. 遍历一个目录下面所有的文件以及文件夹</h3><blockquote><p>面试的时候写了一个 DFS，一下被问到 BFS 怎么写的时候短路了，没有想起了，其实实现的方法不难，参考问题 6</p></blockquote><h3 id="其实还有其他的问题，不过忘了"><a href="#其实还有其他的问题，不过忘了" class="headerlink" title="其实还有其他的问题，不过忘了"></a>其实还有其他的问题，不过忘了</h3><h2 id="三面-20min"><a href="#三面-20min" class="headerlink" title="三面[20min]"></a>三面[20min]</h2><blockquote><p>三面没有被问到技术细节</p></blockquote><h3 id="0-自我介绍-1"><a href="#0-自我介绍-1" class="headerlink" title="0. 自我介绍"></a>0. 自我介绍</h3><h3 id="1-简单的介绍了一个项目"><a href="#1-简单的介绍了一个项目" class="headerlink" title="1. 简单的介绍了一个项目"></a>1. 简单的介绍了一个项目</h3><h3 id="2-在平时做项目的时候遇到的难点"><a href="#2-在平时做项目的时候遇到的难点" class="headerlink" title="2. 在平时做项目的时候遇到的难点"></a>2. 在平时做项目的时候遇到的难点</h3><p>几个方面简单讲了一下，团队协作的难点，技术难点，心理难点</p><h3 id="3-团队合作当中如果碰到一个-BUG，但是开发人员觉得不重要，你觉得重要怎么班？"><a href="#3-团队合作当中如果碰到一个-BUG，但是开发人员觉得不重要，你觉得重要怎么班？" class="headerlink" title="3. 团队合作当中如果碰到一个 BUG，但是开发人员觉得不重要，你觉得重要怎么班？"></a>3. 团队合作当中如果碰到一个 BUG，但是开发人员觉得不重要，你觉得重要怎么班？</h3><p>坚持不放过为底线，换位思考，以产品和用户的角度劝说开发</p><h3 id="4-对加班有什么看法？"><a href="#4-对加班有什么看法？" class="headerlink" title="4. 对加班有什么看法？"></a>4. 对加班有什么看法？</h3><p>正常现象，完全可以接受</p><h3 id="5-为什么想去深圳？"><a href="#5-为什么想去深圳？" class="headerlink" title="5. 为什么想去深圳？"></a>5. 为什么想去深圳？</h3><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/1358.html">招银网络面试总结</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>秋招</tag>
      
      <tag>百度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遗传算法</title>
    <link href="/post/34642.html"/>
    <url>/post/34642.html</url>
    
    <content type="html"><![CDATA[<h2 id="实现示例-Golang"><a href="#实现示例-Golang" class="headerlink" title="实现示例-Golang"></a>实现示例-Golang</h2><p><a href="https://github.com/mohuishou/algorithm/tree/master/GA">github</a></p><pre><code class="hljs golang"><span class="hljs-keyword">package</span> GA<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math&quot;</span><span class="hljs-string">&quot;math/rand&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-keyword">var</span> (groupSize      <span class="hljs-keyword">int</span>      <span class="hljs-comment">//种群大小</span>chromosomeSize <span class="hljs-keyword">int</span>      <span class="hljs-comment">//染色体长度</span>selectRand     <span class="hljs-keyword">float64</span>  <span class="hljs-comment">//轮盘选择概率</span>crossRand      <span class="hljs-keyword">float64</span>  <span class="hljs-comment">//交叉概率</span>mutationRand   <span class="hljs-keyword">float64</span>  <span class="hljs-comment">//变异概率</span>group          []Person <span class="hljs-comment">//种群</span>bestPerson     Person   <span class="hljs-comment">//当前最好的个体</span>r              *rand.Rand)<span class="hljs-comment">//Person 个体</span><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;chromosome []<span class="hljs-keyword">int</span>   <span class="hljs-comment">//染色体</span>value      <span class="hljs-keyword">float64</span> <span class="hljs-comment">//适应值</span>&#125;<span class="hljs-comment">//Init 初始化函数</span><span class="hljs-comment">//初始化设置种群大小、轮盘选择概率、交叉概率已经变异的概率</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Init</span><span class="hljs-params">(GroupSize, ChromosomeSize <span class="hljs-keyword">int</span>, SelectRand, CrossRand, MutationRand <span class="hljs-keyword">float64</span>)</span></span> &#123;groupSize = GroupSizecrossRand = CrossRandselectRand = SelectRandmutationRand = MutationRandchromosomeSize = ChromosomeSizer = rand.New(rand.NewSource(time.Now().UnixNano()))bestPerson.chromosome = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, chromosomeSize)&#125;<span class="hljs-comment">//InitGroup 初始化种群</span><span class="hljs-comment">//根据种群大小随机产生一些个体填充</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitGroup</span><span class="hljs-params">()</span></span> &#123;group = <span class="hljs-built_in">make</span>([]Person, groupSize)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; groupSize; i++ &#123;group[i].chromosome = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, chromosomeSize)<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; chromosomeSize; j++ &#123;<span class="hljs-keyword">if</span> r.Float64() &gt; selectRand &#123;group[i].chromosome[j] = <span class="hljs-number">1</span>&#125;&#125;&#125;&#125;<span class="hljs-comment">//Fitness 计算适应值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fitness</span><span class="hljs-params">(person Person)</span> <span class="hljs-title">float64</span></span> &#123;x := decode(person)<span class="hljs-keyword">return</span> x + <span class="hljs-number">10</span>*math.Sin(<span class="hljs-number">5</span>*x) + <span class="hljs-number">7</span>*math.Cos(<span class="hljs-number">4</span>*x)&#125;<span class="hljs-comment">//解码</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decode</span><span class="hljs-params">(person Person)</span> <span class="hljs-title">float64</span></span> &#123;<span class="hljs-keyword">var</span> sum <span class="hljs-keyword">float64</span><span class="hljs-comment">//解码</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; chromosomeSize; i++ &#123;<span class="hljs-comment">//二进制染色体转十进制值</span><span class="hljs-keyword">if</span> person.chromosome[i] == <span class="hljs-number">1</span> &#123;sum = sum + math.Pow(<span class="hljs-number">2.0</span>, <span class="hljs-keyword">float64</span>(i))&#125;&#125;<span class="hljs-keyword">return</span> sum * <span class="hljs-number">9</span> / (math.Pow(<span class="hljs-number">2.0</span>, <span class="hljs-number">14.0</span>) - <span class="hljs-number">1</span>)&#125;<span class="hljs-comment">//Select 选择</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Select</span><span class="hljs-params">()</span></span> &#123;newGroup := <span class="hljs-built_in">make</span>([]Person, groupSize)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; groupSize; i++ &#123;newGroup[i].chromosome = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, chromosomeSize)rnd := r.Float64()A:<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; groupSize; j++ &#123;<span class="hljs-keyword">if</span> group[j].value &gt; rnd*bestPerson.value &#123;<span class="hljs-built_in">copy</span>(newGroup[i].chromosome, group[j].chromosome)<span class="hljs-keyword">break</span> A&#125;<span class="hljs-keyword">if</span> j == groupSize<span class="hljs-number">-1</span> &#123;<span class="hljs-built_in">copy</span>(newGroup[i].chromosome, bestPerson.chromosome)&#125;&#125;&#125;group = newGroupnewGroup = <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">//Cross 交叉</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Cross</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; groupSize; i = i + <span class="hljs-number">2</span> &#123;<span class="hljs-keyword">if</span> r.Float64() &lt; crossRand &#123;crossPosition := r.Intn(chromosomeSize - <span class="hljs-number">1</span>)<span class="hljs-keyword">if</span> crossPosition == <span class="hljs-number">0</span> || crossPosition == <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">continue</span>&#125;<span class="hljs-comment">//交叉</span><span class="hljs-keyword">for</span> j := crossPosition; j &lt; chromosomeSize; j++ &#123;tmp := group[i].chromosome[j]group[i].chromosome[j] = group[i+<span class="hljs-number">1</span>].chromosome[j]group[i+<span class="hljs-number">1</span>].chromosome[j] = tmp&#125;&#125;&#125;&#125;<span class="hljs-comment">//Mutation 变异</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Mutation</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; groupSize; i++ &#123;<span class="hljs-keyword">if</span> r.Float64() &lt; mutationRand &#123;mutationPosition := r.Intn(chromosomeSize - <span class="hljs-number">1</span>)<span class="hljs-comment">//单点变异</span><span class="hljs-keyword">if</span> group[i].chromosome[mutationPosition] == <span class="hljs-number">0</span> &#123;group[i].chromosome[mutationPosition] = <span class="hljs-number">1</span>&#125; <span class="hljs-keyword">else</span> &#123;group[i].chromosome[mutationPosition] = <span class="hljs-number">0</span>&#125;&#125;&#125;&#125;<span class="hljs-comment">//GA 遗传算法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GA</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//初始化</span>Init(<span class="hljs-number">100</span>, <span class="hljs-number">14</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.05</span>)<span class="hljs-comment">//初始化种群</span>InitGroup()<span class="hljs-comment">//遗传循环</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++ &#123;<span class="hljs-comment">//计算适应值</span><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; groupSize; j++ &#123;group[j].value = Fitness(group[j])<span class="hljs-comment">//保存当前最好的个体</span><span class="hljs-keyword">if</span> group[j].value &gt; bestPerson.value &#123;<span class="hljs-built_in">copy</span>(bestPerson.chromosome, group[j].chromosome)bestPerson.value = group[j].valuefmt.Println(<span class="hljs-string">&quot;第&quot;</span>, i, <span class="hljs-string">&quot;代最好个体：&quot;</span>, bestPerson.value, <span class="hljs-string">&quot; &quot;</span>, decode(bestPerson))&#125;&#125;<span class="hljs-comment">//选择</span>Select()<span class="hljs-comment">//交叉</span>Cross()<span class="hljs-comment">//变异</span>Mutation()&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/defer.html">Go数据结构与算法05-栈下: 深入理解 defer</a></li><li><a href="https://lailin.xyz/post/stack.html">Go数据结构与算法04-栈上: 如何实现一个计算器</a></li><li><a href="https://lailin.xyz/post/array_2.html">Go数据结构与算法03-数组下: 使用 GDB 调试 Golang 代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>算法</tag>
      
      <tag>遗传算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径算法SPFA</title>
    <link href="/post/21230.html"/>
    <url>/post/21230.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>前面说了单源最短路径算法 Dijkstra，以及多源最短路径算法 Floyd，但是都不能适用于有负权边存在的情况，这里实现一下是西南交通大学段凡丁于 1994 年发表的 SPFA（Shortest Path Faster Algorithm）算法。该算法在 Bellman-ford 算法的基础上加上一个队列优化，减少了冗余的松弛操作。</p></blockquote><blockquote><p>spfa 可以适用于有负权边存在的情况，但是无法求解存在负权回路的情况，但是可以判断</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>只要最短路径存在，SPFA 算法必定能求出最小值。证明：每次将点放入队尾，都是经过松弛操作达到的。换言之，每次的优化将会有某个点 v 的最短路径估计值 d[v]变小。所以算法的执行会使 d 越来越小。由于我们假定图中不存在负权回路，所以每个结点都有最短路径值。因此，算法不会无限执行下去，随着 d 值的逐渐变小，直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="github"><a href="#github" class="headerlink" title="github"></a><a href="https://github.com/mohuishou/algorithm/tree/master/ShortestPath/Floyd">github</a></h3><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><pre><code class="hljs go">q := list.New()q.PushBack(s)<span class="hljs-comment">//循环跳出条件：队列为空</span><span class="hljs-keyword">for</span> q.Len() != <span class="hljs-number">0</span> &#123;u := q.Front().Value.(Graph.VextexType)q.Remove(q.Front())<span class="hljs-comment">//释放对点u的标记</span>visited[u] = <span class="hljs-literal">false</span>e := graph.G[u].FisrtEdge<span class="hljs-keyword">for</span> e != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//这条边下的顶点</span>v := e.V<span class="hljs-comment">//如果当前点的距离加上边的距离小于之前该点的距离，那么就更新该点的距离</span><span class="hljs-keyword">if</span> dist[v] &gt; dist[u]+e.Weight &#123;dist[v] = dist[u] + e.Weight <span class="hljs-comment">//更新该点距离</span>path[v] = u                  <span class="hljs-comment">//更新父节点</span><span class="hljs-comment">//如果顶点不在队内，则将顶点入队</span><span class="hljs-keyword">if</span> visited[v] == <span class="hljs-literal">false</span> &#123;q.PushBack(v) <span class="hljs-comment">//将该点入队</span>visited[v] = <span class="hljs-literal">true</span>count[v]++<span class="hljs-comment">//出现负环，报错</span><span class="hljs-keyword">if</span> count[v] &gt; graph.VNum &#123;<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;存在负环！&quot;</span>)&#125;&#125;&#125;e = e.Next&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></code></pre><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><pre><code class="hljs go">visited[u] = <span class="hljs-literal">true</span>e := graph.G[u].FisrtEdge<span class="hljs-keyword">for</span> e != <span class="hljs-literal">nil</span> &#123;v := e.V<span class="hljs-keyword">if</span> dist[v] &gt; dist[u]+e.Weight &#123;dist[v] = dist[u] + e.Weight <span class="hljs-comment">//更新该点距离</span>path[v] = u                  <span class="hljs-comment">//更新父节点</span><span class="hljs-keyword">if</span> visited[v] == <span class="hljs-literal">false</span> &#123;count[v]++<span class="hljs-keyword">if</span> count[v] &gt; graph.VNum &#123;<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;存在负环！&quot;</span>)&#125;<span class="hljs-comment">//注意DFS的结果不能直接return，直接return的时候回溯的时候就没有办法在上一级重新找值了</span>err := DFS(v)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;&#125;e = e.Next&#125;visited[u] = <span class="hljs-literal">false</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/defer.html">Go数据结构与算法05-栈下: 深入理解 defer</a></li><li><a href="https://lailin.xyz/post/stack.html">Go数据结构与算法04-栈上: 如何实现一个计算器</a></li><li><a href="https://lailin.xyz/post/array_2.html">Go数据结构与算法03-数组下: 使用 GDB 调试 Golang 代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>最短路径</tag>
      
      <tag>spfa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径算法-Floyd</title>
    <link href="/post/60101.html"/>
    <url>/post/60101.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>在上一篇当中讲了 Dijkstra 算法，Dijkstra 适用于对于单源路径的求取，但是对于任意两个点之间的最小路径呢？首先想到的当然是直接使用多次的 Dijkstra 算法来求取任意两点之间的最短路径，但是这样下来时间复杂度会比较大，所以使用一种新的算法，Floyd 算法来求取最短路径</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Floyd 算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点 i 到点 j 的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释<br>从任意节点 i 到任意节点 j 的最短路径不外乎 2 种可能:</p><ul><li>1.直接从 i 到 j，</li><li>2.从 i 经过若干个节点 k 到 j。<br>所以，我们假设 Dis(i,j)为节点 u 到节点 v 的最短路径的距离，对于每一个节点 k，我们检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到 j 的路径短，我们便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点 k，Dis(i,j)中记录的便是 i 到 j 的最短路径的距离。</li></ul><h2 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h2><p>a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 　　<br>b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。</p><h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> ShortestPath<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;github.com/mohuishou/algorithm/GraphMatrix&quot;</span>)<span class="hljs-comment">//Floyd 求取多源最短路径</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Floyd</span><span class="hljs-params">(graph GraphMatrix.Graph, dist [][]GraphMatrix.EdgeType, path [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; graph.VNum; i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; graph.VNum; j++ &#123;path[i][j] = <span class="hljs-number">-1</span>dist[i][j] = graph.G[i][j]&#125;&#125;    <span class="hljs-comment">//注意，k必须放在最外层，如果放在最里层会过早的确认两点的最短路径</span><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; graph.VNum; k++ &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; graph.VNum; i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; graph.VNum; j++ &#123;<span class="hljs-comment">//找到更短的路径</span><span class="hljs-keyword">if</span> dist[i][k]+dist[k][j] &lt; dist[i][j] &#123;dist[i][j] = dist[i][k] + dist[k][j]<span class="hljs-comment">//发现负值圈</span><span class="hljs-keyword">if</span> i == j &amp;&amp; dist[i][j] &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;存在负值圈&quot;</span>)&#125;path[i][j] = k&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">//GetPathForFloyd 获取路径</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPathForFloyd</span><span class="hljs-params">(path [][]<span class="hljs-keyword">int</span>, s, t <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(tPath []<span class="hljs-keyword">int</span>)</span></span> &#123;tPath = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)tPath[<span class="hljs-number">0</span>] = s<span class="hljs-keyword">for</span> &#123;s = path[s][t]<span class="hljs-keyword">if</span> s == <span class="hljs-number">-1</span> || s == t &#123;tPath = <span class="hljs-built_in">append</span>(tPath, t)<span class="hljs-keyword">return</span> tPath&#125;tPath = <span class="hljs-built_in">append</span>(tPath, s)&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/defer.html">Go数据结构与算法05-栈下: 深入理解 defer</a></li><li><a href="https://lailin.xyz/post/stack.html">Go数据结构与算法04-栈上: 如何实现一个计算器</a></li><li><a href="https://lailin.xyz/post/array_2.html">Go数据结构与算法03-数组下: 使用 GDB 调试 Golang 代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>最短路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>邻接表-Golang</title>
    <link href="/post/18885.html"/>
    <url>/post/18885.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>最简单直接的办法一般就是使用邻接矩阵的办法来表示图，但是对于稀疏图来说边的数目想对来说比较少的情况下，使用邻接矩阵的办法会比较浪费资源，所以这里采用邻接表</p></blockquote><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p><a href="https://github.com/mohuishou/algorithm/tree/master/Graph">https://github.com/mohuishou/algorithm/tree/master/Graph</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> Graph<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;bufio&quot;</span><span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-comment">// EdgeType 边的权值类型</span><span class="hljs-keyword">type</span> EdgeType <span class="hljs-keyword">int</span><span class="hljs-comment">// VextexType 顶点类型定义</span><span class="hljs-keyword">type</span> VextexType <span class="hljs-keyword">int</span><span class="hljs-comment">// VextexDataType 顶点值类型定义</span><span class="hljs-keyword">type</span> VextexDataType <span class="hljs-keyword">int</span><span class="hljs-comment">//EdgeNode 边的节点</span><span class="hljs-keyword">type</span> EdgeNode <span class="hljs-keyword">struct</span> &#123;Weight EdgeType   <span class="hljs-comment">//权值</span>V      VextexType <span class="hljs-comment">//指向储存该顶点的下标</span>Next   *EdgeNode  <span class="hljs-comment">//指向下一条边</span>&#125;<span class="hljs-comment">//VextexNode 顶点节点定义</span><span class="hljs-keyword">type</span> VextexNode <span class="hljs-keyword">struct</span> &#123;data      VextexDataType <span class="hljs-comment">//顶点的值</span>FisrtEdge *EdgeNode      <span class="hljs-comment">//该顶点指向的第一条边</span>&#125;<span class="hljs-comment">//Graph 图</span><span class="hljs-keyword">type</span> Graph <span class="hljs-keyword">struct</span> &#123;VNum, ENum <span class="hljs-keyword">int</span>          <span class="hljs-comment">//顶点数目，边数目</span>G          []VextexNode <span class="hljs-comment">//邻接表</span>&#125;<span class="hljs-comment">//CreateGraph 创建邻接表</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateGraph</span><span class="hljs-params">(VNum <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(graph Graph)</span></span> &#123;graph.VNum = VNumgraph.G = <span class="hljs-built_in">make</span>([]VextexNode, VNum)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; VNum; i++ &#123;graph.G[i] = VextexNode&#123;&#125;&#125;<span class="hljs-keyword">return</span> graph&#125;<span class="hljs-comment">//AddEdge 添加边</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(graph Graph)</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(s, t VextexType, weight EdgeType)</span></span> &#123;edge := &amp;EdgeNode&#123;V: t, Weight: weight&#125;<span class="hljs-comment">//添加边到头部</span>edge.Next = graph.G[s].FisrtEdgegraph.G[s].FisrtEdge = edge&#125;<span class="hljs-comment">//BuildGraph 通过读取文件建图</span><span class="hljs-comment">//文件格式要求:</span><span class="hljs-comment">//顶点个数 边数</span><span class="hljs-comment">//顶点v1 顶点V2 边的权重</span><span class="hljs-comment">//...</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BuildGraph</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(graph Graph)</span></span> &#123;f, err := os.Open(path)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;buf := bufio.NewReader(f)i := <span class="hljs-number">0</span><span class="hljs-comment">//边的数目</span><span class="hljs-keyword">for</span> &#123;line, err := buf.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> err == io.EOF &#123;<span class="hljs-keyword">return</span> graph&#125;<span class="hljs-built_in">panic</span>(err)&#125;line = strings.TrimSpace(line)data := strings.Split(line, <span class="hljs-string">&quot; &quot;</span>)<span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;n, err := strconv.Atoi(data[<span class="hljs-number">0</span>])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;graph = CreateGraph(n)graph.ENum, err = strconv.Atoi(data[<span class="hljs-number">1</span>])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i &lt;= graph.ENum &#123;s, err := strconv.Atoi(data[<span class="hljs-number">0</span>])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;t, err := strconv.Atoi(data[<span class="hljs-number">1</span>])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;weight, err := strconv.Atoi(data[<span class="hljs-number">2</span>])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;graph.AddEdge(VextexType(s), VextexType(t), EdgeType(weight))&#125;i++&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/defer.html">Go数据结构与算法05-栈下: 深入理解 defer</a></li><li><a href="https://lailin.xyz/post/stack.html">Go数据结构与算法04-栈上: 如何实现一个计算器</a></li><li><a href="https://lailin.xyz/post/array_2.html">Go数据结构与算法03-数组下: 使用 GDB 调试 Golang 代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>邻接表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径算法-Dijkstra</title>
    <link href="/post/13459.html"/>
    <url>/post/13459.html</url>
    
    <content type="html"><![CDATA[<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><blockquote><p>这个算法是通过为每个顶点 v 保留目前为止所找到的从 s 到 v 的最短路径来工作的。初始时，原点 s 的路径权重被赋为 0 （d[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把 d[m]设为 w（s, m）,同时把所有其他（s 不能直接到达的）顶点的路径长度设为无穷大，即表示我们不知道任何通向这些顶点的路径（对于所有顶点的集合 V 中的任意顶点 v， 若 v 不为 s 和上述 m 之一， d[v] = ∞）。当算法结束时，d[v] 中存储的便是从 s 到 v 的最短路径，或者如果路径不存在的话是无穷大。<br>边的拓展是 Dijkstra 算法的基础操作：如果存在一条从 u 到 v 的边，那么从 s 到 v 的最短路径可以通过将边（u, v）添加到尾部来拓展一条从 s 到 v 的路径。这条路径的长度是 d[u] + w(u, v)。如果这个值比目前已知的 d[v] 的值要小，我们可以用新值来替代当前 d[v] 中的值。拓展边的操作一直运行到所有的 d[v] 都代表从 s 到 v 的最短路径的长度值。此算法的组织令 d[u] 达到其最终值时，每条边（u, v）都只被拓展一次。<br>算法维护两个顶点集合 S 和 Q。集合 S 保留所有已知最小 d[v] 值的顶点 v ，而集合 Q 则保留其他所有顶点。集合 S 初始状态为空，而后每一步都有一个顶点从 Q 移动到 S。这个被选择的顶点是 Q 中拥有最小的 d[u] 值的顶点。当一个顶点 u 从 Q 中转移到了 S 中，算法对 u 的每条外接边 (u, v) 进行拓展。</p></blockquote><p>如下图：<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142734.gif" alt=""></p><h2 id="代码实现-Golang"><a href="#代码实现-Golang" class="headerlink" title="代码实现-Golang"></a>代码实现-Golang</h2><p><a href="https://github.com/mohuishou/algorithm/tree/master/ShortestPath">github</a></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> ShortestPath<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;container/list&quot;</span><span class="hljs-string">&quot;github.com/mohuishou/algorithm/Graph&quot;</span>)<span class="hljs-comment">//INF 无穷大</span><span class="hljs-keyword">const</span> INF = <span class="hljs-number">0xffffff</span><span class="hljs-comment">//Dijkstra 算法</span><span class="hljs-comment">//一种求单源最短路径的算法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(graph Graph.Graph, s Graph.VextexType, dist []Graph.EdgeType, path []Graph.VextexType)</span></span> &#123;visited := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, graph.VNum)<span class="hljs-comment">//初始化</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; graph.VNum; i++ &#123;dist[i] = INF <span class="hljs-comment">//距离为无穷大</span>path[i] = <span class="hljs-number">-1</span>  <span class="hljs-comment">//没有上一个节点</span>visited[i] = <span class="hljs-literal">false</span>&#125;path[s] = sdist[s] = <span class="hljs-number">0</span><span class="hljs-comment">//使用list实现一个队列操作</span>q := list.New()<span class="hljs-comment">//将点s入队</span>q.PushBack(s)<span class="hljs-keyword">for</span> q.Len() != <span class="hljs-number">0</span> &#123;u := q.Front().Value.(Graph.VextexType)q.Remove(q.Front())<span class="hljs-comment">//如果该点周围的点已经走过，则无需再走</span><span class="hljs-keyword">if</span> visited[u] &#123;<span class="hljs-keyword">continue</span>&#125;<span class="hljs-comment">//将该点加入已观察</span>visited[u] = <span class="hljs-literal">true</span>e := graph.G[u].FisrtEdge<span class="hljs-keyword">for</span> e != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//这条边下的顶点</span>v := e.V<span class="hljs-comment">//如果该点尚未走过，并且当前点的距离加上边的距离小于之前该点的距离，那么就更新该点的距离</span><span class="hljs-keyword">if</span> visited[v] == <span class="hljs-literal">false</span> &amp;&amp; dist[v] &gt; dist[u]+e.Weight &#123;dist[v] = dist[u] + e.Weight <span class="hljs-comment">//更新该点距离</span>path[v] = u                  <span class="hljs-comment">//更新父节点</span>q.PushBack(v)                <span class="hljs-comment">//将该点入队</span>&#125;e = e.Next&#125;&#125;&#125;<span class="hljs-comment">//GetPath 通过路径获得到指定目的节点的路径</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPath</span><span class="hljs-params">(path []Graph.VextexType, t Graph.VextexType)</span> <span class="hljs-params">([]Graph.VextexType, error)</span></span> &#123;tPath := <span class="hljs-built_in">make</span>([]Graph.VextexType, <span class="hljs-number">0</span>)<span class="hljs-keyword">for</span> &#123;tPath = <span class="hljs-built_in">append</span>(tPath, t)<span class="hljs-keyword">if</span> path[t] == <span class="hljs-number">-1</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;不存在到该节点的路径&quot;</span>)&#125;<span class="hljs-keyword">if</span> t == path[t] &#123;<span class="hljs-keyword">return</span> tPath, <span class="hljs-literal">nil</span>&#125;t = path[t]&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/defer.html">Go数据结构与算法05-栈下: 深入理解 defer</a></li><li><a href="https://lailin.xyz/post/stack.html">Go数据结构与算法04-栈上: 如何实现一个计算器</a></li><li><a href="https://lailin.xyz/post/array_2.html">Go数据结构与算法03-数组下: 使用 GDB 调试 Golang 代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>算法</tag>
      
      <tag>华为软挑</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为软挑2017</title>
    <link href="/post/4976.html"/>
    <url>/post/4976.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>稍稍总结一下最近差不多几天的心路历程，虽然最后没有拿到名次，但是从最开始的连最短路径是什么都不知道，到现在的已经可以利用遗传算法+最小费用最大流算法求出一些可行的解，就短短的不到一周的时间，学习到了可以说之前一个学期也未必能够学习到的知识。</p></blockquote><p>这两天会把最近学到的相关知识记录到博客当中，在这儿暂且先列一个大纲：</p><ul><li><p>最短路径问题</p><ul><li>Dijkstra</li><li>Floyd</li><li>SPFA</li></ul></li><li><p>相关问题</p><ul><li>最大流问题</li><li>最小费用最大流问题</li></ul></li><li><p>启发式算法</p><ul><li>遗传算法</li><li>模拟退火算法</li><li>粒子群算法</li></ul><p>上面都是在这个过程当中用到了的一些算法或者是一些问题的解决方案，但是在对于这个具体的问题解决的时候还要做出一些具体的调整，直接套用是不会出结果的。</p><p>但是大体的思路就是启发式算法确定服务器节点的数目以及位置，然后用最小费用最大流得到花费以及结果路径。</p></li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/defer.html">Go数据结构与算法05-栈下: 深入理解 defer</a></li><li><a href="https://lailin.xyz/post/stack.html">Go数据结构与算法04-栈上: 如何实现一个计算器</a></li><li><a href="https://lailin.xyz/post/array_2.html">Go数据结构与算法03-数组下: 使用 GDB 调试 Golang 代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>华为软挑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用vbox在win下搭建linux开发环境</title>
    <link href="/post/50696.html"/>
    <url>/post/50696.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前一直在用 deepin，但是最近因为要使用 win 下的一些软件就直接切到 win 了，想了想可不可以直接搭建一个 linux 环境，在 windows 下编码呢<br>第一次尝试的是 docker 的方案，但是最后放弃了，因为 docker 利用 vbox 建立的虚拟机启动的时候是不是的会出现问题然后就重建，十分的不稳定。<br>所以这次直接使用虚拟机搭建</p></blockquote><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ul><li>ubuntu-16.04-server-amd64.iso (只需要开发环境，所以使用 server 就行不需要桌面版)</li><li>vbox 5.1.10（我使用的最新版）</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.安装 VBox</p><p><em>不再赘述，直接默认就行，最好不要安装在 C 盘。如果有问题可以参见网上的其他教程</em></p><p>2.安装 UbuntuServer16.04</p><p><em>做了几个动图</em></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142743.gif" alt=""></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142745.gif" alt=""></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142746.gif" alt=""></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142747.gif" alt=""></p><p>3.设置网卡</p><p>VBox 默认使用 NAT 模式，但是这个模式下主机是 ping 不通虚拟机的，所以新建一个 host-only 网卡，使用双网卡，一个 NAT 用于上网，一个 host-only 用于和主机相连，之后直接用 xshell 连接，虚拟机后台打开就行了。</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142747.png" alt=""></p><p>进入虚拟机，使用<code>ifconfig</code>命令发现只有一张网卡<code>ifconfig -a</code>发现还有一张网卡<code>enp0s8</code>未连接上</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142748.png" alt=""></p><p>输入<code>sudo vi /etc/network/interfaces</code></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142750.png" alt=""></p><p>新增下面几行</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142751.png" alt=""></p><p>保存重启</p><p><code>ifconfig</code> 查看一共出现三个网卡<br>使用主机 ping 虚拟机可以 ping 通</p><p>4.安装 ssh 服务端</p><pre><code class="hljs bash">sudo apt-get updatesudo apt-get install openssh-server</code></pre><p>安装之后就可以使用 xshell 等工具直接连接虚拟机了</p><p>5.共享文件夹</p><p>(1).需要先安装 vbox 增强组件</p><p>a.安装增强组件前需要先装一些依赖</p><pre><code class="hljs bash">sudo apt-get install aptitudesudo  aptitude install build-essential linux-headers-$(uname -r) -y</code></pre><p>b.点击 vbox 的菜单，添加增强功能</p><p>c.挂载光盘</p><pre><code class="hljs bash">sudo mount /dev/cdrom /mnt</code></pre><p>d.安装增强功能</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /mntsudo ./VBoxLinuxAdditions.run</code></pre><p>安装成功，重启</p><p>(2).挂载磁盘</p><p>a.在 VBox 主界面-&gt;选中虚拟机-&gt;设置-&gt;共享文件夹-&gt;添加共享文件夹</p><p>b.<br>假设命名共享文件夹为 www</p><pre><code class="hljs bash">sudo mkdir /wwwsudo mount -t vboxsf www /www</code></pre><p>挂载成功</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>之前的启动都是有界面的，之后使用的时候希望不出现界面直接后台运行，我们使用 xshell 连接就好<br>复制下面的代码，新建一个 UbuntuServer.bat 粘贴进去，以后直接点击这个脚本就行了</p><pre><code class="hljs bash">%VBOX_MSI_INSTALL_PATH%VBoxManage startvm ubuntu --<span class="hljs-built_in">type</span> headless</code></pre><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>到这儿整个流程就结束了，之后可以根据需求添加软件或者是环境，例如 lnmp、node、golang、java、gcc 等等</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/50628.html">linux下天翼飞扬认证上网的一个解决方法</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在windows安装dockertool，并且配置文件夹共享</title>
    <link href="/post/7964.html"/>
    <url>/post/7964.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天折腾了好久，终于好了，但是还是有点小遗憾。</p></blockquote><p>实现下面几个点</p><ul><li>安装 dockertool(通过 boot2docker 以及 vbox 驱动)</li><li>使用 kitematic 可视化管理</li><li>和 windows 本地共享文件夹</li></ul><h2 id="安装-dockertool"><a href="#安装-dockertool" class="headerlink" title="安装 dockertool"></a>安装 dockertool</h2><h3 id="下载-dockertool"><a href="#下载-dockertool" class="headerlink" title="下载 dockertool"></a>下载 dockertool</h3><p>地址一：<a href="http://get.daocloud.io/#install-docker-for-mac-windows">daocloud 加速</a><br>地址二：<a href="https://github.com/docker/toolbox/releases/tag/v1.12.3">github</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>双击文件安装即可，可以更改安装位置的选项，其余默认即可<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142752.png" alt=""><br>如果电脑上已经安装了 vbox 将不会再安装，如果没有 vbox 将在 C 盘安装 VBox，如果不想安装到 C 盘可以提前安装</p><h3 id="使用-kitematic-可视化管理"><a href="#使用-kitematic-可视化管理" class="headerlink" title="使用 kitematic 可视化管理"></a>使用 kitematic 可视化管理</h3><p>docker ToolBox 自带 kitematic 可以直接打开<br><strong>注意：</strong> 如果设置了环境变量 MACHINE_STORAGE_PATH，更改了虚拟机的默认保存位置，kitematic 可能会打不开，并且启动报错：<code>Error: write EPROTO</code><br>暂时没有找到可行的解决方案，但是这样只有 kitematic 不能使用，docker 没有影响</p><h3 id="使用加速器"><a href="#使用加速器" class="headerlink" title="使用加速器"></a>使用加速器</h3><p>在不使用加速器的情况下，会自动的向 docker hub 拉取镜像，但是国内的访问 docker hub 的速度实在是有些慢，这里我使用<a href="https://www.daocloud.io/mirror#accelerator-doc">daoclou</a>的加速器<br>打开 powershell</p><pre><code class="hljs awk">docker-machine ssh defaultsudo sed -i <span class="hljs-string">&quot;s|EXTRA_ARGS=&#x27;|EXTRA_ARGS=&#x27;--registry-mirror=加速地址 |g&quot;</span> <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/boot2docker/</span>profile<span class="hljs-keyword">exit</span>docker-machine restart default</code></pre><p>第一行：连接 ssh，进入虚拟机<br>第二行：添加加速器地址<br>第三行：退出虚拟机<br>第四行：重启虚拟机</p><p>也可以使用 xshell 等软件连接之后直接输入</p><pre><code class="hljs awk">sudo sed -i <span class="hljs-string">&quot;s|EXTRA_ARGS=&#x27;|EXTRA_ARGS=&#x27;--registry-mirror=加速地址 |g&quot;</span> <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/boot2docker/</span>profile</code></pre><p>然后在退出连接，在本机环境下重启 docker-machine</p><pre><code class="hljs ruby">docker-machine restart <span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">ault</span></span></code></pre><h2 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h2><p>共享文件夹有两种方式，一种是使用 vbox 与主机共享文件夹然后在让 docker 与 boot2docker 虚拟机共享，第二种是创建一个 samba 服务。<br>我这里使用第一种。</p><p>1.首先在 vbox 当中添加共享文件夹<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142753.png" alt=""></p><p>2.然后进入 powershell 或者其他的 shell 软件</p><p>进入虚拟机(不要直接在 vbox 当中进入，直接进入可能会创建失败)</p><pre><code class="hljs ruby">docker-machine ssh <span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">ault</span></span></code></pre><p>挂载文件夹</p><pre><code class="hljs jboss-cli">sudo mkdir <span class="hljs-string">/www</span>sudo mount -t vboxsf www <span class="hljs-string">/www</span></code></pre><p>www 是在 vbo 共享文件夹设置的，/www 是在虚拟机中新建的</p><p>文件夹挂载成功之后就可以创建 docker 了，但是注意不能直接在 kitematic 当中创建，kitematic 当中只能挂载<code>C\user</code>下的目录，所以只能手动创建 docker 容器<br>例如：</p><pre><code class="hljs jboss-cli">docker run -d -P <span class="hljs-params">--name</span> web -v <span class="hljs-string">/www</span>:<span class="hljs-string">/www</span> webdevops/php-apache-dev</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/51252.html">docker镜像瘦身&优化</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在laravel/lumen之外使用Eloquent</title>
    <link href="/post/29454.html"/>
    <url>/post/29454.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>这周刚做完学校的一个智能硬件比赛的作品，我负责后端服务器，以及配套 App 的制作。整个一块都用 socket 进行数据传输，但是其中涉及到的数据库的操作，最近 lumen 用的比较多，觉得它的数据库的组件特别方便，所以就想看看能不能单独拿出来使用。</p></blockquote><p>经过一番查找资料，主要分为两步进行</p><h2 id="安装相应的数据库包"><a href="#安装相应的数据库包" class="headerlink" title="安装相应的数据库包"></a>安装相应的数据库包</h2><p><em>这里使用 5.2 的包，可以更具自己的需求进行更换</em></p><pre><code class="hljs bash">composer require illuminate/database ~5.2</code></pre><h2 id="设置启动文件-start-php"><a href="#设置启动文件-start-php" class="headerlink" title="设置启动文件(start.php)"></a>设置启动文件(start.php)</h2><p>这里将配置文件与启动文件分开，也可以合并在一起。我直接使用了一个 php 文件返回数组，也可以引入<code>vlucas/phpdotenv</code>使用.env 文件来配置变量</p><h3 id="start-php"><a href="#start-php" class="headerlink" title="start.php"></a>start.php</h3><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;.</span><span class="hljs-comment"> * User: mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;</span><span class="hljs-comment"> * Date: 2016/11/14 0014</span><span class="hljs-comment"> * Time: 18:50</span><span class="hljs-comment"> */</span><span class="hljs-variable">$database</span> = <span class="hljs-keyword">require_once</span> <span class="hljs-string">&quot;config.php&quot;</span>;<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Container</span>\<span class="hljs-title">Container</span>;<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Database</span>\<span class="hljs-title">Capsule</span>\<span class="hljs-title">Manager</span> <span class="hljs-title">as</span> <span class="hljs-title">Capsule</span>;<span class="hljs-variable">$capsule</span> = <span class="hljs-keyword">new</span> Capsule;<span class="hljs-comment">// 创建链接</span><span class="hljs-variable">$capsule</span>-&gt;addConnection(<span class="hljs-variable">$database</span>);<span class="hljs-comment">// 设置全局静态可访问DB</span><span class="hljs-variable">$capsule</span>-&gt;setAsGlobal();<span class="hljs-comment">// 启动Eloquent</span><span class="hljs-variable">$capsule</span>-&gt;bootEloquent();</code></pre><h3 id="config-php"><a href="#config-php" class="headerlink" title="config.php"></a>config.php</h3><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by PhpStorm.</span><span class="hljs-comment"> * User: lxl</span><span class="hljs-comment"> * Date: 16-11-17</span><span class="hljs-comment"> * Time: 下午8:38</span><span class="hljs-comment"> */</span><span class="hljs-keyword">return</span> [    <span class="hljs-string">&#x27;driver&#x27;</span> =&gt; <span class="hljs-string">&#x27;mysql&#x27;</span>,    <span class="hljs-string">&#x27;host&#x27;</span> =&gt; <span class="hljs-string">&quot;localhost&quot;</span>,    <span class="hljs-string">&#x27;database&#x27;</span> =&gt; <span class="hljs-string">&quot;smart_lock&quot;</span>,    <span class="hljs-string">&#x27;username&#x27;</span> =&gt; <span class="hljs-string">&quot;root&quot;</span>,    <span class="hljs-string">&#x27;password&#x27;</span> =&gt; <span class="hljs-string">&quot;mima&quot;</span>,    <span class="hljs-string">&#x27;charset&#x27;</span> =&gt; <span class="hljs-string">&#x27;utf8&#x27;</span>,    <span class="hljs-string">&#x27;collation&#x27;</span> =&gt; <span class="hljs-string">&#x27;utf8_unicode_ci&#x27;</span>,    <span class="hljs-string">&#x27;prefix&#x27;</span> =&gt; <span class="hljs-string">&quot;&quot;</span>,];</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>laravel</tag>
      
      <tag>lumen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java笔记1</title>
    <link href="/post/52826.html"/>
    <url>/post/52826.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>java 初学笔记，随手记录</p></blockquote><ul><li><p>单引号表示字符<code>char</code>类型(<em>不常用</em>)，双引号才是字符串</p></li><li><p>float 类型后面要添加 f<code>3.14f</code>(<em>不常用</em>)，不添加后缀默认为 double</p></li><li><p><code>final</code>表示常量，<code>static final</code>表示类常量</p></li><li><p>位运算 - 与：<code>&amp;</code> - 或：<code>|</code> - 非：<code>~</code> - 异或：<code>^</code> - 左移：<code>&lt;&lt;</code> - 右移：<code>&gt;&gt;</code></p></li><li><p>不要把布尔值强制转换为任何的其他数值，如果要转换为 int，可以使用三元运算符<code>b ? 1:0</code></p></li><li><p>数组的命名 - <code>int[] a</code>(<em>更常用</em>) - <code>int a[]</code></p></li><li><p>数组必须先初始化才能使用，没有初始化的数组不能使用 - <code>int[] a=new int[100]</code></p></li><li><p>命令行参数</p></li></ul><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;&#125;</code></pre><p><em>main 函数的参数，args 接受来自命令行的参数，每一个空格是一个参数，但是程序文件名不包含在内</em></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/62897.html">java中字符串相等的判断</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一键迁移typecho到hexo</title>
    <link href="/post/59080.html"/>
    <url>/post/59080.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>为了更好的写博客，最近打算把博客静态化，发现了 node 写的 hexo。顺便也可以直接利用 github 和 coding 的 pages 来搭建博客同时把之前闲置的未备案域名<a href="http://lailin.xyz">lailin.xyz</a>利用起来.</p></blockquote><p>写了一个 php 的 typecho 一键转换的小程序:<a href="https://github.com/mohuishou/typecho2hexo">github</a></p><h3 id="支持："><a href="#支持：" class="headerlink" title="支持："></a>支持：</h3><ul><li>文档一键转存为 md 文件</li><li>字符编码转换（gbk=&gt;utf8）</li><li>图片/附件一键转存到本地</li><li>图片/附件一键转存到七牛云</li></ul><h3 id="使用说明："><a href="#使用说明：" class="headerlink" title="使用说明："></a>使用说明：</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/mohuishou/</span>typecho2hexo.gitcomposer install</code></pre><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>复制 config.example.php 并重命名为 config.php</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">return</span> [    <span class="hljs-string">&quot;db&quot;</span>=&gt;[        <span class="hljs-string">&quot;host&quot;</span>=&gt;<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-comment">//数据库地址</span>        <span class="hljs-string">&quot;port&quot;</span>=&gt;<span class="hljs-number">3306</span>, <span class="hljs-comment">//端口号</span>        <span class="hljs-string">&quot;name&quot;</span>=&gt;<span class="hljs-string">&quot;typecho&quot;</span>, <span class="hljs-comment">//数据库</span>        <span class="hljs-string">&quot;user&quot;</span>=&gt;<span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-comment">//数据库用户名</span>        <span class="hljs-string">&quot;password&quot;</span>=&gt;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">//数据库密码</span>        <span class="hljs-string">&quot;prefix&quot;</span>=&gt;<span class="hljs-string">&quot;typecho&quot;</span>  <span class="hljs-comment">//表前缀</span>    ],    <span class="hljs-string">&quot;is_gbk&quot;</span>=&gt;<span class="hljs-literal">false</span>, <span class="hljs-comment">//是否开启gbk转utf8（有些数据库里面储存的不是utf8格式需要开启这个选项）</span>    <span class="hljs-comment">//附件相关</span>    <span class="hljs-string">&quot;attachment&quot;</span>=&gt;[        <span class="hljs-string">&quot;is_download&quot;</span>=&gt;<span class="hljs-literal">true</span>, <span class="hljs-comment">//是否下载附件</span>        <span class="hljs-string">&quot;type&quot;</span>=&gt;<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-comment">//附件保存类型：file 或者 qiniu</span>    ],    <span class="hljs-comment">//七牛云储存相关</span>    <span class="hljs-string">&quot;qiniu&quot;</span>=&gt;[        <span class="hljs-string">&quot;access_key&quot;</span>=&gt;<span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;secret_key&quot;</span>=&gt;<span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;bucket_name&quot;</span>=&gt;<span class="hljs-string">&quot;blog&quot;</span>, <span class="hljs-comment">//七牛空间名</span>        <span class="hljs-string">&quot;domain&quot;</span>=&gt;<span class="hljs-string">&quot;http://&quot;</span> <span class="hljs-comment">//七牛外链域名，必须设置,带http://</span>    ]];</code></pre><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><pre><code class="hljs awk">php index.php <span class="hljs-regexp">//</span>命令行</code></pre><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>1.如果出现上传错误，附件下载使用 curl，下载时间最长为 60s，如果有比较大的文件或者是网路环境不好，请手动更改一下 Lib/Attachment.php，当中的文件最长下载时间</p><pre><code class="hljs php"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span>(<span class="hljs-params"><span class="hljs-variable">$url</span>,<span class="hljs-variable">$filename</span>,<span class="hljs-variable">$dir</span></span>)</span>&#123;    <span class="hljs-variable">$path</span>=<span class="hljs-variable">$dir</span>.<span class="hljs-string">&quot;/&quot;</span>.<span class="hljs-variable">$filename</span>;    <span class="hljs-variable">$ch</span>=curl_init();    <span class="hljs-variable">$timeout</span>=<span class="hljs-number">60</span>; <span class="hljs-comment">//文件最长下载时间</span>    curl_setopt(<span class="hljs-variable">$ch</span>,CURLOPT_URL,<span class="hljs-variable">$url</span>);    curl_setopt(<span class="hljs-variable">$ch</span>,CURLOPT_FOLLOWLOCATION,<span class="hljs-number">1</span>);    curl_setopt(<span class="hljs-variable">$ch</span>,CURLOPT_RETURNTRANSFER,<span class="hljs-number">1</span>);    curl_setopt(<span class="hljs-variable">$ch</span>,CURLOPT_CONNECTTIMEOUT,<span class="hljs-variable">$timeout</span>);    <span class="hljs-variable">$res</span>=curl_exec(<span class="hljs-variable">$ch</span>);    curl_close(<span class="hljs-variable">$ch</span>);    <span class="hljs-comment">//检查文件夹是否存在</span>    <span class="hljs-keyword">if</span>(!file_exists(<span class="hljs-variable">$dir</span>)) mkdir(<span class="hljs-variable">$dir</span>);    file_put_contents(<span class="hljs-variable">$path</span>,<span class="hljs-variable">$res</span>);    <span class="hljs-keyword">return</span> <span class="hljs-variable">$path</span>;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/27142.html">hexo-next-algolia-search全文搜索</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>hexo</tag>
      
      <tag>typecho</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在deepin下安装shadowsocks-qt5</title>
    <link href="/post/46155.html"/>
    <url>/post/46155.html</url>
    
    <content type="html"><![CDATA[<h1 id="在-deepin-下安装-ss-qt5"><a href="#在-deepin-下安装-ss-qt5" class="headerlink" title="在 deepin 下安装 ss-qt5"></a>在 deepin 下安装 ss-qt5</h1><blockquote><p>官网的文档上 Ubuntu 可以通过添加私有源的方式安装，deepin 不行，我们这里需要直接从源码编译安装。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>检查下面两个软件是否已经安装，deepin 自带的没有安装上</p><ul><li>git</li><li>g++</li></ul><h2 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h2><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/shadowsocks/</span>shadowsocks-qt5.git</code></pre><p><strong>wiki 地址</strong>：<a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki">https://github.com/shadowsocks/shadowsocks-qt5/wiki</a></p><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>1.按照 wiki 进行安装</p><pre><code class="hljs bash">sudo apt-get install qt5-qmake qtbase5-dev libqrencode-dev libqtshadowsocks-dev libappindicator-dev libzbar-dev libbotan1.10-dev</code></pre><p>会出现错误，没有<code>libqtshadowsocks-dev</code>这个软件包，所以这个包我们也需要自行编译</p><p>2.下载<code>libqtshadowsocks-dev</code>源代码</p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/shadowsocks/libQtShadowsocks.git</code></pre><p>3.安装编译所需的其他组件</p><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> install qt5-qmake qtbase5-<span class="hljs-built_in">dev</span> libqrencode-<span class="hljs-built_in">dev</span>  libappindicator-<span class="hljs-built_in">dev</span> libzbar-<span class="hljs-built_in">dev</span> libbotan1<span class="hljs-number">.10</span>-<span class="hljs-built_in">dev</span></code></pre><p>4.编译<code>libqtshadowsocks-dev</code></p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> libQtShadowsocksdpkg-buildpackage -uc -us -b</code></pre><p>编译成功之后会在上一级目录发现三个 deb 包（安装后两个）：</p><pre><code class="hljs bash">shadowsocks-libqtshadowsocks_1.9.0-1_amd64.deblibqtshadowsocks-dev_1.9.0-1_amd64.deblibqtshadowsocks_1.9.0-1_amd64.deb</code></pre><p>5.安装所需的 deb 包(注意顺序)</p><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> dpkg -i libqtshadowsocks_<span class="hljs-number">1</span>.<span class="hljs-number">9</span>.<span class="hljs-number">0</span>-<span class="hljs-number">1</span>_amd<span class="hljs-number">64</span>.deb<span class="hljs-attribute">sudo</span> dpkg -i libqtshadowsocks-dev_<span class="hljs-number">1</span>.<span class="hljs-number">9</span>.<span class="hljs-number">0</span>-<span class="hljs-number">1</span>_amd<span class="hljs-number">64</span>.deb</code></pre><p>6.编译<code>shadowsocks-qt5</code></p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> shadowsocks-qt5dpkg-buildpackage -uc -us -b</code></pre><p>编译完成之后会在上一级目录出现一个 deb 包<code>shadowsocks-qt5_2.7.0-1_amd64.deb</code>，版本不同包名可能会有一些小的区别</p><p>7.安装试试 shadowsocks-qt5</p><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> dpkg -i shadowsocks-qt<span class="hljs-number">5</span>_<span class="hljs-number">2</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span>-<span class="hljs-number">1</span>_amd<span class="hljs-number">64</span>.deb</code></pre><p><strong>大功告成，最后在启动器里面就可以看到 ss-qt5 的图标了，最后给出上面提到的我编译成功的相关软件包，不保证有用^^</strong></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ss</tag>
      
      <tag>deepin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四川大学锐捷windows解除多网卡限制</title>
    <link href="/post/18280.html"/>
    <url>/post/18280.html</url>
    
    <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><blockquote><p>搬到望江校区之后校园网快了好多，但是需要锐捷认证，锐捷这个坑货需要限制多网卡，而且程序的占用实在太大，十分的不方便。使用 wifi 共享软件可以开启 wifi 热点，但是会出现连接没多久没网的情况</p></blockquote><p>我使用的锐捷版本是 v4.96</p><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>理论上说多网卡限制的问题都可以解决掉：</p><ul><li>wifi 热点共享</li><li>VPN（FQ）</li><li>虚拟机 host-only</li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>1.首先你已经安装了锐捷的客户端并且使用其可以认证上网</p><p><em>更新：可以尝试直接从第五步开始，因为我发现好像直接结束掉网其实也不会掉</em></p><p>2.然后下载 mentohust win 版本（<a href="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/MentoHUST%EF%BC%88WINDOWS%E7%89%88%EF%BC%89.rar">点击下载</a>）<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/4058054721.png" alt="1ecdddfa-ec9a-473b-9a13-3b2e5c3b4fdb.png"></p><p>3.mentohust 的使用方法网上有很多了这里不在赘述，<a href="http://jingyan.baidu.com/article/47a29f2416ba37c015239957.html">百度经验</a></p><p>4.需要注意这里有不一样的地方，直接按照上面链接的方法是没有办法认证成功的，在设置好之后点击认证前，需要先使用锐捷成功认证上网，然后再使用这个软件认证 5.认证成功之后打开任务管理器，找到 8021.exe 这个进程干掉就可以了 6.然后使用 win10 自带的移动热点也可以开启热点不需要单独下载 wifi 共享软件<br>(如果没有，<del>使用 wifi 软件,测试猎豹 wifi 还是会出现没有网的情况</del> 或者直接用命令行开启也是可以的)<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/3439227638.png" alt="1610c2cb-221c-42b6-8824-c47176e27cde.png"></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/5431.html">使用chromedp解决反爬虫问题</a></li><li><a href="https://lailin.xyz/post/51466.html">四川大学望江校区使用mentohust认证上网</a></li><li><a href="https://lailin.xyz/post/31503.html">四川大学评教开源代码</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>大学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>破解</tag>
      
      <tag>四川大学</tag>
      
      <tag>锐捷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php设计模式（一）工厂模式</title>
    <link href="/post/43893.html"/>
    <url>/post/43893.html</url>
    
    <content type="html"><![CDATA[<h1 id="PHP-设计模式（一）工厂模式"><a href="#PHP-设计模式（一）工厂模式" class="headerlink" title="PHP 设计模式（一）工厂模式"></a>PHP 设计模式（一）工厂模式</h1><blockquote><p>最近会简单的自我总结一些 php 当中的一些设计模式，当然个人才疏学浅，可能些不对的地方望各位看官见谅指正</p></blockquote><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>工厂模式是一种创建型的模式，简单的说就是用来创建对象的</p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>我们一般最普通的创建对象的方式是这样<code>new classname()</code>,但是换位想一下，这样创建对象的时候我们必须要知道类名，但是我们考虑一下下面几个情况：</p><ol><li>如果我们不知道类名呢？</li><li>如果我在很多个文件当中都用到了这个类创建对象，new 了很多次，但是在重构或者其他什么情况的时候我要修改类名怎么半？当然有人会说怎么会修改类名，这是有可能会遇到的，那说一一下常见一点的，如果我给这个类的构造方法加了，或者是少了一个参数？那岂不是得一个个的去改</li><li>我现在有一个抽象的基类，由它派生了很多子类，我不知道后面还会不会添加其他的子类</li></ol><p>上面几个都是可能会遇到的一些情况之一，使用工厂模式可以比较好的解决上面的问题</p><h2 id="怎么办？"><a href="#怎么办？" class="headerlink" title="怎么办？"></a>怎么办？</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span></span>&#123;    <span class="hljs-comment">//todo</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FoodFactory</span></span>&#123;    <span class="hljs-built_in">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> food();    &#125;&#125;<span class="hljs-variable">$food</span>= FoodFactory::create();</code></pre><p>上面实现简单工厂模式,<code>FoodFactory</code>这个类很简单只有一个创建方法，返回 food 类的实例，当然也可以发现这个方法很笨拙，只能实现一个对象的创建，感觉比直接 new 一个对象<br>好不了多少，只是方便改动而已</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FoodFactory</span></span>&#123;    <span class="hljs-built_in">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"><span class="hljs-variable">$classname</span></span>)</span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">include_once</span> <span class="hljs-string">&#x27;class/&#x27;</span> . <span class="hljs-variable">$classname</span> . <span class="hljs-string">&#x27;.php&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-variable">$classname</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&#x27;Driver not found&#x27;</span>);        &#125;    &#125;&#125;</code></pre><p>通过上面的方法我们发现我们已经可以不局限于，创建一个固定的类的对象了<br><strong>但是要注意的是：</strong><br><em>如果我们使用了命名空间的话，在动态实例化类的时候必须包含完整的命名空间，提前 use 或者处于统一命名空间都是没有用的</em></p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">namespace</span> <span class="hljs-title">Mohuishou</span>\<span class="hljs-title">Lib</span>;  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FoodFactory</span></span>&#123;    <span class="hljs-built_in">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"><span class="hljs-variable">$classname</span></span>)</span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">include_once</span> <span class="hljs-string">&#x27;class/&#x27;</span> . <span class="hljs-variable">$classname</span> . <span class="hljs-string">&#x27;.php&#x27;</span>)&#123;        <span class="hljs-variable">$classname</span>=<span class="hljs-string">&quot;Mohuishou\Lib\\&quot;</span>.<span class="hljs-variable">$classname</span>;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-variable">$classname</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&#x27;Driver not found&#x27;</span>);        &#125;    &#125;&#125;</code></pre><p>如果我们还想传入参数呢？</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">namespace</span> <span class="hljs-title">Mohuishou</span>\<span class="hljs-title">Lib</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FoodFactory</span></span>&#123;    <span class="hljs-built_in">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"><span class="hljs-variable">$classname</span>,<span class="hljs-variable">$params</span></span>)</span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">include_once</span> <span class="hljs-string">&#x27;class/&#x27;</span> . <span class="hljs-variable">$classname</span> . <span class="hljs-string">&#x27;.php&#x27;</span>)&#123;    <span class="hljs-variable">$classname</span>=<span class="hljs-string">&quot;Mohuishou\Lib\\&quot;</span>.<span class="hljs-variable">$classname</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-variable">$classname</span>(<span class="hljs-variable">$params</span>);&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&#x27;Driver not found&#x27;</span>);&#125;    &#125;&#125;</code></pre><p>如果我们不知道类名，不知道方法，怎么办?怎么实现一个一般的工厂模式？<br>这里可能需要用到反射的概念了，这篇就不过多赘述</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-design-pattern.html">Go设计模式24-总结(更新完毕)</a></li><li><a href="https://lailin.xyz/post/mediator.html">Go设计模式23-中介模式</a></li><li><a href="https://lailin.xyz/post/interpreter.html">Go设计模式22-解释器模式</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四川大学望江校区使用mentohust认证上网</title>
    <link href="/post/51466.html"/>
    <url>/post/51466.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>刚刚解决完天翼飞扬的上网问题，结果就搬校区了，按照上一篇文章的方法在这边也是可以用的，但是校园网使用的锐捷认证已经提供了 linux 的客户端了，所以就没有必要那么麻烦了。但是在信息管理中心下载的客户端简直无语，客户端必须要禁用双网卡，而且连接的的时候会先把你的网络服务给关闭掉。。。但是有时候有开不了。如果不手动禁用掉无线网卡，认证成功之后 3 分钟之内必掉</p></blockquote><h2 id="mentohust"><a href="#mentohust" class="headerlink" title="mentohust"></a>mentohust</h2><blockquote><p>还好有 mentohust 这个神器，但是使用当中还是有一点小坑</p></blockquote><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/4178932952.png" alt="深度截图20160719182529.png"></p><p>1.首先下载安装 mentohust</p><ul><li>官方地址:<a href="https://code.google.com/archive/p/mentohust/downloads">https://code.google.com/archive/p/mentohust/downloads</a></li><li><p>官方的要翻墙，这儿提供一个 ubuntu/debian 的<a href="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/994570489.deb">mentohust_0.3.4-1-2_i386.deb</a></p><p>2.然后在四川大学信息管理中心下载锐捷 4.96 版本，解压提取<code>8021x.exe</code>,<code>W32N55.dll</code>,<code>SuConfig.dat</code>移动到<code>/etc/mentohust</code></p><p>3.在经历一个一个尝试之后的可用模式</p></li></ul><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> mentohust -u用户名 -p密码 -a<span class="hljs-number">0</span> -d<span class="hljs-number">2</span> -b<span class="hljs-number">2</span> -v<span class="hljs-number">4</span>.<span class="hljs-number">96</span> -w //下次使用的时候直接使用sudo mentohust就可以了</code></pre><p><strong>注意：如果显示认证成功但是无法上网，试一试先关闭有线网络的连接然后再打开，然后马上输入上面的命令，即可。拔插网线也可以</strong></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/5431.html">使用chromedp解决反爬虫问题</a></li><li><a href="https://lailin.xyz/post/18280.html">四川大学锐捷windows解除多网卡限制</a></li><li><a href="https://lailin.xyz/post/31503.html">四川大学评教开源代码</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>大学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>四川大学</tag>
      
      <tag>mentohust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下天翼飞扬认证上网的一个解决方法</title>
    <link href="/post/50628.html"/>
    <url>/post/50628.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>博主尝试过许多的方法一直没有解决这个问题，例如：虚拟机桥接 ，crossover、wine 模拟，很早以前的 linux 版本等等，最后都没有成功，但是当要搬校区，不再使用这个客户端的前一天晚上，突发奇想结果解决了….</p></blockquote><p>理论上该方法对于所有需要认证的上网客户端有效</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.安装 virtualbox 2.下载 windows 镜像，博主使用 xp</p><h2 id="开始设置"><a href="#开始设置" class="headerlink" title="开始设置"></a>开始设置</h2><p>1.首先安装 windows 虚拟机,虚拟机设置:</p><ul><li>内存随意，可以在测试好之后，设置为能够正常运行的最小内存，我先使用的是 512M</li><li>网卡，设置两张网卡，一个使用桥接，桥接到连接宽带的有限网络上，另一个使用 host-only 用于组建局域网</li></ul><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/3069020784.png" alt="深度截图20160718200311.png"><br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/878380818.png" alt="深度截图20160718200300.png"></p><p>2.在虚拟机中使用宽带的客户端拨号上网</p><p>3.查看局域网地址</p><ul><li>虚拟机当中使用<code>ipconfig</code>命令</li><li>主机当中使用<code>ifconfig</code>命令</li><li>如图所示</li></ul><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/3302058632.png" alt="深度截图20160718202926.png"></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/3537084827.png" alt="深度截图20160718202945.png"></p><p>4.在虚拟机当中使用服务器代理软件，然后主机实现代理上网，楼主使用的 TGate</p><ul><li>TGate 设置如图所示</li></ul><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/1779186853.png" alt="深度截图20160718203937.png"></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/1448439344.png" alt="深度截图20160718204111.png"></p><p>5.在主机设置代理上网</p><ul><li>可以设置全局代理，但是博主的 deepin 全局代理好像有点问题，所以就先设置 chrome 的代理了</li><li>如图所示<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/3447026534.png" alt="深度截图20160718204345.png"></li></ul><blockquote><p>楼主到此已经可以使用了</p></blockquote><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/50696.html">利用vbox在win下搭建linux开发环境</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>大学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>天翼飞扬</tag>
      
      <tag>linux</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迁移laravel框架项目到虚拟主机</title>
    <link href="/post/13242.html"/>
    <url>/post/13242.html</url>
    
    <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>laravel 版本：<code>5.2</code><br>虚拟主机：万网</p><h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><p>1.先把所有文件复制到网站根目录 2.由于访问的时候入口文件在 public 目录下面，这时候访问 url 会变成 url/public/，重写规则跳转就行了,在根目录新建.hatcess 文件</p><pre><code class="hljs apache"><span class="hljs-section">&lt;IfModule mod_rewrite.c&gt;</span>    <span class="hljs-attribute"><span class="hljs-nomarkup">RewriteEngine</span></span> <span class="hljs-literal">on</span>    <span class="hljs-attribute"><span class="hljs-nomarkup">RewriteCond</span></span> <span class="hljs-variable">%&#123;REQUEST_URI&#125;</span> !^public    <span class="hljs-attribute"><span class="hljs-nomarkup">RewriteRule</span></span> ^(.*)$ public/$<span class="hljs-number">1</span><span class="hljs-meta"> [L]</span><span class="hljs-section">&lt;/IfModule&gt;</span></code></pre><p>3.打开<code>config/app.php</code><br>将</p><pre><code class="hljs dart"><span class="hljs-string">&#x27;key&#x27;</span> =&gt; env(<span class="hljs-string">&#x27;APP_KEY&#x27;</span>, <span class="hljs-string">&#x27;...&#x27;</span>), <span class="hljs-comment">//32位字符串</span><span class="hljs-string">&#x27;cipher&#x27;</span> =&gt; <span class="hljs-string">&#x27;AES-256-CBC&#x27;</span>,</code></pre><p>改为</p><pre><code class="hljs dart"><span class="hljs-string">&#x27;key&#x27;</span> =&gt; env(<span class="hljs-string">&#x27;APP_KEY&#x27;</span>, <span class="hljs-string">&#x27;...&#x27;</span>),<span class="hljs-comment">//16位字符串</span><span class="hljs-string">&#x27;cipher&#x27;</span> =&gt; <span class="hljs-string">&#x27;AES-128-CBC&#x27;</span>,</code></pre><p><em>由于万网不支持’AES-256-CBC’所以用 128 位加密，256 位加密使用 32 位字符串，128 位使用 16 位字符串</em> 4.到这一步基本就没有什么问题了，但是在使用 ajax 的时候，post 方法有可能会被 301 跳转然后变成 get<br>解决方案：<br>打开<code>public</code>目录下的<code>.htaccess</code>文件删除下面这一段</p><pre><code class="hljs apache"><span class="hljs-comment"># Redirect Trailing Slashes If Not A Folder...</span>  <span class="hljs-attribute"><span class="hljs-nomarkup">RewriteCond</span></span> <span class="hljs-variable">%&#123;REQUEST_FILENAME&#125;</span> !-d  <span class="hljs-attribute"><span class="hljs-nomarkup">RewriteRule</span></span> ^(.*)/$ /$<span class="hljs-number">1</span><span class="hljs-meta"> [L,R=301]</span></code></pre><p>5.好了，我的使用过程中就没什么问题了（注：把在控制台把万网的 php 版本调到最高，现在是 5.5）</p><p><strong>补充一点很多人容易忽略的，配置文件不要卸载.env 文件里面，虚拟机一般不支持，换到 config 目录下的相应配置文件下</strong></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/29454.html">在laravel/lumen之外使用Eloquent</a></li><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>laravel</tag>
      
      <tag>虚拟主机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用lnmp+owncloud+ossfs+oss搭建属于自己的私有云盘</title>
    <link href="/post/8013.html"/>
    <url>/post/8013.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>经常写一写文档之类的东西，需要一个同步网盘，但是现在市面上的还是满足不了我的要求，突然发现阿里云的 oss 可以挂载成虚拟磁盘，试着折腾了一下效果还不错，不过这中间还是有许多的坑</p></blockquote><h3 id="之前使用的云盘"><a href="#之前使用的云盘" class="headerlink" title="之前使用的云盘"></a>之前使用的云盘</h3><ol><li><p>坚果云<br>个人认为是现在市面上最好的同步盘了，支持增量同步，多平台有 linux 版本，可以使用 webdav。美中不足的免费版每个月限制上传下载流量，收费版不限制流量有空间限制。有段时间突然有大量文件需要备份导致流量不足，但是平时又用不了太多，开一个月专业版的空间又不够，用的有点憋屈所以就弃用了。</p></li><li><p>百度云等<br>在使用坚果云之前的主力网盘，同步盘功能竟然要会员才能用，而且同步盘做的很不好用，不过用来做资源分享之类的还不错</p></li></ol><h3 id="为什么使用-oss"><a href="#为什么使用-oss" class="headerlink" title="为什么使用 oss"></a>为什么使用 oss</h3><ol><li><p>数据的稳定性，我比较喜欢折腾所以服务器有时候就会重装这时候对于文件就非常的不好管理和备份，放在 oss 上面能够更好的管理</p></li><li><p>第二个就是便宜，不和其他几家的云服务对比仅仅和阿里云的云盘，就是买服务器的时候的一个选项，便宜很多。40g 的话一年也就差不多 10 多块的样子。而且和 ECS 搭配使用没有流量费用</p></li></ol><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>安装 lnmp 架构</p><blockquote><p>其实 owncloud 官方更加推荐 lamp，但是我个人更喜欢 nginx，要比 Apache 省资源一些，能够用 Apache 的也很不错，可以少踩很多配置的坑，owncloud 的 nginx 官方示例配置很多坑，之后会说到</p></blockquote><h3 id="安装-ossfs"><a href="#安装-ossfs" class="headerlink" title="安装 ossfs"></a>安装 ossfs</h3><blockquote><p>注意：在这之前你需要先开通 oss，最好是和你的 ECS 是一个地区的，当然不是用的 ECS 也可以用，只是速度会慢一些，还有就是下载会使用公网流量，上传没有</p></blockquote><p>1.<a href="https://help.aliyun.com/document_detail/32196.html">点击打开 ossfs 的下载页面下载对应系统的安装包</a> 2.我已 Ubuntu 为例，安装 ossfs，其他系统看官方的文档就行</p><pre><code class="hljs bash">sudo apt-get updatesudo apt-get install gdebi-coresudo gdebi your_ossfs_package</code></pre><p>3.将<code>my-bucket</code>这个 bucket 挂载到<code>/data/cloud</code>目录下，AccessKeyId 是<code>faint</code>， AccessKeySecret 是<code>123</code>，oss endpoint 是<code>http://oss-cn-hangzhou.aliyuncs.com</code></p><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> my-bucket:faint:123 &gt; /etc/passwd-ossfschmod 640 /etc/passwd-ossfsmkdir /data/cloud</code></pre><p><strong>最后一步很重要，不能直接照官方文档上面的来，不然安装 owncloud 的时候可能会出现没有访问权限的问题</strong></p><ul><li>首先先看一下 nginx 的用户 id，以我的是<code>www</code>为例</li></ul><pre><code class="hljs bash">id www</code></pre><p>会返回给你用户的 uid 和 gid 等等,我假设返回的 uid 和 gid 都为 1001</p><pre><code class="hljs routeros">ossfs my-bucket /data/cloud <span class="hljs-attribute">-ourl</span>=http://oss-cn-hangzhou-internal.aliyuncs.com <span class="hljs-attribute">-ouid</span>=1001 <span class="hljs-attribute">-ogid</span>=1001 -o allow_other -o <span class="hljs-attribute">umask</span>=007</code></pre><p>这里面<code>allow_other</code>是允许其他用户访问，但是默认设置的是 777 权限这样 owncloud 会提示不安全，用<code>umask=007</code>挂载为 770 权限，不知道为啥这里 0 代表 7,7 表示 0</p><blockquote><p>到这里 ossfs 就安装完毕了下面开始安装 owncloud</p></blockquote><h3 id="安装-OWNCLOUD"><a href="#安装-OWNCLOUD" class="headerlink" title="安装 OWNCLOUD"></a>安装 OWNCLOUD</h3><blockquote><p>owncloud 的安装网上已经有很多的教程我就不多说了</p></blockquote><p>先打开<a href="https://owncloud.org/install/#instructions-server">owncloud 的官网的服务器端的安装地址</a>，我安装的时候最新稳定版是<code>9.0.2</code>建议国内主机用迅雷之类的下载软件先下载下来上传到服务器，直接 wget 比较慢</p><p>1.下载并解压</p><pre><code class="hljs apache"><span class="hljs-attribute">wget</span>  https://download.owncloud.org/community/owncloud-<span class="hljs-number">9</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.tar.bz<span class="hljs-number">2</span> //手动上传这一步就不用了<span class="hljs-attribute">tar</span> xvf owncloud-<span class="hljs-number">9</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.tar.bz<span class="hljs-number">2</span> //以实际的文件名为准</code></pre><p>2.移动到站点目录,假设站点目录为<code>/data/wwwroot</code></p><pre><code class="hljs awk">mv owncloud<span class="hljs-regexp">/ /</span>data<span class="hljs-regexp">/wwwroot/</span></code></pre><p><strong>3.设置目录权限，这一步很重要</strong></p><pre><code class="hljs bash">chown -R www:www /data/wwwroot/owncloud/chmod 777 /data/wwwroot/owncloud//config/</code></pre><h3 id="设置-nginx-规则（Apache-基本不用改，只需要自己去设置一下-ssl，和常规的设置就行了）"><a href="#设置-nginx-规则（Apache-基本不用改，只需要自己去设置一下-ssl，和常规的设置就行了）" class="headerlink" title="设置 nginx 规则（Apache 基本不用改，只需要自己去设置一下 ssl，和常规的设置就行了）"></a>设置 nginx 规则（Apache 基本不用改，只需要自己去设置一下 ssl，和常规的设置就行了）</h3><p><strong>注意规则设置好之后，安装的时候点高级设置，使用 mysql 或者其他数据库，<code>sqllite</code>的性能不够，然后就是数据文件目录填写之前你 ossfs 的挂载目录，我之前挂载的是<code>/data/cloud</code></strong></p><blockquote><p>后面有 9.x 官方的示例，我这儿提示一下有些坑的地方</p></blockquote><p>1.本身的设置里面没有 log 的设置，不方便 debug，access_log 可以不用，error_log 还是需要加上的 2.里面没有 index 的设置，如果打开首页一片空白，加上 index.php 之后没有问题的话，</p><pre><code class="hljs glsl"><span class="hljs-keyword">location</span> / &#123;<span class="hljs-keyword">index</span> <span class="hljs-keyword">index</span>.php <span class="hljs-meta">#加上这一句</span>      rewrite ^ /<span class="hljs-keyword">index</span>.php$uri;&#125;</code></pre><p>3.如果你进入安装页面，按照提示安装好了之后出现说<code>找不到文件目录</code>之类的话，那么很有可能是你没有开启<code>pathinfo</code>，owncloud 需要 pathinfo 的支持(示例的配置里面是有 pathinfo 的设置的)</p><h3 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h3><blockquote><p>到这里基本上 owncloud 的安装应该就结束了，使用也没有什么问题，我建议开启 ssl，不知道为什么，我开了 ssl 之后访问的速度提升了好几倍</p></blockquote><p>附送官方插件的地址<a href="https://apps.owncloud.com/">点我点我</a>,国内主机在线安装插件可能装不上，可以 FQ 之后在这里面下载相应插件包，上传到 apps 目录下即可，下一篇说一下用 owncloud 实现离线下载功能，现在 9.0.2 版本的使用 owncloud 的离线下载插件有问题，但是看了一下这个 bug 很早就有，只是好像一直没有修复。之后我改一下能够用了再写下一篇吧</p><h3 id="9-x-官方示例"><a href="#9-x-官方示例" class="headerlink" title="9.x 官方示例"></a>9.x 官方示例</h3><pre><code class="hljs nginx"> <span class="hljs-attribute">upstream</span> php-handler &#123;    <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:9000</span>; <span class="hljs-comment">#注意一下你自己的php服务设置，这一行可能需要自己调整</span>    <span class="hljs-comment">#server unix:/var/run/php5-fpm.sock;</span>&#125;<span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span> cloud.example.com;    <span class="hljs-comment"># enforce https</span>    <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://$server_name$request_uri;&#125;<span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;    <span class="hljs-attribute">server_name</span> cloud.example.com;    <span class="hljs-comment">#ssl证书的位置</span>    <span class="hljs-attribute">ssl_certificate</span> /etc/ssl/nginx/cloud.example.com.crt;    <span class="hljs-attribute">ssl_certificate_key</span> /etc/ssl/nginx/cloud.example.com.key;    <span class="hljs-comment"># Add headers to serve security related headers</span>    <span class="hljs-comment"># Before enabling Strict-Transport-Security headers please read into this</span>    <span class="hljs-comment"># topic first.</span>    <span class="hljs-comment"># 安装好之后，后台可能会提示相应错误，把这一段的注释去掉就行</span>    <span class="hljs-comment"># add_header Strict-Transport-Security &quot;max-age=15768000;</span>    <span class="hljs-comment"># includeSubDomains; preload;&quot;;</span>    <span class="hljs-comment">#后面安装好了之后后台可能会提示header的错误，把这一短删除掉即可</span>    <span class="hljs-attribute">add_header</span> X-Content-Type-Options nosniff;    <span class="hljs-attribute">add_header</span> X-Frame-Options <span class="hljs-string">&quot;SAMEORIGIN&quot;</span>;    <span class="hljs-attribute">add_header</span> X-XSS-Protection <span class="hljs-string">&quot;1; mode=block&quot;</span>;    <span class="hljs-attribute">add_header</span> X-Robots-Tag <span class="hljs-literal">none</span>;    <span class="hljs-attribute">add_header</span> X-Download-Options noopen;    <span class="hljs-attribute">add_header</span> X-Permitted-Cross-Domain-Policies <span class="hljs-literal">none</span>;    <span class="hljs-comment"># Path to the root of your installation</span>    <span class="hljs-attribute">root</span> /var/www/owncloud/;    <span class="hljs-attribute">location</span> = /robots.txt &#123;        <span class="hljs-attribute">allow</span> all;        <span class="hljs-attribute">log_not_found</span> <span class="hljs-literal">off</span>;        <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>;    &#125;    <span class="hljs-comment"># The following 2 rules are only needed for the user_webfinger app.</span>    <span class="hljs-comment"># Uncomment it if you&#x27;re planning to use this app.</span>    <span class="hljs-comment">#rewrite ^/.well-known/host-meta /public.php?service=host-meta last;</span>    <span class="hljs-comment">#rewrite ^/.well-known/host-meta.json /public.php?service=host-meta-json</span>    <span class="hljs-comment"># last;</span>    <span class="hljs-attribute">location</span> = /.well-known/carddav &#123; <span class="hljs-attribute">return</span> <span class="hljs-number">301</span>     $scheme://$host/remote.php/dav; &#125;    <span class="hljs-attribute">location</span> = /.well-known/caldav &#123; <span class="hljs-attribute">return</span> <span class="hljs-number">301</span>     $scheme://$host/remote.php/dav; &#125;    <span class="hljs-attribute">location</span> /.well-known/acme-challenge &#123; &#125;    <span class="hljs-comment"># set max upload size</span>    <span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">512M</span>;    <span class="hljs-attribute">fastcgi_buffers</span> <span class="hljs-number">64</span> <span class="hljs-number">4K</span>;    <span class="hljs-comment"># Disable gzip to avoid the removal of the ETag header</span>    <span class="hljs-attribute">gzip</span> <span class="hljs-literal">off</span>;    <span class="hljs-comment"># Uncomment if your server is build with the ngx_pagespeed module</span>    <span class="hljs-comment"># This module is currently not supported.</span>    <span class="hljs-comment">#pagespeed off;</span>    <span class="hljs-attribute">error_page</span> <span class="hljs-number">403</span> /core/templates/<span class="hljs-number">403</span>.php;    <span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> /core/templates/<span class="hljs-number">404</span>.php;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^</span> /index.php$uri;    &#125;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/(?:build|tests|config|lib|3rdparty|templates|data)/</span> &#123;        <span class="hljs-attribute">deny</span> all;    &#125;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/(?:\.|autotest|occ|issue|indie|db_|console)</span> &#123;        <span class="hljs-attribute">deny</span> all;    &#125;    <span class="hljs-attribute">location</span> ~   <span class="hljs-regexp"> ^/(?:index|remote|public|cron|core/ajax/update|status|ocs/v[12]|updater</span><span class="hljs-regexp"></span>    /.+|ocs-provider/.+|core/templates/<span class="hljs-number">40</span>[<span class="hljs-number">34</span>])\.php(?:$|/) &#123;        <span class="hljs-attribute">include</span> fastcgi_params;        <span class="hljs-attribute">fastcgi_split_path_info</span><span class="hljs-regexp"> ^(.+\.php)(/.+)$</span>;        <span class="hljs-attribute">fastcgi_param</span> SCRIPT_FILENAME $document_root$fastcgi_script_name;        <span class="hljs-attribute">fastcgi_param</span> PATH_INFO $fastcgi_path_info;        <span class="hljs-attribute">fastcgi_param</span> HTTPS <span class="hljs-literal">on</span>;        <span class="hljs-comment">#Avoid sending the security headers twice</span>        <span class="hljs-attribute">fastcgi_param</span> modHeadersAvailable <span class="hljs-literal">true</span>;        <span class="hljs-attribute">fastcgi_param</span> front_controller_active <span class="hljs-literal">true</span>;        <span class="hljs-attribute">fastcgi_pass</span> php-handler;        <span class="hljs-attribute">fastcgi_intercept_errors</span> <span class="hljs-literal">on</span>;        <span class="hljs-attribute">fastcgi_request_buffering</span> <span class="hljs-literal">off</span>;    &#125;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/(?:updater|ocs-provider)(?:$|/)</span> &#123;        <span class="hljs-attribute">try_files</span> $uri/ =<span class="hljs-number">404</span>;        <span class="hljs-attribute">index</span> index.php;    &#125;    <span class="hljs-comment"># Adding the cache control header for js and css files</span>    <span class="hljs-comment"># Make sure it is BELOW the PHP block</span>    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~* \.(?:css|js)$</span> &#123;        <span class="hljs-attribute">try_files</span> $uri /index.php$uri$is_args$args;        <span class="hljs-attribute">add_header</span> Cache-Control <span class="hljs-string">&quot;public, max-age=7200&quot;</span>;        <span class="hljs-comment"># Add headers to serve security related headers (It is intended to</span>        <span class="hljs-comment"># have those duplicated to the ones above)</span>        <span class="hljs-comment"># Before enabling Strict-Transport-Security headers please read into</span>        <span class="hljs-comment"># this topic first.</span>        <span class="hljs-comment"># add_header Strict-Transport-Security &quot;max-age=15768000;</span>        <span class="hljs-comment">#  includeSubDomains; preload;&quot;;</span>        <span class="hljs-attribute">add_header</span> X-Content-Type-Options nosniff;        <span class="hljs-attribute">add_header</span> X-Frame-Options <span class="hljs-string">&quot;SAMEORIGIN&quot;</span>;        <span class="hljs-attribute">add_header</span> X-XSS-Protection <span class="hljs-string">&quot;1; mode=block&quot;</span>;        <span class="hljs-attribute">add_header</span> X-Robots-Tag <span class="hljs-literal">none</span>;        <span class="hljs-attribute">add_header</span> X-Download-Options noopen;        <span class="hljs-attribute">add_header</span> X-Permitted-Cross-Domain-Policies <span class="hljs-literal">none</span>;        <span class="hljs-comment"># Optional: Don&#x27;t log access to assets</span>        <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>;    &#125;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~* \.(?:svg|gif|png|html|ttf|woff|ico|jpg|jpeg)$</span> &#123;        <span class="hljs-attribute">try_files</span> $uri /index.php$uri$is_args$args;        <span class="hljs-comment"># Optional: Don&#x27;t log access to other assets</span>        <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>;    &#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>lnmp</tag>
      
      <tag>云盘</tag>
      
      <tag>owncloud</tag>
      
      <tag>oss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四川大学评教开源代码</title>
    <link href="/post/31503.html"/>
    <url>/post/31503.html</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">require</span> <span class="hljs-string">&quot;login.php&quot;</span>;<span class="hljs-keyword">require</span> <span class="hljs-string">&quot;QueryList.class.php&quot;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">evaluate</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-variable">$_listUrl</span>=<span class="hljs-string">&quot;http://202.115.47.141/jxpgXsAction.do?oper=listWj&amp;page=&quot;</span>;<span class="hljs-comment">//评教列表页面</span>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$_formUrl</span>=<span class="hljs-string">&quot;http://202.115.47.141/jxpgXsAction.do?oper=wjShow&amp;&quot;</span>;<span class="hljs-comment">//评教表单页面</span>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$_postUrl</span>=<span class="hljs-string">&quot;http://202.115.47.141/jxpgXsAction.do?oper=wjpg&amp;&quot;</span>;<span class="hljs-comment">//评教提交地址</span>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$_yjpj</span>;    <span class="hljs-keyword">private</span> <span class="hljs-variable">$_successNo</span>=<span class="hljs-number">0</span>;<span class="hljs-comment">//成功次数</span>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$_failNo</span>=<span class="hljs-number">0</span>;<span class="hljs-comment">//失败次数</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$name</span>,<span class="hljs-variable">$pass</span></span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;_yjpj=<span class="hljs-keyword">new</span> login(<span class="hljs-variable">$name</span>,<span class="hljs-variable">$pass</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取评教列表并且返回列表信息以及页码</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> mixed</span><span class="hljs-comment">     *       $list=[</span><span class="hljs-comment">     *           &#x27;info&#x27;=&gt;[</span><span class="hljs-comment">     *               [</span><span class="hljs-comment">     *                   &#x27;param&#x27;=&gt;[</span><span class="hljs-comment">     *                       0 =&gt; &#x27;0000000038&#x27;,</span><span class="hljs-comment">     *                       1 =&gt; &#x27;19873162&#x27;,</span><span class="hljs-comment">     *                       2 =&gt; &#x27;高苹&#x27;,</span><span class="hljs-comment">     *                       3 =&gt; &#x27;学评教&#x27;,</span><span class="hljs-comment">     *                       4 =&gt; &#x27;马克思主义基本原理概论&#x27;,</span><span class="hljs-comment">     *                       5 =&gt; &#x27;107021030&#x27;,</span><span class="hljs-comment">     *                   ],</span><span class="hljs-comment">     *                   &#x27;status&#x27;=&gt;0</span><span class="hljs-comment">     *               ],</span><span class="hljs-comment">     *              ......</span><span class="hljs-comment">     *           ],</span><span class="hljs-comment">     *           &#x27;page&#x27;=&gt;[</span><span class="hljs-comment">     *               [</span><span class="hljs-comment">     *                   &#x27;page&#x27;=&gt;&#x27;2&#x27;</span><span class="hljs-comment">     *               ]</span><span class="hljs-comment">     *           ]</span><span class="hljs-comment">     *       ];</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">getList</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">/*--------------获取第一页的评教列表页面---------------*/</span>        <span class="hljs-variable">$listContent</span>=<span class="hljs-keyword">$this</span>-&gt;_yjpj-&gt;show(<span class="hljs-keyword">$this</span>-&gt;_listUrl.<span class="hljs-string">&quot;1&quot;</span>);        <span class="hljs-comment">/*------------获取评教分页信息--------------*/</span>        <span class="hljs-variable">$pageReg</span>=[            <span class="hljs-string">&#x27;page&#x27;</span>=&gt;[<span class="hljs-string">&#x27;script:eq(3)&#x27;</span>,<span class="hljs-string">&#x27;html&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable">$page</span></span>)</span>&#123;                <span class="hljs-variable">$pattern</span>=<span class="hljs-string">&quot;/document\.all\.pageNo\.value&gt;(.)/&quot;</span>;                preg_match(<span class="hljs-variable">$pattern</span>,<span class="hljs-variable">$page</span>,<span class="hljs-variable">$no</span>);                <span class="hljs-keyword">if</span>(<span class="hljs-variable">$no</span>[<span class="hljs-number">1</span>])&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-variable">$no</span>[<span class="hljs-number">1</span>];                &#125;            &#125;]        ];        <span class="hljs-variable">$page</span>=QueryList::Query(<span class="hljs-variable">$listContent</span>,<span class="hljs-variable">$pageReg</span>);        <span class="hljs-variable">$page</span>=<span class="hljs-variable">$page</span>-&gt;jsonArr[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;page&#x27;</span>];        <span class="hljs-comment">/*---------获取评教老师信息--------------*/</span>        <span class="hljs-variable">$listReg</span>=[            <span class="hljs-string">&#x27;param&#x27;</span>=&gt;[<span class="hljs-string">&#x27;img&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable">$a</span></span>)</span>&#123;                <span class="hljs-keyword">if</span>(<span class="hljs-variable">$a</span>)&#123;                    <span class="hljs-keyword">return</span> explode(<span class="hljs-string">&#x27;#@&#x27;</span>,<span class="hljs-variable">$a</span>);                &#125;            &#125;],            <span class="hljs-string">&#x27;status&#x27;</span>=&gt;[<span class="hljs-string">&#x27;img&#x27;</span>,<span class="hljs-string">&#x27;onclick&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable">$a</span></span>)</span>&#123;                <span class="hljs-keyword">if</span>(trim(<span class="hljs-variable">$a</span>)==<span class="hljs-string">&quot;evaluation(this)&quot;</span>)&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                &#125;            &#125;],        ];        <span class="hljs-comment">/*[优化]：减少重复抓取列表页，大大提高效率*/</span>        <span class="hljs-variable">$c</span>=QueryList::Query(<span class="hljs-variable">$listContent</span>,<span class="hljs-variable">$listReg</span>);        <span class="hljs-variable">$list</span>[]=<span class="hljs-variable">$c</span>-&gt;jsonArr;        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$page</span>&gt;<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">2</span>;<span class="hljs-variable">$i</span>&lt;=<span class="hljs-variable">$page</span>;<span class="hljs-variable">$i</span>++)&#123;                <span class="hljs-variable">$listContent</span>=<span class="hljs-keyword">$this</span>-&gt;_yjpj-&gt;show(<span class="hljs-keyword">$this</span>-&gt;_listUrl.<span class="hljs-variable">$i</span>);                <span class="hljs-variable">$c</span>=QueryList::Query(<span class="hljs-variable">$listContent</span>,<span class="hljs-variable">$listReg</span>);                <span class="hljs-variable">$list</span>[]=<span class="hljs-variable">$c</span>-&gt;jsonArr;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-variable">$list</span>;<span class="hljs-comment">//获取到的评教信息</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPostInfo</span>(<span class="hljs-params"><span class="hljs-variable">$list</span></span>)</span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//        print_r($list);</span>        <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$list</span> <span class="hljs-keyword">as</span>  <span class="hljs-variable">$listVal</span>)&#123;<span class="hljs-comment">//            print_r($listVal);</span>            <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$listVal</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$listkey</span> =&gt; <span class="hljs-variable">$listValue</span>)&#123;                <span class="hljs-keyword">if</span>(<span class="hljs-variable">$listValue</span>[<span class="hljs-string">&#x27;status&#x27;</span>]==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//                    print_r($listValue);</span>                    <span class="hljs-variable">$param</span>=[                        <span class="hljs-string">&#x27;wjbm&#x27;</span>=&gt;<span class="hljs-variable">$listValue</span>[<span class="hljs-string">&#x27;param&#x27;</span>][<span class="hljs-number">0</span>],                        <span class="hljs-string">&#x27;bpr&#x27;</span>=&gt;<span class="hljs-variable">$listValue</span>[<span class="hljs-string">&#x27;param&#x27;</span>][<span class="hljs-number">1</span>],                        <span class="hljs-string">&#x27;pgnr&#x27;</span>=&gt;<span class="hljs-variable">$listValue</span>[<span class="hljs-string">&#x27;param&#x27;</span>][<span class="hljs-number">5</span>],                    ];                    <span class="hljs-variable">$param</span>=http_build_query(<span class="hljs-variable">$param</span>);                    <span class="hljs-variable">$url</span>=<span class="hljs-keyword">$this</span>-&gt;_formUrl.<span class="hljs-variable">$param</span>;<span class="hljs-comment">//                    echo $url;</span>                    <span class="hljs-variable">$formContent</span>=<span class="hljs-keyword">$this</span>-&gt;_yjpj-&gt;show(<span class="hljs-variable">$url</span>);<span class="hljs-comment">//                    print_r($formContent);</span>                    <span class="hljs-variable">$res</span>=QueryList::Query(<span class="hljs-variable">$formContent</span>,[<span class="hljs-string">&#x27;name&#x27;</span>=&gt;[<span class="hljs-string">&#x27;[value=10_1]&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>]]);                    <span class="hljs-comment">/*--------------将获取的表单信息整理成为即将post的参数-------------*/</span>                    <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$res</span>-&gt;jsonArr <span class="hljs-keyword">as</span> <span class="hljs-variable">$postKey</span> =&gt; <span class="hljs-variable">$postValue</span>)&#123;                        <span class="hljs-variable">$postParam</span>[<span class="hljs-variable">$postValue</span>[<span class="hljs-string">&#x27;name&#x27;</span>]]=<span class="hljs-string">&quot;10_1&quot;</span>;                    &#125;                    <span class="hljs-variable">$postParam</span>[<span class="hljs-string">&#x27;wjbm&#x27;</span>]=<span class="hljs-variable">$listValue</span>[<span class="hljs-string">&#x27;param&#x27;</span>][<span class="hljs-number">0</span>];                    <span class="hljs-variable">$postParam</span>[<span class="hljs-string">&#x27;bpr&#x27;</span>]=<span class="hljs-variable">$listValue</span>[<span class="hljs-string">&#x27;param&#x27;</span>][<span class="hljs-number">1</span>];                    <span class="hljs-variable">$postParam</span>[<span class="hljs-string">&#x27;pgnr&#x27;</span>]=<span class="hljs-variable">$listValue</span>[<span class="hljs-string">&#x27;param&#x27;</span>][<span class="hljs-number">5</span>];                    <span class="hljs-variable">$postParam</span>[<span class="hljs-string">&#x27;zgpj&#x27;</span>]=<span class="hljs-string">&quot;very good teacher!!&quot;</span>;                    <span class="hljs-keyword">$this</span>-&gt;post(<span class="hljs-variable">$postParam</span>);<span class="hljs-comment">//                    return 0;</span>                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span>(<span class="hljs-params"><span class="hljs-variable">$param</span></span>)</span>&#123;        <span class="hljs-variable">$param</span>=http_build_query(<span class="hljs-variable">$param</span>);        <span class="hljs-variable">$url</span>=<span class="hljs-keyword">$this</span>-&gt;_postUrl.<span class="hljs-variable">$param</span>;<span class="hljs-comment">//        echo $url;</span>        <span class="hljs-variable">$evalContent</span>=<span class="hljs-keyword">$this</span>-&gt;_yjpj-&gt;show(<span class="hljs-variable">$url</span>);        <span class="hljs-comment">/*--------------------抓取提交之后的数据查看是否成功提交--------------------*/</span>        <span class="hljs-variable">$res</span>=QueryList::Query(<span class="hljs-variable">$evalContent</span>,[<span class="hljs-string">&#x27;info&#x27;</span>=&gt;[<span class="hljs-string">&#x27;script&#x27;</span>,<span class="hljs-string">&#x27;html&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable">$a</span></span>)</span>&#123;            <span class="hljs-variable">$pattern</span>=<span class="hljs-string">&#x27;/alert\(&quot;(.+)&quot;\)/&#x27;</span>;            preg_match_all(<span class="hljs-variable">$pattern</span>,<span class="hljs-variable">$a</span>,<span class="hljs-variable">$res</span>);            <span class="hljs-variable">$success</span>=<span class="hljs-string">&#x27;评估成功！&#x27;</span>;            <span class="hljs-keyword">if</span>(<span class="hljs-variable">$res</span>[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]==<span class="hljs-variable">$success</span>)&#123;                <span class="hljs-variable">$a</span>=[                    <span class="hljs-string">&#x27;message&#x27;</span>=&gt;<span class="hljs-variable">$res</span>[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],                    <span class="hljs-string">&#x27;status&#x27;</span>=&gt;<span class="hljs-number">1</span>                ];            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-variable">$a</span>=[                    <span class="hljs-string">&#x27;message&#x27;</span>=&gt;<span class="hljs-variable">$res</span>[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],                    <span class="hljs-string">&#x27;status&#x27;</span>=&gt;<span class="hljs-number">0</span>                ];            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-variable">$a</span>;        &#125;]]);        <span class="hljs-variable">$status</span>=<span class="hljs-variable">$res</span>-&gt;jsonArr[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;info&#x27;</span>][<span class="hljs-string">&#x27;status&#x27;</span>];        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$status</span>==<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">$this</span>-&gt;_successNo+=<span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">$this</span>-&gt;_failNo+=<span class="hljs-number">1</span>;        &#125;<span class="hljs-comment">//        print_r($res-&gt;jsonArr);</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;getPostInfo(<span class="hljs-keyword">$this</span>-&gt;getList());        <span class="hljs-keyword">$this</span>-&gt;count();      <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;success&#x27;</span>=&gt;<span class="hljs-keyword">$this</span>-&gt;_successNo,<span class="hljs-string">&#x27;fail&#x27;</span>=&gt;<span class="hljs-keyword">$this</span>-&gt;_failNo];        <span class="hljs-comment">//return &#x27;评教成功，成功：&#x27;.$this-&gt;_successNo.&#x27;位，&#x27;.&#x27;失败：&#x27;.$this-&gt;_failNo.&quot;位&quot;;</span>    &#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/5431.html">使用chromedp解决反爬虫问题</a></li><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/18280.html">四川大学锐捷windows解除多网卡限制</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>大学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>四川大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Composer上线前的优化</title>
    <link href="/post/36128.html"/>
    <url>/post/36128.html</url>
    
    <content type="html"><![CDATA[<p>更新之后或者上线前别忘了执行下面的命令<br>否则少则损失 20%-50%的性能，多则程序直接报错</p><pre><code class="hljs bash">composer dump-autoload --optimize</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>composer</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php识别验证码（二）</title>
    <link href="/post/10661.html"/>
    <url>/post/10661.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>在 php 识别验证码（一）当中说了基本的识别验证码的方法，及其关键的代码，但是最后我们留下了一个问题，就是对于有旋转的验证码的识别率及其低下的问题，下面来解决这个问题。</p></blockquote><h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><blockquote><p>解决类似于下面图片这种有旋转字符的验证码，我们首先要给出一种标准，让所有的分割后的图片都按照一个标准来摆放，最后对比的时候才能够统一</p></blockquote><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/1900195239.png" alt="inImgTemp.png"></p><p><strong>如何标准化？</strong></p><ul><li><p>我们对一个字符进行旋转，然后计算这个字符的宽度，当宽度最小时，我们认为它是一个标准字符，这样我们就能够得到比较好的结果了（通过观察这种验证码，发现一般只要左右旋转三十度即可）</p></li><li><p>然后仅仅进行旋转还不够，为了能够和模板也就是特征值库进行对比，我们还需要，统一字符长度。也就是二值化之后的字符串长度，这时就需要画一张长宽固定的图片，把我们原来的图片按照比例拉伸压缩复制过去</p></li></ul><pre><code class="hljs php">    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 图像标准化，将旋转的图像标准化</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $img</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> resource 标准的图像资源句柄</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">imageStandard</span>(<span class="hljs-params"><span class="hljs-variable">$img</span></span>)</span>&#123;        <span class="hljs-variable">$min_w</span>=<span class="hljs-number">999</span>;        <span class="hljs-variable">$oimg</span>=<span class="hljs-variable">$img</span>;        <span class="hljs-variable">$c</span>=imagecolorallocate(<span class="hljs-variable">$img</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">-30</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-number">30</span>;<span class="hljs-variable">$i</span>++)&#123;            <span class="hljs-variable">$simg</span>=imagerotate(<span class="hljs-variable">$img</span>,<span class="hljs-variable">$i</span>,<span class="hljs-variable">$c</span>);<span class="hljs-comment">//            //计算字符宽度</span>            <span class="hljs-variable">$simg_hash_data</span>=<span class="hljs-keyword">$this</span>-&gt;getWidth(<span class="hljs-variable">$simg</span>);            <span class="hljs-variable">$w</span>=count(<span class="hljs-variable">$simg_hash_data</span>);            <span class="hljs-keyword">if</span>(<span class="hljs-variable">$w</span>&lt;<span class="hljs-variable">$min_w</span>)&#123;                <span class="hljs-variable">$oimg_hash_data</span>=<span class="hljs-variable">$simg_hash_data</span>;                <span class="hljs-variable">$min_w</span>=<span class="hljs-variable">$w</span>;            &#125;        &#125;        <span class="hljs-variable">$out_img_w</span>=count(<span class="hljs-variable">$oimg_hash_data</span>);        <span class="hljs-variable">$out_img_h</span>=count(<span class="hljs-variable">$oimg_hash_data</span>[<span class="hljs-number">0</span>]);        <span class="hljs-variable">$out_img</span> = imagecreatetruecolor(<span class="hljs-variable">$out_img_w</span>,<span class="hljs-variable">$out_img_h</span>);<span class="hljs-comment">//创建一幅真彩色图像</span>        <span class="hljs-variable">$bg</span>=imagecolorallocate(<span class="hljs-variable">$out_img</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);<span class="hljs-comment">//背景色画为白色</span>        imagefill(<span class="hljs-variable">$out_img</span>, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>, <span class="hljs-variable">$bg</span>);        <span class="hljs-comment">//一列一列的进行画图</span>        <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$oimg_hash_data</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$k</span>=&gt;<span class="hljs-variable">$v</span>)&#123;            <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$v</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$key</span>=&gt; <span class="hljs-variable">$val</span>)&#123;                <span class="hljs-variable">$color</span>=<span class="hljs-number">255</span>;                <span class="hljs-keyword">if</span>(<span class="hljs-variable">$val</span>) <span class="hljs-variable">$color</span>=<span class="hljs-number">0</span>;                <span class="hljs-variable">$c</span> = imagecolorallocate(<span class="hljs-variable">$out_img</span>, <span class="hljs-variable">$color</span>, <span class="hljs-variable">$color</span>, <span class="hljs-variable">$color</span>);                imagesetpixel(<span class="hljs-variable">$out_img</span>, <span class="hljs-variable">$k</span>,<span class="hljs-variable">$key</span>, <span class="hljs-variable">$c</span>);            &#125;        &#125;<span class="hljs-comment">//        imagepng($out_img,&#x27;./0.png&#x27;);</span>        <span class="hljs-variable">$hash_img</span> = imagecreatetruecolor(<span class="hljs-built_in">self</span>::HASH_W, <span class="hljs-built_in">self</span>::HASH_H);        imagecopyresized(<span class="hljs-variable">$hash_img</span>, <span class="hljs-variable">$out_img</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">self</span>::HASH_W,<span class="hljs-built_in">self</span>::HASH_H,<span class="hljs-variable">$out_img_w</span>,<span class="hljs-variable">$out_img_h</span>);        <span class="hljs-keyword">return</span> <span class="hljs-variable">$hash_img</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取图像的宽度</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $img 图像资源句柄</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWidth</span>(<span class="hljs-params"><span class="hljs-variable">$img</span></span>)</span>&#123;        <span class="hljs-comment">//根据资源句柄获取整个图像的高与宽</span>        <span class="hljs-variable">$img_w</span>=imagesx(<span class="hljs-variable">$img</span>);        <span class="hljs-variable">$img_h</span>=imagesy(<span class="hljs-variable">$img</span>);        <span class="hljs-comment">//图像二值化</span>        <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt;<span class="hljs-variable">$img_h</span>; <span class="hljs-variable">$i</span>++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-variable">$j</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$j</span> &lt;<span class="hljs-variable">$img_w</span>; <span class="hljs-variable">$j</span>++) &#123;                <span class="hljs-variable">$rgb</span> = imagecolorat(<span class="hljs-variable">$img</span>,<span class="hljs-variable">$j</span>,<span class="hljs-variable">$i</span>);                <span class="hljs-keyword">if</span>(<span class="hljs-variable">$rgb</span>==<span class="hljs-number">0</span>)&#123;                    <span class="hljs-variable">$data</span>[<span class="hljs-variable">$i</span>][<span class="hljs-variable">$j</span>]=<span class="hljs-number">1</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-variable">$data</span>[<span class="hljs-variable">$i</span>][<span class="hljs-variable">$j</span>]=<span class="hljs-number">0</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">//去掉零行</span>        <span class="hljs-variable">$data</span>=<span class="hljs-keyword">$this</span>-&gt;removeZero(<span class="hljs-variable">$data</span>);        <span class="hljs-comment">//按列取图像获取宽度</span>        <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-variable">$img_w</span>;<span class="hljs-variable">$i</span>++)&#123;            <span class="hljs-variable">$column</span>=array_column(<span class="hljs-variable">$data</span>,<span class="hljs-variable">$i</span>);            <span class="hljs-keyword">if</span>(implode(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-variable">$column</span>)!=<span class="hljs-number">0</span>)&#123;                <span class="hljs-variable">$data1</span>[]=<span class="hljs-variable">$column</span>;            &#125;        &#125;        <span class="hljs-comment">//返回</span>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$data1</span>;    &#125;</code></pre><blockquote><p>看上方的代码发现会有一个去除零行的操作，也就是去除空白行，这一步操作的目的主要是为了出掉上下左右无用的空白部分，在我们进行模板对比的时候更加的精确</p></blockquote><h2 id="建立特征值库"><a href="#建立特征值库" class="headerlink" title="建立特征值库"></a>建立特征值库</h2><blockquote><p>之前提到了很多和模板或者是特征值库进行比较，那我们如何来建立这个库呢？下面说一下最简单的两种方法</p></blockquote><ul><li>第一种，就是把你需要的数字可能还有 26 个字母，都先识别一遍然后存到一个文件当中，使用的时候包含这个文件进行对比就行了</li><li>第二种，也差不多，可以写一个 study 文件，让上面的步骤稍微智能一点，直接输入之后，自动储存到数据库中</li></ul><p>下面是我写的一个针对联通优选在沃的一个小的脚本，需要注意的是对于这种通过链接来识别的，一定要先将链接的图片保存下来，因为链接没获取一次图片就会改变一次</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;.</span><span class="hljs-comment"> * User: mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;</span><span class="hljs-comment"> * Date: 2016/5/1 0001</span><span class="hljs-comment"> * Time: 20:44</span><span class="hljs-comment"> */</span><span class="hljs-keyword">require_once</span> <span class="hljs-string">&#x27;Image.class.php&#x27;</span>;<span class="hljs-keyword">require_once</span>  <span class="hljs-string">&#x27;DB.class.php&#x27;</span>;<span class="hljs-variable">$db</span>=<span class="hljs-keyword">new</span> \ImageOCR\DB();<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;send&#x27;</span>])&amp;&amp;<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;send&#x27;</span>]==<span class="hljs-string">&quot;send&quot;</span>)&#123;    <span class="hljs-variable">$image</span>=<span class="hljs-keyword">new</span> \ImageOCR\Image(<span class="hljs-string">&quot;./img/inImgTemp.png&quot;</span>);    <span class="hljs-variable">$code</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;code&#x27;</span>];    <span class="hljs-variable">$code_arr</span>=str_split(<span class="hljs-variable">$code</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-variable">$image</span>::CHAR_NUM;<span class="hljs-variable">$i</span>++)&#123;        <span class="hljs-variable">$hash_img_data</span>=implode(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-variable">$image</span>-&gt;splitImage(<span class="hljs-variable">$i</span>));        <span class="hljs-variable">$db</span>-&gt;add(<span class="hljs-variable">$code_arr</span>[<span class="hljs-variable">$i</span>],<span class="hljs-variable">$hash_img_data</span>);    &#125;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;script&gt;location.href=&#x27;./study.php&#x27;;&lt;/script&gt;&quot;</span>;&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-variable">$image</span>=<span class="hljs-keyword">new</span> \ImageOCR\Image(<span class="hljs-string">&quot;http://www.169ol.com/Mall/Code/getCode&amp;1462104790492&quot;</span>);    imagepng(<span class="hljs-variable">$image</span>-&gt;_in_img,<span class="hljs-string">&quot;./img/inImgTemp.png&quot;</span>);&#125;<span class="hljs-meta">?&gt;</span>&lt;!DOCTYPE html&gt;&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;&lt;head&gt;    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;    &lt;title&gt;Study&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=<span class="hljs-string">&quot;&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;        &lt;img src=<span class="hljs-string">&quot;img/inImgTemp.png&quot;</span>&gt;        &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;code&quot;</span>&gt;        &lt;input name=<span class="hljs-string">&quot;send&quot;</span> type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;send&quot;</span> /&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="开源代码"><a href="#开源代码" class="headerlink" title="开源代码"></a>开源代码</h2><p><strong>觉得不错，给个 star 呗</strong></p><script src='http://git.oschina.net/lxl520/ImageOCR/widget_preview'></script><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="http://drops.wooyun.org/tips/141">常见验证码的弱点与验证码识别</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>目前的识别效率可以达到 50%以上，基本可以投入正常使用，但是还有很大的进步空间，正在做下一步的优化，针对识别结果对特征库进行自动优化，自动去除使用率较低的特征值，自动保存，识别成功的特征值等等</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>图片</tag>
      
      <tag>验证码识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php利用curl保存图片</title>
    <link href="/post/58471.html"/>
    <url>/post/58471.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>做验证码识别的时候需要先把图片保存起来，写了一个保存图片的函数</p></blockquote><pre><code class="hljs php"><span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> string $url 获取图片的网址</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> string $fileName 保存的地址以及文件名</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getImg</span>(<span class="hljs-params"><span class="hljs-variable">$url</span>, <span class="hljs-variable">$fileName</span></span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-variable">$ch</span> = curl_init();        <span class="hljs-variable">$fp</span> = fopen(<span class="hljs-variable">$fileName</span>, <span class="hljs-string">&#x27;w+&#x27;</span>);        curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_URL, <span class="hljs-variable">$url</span>);        curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_HEADER, <span class="hljs-number">0</span>);        curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_FOLLOWLOCATION, <span class="hljs-number">0</span>);        curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_TIMEOUT, <span class="hljs-number">60</span>);        curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_FILE,<span class="hljs-variable">$fp</span>);        curl_exec(<span class="hljs-variable">$ch</span>);        curl_close(<span class="hljs-variable">$ch</span>);        fclose(<span class="hljs-variable">$fp</span>);    &#125;</code></pre><blockquote><p>使用的时候发现，需要保存验证码的 cookies，留作验证，必要的时候还需要加上 header</p></blockquote><pre><code class="hljs php"><span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> string $url</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> string $fileName</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCode</span>(<span class="hljs-params"><span class="hljs-variable">$url</span> = <span class="hljs-string">&#x27;http://www.169ol.com/Mall/Code/getCode&#x27;</span>, <span class="hljs-variable">$fileName</span> = <span class="hljs-string">&#x27;./img/code.png&#x27;</span></span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;_code_cookie = dirname(<span class="hljs-keyword">__FILE__</span>).<span class="hljs-string">&quot;/pic.cookie&quot;</span>;        <span class="hljs-variable">$ch</span> = curl_init();        <span class="hljs-variable">$fp</span> = fopen(<span class="hljs-variable">$fileName</span>, <span class="hljs-string">&#x27;w+&#x27;</span>);        curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_URL, <span class="hljs-variable">$url</span>);        curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_HEADER, <span class="hljs-number">0</span>);        curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_FOLLOWLOCATION, <span class="hljs-number">0</span>);        curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_TIMEOUT, <span class="hljs-number">60</span>);        curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_FILE,<span class="hljs-variable">$fp</span>);        curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_COOKIEJAR, <span class="hljs-keyword">$this</span>-&gt;_code_cookie);        curl_exec(<span class="hljs-variable">$ch</span>);        curl_close(<span class="hljs-variable">$ch</span>);        fclose(<span class="hljs-variable">$fp</span>);    &#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>图片</tag>
      
      <tag>curl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php识别验证码（一）</title>
    <link href="/post/47583.html"/>
    <url>/post/47583.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>想做一个针对联通优选在沃自动签到的小程序，但是登陆需要验证码，找了一下现有的一些博客或者是开源的验证码识别的代码，没有一个比较满意的，so，自己写了一个。</p></blockquote><h2 id="需要识别的验证码"><a href="#需要识别的验证码" class="headerlink" title="需要识别的验证码"></a>需要识别的验证码</h2><blockquote><p>第一种：</p></blockquote><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2190097228.png" alt="code.png"></p><blockquote><p>第二种</p></blockquote><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/1819792828.gif" alt="1211862590-56a5bd94d822e.gif"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>像上图的验证码一般来说的话，我们需要识别的是 4 个数字，但是验证码为了防止自动识别程序添加了许多的干扰项，例如<code>背景色</code>、<code>雪花</code>、<code>干扰线</code>等等</p><h2 id="去除背景"><a href="#去除背景" class="headerlink" title="去除背景"></a>去除背景</h2><p>我们通过分析该验证码图片可以知道，数字的 rgb 值一般处在 180~190 以下，而背景色和雪花的 rgb 值一般处在 200 以上，so，我们只要在处理图片的时候只取 190 以下的 rgb 值保存就 ok 了，这样就可以去除掉绝大部分的干扰项</p><h2 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h2><p>把干扰信息去除之后，只留下二进制（也就是 0 和 1 表示）的点阵</p><pre><code class="hljs php"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 二值化，排除背景色，雪花等干扰项</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">imageHash</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-keyword">$this</span>-&gt;_image_h; <span class="hljs-variable">$i</span>++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-variable">$j</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$j</span> &lt; <span class="hljs-keyword">$this</span>-&gt;_image_w; <span class="hljs-variable">$j</span>++) &#123;            <span class="hljs-variable">$rgb</span> = imagecolorat(<span class="hljs-keyword">$this</span>-&gt;_in_img,<span class="hljs-variable">$j</span>,<span class="hljs-variable">$i</span>);            <span class="hljs-variable">$rgb_array</span> = imagecolorsforindex(<span class="hljs-keyword">$this</span>-&gt;_in_img, <span class="hljs-variable">$rgb</span>);            <span class="hljs-keyword">if</span>(<span class="hljs-variable">$rgb_array</span>[<span class="hljs-string">&#x27;red&#x27;</span>]&lt;<span class="hljs-number">190</span>&amp;&amp;<span class="hljs-variable">$rgb_array</span>[<span class="hljs-string">&#x27;green&#x27;</span>]&lt;<span class="hljs-number">190</span>&amp;&amp;<span class="hljs-variable">$rgb_array</span>[<span class="hljs-string">&#x27;blue&#x27;</span>]&lt;<span class="hljs-number">190</span>)&#123;                <span class="hljs-variable">$data</span>[<span class="hljs-variable">$i</span>][<span class="hljs-variable">$j</span>]=<span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-variable">$data</span>[<span class="hljs-variable">$i</span>][<span class="hljs-variable">$j</span>]=<span class="hljs-number">0</span>;            &#125;        &#125;    &#125;&#125;</code></pre><blockquote><p>点阵化之后的截图</p></blockquote><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2878339217.png" alt="QQ截图20160503213904.png"></p><h2 id="去噪点"><a href="#去噪点" class="headerlink" title="去噪点"></a>去噪点</h2><p>图像二值化之后可能还存在很多噪点，噪点的特点一般是孤立无援的，这时候我们只需要判断以这个 1 点为中心的点，周围的 1 点个数小于一个阈值（我把它设为 3），就确认它为噪点并将之去除</p><pre><code class="hljs php"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 去除噪点</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> $hash_data</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> mixed</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeHotSpots</span>(<span class="hljs-params"><span class="hljs-variable">$hash_data</span></span>)</span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-keyword">$this</span>-&gt;_image_h; <span class="hljs-variable">$i</span>++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-variable">$j</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$j</span> &lt; <span class="hljs-keyword">$this</span>-&gt;_image_w; <span class="hljs-variable">$j</span>++) &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-variable">$hash_data</span>[<span class="hljs-variable">$i</span>][<span class="hljs-variable">$j</span>])&#123;                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">$this</span>-&gt;isHotSpots(<span class="hljs-variable">$i</span>,<span class="hljs-variable">$j</span>,<span class="hljs-variable">$hash_data</span>)) <span class="hljs-variable">$hash_data</span>[<span class="hljs-variable">$i</span>][<span class="hljs-variable">$j</span>]=<span class="hljs-number">0</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable">$hash_data</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 判断是否是噪点</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> $i</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> $j</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> $hash_data</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> bool ture:是噪点,false:不是</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isHotSpots</span>(<span class="hljs-params"><span class="hljs-variable">$i</span>,<span class="hljs-variable">$j</span>,<span class="hljs-variable">$hash_data</span></span>)</span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$i</span> == <span class="hljs-number">0</span> || <span class="hljs-variable">$j</span> == <span class="hljs-number">0</span> || <span class="hljs-variable">$i</span> == (<span class="hljs-keyword">$this</span>-&gt;_image_h - <span class="hljs-number">1</span>) || <span class="hljs-variable">$j</span> == (<span class="hljs-keyword">$this</span>-&gt;_image_w - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">//待检查点为中心的九个点</span>    <span class="hljs-variable">$points</span>[<span class="hljs-number">0</span>]=<span class="hljs-variable">$hash_data</span>[<span class="hljs-variable">$i</span><span class="hljs-number">-1</span>][<span class="hljs-variable">$j</span><span class="hljs-number">-1</span>];    <span class="hljs-variable">$points</span>[<span class="hljs-number">1</span>]=<span class="hljs-variable">$hash_data</span>[<span class="hljs-variable">$i</span><span class="hljs-number">-1</span>][<span class="hljs-variable">$j</span>];    <span class="hljs-variable">$points</span>[<span class="hljs-number">2</span>]=<span class="hljs-variable">$hash_data</span>[<span class="hljs-variable">$i</span><span class="hljs-number">-1</span>][<span class="hljs-variable">$j</span>+<span class="hljs-number">1</span>];    <span class="hljs-variable">$points</span>[<span class="hljs-number">3</span>]=<span class="hljs-variable">$hash_data</span>[<span class="hljs-variable">$i</span>][<span class="hljs-variable">$j</span><span class="hljs-number">-1</span>];    <span class="hljs-variable">$points</span>[<span class="hljs-number">4</span>]=<span class="hljs-variable">$hash_data</span>[<span class="hljs-variable">$i</span>][<span class="hljs-variable">$j</span>];<span class="hljs-comment">//待检查点</span>    <span class="hljs-variable">$points</span>[<span class="hljs-number">5</span>]=<span class="hljs-variable">$hash_data</span>[<span class="hljs-variable">$i</span>][<span class="hljs-variable">$j</span>+<span class="hljs-number">1</span>];    <span class="hljs-variable">$points</span>[<span class="hljs-number">6</span>]=<span class="hljs-variable">$hash_data</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>][<span class="hljs-variable">$j</span><span class="hljs-number">-1</span>];    <span class="hljs-variable">$points</span>[<span class="hljs-number">7</span>]=<span class="hljs-variable">$hash_data</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>][<span class="hljs-variable">$j</span>];    <span class="hljs-variable">$points</span>[<span class="hljs-number">8</span>]=<span class="hljs-variable">$hash_data</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>][<span class="hljs-variable">$j</span>+<span class="hljs-number">1</span>];    <span class="hljs-variable">$count</span>=<span class="hljs-number">0</span>;    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$points</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$v</span>)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$v</span>)&#123;            <span class="hljs-variable">$count</span>++;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable">$count</span>&lt;<span class="hljs-number">4</span>;&#125;</code></pre><blockquote><p>去除噪点之后</p></blockquote><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/1678387744.png" alt="QQ截图20160503214315.png"></p><h2 id="去除干扰线"><a href="#去除干扰线" class="headerlink" title="去除干扰线"></a>去除干扰线</h2><p>通过去除噪点之后的图像，我们可以发现，大部分的干扰线，其实已经被去除掉了，所以我们可以将，去除噪点的方法当做一个滤镜，多过滤几次，干扰线基本上可以去除完毕（这里测试去除三次的效果是最好的）</p><h2 id="分割验证码"><a href="#分割验证码" class="headerlink" title="分割验证码"></a>分割验证码</h2><p>这个验证码的每个数字其实都是等分的，所以我们可以采用等分的方法去分割它</p><pre><code class="hljs php"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> $n</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> array</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">splitImage</span>(<span class="hljs-params"><span class="hljs-variable">$n</span></span>)</span>&#123;    <span class="hljs-variable">$data</span>=[];    <span class="hljs-variable">$a</span>=<span class="hljs-keyword">$this</span>-&gt;_image_w/<span class="hljs-built_in">self</span>::CHAR_NUM;    <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-variable">$n</span>*<span class="hljs-variable">$a</span>;<span class="hljs-variable">$i</span>&lt;(<span class="hljs-variable">$n</span>+<span class="hljs-number">1</span>)*<span class="hljs-variable">$a</span>;<span class="hljs-variable">$i</span>++)&#123;        <span class="hljs-variable">$column</span>=array_column(<span class="hljs-keyword">$this</span>-&gt;_hash_data,<span class="hljs-variable">$i</span>);        <span class="hljs-keyword">if</span>(implode(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-variable">$column</span>)!=<span class="hljs-number">0</span>)&#123;            <span class="hljs-variable">$data</span>[]=<span class="hljs-variable">$column</span>;        &#125;    &#125;    <span class="hljs-variable">$out_img_w</span>=count(<span class="hljs-variable">$data</span>)+<span class="hljs-number">4</span>;    <span class="hljs-variable">$out_img_h</span>=count(<span class="hljs-variable">$data</span>[<span class="hljs-number">0</span>])+<span class="hljs-number">4</span>;    <span class="hljs-variable">$out_img</span> = imagecreatetruecolor(<span class="hljs-variable">$out_img_w</span>,<span class="hljs-variable">$out_img_h</span>);<span class="hljs-comment">//创建一幅真彩色图像</span>    <span class="hljs-variable">$bg</span>=imagecolorallocate(<span class="hljs-variable">$out_img</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);<span class="hljs-comment">//背景色画为白色</span>    imagefill(<span class="hljs-variable">$out_img</span>, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>, <span class="hljs-variable">$bg</span>);    <span class="hljs-comment">//一列一列的进行画图</span>    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$data</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$k</span>=&gt;<span class="hljs-variable">$v</span>)&#123;        <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$v</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$key</span>=&gt; <span class="hljs-variable">$val</span>)&#123;            <span class="hljs-variable">$color</span>=<span class="hljs-number">255</span>;            <span class="hljs-keyword">if</span>(<span class="hljs-variable">$val</span>) <span class="hljs-variable">$color</span>=<span class="hljs-number">0</span>;            <span class="hljs-variable">$c</span> = imagecolorallocate(<span class="hljs-variable">$out_img</span>, <span class="hljs-variable">$color</span>, <span class="hljs-variable">$color</span>, <span class="hljs-variable">$color</span>);            imagesetpixel(<span class="hljs-variable">$out_img</span>, <span class="hljs-variable">$k</span>+<span class="hljs-number">2</span>,<span class="hljs-variable">$key</span>+<span class="hljs-number">2</span>, <span class="hljs-variable">$c</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable">$out_img</span>;&#125;</code></pre><h2 id="保存-amp-对比识别"><a href="#保存-amp-对比识别" class="headerlink" title="保存&amp;对比识别"></a>保存&amp;对比识别</h2><blockquote><p>最后将分割好的图片二值化，通过一个数组保存下来，作为一个标准，然后后之后需要验证的验证码，通过和之前的数组求交集，比较最相近的数字得出结果即可</p></blockquote><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><strong>其实到这一步之后已经能够识别一些验证码了，对于第二种验证码已经可以达到很好的识别效果，但是对于第一种验证码的识别率很低很低，大概只有<code>5%-15%</code>，基本不能投入使用，下一篇文章针对这种验证码，怎么更好的识别，主要是<code>标准化</code>和<code>特征库的建立</code></strong></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>图片</tag>
      
      <tag>识别</tag>
      
      <tag>验证码识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php-webhook利用php脚本自动化部署git项目</title>
    <link href="/post/61468.html"/>
    <url>/post/61468.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>遇到权限的问题弄了好久，整理一下步骤简单的写一下<br>在阅读这篇文章的时候默认你的服务器上安装了 web 服务器和 git</p></blockquote><h2 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h2><blockquote><p>写一个简单的脚本查看你的服务器运行的账户，和是否能够运行相关函数</p></blockquote><pre><code class="hljs php"><span class="hljs-variable">$test</span>=shell_exec(<span class="hljs-string">&quot;whoami&quot;</span>);var_dump(<span class="hljs-variable">$test</span>);<span class="hljs-comment">//我的返回的是 www-data</span></code></pre><p><strong>如果这里返回 null 的话，不妨检查一下 shell_exec 函数是否被禁用了</strong></p><h2 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h2><blockquote><p>建立 ssh 公钥，以我的 www-data 账户为例子</p></blockquote><p>1.先建立一个.ssh 目录并给予 www-data 用户权限</p><pre><code class="hljs awk">sudo mkdir <span class="hljs-regexp">/var/</span>www/.sshsudo chown -R www-data:www-data <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/.ssh/</span></code></pre><p>2.生成 webhook 部署公钥</p><pre><code class="hljs armasm"><span class="hljs-symbol">sudo</span> -Hu www-<span class="hljs-meta">data</span> ssh-keygen -t rsa <span class="hljs-comment">//一直回车即可</span></code></pre><p><em>如果你和我一样，遇到了<code>-su: sudo: command not found</code>，可以先安装<code>sudo</code>命令,<code>apt-get install sudo</code>，如果你和我还一样遇到了一些问题，不妨先试试<code>apt-get update</code></em></p><p>3.将 webhook 部署公钥上传到托管网站</p><blockquote><p>测试用的 Coding，其他还在测试当中</p></blockquote><p>先查看公钥</p><pre><code class="hljs awk">sudo cat <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub</code></pre><p>然后复制上面的内容到托管网站，项目的 webhook 上面</p><h2 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h2><blockquote><p>webhook 文件</p></blockquote><script src='http://git.oschina.net/lxl520/php-webhook/widget_preview'></script><h2 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h2><blockquote><p>先在服务器上<code>git clone</code></p></blockquote><pre><code class="hljs haskell"><span class="hljs-title">sudo</span> chown -<span class="hljs-type">R</span> www-<span class="hljs-class"><span class="hljs-keyword">data</span>:www-<span class="hljs-keyword">data</span> &#123;代码地址&#125;</span><span class="hljs-title">sudo</span> -<span class="hljs-type">Hu</span> www-<span class="hljs-class"><span class="hljs-keyword">data</span> git clone &#123;你的项目<span class="hljs-title">ssh</span>地址&#125; &#123;代码地址&#125;  <span class="hljs-comment">--depth=1</span></span></code></pre><p><strong>注意，这里初始化 clone 必须要用 www-data 用户</strong></p><h2 id="step5"><a href="#step5" class="headerlink" title="step5"></a>step5</h2><blockquote><p>在托管网站上添加 webhook 地址，然后提交一次测试</p></blockquote><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><blockquote><p>参考了以下代码<br><a href="https://gist.github.com/overtrue/0bf1cd704bf804de2e2c">https://gist.github.com/overtrue/0bf1cd704bf804de2e2c</a></p></blockquote><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>git</tag>
      
      <tag>webhook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx无法启动</title>
    <link href="/post/33991.html"/>
    <url>/post/33991.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天装了一个服务器但是 nginx 一直无法启动，google 了各种答案，还是没有效果</p></blockquote><h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><pre><code class="hljs gradle">nginx启动，重启，关闭命令停止操作停止操作是通过向nginx进程发送信号（什么是信号请参阅linux文 章）来进行的步骤<span class="hljs-number">1</span>：查询nginx主进程号ps -ef | <span class="hljs-keyword">grep</span> nginx在进程列表里 面找master进程，它的编号就是主进程号了。步骤<span class="hljs-number">2</span>：发送信号从容停止Nginx：kill -QUIT 主进程号快速停止Nginx：kill -TERM 主进程号强制停止Nginx：pkill -<span class="hljs-number">9</span> nginx另外， 若在nginx.conf配置了pid文件存放路径则该文件存放的就是Nginx主进程号，如果没指定则放在nginx的logs目录下。有了pid文 件，我们就不用先查询Nginx的主进程号，而直接向Nginx发送信号了，命令如下：kill -信号类型 <span class="hljs-string">&#x27;/usr/nginx/logs/nginx.pid&#x27;</span>平滑重启如果更改了配置就要重启Nginx，要先关闭Nginx再打开？不是的，可以向Nginx 发送信号，平滑重启。平滑重启命令：kill -HUP 住进称号或进程号文件路径或者使用<span class="hljs-regexp">/usr/</span>nginx<span class="hljs-regexp">/sbin/</span>nginx -s reload注意，修改了配置文件后最好先检查一下修改过的配置文件是否正 确，以免重启后Nginx出现错误影响服务器稳定运行。判断Nginx配置是否正确命令如下：nginx -t -c <span class="hljs-regexp">/usr/</span>nginx<span class="hljs-regexp">/conf/</span>nginx.conf或者<span class="hljs-regexp">/usr/</span>nginx<span class="hljs-regexp">/sbin/</span>nginx -t平滑升级如果服务器正在运行的Nginx要进行升级、添加或删除模块时，我们需 要停掉服务器并做相应修改，这样服务器就要在一段时间内停止服务，Nginx可以在不停机的情况下进行各种升级动作而不影响服务器运行。步骤<span class="hljs-number">1</span>：如 果升级Nginx程序，先用新程序替换旧程序文件，编译安装的话新程序直接编译到Nginx安装目录中。步 骤<span class="hljs-number">2</span>：执行命令kill -USR2 旧版程序的主进程号或进程文件名此时旧的Nginx主进程将会把自己的进程文件改名为.oldbin，然后执行新版 Nginx。新旧Nginx会同市运行，共同处理请求。这时要逐步停止旧版 Nginx，输入命令：kill -WINCH 旧版主进程号慢慢旧的工作进程就都会随着任务执行完毕而退出，新版的Nginx的工作进程会逐渐取代旧版 工作进程。此 时，我们可以决定使用新版还是恢复到旧版。不重载配置启动新/旧工作进程kill -HUP 旧/新版主进程号从容关闭旧/新进程kill -QUIT 旧/新主进程号如果此时报错，提示还有进程没有结束就用下面命令先关闭旧/新工作进程，再关闭主进程号：kill -TERM 旧/新工作进程号这样下来，如果要恢复到旧版本，只需要上面的几个步 骤都是操作新版主进程号，如果要用新版本就上面的几个步骤都操作旧版主进程号就行了。上面就是Nginx的一些基本的操作，希望以后Nginx能有更好的方法来处理这些操作， 最好是Nginx的命令而不是向Nginx进程发送系统信号。</code></pre><h3 id="后面发现"><a href="#后面发现" class="headerlink" title="后面发现"></a>后面发现</h3><p>突然想起来会不会是配置文件有错误导致的无法启动，so</p><pre><code class="hljs awk">nginx -t -c <span class="hljs-regexp">/etc/</span>nginx/nginx.conf</code></pre><p><strong>结果发现</strong>是配置项里面的日志文件目录不存在</p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>以后遇到这种问题一定要先看看日志或者先测试一下语句</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59269.html">nginx-php报502错误</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx-php报502错误</title>
    <link href="/post/59269.html"/>
    <url>/post/59269.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>正是悲催犯了一个超低级的错误</p></blockquote><p>在腾讯云新买了一个服务器，直接用了以前 nginx 的配置文件，但是装上之后先是 404 然后 502，一直不知道为什么</p><pre><code class="hljs apache"><span class="hljs-attribute">404</span>是因为本来要报<span class="hljs-number">502</span>的错误，但是<span class="hljs-number">502</span>的页面没有放进去....</code></pre><h4 id="502-的错误在网上搜索了很多答案都没有解决，然后后面发现我自己竟然没有看错误日志，翻日志的时候发现是："><a href="#502-的错误在网上搜索了很多答案都没有解决，然后后面发现我自己竟然没有看错误日志，翻日志的时候发现是：" class="headerlink" title="502 的错误在网上搜索了很多答案都没有解决，然后后面发现我自己竟然没有看错误日志，翻日志的时候发现是："></a>502 的错误在网上搜索了很多答案都没有解决，然后后面发现我自己竟然没有看错误日志，翻日志的时候发现是：</h4><pre><code class="hljs gradle"><span class="hljs-number">2016</span><span class="hljs-regexp">/04/</span><span class="hljs-number">25</span> <span class="hljs-number">04</span>:<span class="hljs-number">32</span>:<span class="hljs-number">42</span> [crit] <span class="hljs-number">251</span>#<span class="hljs-number">251</span>: *<span class="hljs-number">166</span> connect() to unix:<span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/php5-fpm.sock failed (2: No such file or directory) while connecting to upstream, client: 220.167.47.185, server: 127.0.0.1, request: &quot;GET /</span> HTTP<span class="hljs-regexp">/1.1&quot;, upstream: &quot;fastcgi:/</span><span class="hljs-regexp">/unix:/</span>var<span class="hljs-regexp">/run/</span>php5-fpm.sock:<span class="hljs-string">&quot;, host: &quot;</span><span class="hljs-number">115.159</span>.<span class="hljs-number">94.101</span><span class="hljs-string">&quot;</span></code></pre><h4 id="突然间恍然大悟，我新买的服务器装的是-php7，以前用的-php5，sock-文件的地址不一样-改成下面这个重启，就没有问题了"><a href="#突然间恍然大悟，我新买的服务器装的是-php7，以前用的-php5，sock-文件的地址不一样-改成下面这个重启，就没有问题了" class="headerlink" title="突然间恍然大悟，我新买的服务器装的是 php7，以前用的 php5，sock 文件的地址不一样,改成下面这个重启，就没有问题了"></a>突然间恍然大悟，我新买的服务器装的是 php7，以前用的 php5，sock 文件的地址不一样,改成下面这个重启，就没有问题了</h4><pre><code class="hljs awk">fastcgi_pass unix:<span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/php/</span>php7.<span class="hljs-number">0</span>-fpm.sock;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>nginx</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言验证浮点数的二进制表示</title>
    <link href="/post/48100.html"/>
    <url>/post/48100.html</url>
    
    <content type="html"><![CDATA[<h3 id="验证浮点数"><a href="#验证浮点数" class="headerlink" title="验证浮点数"></a>验证浮点数</h3><blockquote><p>虽然以前也学过浮点数的表示原理，大致的原理还是清楚的，但是使用 C 语言的来进性验证还没有尝试过，下面是验证的过程</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>知道浮点数，是按照 32 位在内存中保存，其中第一位表示符号，后 8 位表示指数，最后 23 位表示小数</li><li>C 语言当中存在指针，可以直接通过指针来获取，变量的地址。</li><li>所以就先定义一个变量来储存浮点数，在定义一个指针来获取，浮点数的储存地址，在把 16 进制或者 10 进制的地址转化为 2 进制即可<a id="more"></a></li></ol><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">float</span> a=<span class="hljs-number">209.125</span>;<span class="hljs-keyword">int</span> *p=(<span class="hljs-keyword">int</span> *)&amp;a;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入一串数:&quot;</span>);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%f&quot;</span>,&amp;a);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *p);<span class="hljs-comment">//输出数值在内存中10进制表示</span>decimal2Binary(*p);<span class="hljs-comment">//将十进制转化为二进制</span>decimal2Binary_2(*p);&#125;getchar();<span class="hljs-comment">//防止程序退出</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ol start="4"><li>在十进制转化为二进制的过程中，我使用了两种办法，首先想到的就是通过循环求余的办法来转化</li></ol><pre><code class="hljs C"><span class="hljs-comment">/**</span><span class="hljs-comment"> * [decimal2Binary 十进制转换成二进制，使用循环求余法]</span><span class="hljs-comment"> * @author mohuishou&lt;1@lailin.xyz&gt;</span><span class="hljs-comment"> * @param  x [要转换的十进制数]</span><span class="hljs-comment"> * @return   [0]</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decimal2Binary</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">int</span> a[<span class="hljs-number">32</span>];<span class="hljs-keyword">int</span> rem;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">31</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123; rem=x%<span class="hljs-number">2</span>; x=x/<span class="hljs-number">2</span>; a[j]=rem;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">31</span>;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ol start="5"><li>第二种是后面查资料的时候看到的一种办法，我转换了一下，用于这个小程序。主要是充分应用了 C 语言当中的位运算</li></ol><pre><code class="hljs C"><span class="hljs-comment">/**</span><span class="hljs-comment"> * [decimal2Binary_2 十进制转换成二进制，使用按位对比法]</span><span class="hljs-comment"> * @author mohuishou&lt;1@lailin.xyz&gt;</span><span class="hljs-comment"> * @param  x [要进行转化的10进制数]</span><span class="hljs-comment"> * @return   [0]</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decimal2Binary_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &gt;=<span class="hljs-number">0</span>;i--)&#123;<span class="hljs-keyword">if</span>(x&amp;(<span class="hljs-number">1</span>&lt;&lt;i))&#123;<span class="hljs-comment">//将1左移i位并和x进行按位对比</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-number">1</span> );&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-number">0</span> );&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="0-在浮点数中怎么表示"><a href="#0-在浮点数中怎么表示" class="headerlink" title="0 在浮点数中怎么表示"></a>0 在浮点数中怎么表示</h3><blockquote><p>我先通过上面写好的程序，输入 0 之后，得到的值为 32 个 0，然后进行一个简单的分析认为：</p></blockquote><h4 id="浮点数的表示方法"><a href="#浮点数的表示方法" class="headerlink" title="浮点数的表示方法"></a>浮点数的表示方法</h4><ol><li>浮点数的表示方法是：先转化为 1.xxx（小数部分） * 2^m（指数部分）</li><li>首先判断符号，正的话第一位为 0，负数的话为第一位 1</li><li>指数部分 m+127=&gt;转化为 2 进制</li><li>小数部分 xxx=&gt;转化为 2 进制，</li></ol><h4 id="对于-0-的推断"><a href="#对于-0-的推断" class="headerlink" title="对于 0 的推断"></a>对于 0 的推断</h4><p>由于 0 的话，他第一步就不能转化为 1.xxx（小数部分） * 2^m（指数部分)的形式，所以比较好的一个办法就是以 32 个 0 表示</p><h4 id="推断的验证"><a href="#推断的验证" class="headerlink" title="推断的验证"></a>推断的验证</h4><blockquote><p>对于 C 语言来说我在之前就已经验证了，然后我查询了维基百科 IEEE 二进制浮点数算术标准（IEEE 754）<a href="https://zh.wikipedia.org/wiki/IEEE_754">点击打开</a>，对比得出，0 的二进制浮点数表示的确是 32 个 0</p></blockquote><h3 id="程序运行结果截图"><a href="#程序运行结果截图" class="headerlink" title="程序运行结果截图"></a>程序运行结果截图</h3><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2541890988.png" alt="1.png"></p><h3 id="程序源代码截图"><a href="#程序源代码截图" class="headerlink" title="程序源代码截图"></a>程序源代码截图</h3><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2014147934.png" alt="2.png"><br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2014147934.png" alt="3.png"></p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js编码解码URL</title>
    <link href="/post/62847.html"/>
    <url>/post/62847.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>在 js 的 URL 编码解码当中有这两个函数，分别是</p></blockquote><h3 id="编码解码函数"><a href="#编码解码函数" class="headerlink" title="编码解码函数"></a>编码解码函数</h3><p>1.</p><p>编码<code>encodeURI(str)</code><br>解码<code>decodeURI(str)</code></p><p>2.</p><p>编码<code>encodeURIComponent</code><br>解码<code>decodeURIComponent</code></p> <a id="more"></a><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>encodeURI 对于字母和属于 URL 的字符不进行编码<br>但是 encodeURIComponent 会对属于 URL 的字符也进行编码<br><strong>例如这些字符</strong><code>-_.!~*&#39;()</code></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> <span class="hljs-built_in">str</span>=<span class="hljs-string">&quot;http://lxl520.com/程序&quot;</span>;console.log(<span class="hljs-string">&quot;我是初始字符串&quot;</span>+<span class="hljs-built_in">str</span>);</code></pre><p><em>我是初始字符串<a href="http://lxl520.com/程序">http://lxl520.com/程序</a></em></p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str2=<span class="hljs-built_in">encodeURI</span>(str);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是经过encodeURI编码的：&quot;</span>+str2);</code></pre><p><em>我是经过 encodeURI 编码的：<a href="http://lxl520.com/%E7%A8%8B%E5%BA%8F">http://lxl520.com/%E7%A8%8B%E5%BA%8F</a></em></p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str3=<span class="hljs-built_in">encodeURIComponent</span>(str);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是经过encodeURIComponent编码的：&quot;</span>+str3);</code></pre><p><em>我是经过 encodeURIComponent 编码的：http%3A%2F%2Flxl520.com%2F%E7%A8%8B%E5%BA%8F</em></p><pre><code class="hljs apache"><span class="hljs-attribute">var</span> str<span class="hljs-number">2</span>Decode=decodeURI(str<span class="hljs-number">2</span>);<span class="hljs-attribute">var</span> str<span class="hljs-number">3</span>Decode=decodeURIComponent(str<span class="hljs-number">3</span>);<span class="hljs-attribute">console</span>.log(<span class="hljs-string">&quot;我们是经过解码的字符串：&quot;</span>+str<span class="hljs-number">2</span>Decode+<span class="hljs-string">&quot;\n&quot;</span>+str<span class="hljs-number">3</span>Decode);</code></pre><p><em>我们是经过解码的字符串：<a href="http://lxl520.com/程序">http://lxl520.com/程序</a><br><a href="http://lxl520.com/程序">http://lxl520.com/程序</a></em></p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>URL编码<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;get&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入您要编码的字符串&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;urlEncode();&quot;</span>&gt;</span>点击进行编码<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;urlDecode();&quot;</span>&gt;</span>点击进行解码<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;output&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;输出框&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span>      /**       * @author mohuishou       * [test URL编码测试]<span class="javascript">       * @<span class="hljs-keyword">return</span> &#123;[type]&#125; [description]</span>       */<span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        <span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;http://lxl520.com/程序&quot;</span>;</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是初始字符串&quot;</span> + str);</span><span class="javascript">        <span class="hljs-keyword">var</span> str2 = <span class="hljs-built_in">encodeURI</span>(str);</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是经过encodeURI编码的：&quot;</span> + str2);</span><span class="javascript">        <span class="hljs-keyword">var</span> str3 = <span class="hljs-built_in">encodeURIComponent</span>(str);</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是经过encodeURIComponent编码的：&quot;</span> + str3);</span><span class="javascript">        <span class="hljs-keyword">var</span> str2Decode = <span class="hljs-built_in">decodeURI</span>(str2);</span><span class="javascript">        <span class="hljs-keyword">var</span> str3Decode = <span class="hljs-built_in">decodeURIComponent</span>(str3);</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(</span><span class="javascript">          <span class="hljs-string">&quot;我们是经过解码的字符串：&quot;</span> + str2Decode + <span class="hljs-string">&quot;\n&quot;</span> + str3Decode</span>        );      &#125;      /**       * @author mohuishou       * 更改输入的值，并将其输出       */<span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">urlEncode</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        <span class="hljs-keyword">var</span> getVal = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;get&quot;</span>).value; <span class="hljs-comment">//获取输入框的值</span></span><span class="javascript">        <span class="hljs-keyword">var</span> strEncode = <span class="hljs-built_in">encodeURI</span>(getVal);</span><span class="javascript">        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;output&quot;</span>).value = strEncode; <span class="hljs-comment">//将编码过后的值输出到输出框</span></span>      &#125;      /**       * [urlDecode 解码函数，对进行解码]<span class="javascript">       * @<span class="hljs-keyword">return</span> &#123;[type]&#125; [description]</span>       */<span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">urlDecode</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        <span class="hljs-keyword">var</span> getVal = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;get&quot;</span>).value; <span class="hljs-comment">//获取输入框的值</span></span><span class="javascript">        <span class="hljs-keyword">var</span> strDecode = <span class="hljs-built_in">decodeURI</span>(getVal);</span><span class="javascript">        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;output&quot;</span>).value = strDecode;</span>      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59875.html">【福利】至善网媒体素材一键评价</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css中权重与优先级</title>
    <link href="/post/39494.html"/>
    <url>/post/39494.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天在写一个前端文件的时候发现有一个样式突然没有了作用，但是按照优先级来说应该后面的前面的才对。<br>然后研究了一下 css 当中的优先级到底是怎么回事，才发现原来都是权重的锅</p></blockquote><a id="more"></a><h3 id="选择器的权重"><a href="#选择器的权重" class="headerlink" title="选择器的权重"></a>选择器的权重</h3><blockquote><p>分为四个等级,权重值越大表示优先级别越高</p></blockquote><h4 id="权重表"><a href="#权重表" class="headerlink" title="权重表"></a>权重表</h4><table><thead><tr><th>选择器</th><th>例子</th><th>权重值</th></tr></thead><tbody><tr><td>内联样式</td><td><code>style=&#39;&#39;</code></td><td>1000</td></tr><tr><td>id 选择器</td><td><code>#title</code></td><td>100</td></tr><tr><td>类，伪类，属性选择器</td><td><code>.title，:hover ,a[href]</code></td><td>10</td></tr><tr><td>类型选择器，伪元素选择器</td><td><code>p, :before</code></td><td>1</td></tr><tr><td>通用选择器，子选择器和相邻同胞选择器</td><td><code>*,&gt;,+</code></td><td>0</td></tr></tbody></table><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p><strong>sytle</strong></p><pre><code class="hljs css"><span class="hljs-comment">/*权重=100+1=101*/</span><span class="hljs-selector-id">#title</span> <span class="hljs-selector-tag">h2</span> &#123;  <span class="hljs-attribute">color</span>: red;&#125;<span class="hljs-comment">/*权重=10+1=11*/</span><span class="hljs-selector-class">.content</span> <span class="hljs-selector-tag">h2</span> &#123;  <span class="hljs-attribute">color</span>: blue;&#125;<span class="hljs-comment">/*权重=100+1=101*/</span><span class="hljs-selector-id">#title</span> <span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">color</span>: orange;&#125;<span class="hljs-comment">/*权重=100+10=110*/</span><span class="hljs-selector-id">#title</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href]</span> &#123;  <span class="hljs-attribute">color</span>: green;&#125;</code></pre><p><strong>html</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:#333;&quot;</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-comment">&lt;!--权重=1000--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://lxl520.com&quot;</span>&gt;</span>lxl520<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>0...0<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141636.png" alt=""></p><h3 id="层叠原理（或者说是就近原则）"><a href="#层叠原理（或者说是就近原则）" class="headerlink" title="层叠原理（或者说是就近原则）"></a>层叠原理（<em>或者说是就近原则</em>）</h3><p><strong>当两个样式的优先级一样时,会自动选择最近的一条样式</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">  <span class="hljs-selector-id">#title</span> &#123;</span>    color: red;  &#125;<span class="css">  <span class="hljs-selector-id">#title</span> &#123;</span>    color: blue;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>我到底啥颜色<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141637.png" alt=""></p><h3 id="例外（-important）"><a href="#例外（-important）" class="headerlink" title="例外（!important）"></a>例外（!important）</h3><p><strong>在属性的后面加上!important 可以用来提权，就好比直接获得管理员权限一样，这这个属性会变成最高优先级</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>  h2 &#123;    color: red !important;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue;&quot;</span>&gt;</span>我想必应该是蓝色<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141638.png" alt=""></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li><p><strong>一些不成文规则</strong></p><ul><li><strong>不要</strong>在全站范围的 css 中使用<code>!important</code>.</li><li><strong>只在</strong>需要覆盖全站范围的 css 或是外部 css（例如引用的 ExtJs 或是 YUI）的时候才在指定的页面上使用<code>!important</code>。</li><li><strong>不要</strong>在你的插件中使用<code>!important</code>。</li><li><strong>永远</strong>都要优先考虑使用样式规则的优先级来解决问题而不是<code>!important</code>。</li></ul></li><li><p>如果你和我一样遇到了似乎没有起作用的 CSS 规则，请试试在你的选择器中添加他的一个父元素的 ID，从而提高它的特殊性。看看能不能解决问题</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EmotionCamera</title>
    <link href="/post/16707.html"/>
    <url>/post/16707.html</url>
    
    <content type="html"><![CDATA[<h4 id="wiz_toc_0">简单实现逻辑</h4><ol><br><li>首先识别脸部</li><br><li>标识出关键点</li><br><li>通过一定的算法捕抓表情</li><br></ol><h4 id="wiz_toc_1">表情相机模块需要实现的任务</h4><ol><br><li>什么时候拍照？ <br><br><em>需要确定一个阈值</em></li><br><li>导出一个静态库 <br><br><em>ios和andriod</em><br><br><blockquote><br>  <p>补充，ios需要涉及到mac系统还有OC；andriod需要涉及到Linux，安卓方面导出的静态库是.a格式；动态库为.so格式</p><br></blockquote></li><br></ol><h4 id="wiz_toc_2">最近两周需要完成的任务</h4><blockquote><br>  <p>现在的时间：2015年11月1日 23:34:33 <br><br>  两周后需要达到的效果：使用安卓调用C++生成的.a文件</p><br></blockquote><h5 id="wiz_toc_3">需要搜索的一些东西：</h5><p><ol></p><li>C++静态库导出（ios/andriod）</li><br><li>静态vs动态库</li><br><li>object―C （ios）</li><br><li>makefile&amp;modify Macro</li><br><li>能不能直接在一个环境下同时导出ios和安卓需要的库</li>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>phpstrom10激活方法（JetBrains系列软件激活）</title>
    <link href="/post/28397.html"/>
    <url>/post/28397.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>找到一个 JetBrains 系列软件的注册服务器</p></blockquote><p><strong>注册时选择“License server”输入“<a href="http://idea.lanyus.com/”点击“OK”快速激活JetBrains系列产品">http://idea.lanyus.com/”点击“OK”快速激活JetBrains系列产品</a></strong></p><p>也可以<br><a href="http://idea.lanyus.com/">点击进入计算注册码</a></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/18280.html">四川大学锐捷windows解除多网卡限制</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NDK开发中无法访问android.support.v7.app.AppCompatActivity解决办法</title>
    <link href="/post/64902.html"/>
    <url>/post/64902.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>错误详情：<br>错误: 无法访问 android.support.v7.app.AppCompatActivity<br>找不到 android.support.v7.app.AppCompatActivity 的类文件</p></blockquote><p>为了这个问题纠结 2 天了，在网上找了很多的解决办法都不行，几乎所有的办法都试过了</p><p>无意中查看 sdk Manager 的时候发现我的<strong>“android support library”</strong>没有安装，然后当即安装上去</p><p>随后执行：</p><pre><code class="hljs taggerscript">javah -d jni -classpath   F:<span class="hljs-symbol">\S</span>oftInstall<span class="hljs-symbol">\A</span>ndroid<span class="hljs-symbol">\s</span>dk<span class="hljs-symbol">\p</span>latforms<span class="hljs-symbol">\a</span>ndroid-23<span class="hljs-symbol">\a</span>ndroid.jar;F:<span class="hljs-symbol">\S</span>oftInstall<span class="hljs-symbol">\a</span>ndroid<span class="hljs-symbol">\s</span>dk<span class="hljs-symbol">\e</span>xtras<span class="hljs-symbol">\a</span>ndroid<span class="hljs-symbol">\s</span>upport<span class="hljs-symbol">\v</span>4<span class="hljs-symbol">\a</span>ndroid-support-v4.jar;F:<span class="hljs-symbol">\S</span>oftInstall<span class="hljs-symbol">\a</span>ndroid<span class="hljs-symbol">\s</span>dk<span class="hljs-symbol">\e</span>xtras<span class="hljs-symbol">\a</span>ndroid<span class="hljs-symbol">\s</span>upport<span class="hljs-symbol">\v</span>7<span class="hljs-symbol">\a</span>ppcompat<span class="hljs-symbol">\l</span>ibs<span class="hljs-symbol">\a</span>ndroid-support-v7-appcompat.jar;..<span class="hljs-symbol">\.</span>.<span class="hljs-symbol">\b</span>uild<span class="hljs-symbol">\i</span>ntermediates<span class="hljs-symbol">\c</span>lasses<span class="hljs-symbol">\d</span>ebug com.lxl520.demo3.MainActivity</code></pre><p>即可</p><p><strong>注意：</strong><br>如果发现你的 sdk 文件夹下面没有<strong>sdk\extras\android\support**<br>这个文件夹的时候一定要检查一下你的</strong>“android support library”**是否安装，<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141647.png" alt=""></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/34934.html">appcan利用天翼rtc实现视频通话功能</a></li><li><a href="https://lailin.xyz/post/35791.html">使用MITAPPInventor2web客户端组件保存数据至云端</a></li><li><a href="https://lailin.xyz/post/23045.html">如何使用MITAPPInventor2快速创建一个蓝牙串口app</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>app</tag>
      
      <tag>ndk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>phpsocket连接，UDP</title>
    <link href="/post/19867.html"/>
    <url>/post/19867.html</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs php">&lt;meta charset=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;<span class="hljs-meta">&lt;?php</span><span class="hljs-comment">//服务器信息</span><span class="hljs-variable">$server</span> = <span class="hljs-string">&#x27;udp://192.168.253.1:9998&#x27;</span>;<span class="hljs-comment">//消息结束符号</span><span class="hljs-variable">$msg_eof</span> = <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-variable">$socket</span> = stream_socket_server(<span class="hljs-variable">$server</span>, <span class="hljs-variable">$errno</span>, <span class="hljs-variable">$errstr</span>, STREAM_SERVER_BIND);<span class="hljs-keyword">if</span> (!<span class="hljs-variable">$socket</span>) &#123;<span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;<span class="hljs-subst">$errstr</span> (<span class="hljs-subst">$errno</span>)&quot;</span>);&#125;<span class="hljs-keyword">do</span> &#123;<span class="hljs-comment">//接收客户端发来的信息</span><span class="hljs-variable">$inMsg</span> = stream_socket_recvfrom(<span class="hljs-variable">$socket</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">$peer</span>);<span class="hljs-comment">//服务端打印出相关信息</span><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Client : <span class="hljs-subst">$peer</span>\n&quot;</span>;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Receive : <span class="hljs-subst">&#123;$inMsg&#125;</span>&quot;</span>;<span class="hljs-comment">//给客户端发送信息</span><span class="hljs-variable">$outMsg</span> = substr(<span class="hljs-variable">$inMsg</span>, <span class="hljs-number">0</span>, (strrpos(<span class="hljs-variable">$inMsg</span>, <span class="hljs-variable">$msg_eof</span>))).<span class="hljs-string">&#x27; -- &#x27;</span>.date(<span class="hljs-string">&quot;D M j H:i:s Y\r\n&quot;</span>);stream_socket_sendto(<span class="hljs-variable">$socket</span>, <span class="hljs-variable">$outMsg</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">$peer</span>);&#125; <span class="hljs-keyword">while</span> (<span class="hljs-variable">$inMsg</span> !== <span class="hljs-literal">false</span>);<span class="hljs-meta">?&gt;</span></code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>socket</tag>
      
      <tag>udp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>appcan利用天翼rtc实现视频通话功能</title>
    <link href="/post/34934.html"/>
    <url>/post/34934.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本代码是在示例代码的基础上进行了一些简化，并将其单独做了一个 vedio.js 文件，只需要两个按钮，即可完成接听和拨打的需求</p></blockquote><p><strong>attention：</strong></p><ol><li>默认将用户名设置成 1234，拨打的帐号设置成 4321，如果需要使用一个 app 实现的话，具体逻辑自行修改</li></ol><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 视频功能实现</span><span class="hljs-comment"> * 使用天翼rtc插件实现</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 初始化，在页面初始化方法中调用这个函数</span><span class="hljs-comment"> * 定义天翼rtc回调函数</span><span class="hljs-comment"> * 同一个页面中  appcan.ready可以存在多个，不会冲突;而uexOnload不行...</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rtcInit</span>(<span class="hljs-params"></span>) </span>&#123;  uexESurfingRtc.onGlobalStatus = upgateGlobalStatus; <span class="hljs-comment">//全局监控</span>  uexESurfingRtc.cbLogStatus = upgateLogStatus; <span class="hljs-comment">//登陆回调</span>  uexESurfingRtc.cbCallStatus = updateCallStatus; <span class="hljs-comment">//呼叫回调</span>  <span class="hljs-comment">//uexESurfingRtc.cbRemotePicPath = showRemotePicPath;//截屏回调</span>  <span class="hljs-comment">/*----------配置天翼rtc插件的appkey &amp; appid---------*/</span>  appId = <span class="hljs-string">&quot;70392&quot;</span>;  appKey = uexESurfingRtc.setAppKeyAndAppId(appKey, appId); <span class="hljs-comment">//输入你自己的appKey;</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 登陆回调，返回是否登陆成功</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upgateLogStatus</span>(<span class="hljs-params">opCode, dataType, data</span>) </span>&#123;  <span class="hljs-comment">//alert(data);</span>  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;OK&quot;</span> == data.substring(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) &#123;    <span class="hljs-keyword">var</span> status = data.split(<span class="hljs-string">&quot;OK:&quot;</span>)[<span class="hljs-number">1</span>];    <span class="hljs-keyword">var</span> showStr = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;LOGIN&quot;</span> == status) &#123;      showStr = <span class="hljs-string">&quot;登陆成功，点击退出&quot;</span>;      $(<span class="hljs-string">&quot;#login&quot;</span>).attr(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;logout&quot;</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;LOGOUT&quot;</span> == status) &#123;      showStr = <span class="hljs-string">&quot;登陆&quot;</span>;      $(<span class="hljs-string">&quot;#login&quot;</span>).attr(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;login&quot;</span>);    &#125;    $(<span class="hljs-string">&quot;#login&quot;</span>).text(showStr);  &#125; <span class="hljs-keyword">else</span> &#123;    alert(data);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCallStatus</span>(<span class="hljs-params">opCode, dataType, data</span>) </span>&#123;  alert(data);  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;OK&quot;</span> == data.substring(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) &#123;    <span class="hljs-keyword">var</span> status = data.split(<span class="hljs-string">&quot;OK:&quot;</span>)[<span class="hljs-number">1</span>];    <span class="hljs-keyword">var</span> showStr = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;NORMAL&quot;</span> == status) &#123;      showStr = <span class="hljs-string">&quot;call&quot;</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;INCOMING&quot;</span> == status) &#123;      showStr = <span class="hljs-string">&quot;accept&quot;</span>;    &#125;    <span class="hljs-comment">// else if(&quot;CALLING&quot; == status)</span>    <span class="hljs-comment">// &#123;</span>    <span class="hljs-comment">//     showStr = &quot;Calling&quot;;</span>    <span class="hljs-comment">// &#125;</span>    $(<span class="hljs-string">&quot;#call&quot;</span>).attr(<span class="hljs-string">&quot;name&quot;</span>, showStr);    $(<span class="hljs-string">&quot;#call&quot;</span>).text(showStr);  &#125; <span class="hljs-keyword">else</span> &#123;    alert(data);  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> *监控中心回调</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upgateGlobalStatus</span>(<span class="hljs-params">opCode, dataType, data</span>) </span>&#123;  $(<span class="hljs-string">&quot;#content&quot;</span>).append(data);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 登陆方法的实现</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">login</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// alert(123);</span>  <span class="hljs-comment">/*--设置登陆的配置，分别是本地窗口和对方视频窗口的大小----*/</span>  jsonViewConfig = &#123;    localView: &#123;      x: <span class="hljs-string">&quot;10&quot;</span>,      y: <span class="hljs-string">&quot;800&quot;</span>,      w: <span class="hljs-string">&quot;432&quot;</span>,      h: <span class="hljs-string">&quot;528&quot;</span>,    &#125;,    remoteView: &#123;      x: <span class="hljs-string">&quot;440&quot;</span>,      y: <span class="hljs-string">&quot;800&quot;</span>,      w: <span class="hljs-string">&quot;432&quot;</span>,      h: <span class="hljs-string">&quot;528&quot;</span>,    &#125;,  &#125;;  <span class="hljs-comment">/*---这里默认设置一个用户名用于调试，后期用户登录之后直接自动生成---*/</span>  userName = <span class="hljs-string">&quot;1234&quot;</span>;  <span class="hljs-comment">/*--uexESurfingRtc.login函数需要传入的参数是一个json字符串，所以需要调用JSON.stringify方法将json对象转换为字符串--*/</span>  jsonDtr = <span class="hljs-built_in">JSON</span>.stringify(jsonViewConfig);  uexESurfingRtc.login(jsonDtr, userName);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 退出登录</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;[type]&#125;</span> </span>[description]</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logout</span>(<span class="hljs-params"></span>) </span>&#123;  uexESurfingRtc.logout();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">call</span>(<span class="hljs-params"></span>) </span>&#123;  uexESurfingRtc.call(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4321&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accept</span>(<span class="hljs-params"></span>) </span>&#123;  uexESurfingRtc.acceptCall(<span class="hljs-string">&quot;3&quot;</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> *登陆按钮</span><span class="hljs-comment"> *点击之后直接视频登陆</span><span class="hljs-comment"> */</span>appcan.button(<span class="hljs-string">&quot;#login&quot;</span>, <span class="hljs-string">&quot;ani-act&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> btnName = $(<span class="hljs-string">&quot;#login&quot;</span>).attr(<span class="hljs-string">&quot;name&quot;</span>);  <span class="hljs-keyword">if</span> (btnName == <span class="hljs-string">&quot;login&quot;</span>) &#123;    $(<span class="hljs-string">&quot;#login&quot;</span>).text(<span class="hljs-string">&quot;登陆中，请稍候...&quot;</span>);    login();  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((btnName = <span class="hljs-string">&quot;logout&quot;</span>)) &#123;    $(<span class="hljs-string">&quot;#login&quot;</span>).text(<span class="hljs-string">&quot;退出中，请稍候...&quot;</span>);    logout();  &#125;&#125;);<span class="hljs-comment">/**</span><span class="hljs-comment"> * 呼叫按钮</span><span class="hljs-comment"> */</span>appcan.button(<span class="hljs-string">&quot;#call&quot;</span>, <span class="hljs-string">&quot;ani-act&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> btnName = $(<span class="hljs-string">&quot;#call&quot;</span>).attr(<span class="hljs-string">&quot;name&quot;</span>);  <span class="hljs-keyword">if</span> (btnName == <span class="hljs-string">&quot;call&quot;</span>) &#123;    $(<span class="hljs-string">&quot;#call&quot;</span>).text(<span class="hljs-string">&quot;呼叫中，请稍候...&quot;</span>);    call();  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((btnName = <span class="hljs-string">&quot;accept&quot;</span>)) &#123;    $(<span class="hljs-string">&quot;#call&quot;</span>).text(<span class="hljs-string">&quot;接听中，请稍候...&quot;</span>);    accept();  &#125;&#125;);</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/64902.html">NDK开发中无法访问android.support.v7.app.AppCompatActivity解决办法</a></li><li><a href="https://lailin.xyz/post/35791.html">使用MITAPPInventor2web客户端组件保存数据至云端</a></li><li><a href="https://lailin.xyz/post/23045.html">如何使用MITAPPInventor2快速创建一个蓝牙串口app</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>app</tag>
      
      <tag>appcan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java中字符串相等的判断</title>
    <link href="/post/62897.html"/>
    <url>/post/62897.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天需要写一个 Java 的小程序需要判断一下从控制台输入的字符串是否相等，在使用的过程中发现直接使用“==”来判断是没有办法判断出来的，Google&amp;百度了一下，找到一个解决办法</p></blockquote><h4 id="1-用“-”运算符，该运算符表示指向字符串的引用是否相同"><a href="#1-用“-”运算符，该运算符表示指向字符串的引用是否相同" class="headerlink" title="1. 用“==”运算符，该运算符表示指向字符串的引用是否相同"></a>1. 用“==”运算符，该运算符表示指向字符串的引用是否相同</h4><p>比如说：</p><pre><code class="hljs java">String a=<span class="hljs-string">&quot;abc&quot;</span>;String b=<span class="hljs-string">&quot;abc&quot;</span>;a==b;<span class="hljs-comment">//将返回true。</span><span class="hljs-comment">/*这是因为在java中字符串的值是不可改变的，相同的字符串在内存中只会存一份，所以a和b指向的是同一个对象*/</span></code></pre><p>再比如：</p><pre><code class="hljs java">String a=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);String b=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-comment">//那么a==b将返回false，因为a和b指向不同的对象。</span></code></pre><p>用 scanner 类获取字符串来比较的时候：</p><pre><code class="hljs java">Scanner input=<span class="hljs-keyword">new</span> Scanner(System.in);<span class="hljs-comment">//新建input对象，用于实现输入功能</span>String a=<span class="hljs-string">&quot;exit&quot;</span>;<span class="hljs-comment">//定义一个字符串</span>System.out.println(<span class="hljs-string">&quot;请输入您想输入的字符串：&quot;</span>);String get=input.nextLine();<span class="hljs-comment">//获取输入得的字符串的值</span><span class="hljs-keyword">if</span>(get==a)&#123;    System.out.println(a);&#125;<span class="hljs-comment">//这个时候没有输出值</span></code></pre><h4 id="2-用-equals-方法，该方法比较的是字符串的内容是否相同"><a href="#2-用-equals-方法，该方法比较的是字符串的内容是否相同" class="headerlink" title="2. 用 equals 方法，该方法比较的是字符串的内容是否相同"></a>2. 用 equals 方法，该方法比较的是字符串的内容是否相同</h4><p>比如：</p><pre><code class="hljs java">String a=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);String b=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);a.equals(b);<span class="hljs-comment">//将返回true。</span></code></pre><p><strong>所以通常情况下，为了避免出现上述问题，判断字符串是否相等使用 equals 方法。</strong></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/52826.html">java笔记1</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>office2016激活工具</title>
    <link href="/post/37989.html"/>
    <url>/post/37989.html</url>
    
    <content type="html"><![CDATA[<h4 id="可以用于激活-windows-office2010-2013-2016-全系列版本"><a href="#可以用于激活-windows-office2010-2013-2016-全系列版本" class="headerlink" title="可以用于激活 windows office2010/2013/2016 全系列版本"></a>可以用于激活 windows office2010/2013/2016 全系列版本</h4><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720151022110350.png" alt="请输入图片描述"></p><p><strong>以管理员身份运行该软件即可</strong><br>30S 不到，你会发现你的 office 或者 windows 已经激活了，没有安装界面</p><p><a href="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/1198607745.rar">软件下载</a></p><h3 id="ps-本软件收集于网络，这里仅作分享，请下载之后-24-小时之内删除，并且不得用于商业用途"><a href="#ps-本软件收集于网络，这里仅作分享，请下载之后-24-小时之内删除，并且不得用于商业用途" class="headerlink" title="ps:本软件收集于网络，这里仅作分享，请下载之后 24 小时之内删除，并且不得用于商业用途"></a><em>ps:本软件收集于网络，这里仅作分享，请下载之后 24 小时之内删除，并且不得用于商业用途</em></h3><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/18280.html">四川大学锐捷windows解除多网卡限制</a></li><li><a href="https://lailin.xyz/post/28397.html">phpstrom10激活方法（JetBrains系列软件激活）</a></li><li><a href="https://lailin.xyz/post/19314.html">phpstrom9可用注册码一枚</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>破解</tag>
      
      <tag>软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用MITAPPInventor2web客户端组件保存数据至云端</title>
    <link href="/post/35791.html"/>
    <url>/post/35791.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>接着前面的说，蓝牙接收到数据之后需要将数据处理分析然后保存下来，但是 AI2 并没有直接写代码来的方便快捷，并且我们的现在处于云计算的时代，数据无价，所以我们需要想办法将数据保存到云端。</p></blockquote><h4 id="数据保存到云端的方法："><a href="#数据保存到云端的方法：" class="headerlink" title="数据保存到云端的方法："></a>数据保存到云端的方法：</h4><ol><li>使用自带的网络微数据库</li><li>使用 web 客户端调用写好的后端接口上传数据</li></ol><blockquote><p>由于自带的网络微数据库是 Python 写的，而且对于数据库的接口有着严格限制，所以这里我才用我自己用 php+mysql 写的一个 api 来进行上传</p></blockquote><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>先看看用到的组件：主要是 web 客户端<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141639.jpg" alt=""></li><li>组件的代码块:<ul><li>用于设置 web 客户端的网址<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141640.jpg" alt=""></li><li>执行 get 请求<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141641.jpg" alt=""></li><li>请求成功后返回操作<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141642.jpg" alt=""><br>注意：这一个的话如果你设置了保存响应信息为 ture 就选择获得文件这个控制块，否则的话选择获得文字的控制块，我们使用获得文字的控制块</li></ul></li></ol><h4 id="逻辑控制图"><a href="#逻辑控制图" class="headerlink" title="逻辑控制图"></a>逻辑控制图</h4><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141643.jpg" alt=""><br><em>我做的接口的返回值为 json 格式所以采用了 json 的解析，我暂时不需要判断返回值得内容【里面包含了上传是否成功之类的】，如果需要的话请参考有关 json 解析的相关内容</em></p><h4 id="推荐参考手册"><a href="#推荐参考手册" class="headerlink" title="推荐参考手册"></a>推荐参考手册</h4><ol><li>感谢@老巫婆翻译的参考手册，这里分享给大家：<a href="http://www.17coding.net/reference/">AI2 中文参考手册</a></li><li><a href="http://blog.sina.com.cn/s/blog_62218b990102vhmo.html">@老巫婆的 json 解析教程</a></li><li><a href="http://i.youku.com/u/UNTc5MzY3NTYw/playlists">AI2 视频教程</a>不得不吐槽这个教程的清晰度</li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/64902.html">NDK开发中无法访问android.support.v7.app.AppCompatActivity解决办法</a></li><li><a href="https://lailin.xyz/post/34934.html">appcan利用天翼rtc实现视频通话功能</a></li><li><a href="https://lailin.xyz/post/23045.html">如何使用MITAPPInventor2快速创建一个蓝牙串口app</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>app</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>phpstrom9可用注册码一枚</title>
    <link href="/post/19314.html"/>
    <url>/post/19314.html</url>
    
    <content type="html"><![CDATA[<h4 id="phpstrom9-可用注册码一枚"><a href="#phpstrom9-可用注册码一枚" class="headerlink" title="phpstrom9 可用注册码一枚"></a>phpstrom9 可用注册码一枚</h4><p><strong>username</strong></p><pre><code>EMBRACE</code></pre><p><strong>key</strong></p><pre><code class="hljs asciidoc"><span class="hljs-section">===== LICENSE BEGIN =====</span>43136-1204201000002UsvSON704l&quot;dILe1PVx3y4&quot;B349AU6oSDJrsjE8nMOQh&quot;8HTDJHIUUhgd1BebYc5U&quot;6OxDbVsALB4Eb10PW8&quot;<span class="hljs-section">===== LICENSE END =====</span></code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/18280.html">四川大学锐捷windows解除多网卡限制</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>破解</tag>
      
      <tag>注册码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php如何实现整除</title>
    <link href="/post/28942.html"/>
    <url>/post/28942.html</url>
    
    <content type="html"><![CDATA[<h3 id="php-如何实现整除"><a href="#php-如何实现整除" class="headerlink" title="php 如何实现整除"></a>php 如何实现整除</h3><blockquote><p>以前在用 C/C++的时候，整除就是’/‘，还要特别注意这个问题，今天用到 php 调试的时候出错了，最后发现：在 php 中’/‘除法是默认带有小数部分的，php 自带有几个函数可以对小数进行处理</p></blockquote><h4 id="1-round-函数，四舍五入"><a href="#1-round-函数，四舍五入" class="headerlink" title="1. round()函数，四舍五入"></a>1. round()函数，四舍五入</h4><pre><code>&lt;?php echo round(7/3); //2 ?&gt;</code></pre><h4 id="2-ceil-函数，进一法"><a href="#2-ceil-函数，进一法" class="headerlink" title="2. ceil()函数，进一法"></a>2. ceil()函数，进一法</h4><p><em>也就是取比该数大的最小整数</em></p><pre><code>&lt;?php echo ceil(7/3); //3 ?&gt;</code></pre><h4 id="3-floor-函数，舍一法"><a href="#3-floor-函数，舍一法" class="headerlink" title="3. floor()函数，舍一法"></a>3. floor()函数，舍一法</h4><p><em>也就是取比该数小的最大整数</em></p><p> &lt;?php echo floor(7/3); //2?&gt;</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-once.html">Week03: Go并发编程(八) 深入理解 sync.Once</a></li><li><a href="https://lailin.xyz/post/go-training-week3-errgroup.html">Week03: Go并发编程(七) 深入理解 errgroup</a></li><li><a href="https://lailin.xyz/post/go-training-week3-waitgroup.html">Week03: Go并发编程(六) 深入理解 WaitGroup</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【福利】至善网媒体素材一键评价</title>
    <link href="/post/59875.html"/>
    <url>/post/59875.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近做至善网上面的题时候，发现媒体素材需要一个一个的评价实在是有点烦；所以开挂写了一个 JS 的小插件，直接一次性搞定</p></blockquote><p><strong>方法一：直接将下面这个链接拖入书签栏，然后在你需要一件评价媒体素材的地方点击就好</strong><br><em>ps:毛概测试成功，其他的请自测</em></p><p><a href='javascript:(function(){function sleep(d){for(var t=Date.now();Date.now()-t<=d;){}}function getNum(text){var value=text.replace(/[^0-9]/ig,"");return value}var obj=$("p[href="+"\"javascript:;\""+"]").each(function(){var name=$(this).attr("name");name=getNum(name);parent.showMediaRight(name);wkMediaPj(name,3);var btn1=$(".aui_state_highlight");btn1.click();sleep(1000)})})();'>至善网媒体素材一键评价</a></p><p><em>有什么问题直接在评论问就好</em></p><p><strong>更新，附赠一个毛概的答案</strong><br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141644.jpg" alt=""></p><p><strong>毛概答案补充：中间有一个问号，那道题的答案是：一个中心，两个基本的</strong><br><strong>注：这是毛概上的答案</strong></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/62847.html">js编码解码URL</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Corethink瀑布流插件</title>
    <link href="/post/54589.html"/>
    <url>/post/54589.html</url>
    
    <content type="html"><![CDATA[<h2 id="【原创插件】瀑布流"><a href="#【原创插件】瀑布流" class="headerlink" title="【原创插件】瀑布流"></a>【原创插件】瀑布流</h2><h3 id="1、前台界面"><a href="#1、前台界面" class="headerlink" title="1、前台界面"></a>1、前台界面</h3><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141648.png" alt=""></p><h3 id="2、前台大图预览"><a href="#2、前台大图预览" class="headerlink" title="2、前台大图预览"></a>2、前台大图预览</h3><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141649.png" alt=""></p><h3 id="3、后台设置"><a href="#3、后台设置" class="headerlink" title="3、后台设置"></a>3、后台设置</h3><p>支持容器宽度自定义，高度随宽度按比例改变</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141650.png" alt=""></p><h3 id="4、后台管理界面"><a href="#4、后台管理界面" class="headerlink" title="4、后台管理界面"></a>4、后台管理界面</h3><p>作者，内容为选填项，其余为必填项<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141651.png" alt=""></p><h3 id="5、新增界面"><a href="#5、新增界面" class="headerlink" title="5、新增界面"></a>5、新增界面</h3><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141653.png" alt=""></p><p><strong>**</strong>***<strong>**</strong>使用说明<strong><strong><em>**</em></strong></strong>****<strong><strong><em>**</em></strong></strong><br>1、前台调用</p><pre><code>钩子&#123;:hook(&apos;WaterFall&apos;)&#125;</code></pre><p>2、安装说明</p><p>如果默认表前缀不是 ct<em>，请在插件目录下 WaterFallAddon.class.php 中的 ct</em>改为你的表前缀</p><pre><code>-&gt;where(&apos;ct_addon_waterfall.status=1&apos;)</code></pre><p>3、安装说明 2<br>如果不能安装是不存在钩子原因，解决办法请看我上一个 OT 移植插件 ImageSlider 中的使用方法</p><p><a href="http://lxl520.com/me/blog/index.php/archives/6/">ImageSlider</a></p><p>ps：</p><p><a href="http://www.cnblogs.com/sanshi/p/3237429.html">感谢三生石上的前端瀑布流教程</a></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>corethink</tag>
      
      <tag>插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreThink图片轮播插件【ImageSlider】</title>
    <link href="/post/15278.html"/>
    <url>/post/15278.html</url>
    
    <content type="html"><![CDATA[<p>移植于 OT 插件，原文地址<a href="http://www.topthink.com/topic/6244.html">http://www.topthink.com/topic/6244.html</a></p><p>1、支持 unslider\flexslider 切换选择</p><p>2、支持推荐位选择</p><p>3、支持多图</p><p>4、切换时间&amp;方向选择</p><p>5、自定义容器宽度&amp;高度</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141646.png" alt=""></p><p><strong><em>**</em></strong>*<strong><em>**</em></strong>使用说明<strong><em>**</em></strong>***<strong><em>**</em></strong><br>1、请先将下面这段代码复制到 Application\common\controller\addon.class.php</p><pre><code>/* 获取件所需的钩子是否存在，没有则新增   * @param string $str  钩子名称   * @param string $addons  插件名称   * @param string $addons  件简介   */ public function existHook($str, $addons, $msg=&apos;&apos;)&#123;       $hook_mod = M(&apos;addon_hook&apos;); $where[&apos;name&apos;] = $str;       $gethook = $hook_mod-&gt;where($where)-&gt;find();       if(!$gethook || empty($gethook) || !is_array($gethook))&#123;           $data[&apos;name&apos;] = $str; $data[&apos;description&apos;] = $msg; $data[&apos;type&apos;] = 1;           $data[&apos;update_time&apos;] = NOW_TIME; $data[&apos;addons&apos;] = $addons;           if( false !== $hook_mod-&gt;create($data) )&#123;               $hook_mod-&gt;add();           &#125;       &#125;   &#125;   /**    * delete钩子    * @param string $hook  钩子名称    */   public function deleteHook($hook)&#123;       $model = M(&apos;addon_hook&apos;);       $condition = array( &apos;name&apos; =&gt; $hook, );       $model-&gt;where($condition)-&gt;delete();   &#125;</code></pre><p>2、调用方法</p><pre><code class="hljs clojure">&#123;<span class="hljs-symbol">:hook</span>(<span class="hljs-name">&#x27;ImageSlider&#x27;</span>)&#125;</code></pre><p>3、如果出现显示不出图片，路径错误的情况</p><p>请改一下那个 unslider\flexslider.html 的图片路径，因为安装的路径不同可能出现意外</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>corethink</tag>
      
      <tag>插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用MITAPPInventor2快速创建一个蓝牙串口app</title>
    <link href="/post/23045.html"/>
    <url>/post/23045.html</url>
    
    <content type="html"><![CDATA[<h3 id="如何使用-MIT-APP-Inventor2-快速创建一个蓝牙串口-app"><a href="#如何使用-MIT-APP-Inventor2-快速创建一个蓝牙串口-app" class="headerlink" title="如何使用 MIT APP Inventor2 快速创建一个蓝牙串口 app"></a>如何使用 MIT APP Inventor2 快速创建一个蓝牙串口 app</h3><hr><blockquote><p>最近做学校的一个比赛，我是平时是学习做 web 后端的，有时候捎带一些前端的东西，但是最近这个比赛需要做一个 app，问题来了，没有学过 Java 没有学过 OC 所以 ios 和安卓都是无从下手，然后最后找了很多混合开发的工具，比如说 APPCAN，apicloud，hbuilder，wex5 等等，最后不是没有蓝牙串口的插件，就是没有办法使用.最终在一次搜索中无意的发现了这个 AI2.</p></blockquote><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><hr><p><strong>1. 使用 AI2 的前提条件：</strong></p><ul><li>不要求界面的美观性，需要实用性</li><li>不会原生代码的编程</li></ul><p><strong>2. 使用 AI2 好处：</strong></p><ul><li>不要求你会写代码，图形化编程，简单易用</li><li>提供了很多模块一般做一个常用的 app 完全没有问题</li><li>有中文版，所以说语言障碍也不存在了</li></ul><p><strong>3. 使用 AI2 的几种方式：</strong></p><ul><li>离线安装，离线调试</li><li>在线使用，AI 伴侣调试（模拟器调试）<br><em>个人推荐第二种，在线使用，AI 伴侣调试</em></li></ul><p><strong>4. AI2 的中文网址：</strong></p><ul><li>最新的中文服务器：<a href="http://app.gzjkw.net/">http://app.gzjkw.net/</a></li><li>中文教程网站：<a href="http://www.17coding.net/">http://www.17coding.net/</a></li></ul><h4 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h4><blockquote><p>PS:仅仅是自己的一些经验观点，有什么错误大家交流啊</p></blockquote><hr><h5 id="1-点击进入-http-app-gzjkw-net-，-注册帐号之后，进入以下页面"><a href="#1-点击进入-http-app-gzjkw-net-，-注册帐号之后，进入以下页面" class="headerlink" title="1. 点击进入 http://app.gzjkw.net/， 注册帐号之后，进入以下页面"></a>1. 点击进入 <a href="http://app.gzjkw.net/">http://app.gzjkw.net/</a>， 注册帐号之后，进入以下页面</h5><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/blogQQ图片20151015130813.png" alt="点击查看大图"></p><h5 id="2-选择上面的帮助下载AI-伴侣apk，之后用于在线调试"><a href="#2-选择上面的帮助下载AI-伴侣apk，之后用于在线调试" class="headerlink" title="2. 选择上面的帮助下载AI 伴侣apk，之后用于在线调试"></a>2. 选择上面的帮助下载<strong>AI 伴侣</strong>apk，之后用于在线调试</h5><ul><li>或者直接点击 <a href="http://app.gzjkw.net/companions/MITAI2Companion.apk" title="AI伴侣">AI 伴侣</a> 下载</li></ul><h5 id="3-简单的功能介绍"><a href="#3-简单的功能介绍" class="headerlink" title="3. 简单的功能介绍"></a>3. 简单的功能介绍</h5><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/blogQQ图片20151015131926.png" alt="点击查看大图"></p><ul><li><strong>其中我们需要用到的几个组件：</strong></li></ul><table><thead><tr><th>名称</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>蓝牙客户端 1</td><td style="text-align:center">用于接收蓝牙串口设备的消息</td></tr><tr><td>按钮</td><td style="text-align:center">一般的 button</td></tr><tr><td>水平布局</td><td style="text-align:center">用于布局整个界面</td></tr><tr><td>对话框</td><td style="text-align:center">用于发出提示消息</td></tr><tr><td>activity 控制器</td><td style="text-align:center">用于打开蓝牙</td></tr><tr><td>web 客户端</td><td style="text-align:center">用于链接网络相关的东西（这个下一次用到）</td></tr><tr><td>计时器</td><td style="text-align:center">用于定时接收蓝牙串口发送出来的消息</td></tr></tbody></table><ul><li><strong>具体的常用组件的介绍，请大家点击网站查看<a href="http://www.17coding.net/">http://www.17coding.net/</a></strong></li></ul><h5 id="4-逻辑设置"><a href="#4-逻辑设置" class="headerlink" title="4. 逻辑设置"></a>4. 逻辑设置</h5><ul><li>首先完成界面的一个界面的布局工作<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/blogQQ图片20151015170129.png" alt="点击查看大图"></li><li><p>组件的逻辑设置【点击右上角的逻辑设计即可】<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/blogQQ图片20151015170447.png" alt="点击查看大图"></p></li><li><p>其中将 activity 启动器 1 的 action 值设置为<strong>android.bluetooth.adapter.action.REQUEST_ENABLE</strong> ，这样可以达到开启蓝牙的效果</p></li></ul><h3 id="下一篇讲如何将数据保存到服务器（不使用自带的网络数据库的情况下）"><a href="#下一篇讲如何将数据保存到服务器（不使用自带的网络数据库的情况下）" class="headerlink" title="下一篇讲如何将数据保存到服务器（不使用自带的网络数据库的情况下）"></a><em>下一篇讲如何将数据保存到服务器（不使用自带的网络数据库的情况下）</em></h3><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/64902.html">NDK开发中无法访问android.support.v7.app.AppCompatActivity解决办法</a></li><li><a href="https://lailin.xyz/post/34934.html">appcan利用天翼rtc实现视频通话功能</a></li><li><a href="https://lailin.xyz/post/35791.html">使用MITAPPInventor2web客户端组件保存数据至云端</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>app</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
