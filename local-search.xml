<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Week03: Go并发编程(六) 深入理解 WaitGroup</title>
    <link href="/post/go-training-week3-waitgroup.html"/>
    <url>/post/go-training-week3-waitgroup.html</url>
    
    <content type="html"><![CDATA[<p>tags: [Go, 学习笔记, Go 进阶训练营, 并发]<br>categories: [Go 进阶训练营, Go 并发编程]<br>date: 2020-12-27 22:08:51 +0800</p><hr><blockquote><p>本系列为极客时间 Go 进阶训练营笔记，同步直播更新，预计一周更新 1 ~ 2 篇文章，到 202103 月更新完成</p></blockquote><p>在前面的几篇文章中我们或多或少都用到了 WaitGroup 来等待多个 goroutine 执行结束，今天我们来深入学习一下</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><code>WaitGroup</code> 可以解决一个 goroutine 等待多个 goroutine 同时结束的场景，这个比较常见的场景就是例如 后端 worker 启动了多个消费者干活，还有爬虫并发爬取数据，多线程下载等等。<br>我们这里模拟一个 worker 的例子</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"sync"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Println(<span class="hljs-string">"worker: "</span>, i)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> wg sync.WaitGroup<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> wg.Done()worker(i)&#125;(i)&#125;wg.Wait()&#125;</code></pre><div style="background:#e8f7ff;padding:10px;border:1px solid #abd2da;border-radius:5px;margin-bottom:5px">问题: 反过来支持多个 goroutine 等待一个 goroutine 完成后再干活吗？<br>看我们接下来的源码分析你就知道了</div><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><pre><code class="hljs go"><span class="hljs-keyword">type</span> WaitGroup <span class="hljs-keyword">struct</span> &#123;noCopy noCopy<span class="hljs-comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span><span class="hljs-comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span><span class="hljs-comment">// compilers do not ensure it. So we allocate 12 bytes and then use</span><span class="hljs-comment">// the aligned 8 bytes in them as state, and the other 4 as storage</span><span class="hljs-comment">// for the sema.</span>state1 [<span class="hljs-number">3</span>]<span class="hljs-keyword">uint32</span>&#125;</code></pre><p><code>WaitGroup</code> 结构十分简单，由 <code>nocopy</code> 和 <code>state1</code> 两个字段组成，其中 <code>nocopy</code> 是用来防止复制的</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> noCopy <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// Lock is a no-op used by -copylocks checker from `go vet`.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*noCopy)</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span>   &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*noCopy)</span> <span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span> &#123;&#125;</code></pre><p>由于嵌入了 <code>nocopy</code> 所以在执行 <code>go vet</code> 时如果检查到 <code>WaitGroup</code> 被复制了就会报错。这样可以一定程度上保证 <code>WaitGroup</code> 不被复制，对了直接 go run 是不会有错误的，所以我们代码 push 之前都会强制要求进行 lint 检查，在 ci/cd 阶段也需要先进行 lint 检查，避免出现这种类似的错误。</p><pre><code class="hljs go">~/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">06</span>_waitgroup/<span class="hljs-number">02</span> main*❯ <span class="hljs-keyword">go</span> run ./main.<span class="hljs-keyword">go</span>~/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">06</span>_waitgroup/<span class="hljs-number">02</span> main*❯ <span class="hljs-keyword">go</span> vet .# github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week03/blog/<span class="hljs-number">06</span>_waitgroup/<span class="hljs-number">02</span>./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>:<span class="hljs-number">9</span>: assignment copies lock value to wg2: sync.WaitGroup contains sync.noCopy</code></pre><p><code>state1</code> 的设计非常巧妙，这是一个是十二字节的数据，这里面主要包含两大块，counter 占用了 8 字节用于计数，sema 占用 4 字节用做信号量</p><p>为什么要这么搞呢？直接用两个字段一个表示 counter，一个表示 sema 不行么？<br>不行，我们看看注释里面怎么写的。</p><blockquote><p><em>// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</em> &gt; <em>// 64-bit atomic operations require 64-bit alignment, but 32-bit</em> &gt; <em>// compilers do not ensure it. So we allocate 12 bytes and then use</em> &gt; <em>// the aligned 8 bytes in them as state, and the other 4 as storage</em> &gt; <em>// for the sema.</em></p></blockquote><p>这段话的关键点在于，在做 64 位的原子操作的时候必须要保证 64 位（8 字节）对齐，如果没有对齐的就会有问题，但是 32 位的编译器并不能保证 64 位对齐所以这里用一个 12 字节的 state1 字段来存储这两个状态，然后根据是否 8 字节对齐选择不同的保存方式。<br><img src="https://lailin.xyz/images/1609085423413-88a8f508-0269-4cf9-9474-9f78b78a53ea.svg" srcset="/img/loading.gif" alt="02_Go进阶03_blog_waitgroup.drawio.svg"><br>这个操作巧妙在哪里呢？</p><ul><li>如果是 64 位的机器那肯定是 8 字节对齐了的，所以是上面第一种方式</li><li>如果在 32 位的机器上<ul><li>如果恰好 8 字节对齐了，那么也是第一种方式取前面的 8 字节数据</li><li>如果是没有对齐，但是 32 位 4 字节是对齐了的，所以我们只需要后移四个字节，那么就 8 字节对齐了，所以是第二种方式</li></ul></li></ul><p>所以通过 sema 信号量这四个字节的位置不同，保证了 counter 这个字段无论在 32 位还是 64 为机器上都是 8 字节对齐的，后续做 64 位原子操作的时候就没问题了。<br>这个实现是在 <code>state</code> 方法实现的</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span> <span class="hljs-title">state</span><span class="hljs-params">()</span> <span class="hljs-params">(statep *<span class="hljs-keyword">uint64</span>, semap *<span class="hljs-keyword">uint32</span>)</span></span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="hljs-number">8</span> == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> (*<span class="hljs-keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="hljs-number">2</span>]&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> (*<span class="hljs-keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="hljs-number">1</span>])), &amp;wg.state1[<span class="hljs-number">0</span>]&#125;&#125;</code></pre><p><code>state</code> 方法返回 counter 和信号量，通过 <code>uintptr(unsafe.Pointer(&amp;wg.state1))%8 == 0</code> 来判断是否 8 字节对齐</p><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span> <span class="hljs-title">Add</span><span class="hljs-params">(delta <span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-comment">// 先从 state 当中把数据和信号量取出来</span>statep, semap := wg.state()    <span class="hljs-comment">// 在 waiter 上加上 delta 值</span>state := atomic.AddUint64(statep, <span class="hljs-keyword">uint64</span>(delta)&lt;&lt;<span class="hljs-number">32</span>)    <span class="hljs-comment">// 取出当前的 counter</span>v := <span class="hljs-keyword">int32</span>(state &gt;&gt; <span class="hljs-number">32</span>)    <span class="hljs-comment">// 取出当前的 waiter，正在等待 goroutine 数量</span>w := <span class="hljs-keyword">uint32</span>(state)    <span class="hljs-comment">// counter 不能为负数</span><span class="hljs-keyword">if</span> v &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"sync: negative WaitGroup counter"</span>)&#125;    <span class="hljs-comment">// 这里属于防御性编程</span>    <span class="hljs-comment">// w != 0 说明现在已经有 goroutine 在等待中，说明已经调用了 Wait() 方法</span>    <span class="hljs-comment">// 这时候 delta &gt; 0 &amp;&amp; v == int32(delta) 说明在调用了 Wait() 方法之后又想加入新的等待者</span>    <span class="hljs-comment">// 这种操作是不允许的</span><span class="hljs-keyword">if</span> w != <span class="hljs-number">0</span> &amp;&amp; delta &gt; <span class="hljs-number">0</span> &amp;&amp; v == <span class="hljs-keyword">int32</span>(delta) &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"sync: WaitGroup misuse: Add called concurrently with Wait"</span>)&#125;    <span class="hljs-comment">// 如果当前没有人在等待就直接返回，并且 counter &gt; 0</span><span class="hljs-keyword">if</span> v &gt; <span class="hljs-number">0</span> || w == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span>&#125;    <span class="hljs-comment">// 这里也是防御 主要避免并发调用 add 和 wait</span><span class="hljs-keyword">if</span> *statep != state &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"sync: WaitGroup misuse: Add called concurrently with Wait"</span>)&#125;<span class="hljs-comment">// 唤醒所有 waiter，看到这里就回答了上面的问题了</span>*statep = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> ; w != <span class="hljs-number">0</span>; w-- &#123;runtime_Semrelease(semap, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)&#125;&#125;</code></pre><h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h3><p>wait 主要就是等待其他的 goroutine 完事之后唤醒</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span> <span class="hljs-title">Wait</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 先从 state 当中把数据和信号量的地址取出来</span>    statep, semap := wg.state()<span class="hljs-keyword">for</span> &#123;     <span class="hljs-comment">// 这里去除 counter 和 waiter 的数据</span>state := atomic.LoadUint64(statep)v := <span class="hljs-keyword">int32</span>(state &gt;&gt; <span class="hljs-number">32</span>)w := <span class="hljs-keyword">uint32</span>(state)        <span class="hljs-comment">// counter = 0 说明没有在等的，直接返回就行</span>        <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// Counter is 0, no need to wait.</span><span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// waiter + 1，调用一次就多一个等待者，然后休眠当前 goroutine 等待被唤醒</span><span class="hljs-keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="hljs-number">1</span>) &#123;runtime_Semacquire(semap)<span class="hljs-keyword">if</span> *statep != <span class="hljs-number">0</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"sync: WaitGroup is reused before previous Wait has returned"</span>)&#125;<span class="hljs-keyword">return</span>&#125;&#125;&#125;</code></pre><h3 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h3><p>这个只是 add 的简单封装</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span> <span class="hljs-title">Done</span><span class="hljs-params">()</span></span> &#123;wg.Add(<span class="hljs-number">-1</span>)&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>WaitGroup</code> 可以用于一个 goroutine 等待多个 goroutine 干活完成，也可以多个 goroutine 等待一个 goroutine 干活完成，是一个多对多的关系<ul><li>多个等待一个的典型案例是 <a href="https://pkg.go.dev/golang.org/x/sync/singleflight" target="_blank" rel="noopener">singleflight</a>，这个在后面将微服务可用性的时候还会再讲到，感兴趣可以看看源码</li></ul></li><li><code>Add(n&gt;0)</code> 方法应该在启动 goroutine 之前调用，然后在 goroution 内部调用 <code>Done</code> 方法</li><li><code>WaitGroup</code> 必须在 <code>Wait</code> 方法返回之后才能再次使用</li><li><code>Done</code> 只是 <code>Add</code> 的简单封装，所以实际上是可以通过一次加一个比较大的值减少调用，或者达到快速唤醒的目的。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://pkg.go.dev/sync" target="_blank" rel="noopener">https://pkg.go.dev/sync</a> 官网文档，必读</li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/" target="_blank" rel="noopener">Go 语言设计与实现-6.2 同步原语与锁</a> 这本书值得一看</li><li><a href="https://gobyexample.com/waitgroups" target="_blank" rel="noopener">Go by Example: WaitGroups</a></li><li><a href="https://golang.org/issues/8005#issuecomment-190753527" target="_blank" rel="noopener">https://golang.org/issues/8005#issuecomment-190753527</a></li><li><a href="https://juejin.cn/post/6893019249263001613" target="_blank" rel="noopener">Golang 源码系列 sync.waitgroup 源码剖析</a></li></ol><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新</h2><p>看到这里了还不关注点赞走一波</p><ul><li><a href="https://lailin.xyz">博客</a> 可以订阅 RSS</li><li><a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a> Follow me</li><li><a href="https://www.zhihu.com/people/mo-hui-shou-76" target="_blank" rel="noopener">知乎</a> 关注账号，顺便点个 👍</li><li><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a> 订阅订阅号，顺便点个 👍</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Week03: Go并发编程(五) 深入理解 sync/atomic</title>
    <link href="/post/go-training-week3-atomic.html"/>
    <url>/post/go-training-week3-atomic.html</url>
    
    <content type="html"><![CDATA[<p>tags: [Go, 学习笔记, Go 进阶训练营, 并发]<br>categories: [Go 进阶训练营, Go 并发编程]<br>date: 2020-12-27 14:08:51 +0800</p><hr><blockquote><p>本系列为极客时间 Go 进阶训练营笔记，同步直播更新，预计一周更新 1 ~ 2 篇文章，到 202103 月更新完成</p></blockquote><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在上一篇文章《<a href="https://lailin.xyz/post/go-training-week3-sync.html">Week03: Go 并发编程(四) 深入理解 Mutex</a>》当中我们主要讲到了互斥锁以及读写锁的使用以及源码解析。在看源码的时候我们可以发现里面使用了很多 atomic 包的方法来保证原子，那么我们就趁热打铁接下来就随着本文来看一看 atomic 应该怎么用，以及它又是如何实现的</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>上一篇文章我们在讲读写锁的时候讲到了一个配置读取的例子，这里我们使用 atomic 实现看一下</p><pre><code class="hljs go"><span class="hljs-comment">// Config atomic 实现</span><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;v atomic.Value <span class="hljs-comment">// 假设 data 就是整个 config 了</span>&#125;<span class="hljs-comment">// Get get config data</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Config)</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span> []<span class="hljs-title">int</span></span> &#123;<span class="hljs-comment">// 这里偷个懒，不要学</span><span class="hljs-keyword">return</span> (*c.v.Load().(*[]<span class="hljs-keyword">int</span>))&#125;<span class="hljs-comment">// Set set config data</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Config)</span> <span class="hljs-title">Set</span><span class="hljs-params">(n []<span class="hljs-keyword">int</span>)</span></span> &#123;c.v.Store(&amp;n)&#125;</code></pre><p>跑一个一样的测试，可以发现 atomic 的性能又好上了许多</p><pre><code class="hljs go">❯ <span class="hljs-keyword">go</span> test -race -bench=.goos: linuxgoarch: amd64pkg: github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week03/blog/<span class="hljs-number">05</span>_atomicBenchmarkMutexConfig<span class="hljs-number">-4</span>           <span class="hljs-number">1021684</span>              <span class="hljs-number">1121</span> ns/opBenchmarkRWMutexConfig<span class="hljs-number">-4</span>         <span class="hljs-number">2604524</span>               <span class="hljs-number">433</span> ns/opBenchmarkConfig<span class="hljs-number">-4</span>                <span class="hljs-number">6941658</span>               <span class="hljs-number">170</span> ns/opPASS</code></pre><p><code>atomic.Value</code> 这种适合配置文件这种读特别多，写特别少的场景，因为他是 COW（Copy On Write）写时复制的一种思想，COW 就是指我需要写入的时候我先把老的数据复制一份到一个新的对象，然后再写入新的值。<br>我们看看维基百科的描述，我觉得已经说得很清楚了</p><blockquote><p>写入时复制（英语：Copy-on-write，简称 COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p></blockquote><p>这种思路会有一个问题，就是可能有部分 goroutine 在使用老的对象，所以老的对象不会立即被回收，如果存在大量写入的话，会导致产生大量的副本，性能反而不一定好 。<br>这种方式的好处就是不用加锁，所以也不会有 goroutine 的上下文切换，并且在读取的时候大家都读取的相同的副本所以性能上回好一些。<br>COW 策略在 linux， redis 当中都用的很多，具体可以看一下我后面的参考文献，本文就不展开讲了。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="方法一览"><a href="#方法一览" class="headerlink" title="方法一览"></a>方法一览</h3><p>如果去看文档会发现 atomic 的函数签名有很多，但是大部分都是重复的为了不同的数据类型创建了不同的签名，这就是没有泛型的坏处了，基础库会比较麻烦</p><p>1、第一类 <code>AddXXX</code> 当需要添加的值为负数的时候，做减法，正数做加法</p><pre><code class="hljs go"><span class="hljs-comment">// 第一类，AddXXX，delta 为</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddInt32</span><span class="hljs-params">(addr *<span class="hljs-keyword">int32</span>, delta <span class="hljs-keyword">int32</span>)</span> <span class="hljs-params">(<span class="hljs-built_in">new</span> <span class="hljs-keyword">int32</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddInt64</span><span class="hljs-params">(addr *<span class="hljs-keyword">int64</span>, delta <span class="hljs-keyword">int64</span>)</span> <span class="hljs-params">(<span class="hljs-built_in">new</span> <span class="hljs-keyword">int64</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUint32</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint32</span>, delta <span class="hljs-keyword">uint32</span>)</span> <span class="hljs-params">(<span class="hljs-built_in">new</span> <span class="hljs-keyword">uint32</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUint64</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint64</span>, delta <span class="hljs-keyword">uint64</span>)</span> <span class="hljs-params">(<span class="hljs-built_in">new</span> <span class="hljs-keyword">uint64</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUintptr</span><span class="hljs-params">(addr *<span class="hljs-keyword">uintptr</span>, delta <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-params">(<span class="hljs-built_in">new</span> <span class="hljs-keyword">uintptr</span>)</span></span></code></pre><p>2、第二类 <code>CompareAndSwapXXX</code> CAS 操作， 会先比较传入的地址的值是否是 old，如果是的话就尝试赋新值，如果不是的话就直接返回 false，返回 true 时表示赋值成功。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapInt32</span><span class="hljs-params">(addr *<span class="hljs-keyword">int32</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-keyword">int32</span>)</span> <span class="hljs-params">(swapped <span class="hljs-keyword">bool</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapInt64</span><span class="hljs-params">(addr *<span class="hljs-keyword">int64</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-keyword">int64</span>)</span> <span class="hljs-params">(swapped <span class="hljs-keyword">bool</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapPointer</span><span class="hljs-params">(addr *unsafe.Pointer, old, <span class="hljs-built_in">new</span> unsafe.Pointer)</span> <span class="hljs-params">(swapped <span class="hljs-keyword">bool</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapUint32</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint32</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-keyword">uint32</span>)</span> <span class="hljs-params">(swapped <span class="hljs-keyword">bool</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapUint64</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint64</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-keyword">uint64</span>)</span> <span class="hljs-params">(swapped <span class="hljs-keyword">bool</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapUintptr</span><span class="hljs-params">(addr *<span class="hljs-keyword">uintptr</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-params">(swapped <span class="hljs-keyword">bool</span>)</span></span></code></pre><p>3、第三类 <code>LoadXXX</code> ，从某个地址中取值</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadInt32</span><span class="hljs-params">(addr *<span class="hljs-keyword">int32</span>)</span> <span class="hljs-params">(val <span class="hljs-keyword">int32</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadInt64</span><span class="hljs-params">(addr *<span class="hljs-keyword">int64</span>)</span> <span class="hljs-params">(val <span class="hljs-keyword">int64</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadPointer</span><span class="hljs-params">(addr *unsafe.Pointer)</span> <span class="hljs-params">(val unsafe.Pointer)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadUint32</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint32</span>)</span> <span class="hljs-params">(val <span class="hljs-keyword">uint32</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadUint64</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint64</span>)</span> <span class="hljs-params">(val <span class="hljs-keyword">uint64</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadUintptr</span><span class="hljs-params">(addr *<span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-params">(val <span class="hljs-keyword">uintptr</span>)</span></span></code></pre><p>4、第四类 <code>StoreXXX</code> ，给某个地址赋值</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreInt32</span><span class="hljs-params">(addr *<span class="hljs-keyword">int32</span>, val <span class="hljs-keyword">int32</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreInt64</span><span class="hljs-params">(addr *<span class="hljs-keyword">int64</span>, val <span class="hljs-keyword">int64</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StorePointer</span><span class="hljs-params">(addr *unsafe.Pointer, val unsafe.Pointer)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreUint32</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint32</span>, val <span class="hljs-keyword">uint32</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreUint64</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint64</span>, val <span class="hljs-keyword">uint64</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreUintptr</span><span class="hljs-params">(addr *<span class="hljs-keyword">uintptr</span>, val <span class="hljs-keyword">uintptr</span>)</span></span></code></pre><p>5、第五类 <code>SwapXXX</code> ，交换两个值，并且返回老的值</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapInt32</span><span class="hljs-params">(addr *<span class="hljs-keyword">int32</span>, <span class="hljs-built_in">new</span> <span class="hljs-keyword">int32</span>)</span> <span class="hljs-params">(old <span class="hljs-keyword">int32</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapInt64</span><span class="hljs-params">(addr *<span class="hljs-keyword">int64</span>, <span class="hljs-built_in">new</span> <span class="hljs-keyword">int64</span>)</span> <span class="hljs-params">(old <span class="hljs-keyword">int64</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapPointer</span><span class="hljs-params">(addr *unsafe.Pointer, <span class="hljs-built_in">new</span> unsafe.Pointer)</span> <span class="hljs-params">(old unsafe.Pointer)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapUint32</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint32</span>, <span class="hljs-built_in">new</span> <span class="hljs-keyword">uint32</span>)</span> <span class="hljs-params">(old <span class="hljs-keyword">uint32</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapUint64</span><span class="hljs-params">(addr *<span class="hljs-keyword">uint64</span>, <span class="hljs-built_in">new</span> <span class="hljs-keyword">uint64</span>)</span> <span class="hljs-params">(old <span class="hljs-keyword">uint64</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapUintptr</span><span class="hljs-params">(addr *<span class="hljs-keyword">uintptr</span>, <span class="hljs-built_in">new</span> <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-params">(old <span class="hljs-keyword">uintptr</span>)</span></span></code></pre><p>6、最后一类 <code>Value</code> 用于任意类型的值的 Store、Load，我们开始的案例就用到了这个，这是 1.4 版本之后引入的，签名的方法都只能作用于特定的类型，引入这个方法之后就可以用于任意类型了。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Value<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Value)</span> <span class="hljs-title">Load</span><span class="hljs-params">()</span> <span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Value)</span> <span class="hljs-title">Store</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span></code></pre><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>在 <code>sync/atomic</code> 包中的源码除了 <code>Value</code> 之外其他的函数都是没有直接的源码的，需要去 <code>runtime/internal/atomic</code> 中找寻，这里为 <code>CAS</code> 函数为例，其他的都是大同小异</p><pre><code class="hljs go"><span class="hljs-comment">// bool Cas(int32 *val, int32 old, int32 new)</span><span class="hljs-comment">// Atomically:</span><span class="hljs-comment">//if(*val == old)&#123;</span><span class="hljs-comment">//*val = new;</span><span class="hljs-comment">//return 1;</span><span class="hljs-comment">//&#125; else</span><span class="hljs-comment">//return 0;</span>TEXT runtime∕internal∕atomic·Cas(SB),NOSPLIT,$<span class="hljs-number">0</span><span class="hljs-number">-17</span>MOVQptr+<span class="hljs-number">0</span>(FP), BXMOVLold+<span class="hljs-number">8</span>(FP), AXMOVL<span class="hljs-built_in">new</span>+<span class="hljs-number">12</span>(FP), CXLOCKCMPXCHGLCX, <span class="hljs-number">0</span>(BX)SETEQret+<span class="hljs-number">16</span>(FP)RET</code></pre><p>在注释部分写的非常清楚，这个函数主要就是先比较一下当前传入的地址的值是否和 old 值相等，如果相等，就赋值新值返回 true，如果不相等就返回 false<br>我们看这个具体汇编代码就可以发现，使用了 <code>LOCK</code> 来保证操作的原子性，《<a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html#%E5%86%85%E5%AD%98%E9%87%8D%E6%8E%92">Week03: Go 并发编程(二) Go 内存模型</a>》提到过的一致性问题， <code>CMPXCHG</code> 指令其实就是 CPU 实现的 CAS 操作。</p><div style="background:#fffbe6;padding:10px;border:1px solid #c3c3c3;border-radius:5px;margin-bottom:5px">关于 LOCK 指令通过查阅 intel 的手册我们可以发现，对于P6之前的处理器，LOCK 指令会总是锁总线，但是 P6 之后可能会执行“缓存锁定”，如果被锁定的内存区域被缓存在了处理器中，这个时候会通过缓存一致性来保证操作的原子性</div><h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><pre><code class="hljs go"><span class="hljs-keyword">type</span> Value <span class="hljs-keyword">struct</span> &#123;v <span class="hljs-keyword">interface</span>&#123;&#125;&#125;</code></pre><p>结构非常简单，只有一个 v 用来保存传入的值</p><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p>我们先看看 store 方法，store 方法会将值存储为 x，这里需要注意，每次传入的 x 不能为 nil，并且他们类型必须是相同的，不然会导致 panic</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Value)</span> <span class="hljs-title">Store</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"sync/atomic: store of nil value into Value"</span>)&#125;    <span class="hljs-comment">// ifaceWords 其实就是定义了一下 interface 的结构，包含 data 和 type 两部分</span>    <span class="hljs-comment">// 这里 vp 是原有值</span>    <span class="hljs-comment">// xp 是传入的值</span>vp := (*ifaceWords)(unsafe.Pointer(v))xp := (*ifaceWords)(unsafe.Pointer(&amp;x))    <span class="hljs-comment">// for 循环不断尝试</span><span class="hljs-keyword">for</span> &#123;        <span class="hljs-comment">// 这里先用原子方法取一下老的类型值</span>typ := LoadPointer(&amp;vp.typ)<span class="hljs-keyword">if</span> typ == <span class="hljs-literal">nil</span> &#123;            <span class="hljs-comment">// 等于 nil 就说明这是第一次 store</span>            <span class="hljs-comment">// 调用 runtime 的方法禁止抢占，避免操作完成一半就被抢占了</span>            <span class="hljs-comment">// 同时可以避免 GC 的时候看到 unsafe.Pointer(^uintptr(0)) 这个中间状态的值</span>runtime_procPin()<span class="hljs-keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="hljs-literal">nil</span>, unsafe.Pointer(^<span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>))) &#123;runtime_procUnpin()<span class="hljs-keyword">continue</span>&#125;<span class="hljs-comment">// 分别把值和类型保存下来</span>StorePointer(&amp;vp.data, xp.data)StorePointer(&amp;vp.typ, xp.typ)runtime_procUnpin()<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">if</span> <span class="hljs-keyword">uintptr</span>(typ) == ^<span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 如果判断发现这个类型是这个固定值，说明当前第一次赋值还没有完成，所以进入自旋等待</span><span class="hljs-keyword">continue</span>&#125;<span class="hljs-comment">// 第一次赋值已经完成，判断新的赋值的类型和之前是否一致，如果不一致就直接 panic</span><span class="hljs-keyword">if</span> typ != xp.typ &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"sync/atomic: store of inconsistently typed value into Value"</span>)&#125;        <span class="hljs-comment">// 保存值</span>StorePointer(&amp;vp.data, xp.data)<span class="hljs-keyword">return</span>&#125;&#125;</code></pre><p>具体的逻辑都写在注释中了，这里面复杂逻辑在第一次写入，因为第一次写入的时候有两次原子写操作，所以这个时候用 typ 值作为一个判断，通过不同值判断当前所处的状态，这个在我们业务代码中其实也经常用到。然后因为引入了这个中间状态，所以又使用了 <code>runtime_procPin</code> 方法避免抢占</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sync_runtime_procPin</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> procPin()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">procPin</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;    <span class="hljs-comment">// 获取到当前 goroutine 的 m</span>_g_ := getg()mp := _g_.m    <span class="hljs-comment">// unpin 的时候就是 locks--</span>mp.locks++<span class="hljs-keyword">return</span> <span class="hljs-keyword">int</span>(mp.p.ptr().id)&#125;</code></pre><h4 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Value)</span> <span class="hljs-title">Load</span><span class="hljs-params">()</span> <span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;vp := (*ifaceWords)(unsafe.Pointer(v))    <span class="hljs-comment">// 先拿到类型值</span>typ := LoadPointer(&amp;vp.typ)    <span class="hljs-comment">// 这个说明还没有第一次 store 或者是第一次 store 还没有完成</span><span class="hljs-keyword">if</span> typ == <span class="hljs-literal">nil</span> || <span class="hljs-keyword">uintptr</span>(typ) == ^<span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// First store not yet completed.</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;    <span class="hljs-comment">// 获取值</span>data := LoadPointer(&amp;vp.data)    <span class="hljs-comment">// 构造 x 类型</span>xp := (*ifaceWords)(unsafe.Pointer(&amp;x))xp.typ = typxp.data = data<span class="hljs-keyword">return</span>&#125;</code></pre><h2 id="实战-实现一个“无锁”栈"><a href="#实战-实现一个“无锁”栈" class="headerlink" title="实战: 实现一个“无锁”栈"></a>实战: 实现一个“无锁”栈</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"sync/atomic"</span><span class="hljs-string">"unsafe"</span>)<span class="hljs-comment">// LFStack 无锁栈</span><span class="hljs-comment">// 使用链表实现</span><span class="hljs-keyword">type</span> LFStack <span class="hljs-keyword">struct</span> &#123;head unsafe.Pointer <span class="hljs-comment">// 栈顶</span>&#125;<span class="hljs-comment">// Node 节点</span><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;val  <span class="hljs-keyword">int32</span>next unsafe.Pointer&#125;<span class="hljs-comment">// NewLFStack NewLFStack</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLFStack</span><span class="hljs-params">()</span> *<span class="hljs-title">LFStack</span></span> &#123;n := unsafe.Pointer(&amp;Node&#123;&#125;)<span class="hljs-keyword">return</span> &amp;LFStack&#123;head: n&#125;&#125;<span class="hljs-comment">// Push 入栈</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *LFStack)</span> <span class="hljs-title">Push</span><span class="hljs-params">(v <span class="hljs-keyword">int32</span>)</span></span> &#123;n := &amp;Node&#123;val: v&#125;<span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">// 先取出栈顶</span>old := atomic.LoadPointer(&amp;s.head)n.next = old<span class="hljs-keyword">if</span> atomic.CompareAndSwapPointer(&amp;s.head, old, unsafe.Pointer(n)) &#123;<span class="hljs-keyword">return</span>&#125;&#125;&#125;<span class="hljs-comment">// Pop 出栈，没有数据时返回 nil</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *LFStack)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">int32</span></span> &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">// 先取出栈顶</span>old := atomic.LoadPointer(&amp;s.head)<span class="hljs-keyword">if</span> old == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;oldNode := (*Node)(old)<span class="hljs-comment">// 取出下一个节点</span>next := atomic.LoadPointer(&amp;oldNode.next)<span class="hljs-comment">// 重置栈顶</span><span class="hljs-keyword">if</span> atomic.CompareAndSwapPointer(&amp;s.head, old, next) &#123;<span class="hljs-keyword">return</span> oldNode.val&#125;&#125;&#125;</code></pre><p>这里的无锁其实只是没用互斥锁，用了原子操作，前面我们看 atomic 的源码的时候可以发现实际上在 CPU 上还是有锁的，只是我们这个锁的粒度非常小</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然在一些情况下 atomic 的性能要好很多，但是这个是一个 low level 的库，在实际的业务代码中最好还是使用 channel 但是我们也需要知道，在一些基础库，或者是需要极致性能的地方用上这个还是很爽的，但是使用的过程中一定要小心，不然还是会容易出 bug。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://pkg.go.dev/sync/atomic" target="_blank" rel="noopener">https://pkg.go.dev/sync/atomic</a></li><li><a href="https://blog.betacat.io/post/golang-atomic-value-exploration/" target="_blank" rel="noopener">Go 语言标准库中 atomic.Value 的前世今生</a></li><li><a href="https://xie.infoq.cn/article/562eff7a1108a7a2bc46058ca" target="_blank" rel="noopener">深入浅出 Go - sync/atomic 源码分析</a></li><li><a href="https://juejin.cn/post/6844903702373859335" target="_blank" rel="noopener">COW 奶牛！Copy On Write 机制了解一下</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD" target="_blank" rel="noopener">维基百科: COW</a></li><li><a href="https://albk.tech/%E8%81%8A%E8%81%8ACPU%E7%9A%84LOCK%E6%8C%87%E4%BB%A4.html" target="_blank" rel="noopener">聊聊 CPU 的 LOCK 指令</a></li><li><a href="https://zhuanlan.zhihu.com/p/24146167" target="_blank" rel="noopener">浅论 Lock 与 X86 Cache 一致性</a></li><li><a href="https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf" target="_blank" rel="noopener">intel 手册</a></li><li><a href="https://colobu.com/2020/08/14/lock-free-queue-in-go/" target="_blank" rel="noopener">使用 Go 实现 lock-free 的队列</a></li></ol><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新</h2><p>看到这里了还不关注点赞走一波</p><ul><li><a href="https://lailin.xyz">博客</a> 可以订阅 RSS</li><li><a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a> Follow me</li><li><a href="https://www.zhihu.com/people/mo-hui-shou-76" target="_blank" rel="noopener">知乎</a> 关注账号，顺便点个 👍</li><li><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a> 订阅订阅号，顺便点个 👍</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Week03: Go并发编程(四) 深入理解 Mutex</title>
    <link href="/post/go-training-week3-sync.html"/>
    <url>/post/go-training-week3-sync.html</url>
    
    <content type="html"><![CDATA[<p>tags: [Go, 学习笔记, Go 进阶训练营, 并发]<br>categories: [Go 进阶训练营, Go 并发编程]<br>date: 2020-12-26 13:08:51 +0800</p><hr><blockquote><p>本系列为极客时间 Go 进阶训练营笔记，同步直播更新，预计一周更新 1 ~ 2 篇文章，到 202103 月更新完成</p></blockquote><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>前面几篇文章当中我们都反复提到了 goroutine 创建是简单的，但是我们仍然要小心，习惯总会不经意间的导致我们写出很多 bug 对于语言规范没有定义的内容我们不要做任何假设。我们需要通过同步语义控制他们的执行顺序，关于之前的内容可以看前面的三篇文章：</p><ul><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go 并发编程(一) goroutine</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go 并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go 并发编程(三) data race</a></li></ul><p>接下来的几篇文章就让我们我们一起来了解一下 sync 包相关的一些用法，以及部分实现原理，当然这里说是 sync 包，实际上包含了三个包分别是: sync, sync/atomic, golang.org/x/sync/errgroup</p><div style="background:#fffbe6;padding:10px;border:1px solid #c3c3c3;border-radius:5px;margin-bottom:5px">这些包提供了一些基础的同步语义，但是在实际的并发编程当中，我们应该使用 channel 来进行同步控制。“Share memory by communicating; don’t communicate by sharing memory.”</div><h1 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h1><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>我们先来看一下上一篇文章说到的例子应该怎么改</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.Mutex<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; i++ &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> routine(i)&#125;wg.Wait()fmt.Printf(<span class="hljs-string">"Final Counter: %d\n"</span>, counter)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">routine</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;mu.Lock()counter++mu.Unlock()&#125;wg.Done()&#125;</code></pre><p>这里主要的目的就是为了保护我们临界区的数据，通过锁来进行保证。锁的使用非常的简单，但是还是有几个需要注意的点</p><ul><li>锁的范围要尽量的小，不要搞很多大锁</li><li>用锁一定要解锁，小心产生死锁</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>我们来看一下在 Go 中锁是怎么实现的</p><h3 id="锁的实现模式-5"><a href="#锁的实现模式-5" class="headerlink" title="锁的实现模式[5]"></a>锁的实现模式[5]</h3><ul><li><strong>Barging</strong>: 这种模式是为了提高吞吐量，当锁被释放时，它会唤醒第一个等待者，然后把锁给第一个等待者或者给第一个请求锁的人</li></ul><p><img src="https://lailin.xyz/images/1608967840701-d8c54ee4-964b-49d0-8fab-6f98dd777fd2.png" srcset="/img/loading.gif" alt="1_B1atM-b6GPDS0_Q_TPEUBw.png"></p><ul><li><strong>Handoff: </strong>当锁释放时候，锁会一直持有直到第一个等待者准备好获取锁。它降低了吞吐量，因为锁被持有，即使另一个 goroutine 准备获取它。<strong><em>这种模式可以解决公平性的问题，因为在 Barging 模式下可能会存在被唤醒的 goroutine 永远也获取不到锁的情况，毕竟一直在 cpu 上跑着的 goroutine 没有上下文切换会更快一些。缺点就是性能会相对差一些</em></strong></li></ul><p><img src="https://lailin.xyz/images/1608967902210-d4c2937f-56fd-49e8-a5a3-903bec31e6fc.png" srcset="/img/loading.gif" alt="image.png"></p><ul><li><strong>Spining：</strong>自旋在等待队列为空或者应用程序重度使用锁时效果不错。Parking 和 Unparking goroutines 有不低的性能成本开销，相比自旋来说要慢得多。<em><strong>但是自旋是有成本的，所以在 go 的实现中进入自旋的条件十分的苛刻。</strong></em></li></ul><p><img src="https://lailin.xyz/images/1608967913891-eb4cf780-6ffd-4a2d-a3d5-8e05d7e3fce3.png" srcset="/img/loading.gif" alt="image.png"></p><h3 id="Go-Mutex-实现原理"><a href="#Go-Mutex-实现原理" class="headerlink" title="Go Mutex 实现原理"></a>Go Mutex 实现原理</h3><p>我们先来看一下在 Go 中具体是怎么实现的，我们先讲原理再看源码，避免看的云里雾里的。**</p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>如下图所示，Go 在 1.15 的版本中锁的实现结合上面提到的三种模式，调用 Lock 方法的时候。</p><ol><li>首先如果当前锁处于初始化状态就直接用 CAS 方法尝试获取锁，这是<strong>_ Fast Path_</strong></li><li>如果失败就进入<strong><em> Slow Path</em></strong><ol><li>会首先判断当前能不能进入自旋状态，如果可以就进入自旋，最多自旋 4 次</li><li>自旋完成之后，就会去计算当前的锁的状态</li><li>然后尝试通过 CAS 获取锁</li><li>如果没有获取到就调用 <code>runtime_SemacquireMutex</code> 方法休眠当前 goroutine 并且尝试获取信号量</li><li>goroutine 被唤醒之后会先判断当前是否处在饥饿状态，（如果当前 goroutine 超过 1ms 都没有获取到锁就会进饥饿模式） 1. 如果处在饥饿状态就会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出 1. 如果不在，就会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环<br><div style="background:#fffbe6;padding:10px;border:1px solid #c3c3c3;border-radius:5px;margin-bottom:5px">CAS 方法在这里指的是 <code>atomic.CompareAndSwapInt32(addr, old, new) bool</code> 方法，这个方法会先比较传入的地址的值是否是 old，如果是的话就尝试赋新值，如果不是的话就直接返回 false，返回 true 时表示赋值成功<br>饥饿模式是 Go 1.9 版本之后引入的优化，用于解决公平性的问题[10]</div><br><img src="https://lailin.xyz/images/1608970759375-09d8cda7-77ac-48d3-b2f3-b8890e927bd4.svg" srcset="/img/loading.gif" alt="02_Go进阶03_blog_sync.drawio.svg"></li></ol></li></ol><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>解锁的流程相对于加锁简单许多<br><img src="https://lailin.xyz/images/1608978117259-455cf28e-aa1e-46cf-8fd6-6040ed6c0a7a.svg" srcset="/img/loading.gif" alt="02_Go进阶03_blog_sync.drawio.svg"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Mutex-基本结构"><a href="#Mutex-基本结构" class="headerlink" title="Mutex 基本结构"></a>Mutex 基本结构</h3><p>知道其中的原理之后，我们再来看看源码分析</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;state <span class="hljs-keyword">int32</span>sema  <span class="hljs-keyword">uint32</span>&#125;</code></pre><p><code>Mutex</code> 结构体由 <code>state</code> <code>sema</code> 两个 4 字节成员组成，其中 <code>state</code> 表示了当前锁的状态， <code>sema</code> 是用于控制锁的信号量<br><img src="https://lailin.xyz/images/1608972241012-8c0fe8e2-b1c8-4696-a9c4-454e11753e0f.svg" srcset="/img/loading.gif" alt="02_Go进阶03_blog_sync.drawio.svg"><br><code>state</code> 字段的最低三位表示三种状态，分别是 <code>mutexLocked</code> <code>mutexWoken</code> <code>mutexStarving</code> ，剩下的用于统计当前在等待锁的 goroutine 数量</p><ul><li><code>mutexLocked</code> 表示是否处于锁定状态</li><li><code>mutexWoken</code> 表示是否处于唤醒状态</li><li><code>mutexStarving</code> 表示是否处于饥饿状态</li></ul><h3 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h3><p>回味一下上面看到的流程图，我们来看看互斥锁是如何加锁的</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// Fast path: grab unlocked mutex.</span><span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="hljs-number">0</span>, mutexLocked) &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// Slow path (outlined so that the fast path can be inlined)</span>m.lockSlow()&#125;</code></pre><ul><li>当我们调用 <code>Lock</code> 方法的时候，会先尝试走 Fast Path，也就是如果当前互斥锁如果处于未加锁的状态，尝试加锁，只要加锁成功就直接返回</li><li>否则的话就进入 slow path</li></ul><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">lockSlow</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> waitStartTime <span class="hljs-keyword">int64</span> <span class="hljs-comment">// 等待时间</span>starving := <span class="hljs-literal">false</span> <span class="hljs-comment">// 是否处于饥饿状态</span>awoke := <span class="hljs-literal">false</span> <span class="hljs-comment">// 是否处于唤醒状态</span>iter := <span class="hljs-number">0</span> <span class="hljs-comment">// 自旋迭代次数</span>old := m.state<span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">// Don't spin in starvation mode, ownership is handed off to waiters</span><span class="hljs-comment">// so we won't be able to acquire the mutex anyway.</span><span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;<span class="hljs-comment">// Active spinning makes sense.</span><span class="hljs-comment">// Try to set mutexWoken flag to inform Unlock</span><span class="hljs-comment">// to not wake other blocked goroutines.</span><span class="hljs-keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="hljs-number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="hljs-number">0</span> &amp;&amp;atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;awoke = <span class="hljs-literal">true</span>&#125;runtime_doSpin()iter++old = m.state<span class="hljs-keyword">continue</span>&#125;</code></pre><p>在 <code>lockSlow</code> 方法中我们可以看到，有一个大的 for 循环，不断的尝试去获取互斥锁，在循环的内部，第一步就是判断能否自旋状态。<br>进入自旋状态的判断比较苛刻，具体需要满足什么条件呢？ <code>runtime_canSpin</code> 源码见下方</p><ul><li>当前互斥锁的状态是非饥饿状态，并且已经被锁定了</li><li>自旋次数不超过 4 次</li><li>cpu 个数大于一，必须要是多核 cpu</li><li>当前正在执行当中，并且队列空闲的 p 的个数大于等于一</li></ul><pre><code class="hljs go"><span class="hljs-comment">// Active spinning for sync.Mutex.</span><span class="hljs-comment">//go:linkname sync_runtime_canSpin sync.runtime_canSpin</span><span class="hljs-comment">//go:nosplit</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sync_runtime_canSpin</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="hljs-number">1</span> || gomaxprocs &lt;= <span class="hljs-keyword">int32</span>(sched.npidle+sched.nmspinning)+<span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><p>如果可以进入自旋状态之后就会调用 <code>runtime_doSpin</code> 方法进入自旋， <code>doSpin</code> 方法会调用 <code>procyield(30)</code> 执行三十次 <code>PAUSE</code> 指令</p><pre><code class="hljs go">TEXT runtime·procyield(SB),NOSPLIT,$<span class="hljs-number">0</span><span class="hljs-number">-0</span>MOVLcycles+<span class="hljs-number">0</span>(FP), AXagain:PAUSESUBL$<span class="hljs-number">1</span>, AXJNZagainRET</code></pre><p></p><div style="background:#fffbe6;padding:10px;border:1px solid #c3c3c3;border-radius:5px;margin-bottom:5px">为什么使用 PAUSE 指令呢？<br>PAUSE 指令会告诉 CPU 我当前处于处于自旋状态，这时候 CPU 会针对性的做一些优化，并且在执行这个指令的时候 CPU 会降低自己的功耗，减少能源消耗</div><br><pre><code class="hljs go"><span class="hljs-keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="hljs-number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="hljs-number">0</span> &amp;&amp;atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;awoke = <span class="hljs-literal">true</span>&#125;</code></pre><p></p><p>在自旋的过程中会尝试设置 <code>mutexWoken</code> 来通知解锁，从而避免唤醒其他已经休眠的 <code>goroutine</code> 在自旋模式下，当前的 <code>goroutine</code> 就能更快的获取到锁<br><pre><code class="hljs go"><span class="hljs-built_in">new</span> := old<span class="hljs-comment">// Don't try to acquire starving mutex, new arriving goroutines must queue.</span><span class="hljs-keyword">if</span> old&amp;mutexStarving == <span class="hljs-number">0</span> &#123;<span class="hljs-built_in">new</span> |= mutexLocked&#125;<span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="hljs-number">0</span> &#123;<span class="hljs-built_in">new</span> += <span class="hljs-number">1</span> &lt;&lt; mutexWaiterShift&#125;<span class="hljs-comment">// The current goroutine switches mutex to starvation mode.</span><span class="hljs-comment">// But if the mutex is currently unlocked, don't do the switch.</span><span class="hljs-comment">// Unlock expects that starving mutex has waiters, which will not</span><span class="hljs-comment">// be true in this case.</span><span class="hljs-keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="hljs-number">0</span> &#123;<span class="hljs-built_in">new</span> |= mutexStarving&#125;<span class="hljs-keyword">if</span> awoke &#123;<span class="hljs-comment">// The goroutine has been woken from sleep,</span><span class="hljs-comment">// so we need to reset the flag in either case.</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexWoken == <span class="hljs-number">0</span> &#123;throw(<span class="hljs-string">"sync: inconsistent mutex state"</span>)&#125;<span class="hljs-built_in">new</span> &amp;^= mutexWoken&#125;</code></pre></p><p>自旋结束之后就会去计算当前互斥锁的状态，如果当前处在饥饿模式下则不会去请求锁，而是会将当前 goroutine 放到队列的末端<br><pre><code class="hljs go"><span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;    <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">break</span> <span class="hljs-comment">// locked the mutex with CAS</span>    &#125;    <span class="hljs-comment">// If we were already waiting before, queue at the front of the queue.</span>    queueLifo := waitStartTime != <span class="hljs-number">0</span>    <span class="hljs-keyword">if</span> waitStartTime == <span class="hljs-number">0</span> &#123;        waitStartTime = runtime_nanotime()    &#125;    runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="hljs-number">1</span>)    starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs    old = m.state    <span class="hljs-keyword">if</span> old&amp;mutexStarving != <span class="hljs-number">0</span> &#123;        <span class="hljs-comment">// If this goroutine was woken and mutex is in starvation mode,</span>        <span class="hljs-comment">// ownership was handed off to us but mutex is in somewhat</span>        <span class="hljs-comment">// inconsistent state: mutexLocked is not set and we are still</span>        <span class="hljs-comment">// accounted as waiter. Fix that.</span>        <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="hljs-number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> &#123;            throw(<span class="hljs-string">"sync: inconsistent mutex state"</span>)        &#125;        delta := <span class="hljs-keyword">int32</span>(mutexLocked - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift)        <span class="hljs-keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">1</span> &#123;            <span class="hljs-comment">// Exit starvation mode.</span>            <span class="hljs-comment">// Critical to do it here and consider wait time.</span>            <span class="hljs-comment">// Starvation mode is so inefficient, that two goroutines</span>            <span class="hljs-comment">// can go lock-step infinitely once they switch mutex</span>            <span class="hljs-comment">// to starvation mode.</span>            delta -= mutexStarving        &#125;        atomic.AddInt32(&amp;m.state, delta)        <span class="hljs-keyword">break</span>    &#125;    awoke = <span class="hljs-literal">true</span>    iter = <span class="hljs-number">0</span>&#125;</code></pre></p><p>状态计算完成之后就会尝试使用 CAS 操作获取锁，如果获取成功就会直接退出循环<br>如果获取失败，则会调用 <code>runtime_SemacquireMutex(&amp;m.sema, queueLifo, 1)</code> 方法保证锁不会同时被两个 goroutine 获取。<code>runtime_SemacquireMutex</code> 方法的主要作用是:</p><ul><li>不断调用尝试获取锁</li><li>休眠当前 goroutine</li><li>等待信号量，唤醒 goroutine</li></ul><p>goroutine 被唤醒之后就会去判断当前是否处于饥饿模式，如果当前等待超过 <code>1ms</code> 就会进入饥饿模式</p><ul><li>饥饿模式下：会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出</li><li>正常模式下：会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环</li></ul><h3 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h3><p>和加锁比解锁就很简单了，直接看注释就好</p><pre><code class="hljs go"><span class="hljs-comment">// 解锁一个没有锁定的互斥量会报运行时错误</span><span class="hljs-comment">// 解锁没有绑定关系，可以一个 goroutine 锁定，另外一个 goroutine 解锁</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// Fast path: 直接尝试设置 state 的值，进行解锁</span><span class="hljs-built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)    <span class="hljs-comment">// 如果减去了 mutexLocked 的值之后不为零就会进入慢速通道，这说明有可能失败了，或者是还有其他的 goroutine 等着</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span> != <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// Outlined slow path to allow inlining the fast path.</span><span class="hljs-comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span>m.unlockSlow(<span class="hljs-built_in">new</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">unlockSlow</span><span class="hljs-params">(<span class="hljs-built_in">new</span> <span class="hljs-keyword">int32</span>)</span></span> &#123;    <span class="hljs-comment">// 解锁一个没有锁定的互斥量会报运行时错误</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="hljs-number">0</span> &#123;throw(<span class="hljs-string">"sync: unlock of unlocked mutex"</span>)&#125;    <span class="hljs-comment">// 判断是否处于饥饿模式</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexStarving == <span class="hljs-number">0</span> &#123;        <span class="hljs-comment">// 正常模式</span>old := <span class="hljs-built_in">new</span><span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">// 如果当前没有等待者.或者 goroutine 已经被唤醒或者是处于锁定状态了，就直接返回</span><span class="hljs-keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 唤醒等待者并且移交锁的控制权</span><span class="hljs-built_in">new</span> = (old - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken<span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span>&#125;old = m.state&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 饥饿模式，走 handoff 流程，直接将锁交给下一个等待的 goroutine，注意这个时候不会从饥饿模式中退出</span>runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>)&#125;&#125;</code></pre><h1 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h1><p>读写锁相对于互斥锁来说粒度更细，使用读写锁可以并发读，但是不能并发读写，或者并发写写</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>读</strong></th><th style="text-align:center"><strong>写</strong></th></tr></thead><tbody><tr><td style="text-align:center">读</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">写</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><p>其实大部分的业务应用都是读多写少的场景，这个时候使用读写锁的性能就会比互斥锁要好一些，例如下面的这个例子，是一个配置读写的例子，我们分别使用读写锁和互斥锁实现</p><pre><code class="hljs go"><span class="hljs-comment">// RWMutexConfig 读写锁实现</span><span class="hljs-keyword">type</span> RWMutexConfig <span class="hljs-keyword">struct</span> &#123;rw   sync.RWMutexdata []<span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">// Get get config data</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *RWMutexConfig)</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span> []<span class="hljs-title">int</span></span> &#123;c.rw.RLock()<span class="hljs-keyword">defer</span> c.rw.RUnlock()<span class="hljs-keyword">return</span> c.data&#125;<span class="hljs-comment">// Set set config data</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *RWMutexConfig)</span> <span class="hljs-title">Set</span><span class="hljs-params">(n []<span class="hljs-keyword">int</span>)</span></span> &#123;c.rw.Lock()<span class="hljs-keyword">defer</span> c.rw.Unlock()c.data = n&#125;</code></pre><p>互斥锁实现</p><pre><code class="hljs go"><span class="hljs-comment">// MutexConfig 互斥锁实现</span><span class="hljs-keyword">type</span> MutexConfig <span class="hljs-keyword">struct</span> &#123;data []<span class="hljs-keyword">int</span>mu   sync.Mutex&#125;<span class="hljs-comment">// Get get config data</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *MutexConfig)</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span> []<span class="hljs-title">int</span></span> &#123;c.mu.Lock()<span class="hljs-keyword">defer</span> c.mu.Unlock()<span class="hljs-keyword">return</span> c.data&#125;<span class="hljs-comment">// Set set config data</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *MutexConfig)</span> <span class="hljs-title">Set</span><span class="hljs-params">(n []<span class="hljs-keyword">int</span>)</span></span> &#123;c.mu.Lock()<span class="hljs-keyword">defer</span> c.mu.Unlock()c.data = n&#125;</code></pre><p>并发基准测试</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> iConfig <span class="hljs-keyword">interface</span> &#123;Get() []<span class="hljs-keyword">int</span>Set([]<span class="hljs-keyword">int</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bench</span><span class="hljs-params">(b *testing.B, c iConfig)</span></span> &#123;b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *testing.PB)</span></span> &#123;<span class="hljs-keyword">for</span> p.Next() &#123;c.Set([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">100</span>&#125;)c.Get()c.Get()c.Get()c.Set([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">100</span>&#125;)c.Get()c.Get()&#125;&#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMutexConfig</span><span class="hljs-params">(b *testing.B)</span></span> &#123;conf := &amp;MutexConfig&#123;data: []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;&#125;bench(b, conf)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkRWMutexConfig</span><span class="hljs-params">(b *testing.B)</span></span> &#123;conf := &amp;RWMutexConfig&#123;data: []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;&#125;bench(b, conf)&#125;</code></pre><p>执行结果</p><pre><code class="hljs go">❯ <span class="hljs-keyword">go</span> test -race -bench=.goos: linuxgoarch: amd64pkg: github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week03/blog/<span class="hljs-number">04</span>_sync/<span class="hljs-number">02</span>_rwmutexBenchmarkMutexConfig<span class="hljs-number">-4</span>            <span class="hljs-number">179577</span>              <span class="hljs-number">6912</span> ns/opBenchmarkRWMutexConfig<span class="hljs-number">-4</span>          <span class="hljs-number">341620</span>              <span class="hljs-number">3425</span> ns/opPASSok      github.com/mohuishou/<span class="hljs-keyword">go</span>-training/Week03/blog/<span class="hljs-number">04</span>_sync/<span class="hljs-number">02</span>_rwmutex <span class="hljs-number">3.565</span>s</code></pre><p>可以看到首先是没有 data race 问题，其次读写锁的性能几乎是互斥锁的一倍</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><pre><code class="hljs go"><span class="hljs-keyword">type</span> RWMutex <span class="hljs-keyword">struct</span> &#123;w           Mutex  <span class="hljs-comment">// 复用互斥锁</span>writerSem   <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// 信号量，用于写等待读</span>readerSem   <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// 信号量，用于读等待写</span>readerCount <span class="hljs-keyword">int32</span>  <span class="hljs-comment">// 当前执行读的 goroutine 数量</span>readerWait  <span class="hljs-keyword">int32</span>  <span class="hljs-comment">// 写操作被阻塞的准备读的 goroutine 的数量</span>&#125;</code></pre><p>由于复用了互斥锁的代码，读写锁的源码很简单，这里我就不单独画图了</p><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><h4 id="加锁-2"><a href="#加锁-2" class="headerlink" title="加锁"></a>加锁</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span> <span class="hljs-title">RLock</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// A writer is pending, wait for it.</span>runtime_SemacquireMutex(&amp;rw.readerSem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)&#125;&#125;</code></pre><p>首先是读锁， <code>atomic.AddInt32(&amp;rw.readerCount, 1)</code> 调用这个原子方法，对当前在读的数量加一，如果返回负数，那么说明当前有其他写锁，这时候就调用 <code>runtime_SemacquireMutex</code> 休眠 goroutine 等待被唤醒</p><h4 id="解锁-2"><a href="#解锁-2" class="headerlink" title="解锁"></a>解锁</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span> <span class="hljs-title">RUnlock</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="hljs-number">-1</span>); r &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// Outlined slow-path to allow the fast-path to be inlined</span>rw.rUnlockSlow(r)&#125;&#125;</code></pre><p>解锁的时候对正在读的操作减一，如果返回值小于 0 那么说明当前有在写的操作，这个时候调用 <code>rUnlockSlow</code> 进入慢速通道</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span> <span class="hljs-title">rUnlockSlow</span><span class="hljs-params">(r <span class="hljs-keyword">int32</span>)</span></span> &#123;<span class="hljs-keyword">if</span> r+<span class="hljs-number">1</span> == <span class="hljs-number">0</span> || r+<span class="hljs-number">1</span> == -rwmutexMaxReaders &#123;race.Enable()throw(<span class="hljs-string">"sync: RUnlock of unlocked RWMutex"</span>)&#125;<span class="hljs-comment">// A writer is pending.</span><span class="hljs-keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="hljs-number">-1</span>) == <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// The last reader unblocks the writer.</span>runtime_Semrelease(&amp;rw.writerSem, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>)&#125;&#125;</code></pre><p>被阻塞的准备读的 goroutine 的数量减一，readerWait 为 0，就表示当前没有正在准备读的 goroutine 这时候调用 <code>runtime_Semrelease</code> 唤醒写操作</p><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><h4 id="加锁-3"><a href="#加锁-3" class="headerlink" title="加锁"></a>加锁</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// First, resolve competition with other writers.</span>rw.w.Lock()<span class="hljs-comment">// Announce to readers there is a pending writer.</span>r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders<span class="hljs-comment">// Wait for active readers.</span><span class="hljs-keyword">if</span> r != <span class="hljs-number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="hljs-number">0</span> &#123;runtime_SemacquireMutex(&amp;rw.writerSem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)&#125;&#125;</code></pre><p>首先调用互斥锁的 lock，获取到互斥锁之后，</p><ul><li><code>atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders)</code> 调用这个函数阻塞后续的读操作</li><li>如果计算之后当前仍然有其他 goroutine 持有读锁，那么就调用 <code>runtime_SemacquireMutex</code> 休眠当前的 goroutine 等待所有的读操作完成</li></ul><h4 id="解锁-3"><a href="#解锁-3" class="headerlink" title="解锁"></a>解锁</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RWMutex)</span> <span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// Announce to readers there is no active writer.</span>r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)<span class="hljs-keyword">if</span> r &gt;= rwmutexMaxReaders &#123;race.Enable()throw(<span class="hljs-string">"sync: Unlock of unlocked RWMutex"</span>)&#125;<span class="hljs-comment">// Unblock blocked readers, if any.</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">int</span>(r); i++ &#123;runtime_Semrelease(&amp;rw.readerSem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)&#125;&#125;</code></pre><p>解锁的操作，会先调用 <code>atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</code> 将恢复之前写入的负数，然后根据当前有多少个读操作在等待，循环唤醒</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://pkg.go.dev/sync" target="_blank" rel="noopener">https://pkg.go.dev/sync</a> 官网文档，必读</li><li><a href="https://pkg.go.dev/golang.org/x/sync@v0.0.0-20201207232520-09787c993a3a/errgroup" target="_blank" rel="noopener">https://pkg.go.dev/golang.org/x/sync@v0.0.0-20201207232520-09787c993a3a/errgroup</a> 官网文档，必读</li><li><a href="https://pkg.go.dev/sync/atomic" target="_blank" rel="noopener">https://pkg.go.dev/sync/atomic</a> 官网文档，必读</li><li><a href="https://medium.com/a-journey-with-go/go-how-to-reduce-lock-contention-with-the-atomic-package-ba3b2664b549" target="_blank" rel="noopener">Go: How to Reduce Lock Contention with the Atomic Package</a></li><li><a href="https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50" target="_blank" rel="noopener">Go: Mutex and Starvation</a></li><li><a href="https://mojotv.cn/go/golang-muteex-starvation" target="_blank" rel="noopener">Go 进阶 27:Go 语言 Mutex Starvation(译)</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/" target="_blank" rel="noopener">Go 语言设计与实现-6.2 同步原语与锁</a> 这本书值得一看</li><li><a href="https://www.felixcloutier.com/x86/pause" target="_blank" rel="noopener">PAUSE — Spin Loop Hint</a></li><li><a href="https://github.com/freelancer-leon/notes/blob/master/kernel/lock/Lock-2-Linux_x86_Spin_Lock.md#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF-pause-%E6%8C%87%E4%BB%A4" target="_blank" rel="noopener">Linux x86 自旋锁的实现</a></li><li><a href="https://github.com/golang/go/commit/0556e26273f704db73df9e7c4c3d2e8434dec7be" target="_blank" rel="noopener">https://github.com/golang/go/commit/0556e26273f704db73df9e7c4c3d2e8434dec7be</a></li></ol><h1 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新</h1><p>看到这里了还不关注点赞走一波</p><ul><li><a href="https://lailin.xyz">博客</a> 可以订阅 RSS</li><li><a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a> Follow me</li><li><a href="https://www.zhihu.com/people/mo-hui-shou-76" target="_blank" rel="noopener">知乎</a> 关注账号，顺便点个 👍</li><li><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a> 订阅订阅号，顺便点个 👍</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Week03: Go并发编程(三) data race</title>
    <link href="/post/go-training-week3-data-race.html"/>
    <url>/post/go-training-week3-data-race.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为极客时间 Go 进阶训练营笔记，同步直播更新，预计一周更新 1 ~ 2 篇文章，到 202103 月更新完成</p></blockquote><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在前两篇文章当中我们反复提到了虽然在 go 中，并发编程十分简单，我们只需要使用 <code>go func()</code> 就能启动一个 goroutine 去做一些事情，但是正是由于这种简单我们要十分当心，不然很容易出现一些莫名其妙的 bug 或者是你的服务由于不知名的原因就重启了。</p><h2 id="数据竞争-data-race"><a href="#数据竞争-data-race" class="headerlink" title="数据竞争(data race)"></a>数据竞争(data race)</h2><p>之前我们提到了很多次在多个 goroutine 对同一个变量的数据进行修改的时候会出现很多奇奇怪怪的问题，那我们有没有什么办法检测它呢，除了通过我们聪明的脑袋？</p><p>答案就是 data race tag，go 官方早在 1.1 版本就引入了数据竞争的检测工具，我们只需要在执行测试或者是编译的时候加上 <code>-race</code> 的 flag 就可以开启数据竞争的检测</p><pre><code class="hljs go"><span class="hljs-keyword">go</span> test -race ./...<span class="hljs-keyword">go</span> build -race</code></pre><div style="background:#fffbe6;padding:10px;border:1px solid #c3c3c3;border-radius:5px;margin-bottom:5px">不建议在生产环境 build 的时候开启数据竞争检测，因为这会带来一定的性能损失(一般内存5-10倍，执行时间2-20倍)，当然 必须要 debug 的时候除外。<br>建议在执行单元测试时始终开启数据竞争的检测。</div><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p>我们来直接看一下下面的这个例子，这是来自课上的一个例子，但是我稍稍做了一些改造，源代码没有跑 10w 次这个操作，会导致看起来每次跑的结果都是差不多的，我们只需要把这个次数放大就可以发现每次结果都会不一样</p><h4 id="正常执行"><a href="#正常执行" class="headerlink" title="正常执行"></a>正常执行</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"sync"</span>)<span class="hljs-keyword">var</span> wg sync.WaitGroup<span class="hljs-keyword">var</span> counter <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 多跑几次来看结果</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++ &#123;run()&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; i++ &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> routine(i)&#125;wg.Wait()fmt.Printf(<span class="hljs-string">"Final Counter: %d\n"</span>, counter)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">routine</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;value := countervalue++counter = value&#125;wg.Done()&#125;</code></pre><p>我执行了三次每次的结果都不一致，分别是:</p><pre><code class="hljs go">Final Counter: <span class="hljs-number">399996</span>Final Counter: <span class="hljs-number">399989</span>Final Counter: <span class="hljs-number">399988</span></code></pre><p>为什么会导致这样的结果呢，是因为每一次执行的时候，我们都使用 <code>go routine(i)</code> 启动了两个 goroutine，但是我们并没有控制它的执行顺序，那就有好几种可能了，我这里描述两种情况</p><ol><li>执行一次 <code>run()</code> , <code>counter + 4</code> 这种情况下，第二个 goroutine 开始执行时，拿到了第一个 goroutine 的执行结果，也就是 <code>value := counter</code> 这一步时，value = 2</li><li>执行一次 <code>run()</code> , <code>counter + 2</code> 这种情况下，第二个 goroutine 开始执行时，没有拿到了第一个 goroutine 的执行结果，也就是 <code>value := counter</code> 这一步时，counter 还是零值，这时候 value = 0</li></ol><p>当然由于种种不确定性，所有肯定不止这两种情况，但是这个不是本文讨论的重点，具体的原因可以结合上一篇文章 <a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go 并发编程(二) Go 内存模型</a> 进行思考</p><h4 id="data-race-执行"><a href="#data-race-执行" class="headerlink" title="data race 执行"></a>data race 执行</h4><p>可以发现，写出这种代码时上线后如果出现 bug 会非常难定位，因为你不知道到底是哪里出现了问题，所以我们就要在测试阶段就结合 data race 工具提前发现问题。<br>我们执行以下命令</p><pre><code class="hljs go"><span class="hljs-keyword">go</span> run -race ./main.<span class="hljs-keyword">go</span></code></pre><p>会发现结果会所有的都输出， <code>data race</code> 的报错信息，我们已经看不到了，因为终端的打印的太长了，可以发现的是，最后打印出发现了一处 data race 并且推出码为 <code>66</code></p><pre><code class="hljs go">Final Counter: <span class="hljs-number">399956</span>Final Counter: <span class="hljs-number">399960</span>Found <span class="hljs-number">1</span> data race(s)exit status <span class="hljs-number">66</span></code></pre><h4 id="data-race-配置"><a href="#data-race-配置" class="headerlink" title="data race 配置"></a>data race 配置</h4><p>问题来了，我们有没有什么办法可以立即知道 data race 的报错呢？<br>答案就在官方的文档当中，我们可以通过设置 <code>GORACE</code> 环境变量，来控制 data race 的行为， 格式如下:</p><pre><code class="hljs go">GORACE=<span class="hljs-string">"option1=val1 option2=val2"</span></code></pre><p>可选配置:</p><table><thead><tr><th><strong>配置</strong></th><th><strong>默认值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>log_path</td><td>stderr</td><td>日志文件的路径，除了文件路径外支持 stderr, stdout 这两个特殊值</td></tr><tr><td>exitcode</td><td>66</td><td>退出码</td></tr><tr><td>strip_path_prefix</td><td>“”</td><td>从日志中的文件信息里面去除相关的前缀，可以去除本地信息，同时会更好看</td></tr><tr><td>history_size</td><td>1</td><td>per-goroutine 内存访问历史记录为 32K * 2 ** history_size，增加这个可以避免出现堆栈还原失败的错误，但是增加这个会导致使用的内存也跟着增加</td></tr><tr><td>halt_on_error</td><td>0</td><td>用来控制第一个数据竞争错误出现后是否立即退出</td></tr><tr><td>atexit_sleep_ms</td><td>100</td><td>用来控制 main 退出之前 sleep 的时间</td></tr></tbody></table><p>有了这个背景知识后就很简单了，在我们这个场景我们可以控制发现数据竞争后直接退出</p><pre><code class="hljs go">GORACE=<span class="hljs-string">"halt_on_error=1 strip_path_prefix=/home/ll/project/Go-000/Week03/blog/03_sync/01_data_race"</span> <span class="hljs-keyword">go</span> run -race ./main.<span class="hljs-keyword">go</span></code></pre><p>重新执行后我们的结果</p><pre><code class="hljs go">==================WARNING: DATA RACERead at <span class="hljs-number">0x00000064a9c0</span> by goroutine <span class="hljs-number">7</span>:  main.routine()      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">29</span> +<span class="hljs-number">0x47</span>Previous write at <span class="hljs-number">0x00000064a9c0</span> by goroutine <span class="hljs-number">8</span>:  main.routine()      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">31</span> +<span class="hljs-number">0x64</span>Goroutine <span class="hljs-number">7</span> (running) created at:  main.run()      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">21</span> +<span class="hljs-number">0x75</span>  main.main()      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span> +<span class="hljs-number">0x38</span>Goroutine <span class="hljs-number">8</span> (finished) created at:  main.run()      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">21</span> +<span class="hljs-number">0x75</span>  main.main()      /main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span> +<span class="hljs-number">0x38</span>==================exit status <span class="hljs-number">66</span></code></pre><p>这个结果非常清晰的告诉了我们在 29 行这个地方我们有一个 goroutine 在读取数据，但是呢，在 31 行这个地方又有一个 goroutine 在写入，所以产生了数据竞争。<br>然后下面分别说明这两个 goroutine 是什么时候创建的，已经当前是否在运行当中。</p><h3 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h3><p>接来下我们再来看一些典型案例，这些案例都来自 go 官方的文档 <a href="https://golang.org/doc/articles/race_detector.html" target="_blank" rel="noopener">Data Race Detector</a>，这些也是初学者很容易犯的错误</p><h4 id="案例二-在循环中启动-goroutine-引用临时变量"><a href="#案例二-在循环中启动-goroutine-引用临时变量" class="headerlink" title="案例二 在循环中启动 goroutine 引用临时变量"></a>案例二 在循环中启动 goroutine 引用临时变量</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> wg sync.WaitGroupwg.Add(<span class="hljs-number">5</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;fmt.Println(i) <span class="hljs-comment">// Not the 'i' you are looking for.</span>wg.Done()&#125;()&#125;wg.Wait()&#125;</code></pre><p>如果你去找一些 go 的面试题，肯定能找到类似的例子，然后会问你这里会输出什么？<br>常见的答案就是会输出 5 个 5，因为在 for 循环的 i++ 会执行的快一些，所以在最后打印的结果都是 5<br>这个答案不能说不对，因为真的执行的话大概率也是这个结果，但是不全<br>因为这里本质上是有数据竞争，在新启动的 goroutine 当中读取 i 的值，在 main 中写入，导致出现了 data race，这个结果应该是不可预知的，因为我们不能假定 goroutine 中 print 就一定比外面的 i++ 慢，习惯性的做这种假设在并发编程中是很有可能会出问题的</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> wg sync.WaitGroupwg.Add(<span class="hljs-number">5</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Println(i)wg.Done()&#125;(i)&#125;wg.Wait()&#125;</code></pre><p>这个要修改也很简单，只需要将 i 作为参数传入即可，这样每个 goroutine 拿到的都是拷贝后的数据</p><h4 id="案例三-一不小心就把变量共享了"><a href="#案例三-一不小心就把变量共享了" class="headerlink" title="案例三 一不小心就把变量共享了"></a>案例三 一不小心就把变量共享了</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"os"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ParallelWrite([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">"xxx"</span>))&#125;<span class="hljs-comment">// ParallelWrite writes data to file1 and file2, returns the errors.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParallelWrite</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">chan</span> <span class="hljs-title">error</span></span> &#123;res := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> error, <span class="hljs-number">2</span>)f1, err := os.Create(<span class="hljs-string">"/tmp/file1"</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;res &lt;- err&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// This err is shared with the main goroutine,</span><span class="hljs-comment">// so the write races with the write below.</span>_, err = f1.Write(data)res &lt;- errf1.Close()&#125;()&#125;f2, err := os.Create(<span class="hljs-string">"/tmp/file2"</span>) <span class="hljs-comment">// The second conflicting write to err.</span><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;res &lt;- err&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;_, err = f2.Write(data)res &lt;- errf2.Close()&#125;()&#125;<span class="hljs-keyword">return</span> res&#125;</code></pre><p>我们使用 <code>go run -race main.go</code> 执行，可以发现这里报错的地方是，19 行和 24 行，有 data race，这里主要是因为共享了 err 这个变量</p><pre><code class="hljs go">==================WARNING: DATA RACEWrite at <span class="hljs-number">0x00c0000a01a0</span> by goroutine <span class="hljs-number">7</span>:  main.ParallelWrite.func1()      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">19</span> +<span class="hljs-number">0x94</span>Previous write at <span class="hljs-number">0x00c0000a01a0</span> by main goroutine:  main.ParallelWrite()      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">24</span> +<span class="hljs-number">0x1dd</span>  main.main()      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">6</span> +<span class="hljs-number">0x84</span>Goroutine <span class="hljs-number">7</span> (running) created at:  main.ParallelWrite()      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">16</span> +<span class="hljs-number">0x336</span>  main.main()      /home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">03</span>_data_race/<span class="hljs-number">03</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">6</span> +<span class="hljs-number">0x84</span>==================Found <span class="hljs-number">1</span> data race(s)exit status <span class="hljs-number">66</span></code></pre><p>修改的话只需要在两个 goroutine 中使用新的临时变量就行了</p><pre><code class="hljs go">..._, err := f1.Write(data)..._, err := f2.Write(data)...</code></pre><p>细心的同学可能会有这个疑问，在 24 行不也是重新赋值了么，为什么在这里会和 19 行产生 data race 呢？<br>这是由于 go 的语法规则导致的，我们在初始化变量的时候如果在同一个作用域下，如下方代码，这里使用的 err 其实是同一个变量，只是 f1 f2 不同，具体可以看 <a href="https://golang.org/doc/effective_go.html#redeclaration" target="_blank" rel="noopener">effective go 当中 Redeclaration and reassignment</a> 的内容</p><pre><code class="hljs go">f1, err := os.Create(<span class="hljs-string">"a"</span>)f2, err := os.Create(<span class="hljs-string">"b"</span>)</code></pre><h4 id="案例四-不受保护的全局变量"><a href="#案例四-不受保护的全局变量" class="headerlink" title="案例四 不受保护的全局变量"></a>案例四 不受保护的全局变量</h4><pre><code class="hljs go"><span class="hljs-keyword">var</span> service = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;&#125;<span class="hljs-comment">// RegisterService RegisterService</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterService</span><span class="hljs-params">(name, addr <span class="hljs-keyword">string</span>)</span></span> &#123;service[name] = addr&#125;<span class="hljs-comment">// LookupService LookupService</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LookupService</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> service[name]&#125;</code></pre><p>这个也是很容易犯的一个错，在之前写 Go 设计模式这个系列文章的时候，应该有提到过我们要写出可测性比较高的代码就要少用或者是尽量避免用全局变量，使用 map 作为全局变量比较常见的一种情况就是配置信息。关于全局变量的话一般的做法就是加锁，就本文这个问题也可以使用 sync.Map 这个下一篇文章会讲，这里篇幅有限就不多讲了</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> (service   <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>serviceMu sync.Mutex)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterService</span><span class="hljs-params">(name, addr <span class="hljs-keyword">string</span>)</span></span> &#123;serviceMu.Lock()<span class="hljs-keyword">defer</span> serviceMu.Unlock()service[name] = addr&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LookupService</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;serviceMu.Lock()<span class="hljs-keyword">defer</span> serviceMu.Unlock()<span class="hljs-keyword">return</span> service[name]&#125;</code></pre><h4 id="案例五-未受保护的成员变量"><a href="#案例五-未受保护的成员变量" class="headerlink" title="案例五 未受保护的成员变量"></a>案例五 未受保护的成员变量</h4><pre><code class="hljs go"><span class="hljs-keyword">type</span> Watchdog <span class="hljs-keyword">struct</span>&#123; last <span class="hljs-keyword">int64</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Watchdog)</span> <span class="hljs-title">KeepAlive</span><span class="hljs-params">()</span></span> &#123;w.last = time.Now().UnixNano() <span class="hljs-comment">// First conflicting access.</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Watchdog)</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;time.Sleep(time.Second)<span class="hljs-comment">// Second conflicting access.</span><span class="hljs-keyword">if</span> w.last &lt; time.Now().Add(<span class="hljs-number">-10</span>*time.Second).UnixNano() &#123;fmt.Println(<span class="hljs-string">"No keepalives for 10 seconds. Dying."</span>)os.Exit(<span class="hljs-number">1</span>)&#125;&#125;&#125;()&#125;</code></pre><p>同样成员变量也会有这个问题，这里可以用 <code>atomic</code> 包来解决，同样这个我们下篇文章会细讲</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Watchdog <span class="hljs-keyword">struct</span>&#123; last <span class="hljs-keyword">int64</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Watchdog)</span> <span class="hljs-title">KeepAlive</span><span class="hljs-params">()</span></span> &#123;atomic.StoreInt64(&amp;w.last, time.Now().UnixNano())&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Watchdog)</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;time.Sleep(time.Second)<span class="hljs-keyword">if</span> atomic.LoadInt64(&amp;w.last) &lt; time.Now().Add(<span class="hljs-number">-10</span>*time.Second).UnixNano() &#123;fmt.Println(<span class="hljs-string">"No keepalives for 10 seconds. Dying."</span>)os.Exit(<span class="hljs-number">1</span>)&#125;&#125;&#125;()&#125;</code></pre><h3 id="案例六-一个有趣的例子"><a href="#案例六-一个有趣的例子" class="headerlink" title="案例六 一个有趣的例子"></a>案例六 一个有趣的例子</h3><p>dava 在博客中提到过一个很有趣的例子的 <a href="https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races" target="_blank" rel="noopener">Ice cream makers and data races</a></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-keyword">type</span> IceCreamMaker <span class="hljs-keyword">interface</span> &#123;<span class="hljs-comment">// Great a customer.</span>Hello()&#125;<span class="hljs-keyword">type</span> Ben <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Ben)</span> <span class="hljs-title">Hello</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">"Ben says, \"Hello my name is %s\"\n"</span>, b.name)&#125;<span class="hljs-keyword">type</span> Jerry <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j *Jerry)</span> <span class="hljs-title">Hello</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">"Jerry says, \"Hello my name is %s\"\n"</span>, j.name)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> ben = &amp;Ben&#123;name: <span class="hljs-string">"Ben"</span>&#125;<span class="hljs-keyword">var</span> jerry = &amp;Jerry&#123;<span class="hljs-string">"Jerry"</span>&#125;<span class="hljs-keyword">var</span> maker IceCreamMaker = ben<span class="hljs-keyword">var</span> loop0, loop1 <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>loop0 = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;maker = ben<span class="hljs-keyword">go</span> loop1()&#125;loop1 = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;maker = jerry<span class="hljs-keyword">go</span> loop0()&#125;<span class="hljs-keyword">go</span> loop0()<span class="hljs-keyword">for</span> &#123;maker.Hello()&#125;&#125;</code></pre><p>这个例子有趣的点在于，最后输出的结果会有这种例子</p><pre><code class="hljs go">Ben says, <span class="hljs-string">"Hello my name is Jerry"</span>Ben says, <span class="hljs-string">"Hello my name is Jerry"</span></code></pre><p>这是因为我们在 <code>maker = jerry</code> 这种赋值操作的时候并不是原子的，在上一篇文章中我们讲到过，只有对 single machine word 进行赋值的时候才是原子的，虽然这个看上去只有一行，但是 interface 在 go 中其实是一个结构体，它包含了 type 和 data 两个部分，所以它的复制也不是原子的，会出现问题</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-keyword">interface</span> <span class="hljs-keyword">struct</span> &#123;       Type <span class="hljs-keyword">uintptr</span>     <span class="hljs-comment">// points to the type of the interface implementation</span>       Data <span class="hljs-keyword">uintptr</span>     <span class="hljs-comment">// holds the data for the interface's receiver</span>&#125;</code></pre><p>这个案例有趣的点还在于，这个案例的两个结构体的内存布局一模一样所以出现错误也不会 panic 退出，如果在里面再加入一个 string 的字段，去读取就会导致 panic，但是这也恰恰说明这个案例很可怕，这种错误在线上实在太难发现了，而且很有可能会很致命。<br>这个案例还有一个衍生案例，大家有兴趣可以点开查看一下，并不是说要看起来一样才不会 panic <a href="https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾一下，这篇文章通过一个案例讲解了 data race 的使用方法:</p><pre><code class="hljs go"><span class="hljs-keyword">go</span> build -race main.<span class="hljs-keyword">go</span><span class="hljs-keyword">go</span> test -race ./...</code></pre><p>然后讲述了 data race 如何通过 GORACE 环境变量进行配置<br>最后讲解了几个典型案例，看完这篇相信你对 data race 已经有了一个基本的了解，希望可以在接下来的工作学习当中对你有有所启发<br>最后在重申一下关键点：</p><ul><li>善用 data race 这个工具帮助我们提前发现并发错误</li><li>不要对未定义的行为做任何假设，虽然有时候我们写的只是一行代码，但是 go 编译器可能后面坐了很多事情，并不是说一行写完就一定是原子的</li><li>即使是原子的出现了 data race 也不能保证安全，因为我们还有可见性的问题，上篇我们讲到了现代的 cpu 基本上都会有一些缓存的操作。</li><li>所有出现了 data race 的地方都需要进行处理</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races" target="_blank" rel="noopener">https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races</a></li><li><a href="https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html</a></li><li><a href="http://blog.golang.org/race-detector" target="_blank" rel="noopener">http://blog.golang.org/race-detector</a></li><li><a href="https://golang.org/doc/articles/race_detector.html" target="_blank" rel="noopener">https://golang.org/doc/articles/race_detector.html</a></li><li><a href="https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package" target="_blank" rel="noopener">https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package</a> 除了考虑原子性之外，还要考虑可见性，并不是说赋值原子了，并发操作就没有问题了</li><li><a href="https://golang.org/doc/effective_go.html#redeclaration" target="_blank" rel="noopener">https://golang.org/doc/effective_go.html#redeclaration</a></li></ul><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新</h2><p>看到这里了还不关注点赞走一波</p><ul><li><a href="https://lailin.xyz">博客</a> 可以订阅 RSS</li><li><a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a> Follow me</li><li><a href="https://www.zhihu.com/people/mo-hui-shou-76" target="_blank" rel="noopener">知乎</a> 关注账号，顺便点个 👍</li><li><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a> 订阅订阅号，顺便点个 👍</li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li><li><a href="https://lailin.xyz/post/go-training-03.html">Week02: Go错误处理最佳实践</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Go并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Week03: Go并发编程(二) Go 内存模型</title>
    <link href="/post/go-training-week3-go-memory-model.html"/>
    <url>/post/go-training-week3-go-memory-model.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为极客时间 Go 进阶训练营笔记，同步直播更新，预计一周更新 1 ~ 2 篇文章，到 202103 月更新完成</p></blockquote><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在上一篇文章当中我们讲到了使用 goroutine 的一些注意事项，我们先简单回顾一下:</p><ol><li><strong>请将是否异步调用的选择权交给调用者</strong>，不然很有可能大家并不知道你在这个函数里面使用了 goroutine</li><li>如果你要启动一个 goroutine 请对它负责<ol><li><strong>永远不要启动一个你无法控制它退出，或者你无法知道它何时推出的 goroutine</strong></li><li>还有上一篇提到的，启动 goroutine 时请加上 panic recovery 机制，避免服务直接不可用</li><li>造成 goroutine 泄漏的主要原因就是 goroutine 中造成了阻塞，并且没有外部手段控制它退出</li></ol></li><li><strong>尽量避免在请求中直接启动 goroutine 来处理问题</strong>，而应该通过启动 worker 来进行消费，这样可以避免由于请求量过大，而导致大量创建 goroutine 从而导致 oom，当然如果请求量本身非常小，那当我没说</li></ol><p>那我们为什么要这么使用 goroutine 呢？今天我们从原理层面来了解一下 goroutine 的注意事项，本文以 Go 官方博客当中的 <a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a> 为主干穿插讲解，建议阅读本文前先自行看完一遍原文，会有更多的收获</p><h2 id="Go-内存模型"><a href="#Go-内存模型" class="headerlink" title="Go 内存模型"></a>Go 内存模型</h2><p>同样我们先来看一段代码，请问下面的代码可能会输出什么？</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">var</span> a, b <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;a = <span class="hljs-number">1</span>b = <span class="hljs-number">2</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-built_in">print</span>(b)<span class="hljs-built_in">print</span>(a)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">go</span> f()g()&#125;</code></pre><p>ok，请带着你的答案或者是困惑我们往下走<br><img src="https://lailin.xyz/images/1608363233129-3653a44c-74a9-46dc-94b0-c6151da0c07c.svg" srcset="/img/loading.gif" alt="02_Go进阶03_blog_img.drawio.svg"><br>比较容易想到的结果是:</p><ul><li>执行顺序: 1 - 2 - 3 - 4, f 先执行, g 后执行, 输出 <code>2 1</code></li><li>执行顺序: 3 - 4 - 1 - 2, g 先执行，f 后执行，输出 <code>0 0</code></li></ul><p>就这几种结果么？其实不然，还有可能</p><ul><li>执行顺序: 1 - 3 - 4 - 2, <code>f</code> 先执行一部分, 然后 <code>g</code> 执行, 输出 <code>0 1</code></li></ul><p>那能不能输出 <code>2 0</code> 呢？</p><ul><li>先说答案，是有可能的</li></ul><p>是不是感觉有点反常识？是不是感觉有点飘忽不定？引用参考文章里面曹大的一句话：</p><blockquote><p>软件(<em>编译器</em>)或硬件(<em>CPU</em>)系统可以根据其对代码的分析结果，一定程度上打乱代码的执行顺序，以达到其不可告人的目的(<em>提高 CPU 利用率)</em></p></blockquote><p>所以我们在编写并发程序的时候一定要小心，然后回到我们本次的主题 Go 内存模型，就是要解决两个问题，一个是要了解谁先谁后，有个专有名词叫 <code>Happens Before</code> ，另外一个就是了解可见性的问题，我这次读取能不能看到另外一个线程的写入<br>接下来我们官方的文档<a href="https://golang.org/ref/mem" target="_blank" rel="noopener">《The Go Memory Model》</a>的思路一步一步的了解这些问题，因为官方的文档写的相对比较精炼，所以会比较难懂，我会尝试加入一些我的理解补充说明</p><h3 id="忠告"><a href="#忠告" class="headerlink" title="忠告"></a>忠告</h3><blockquote><p>Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access.<br>To serialize access, protect the data with channel operations or other synchronization primitives such as those in the <a href="https://golang.org/pkg/sync/" target="_blank" rel="noopener"><code>sync</code></a> and <a href="https://golang.org/pkg/sync/atomic/" target="_blank" rel="noopener"><code>sync/atomic</code></a> packages.</p></blockquote><p>这个是说如果你的程序存在多个 goroutine 去访问数据的时候，<strong>必须序列化的访问，</strong>如何保证序列化呢？我们可以采用 channel 或者是 sync 以及 sync/atomic 下面提供的同步语义来保证</p><h3 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens Before"></a>Happens Before</h3><h4 id="序"><a href="#序" class="headerlink" title="序"></a>序</h4><blockquote><p>Within a single goroutine, reads and writes must behave as if they executed in the order specified by the program. That is, compilers and processors may reorder the reads and writes executed within a single goroutine only when the reordering does not change the behavior within that goroutine as defined by the language specification. Because of this reordering, the execution order observed by one goroutine may differ from the order perceived by another. For example, if one goroutine executes a = 1; b = 2;, another might observe the updated value of b before the updated value of a.</p></blockquote><p>这段话就解释了上面我们示例当中为什么会出现 <code>2 0</code> 这种情况。<br>这段话就是说我们在单个 goroutine 当中的编写的代码会总是按照我们编写代码的顺序来执行</p><ul><li>当然这个也是符合我们的习惯的</li><li>当然这并不表示编译器在编译的时候不会对我们的程序进行指令重排</li><li>而是说只会在不影响语言规范对 goroutine 的行为定义的时候，编译器和 CPU 才会对读取和写入的顺序进行重新排序。</li></ul><p>但是正是因为存在这种重排的情况，所以一个 goroutine 监测到的执行顺序和另外一个 goroutine 监测到的有可能不一样。就像我们最上面的这个例子一样，可能我们在 f 执行的顺序是先执行 <code>a = 1</code> 后执行 <code>b = 2</code> 但是在 g 中我们只看到了 b = 2 具体什么情况可能会导致这个呢？不要着急，我们后面还会说到</p><h4 id="编译器重排"><a href="#编译器重排" class="headerlink" title="编译器重排"></a>编译器重排</h4><p>我们来看参考文章中的一个编译器重排例子</p><pre><code class="hljs go">X = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i in <span class="hljs-keyword">range</span>(<span class="hljs-number">100</span>):    X = <span class="hljs-number">1</span>    <span class="hljs-built_in">print</span> X</code></pre><p>在这段代码中，X = 1 在 for 循环内部被重复赋值了 100 次，这完全没有必要，于是聪明的编译器就会帮助我们优化成下面的样子</p><pre><code class="hljs go">X = <span class="hljs-number">1</span><span class="hljs-keyword">for</span> i in <span class="hljs-keyword">range</span>(<span class="hljs-number">100</span>):    <span class="hljs-built_in">print</span> X</code></pre><p>完美，在单个 goroutine 中并不会改变程序的执行，这时候同样会输出 100 次 1 ，并且减少了 100 次赋值操作。<br>但是，如果与此同时我们存在一个另外一个 goroutine 干了另外一个事情 X = 0 那么，这个输出就变的不可预知了，就有可能是 1001111101… 这种，所以回到刚开始的忠告：<strong>这个是说如果你的程序存在多个 goroutine 去访问数据的时候，必须序列化的访问</strong></p><h4 id="happens-before-定义"><a href="#happens-before-定义" class="headerlink" title="happens before 定义"></a>happens before 定义</h4><blockquote><p>To specify the requirements of reads and writes, we define happens before, a partial order on the execution of memory operations in a Go program. If event <code>e1</code> happens before event <code>e2</code>, then we say that <code>e2</code> happens after <code>e1</code>. Also, if <code>e1</code> does not happen before <code>e2</code> and does not happen after <code>e2</code>, then we say that <code>e1</code> and <code>e2</code> happen concurrently.</p></blockquote><p>这是 Happens Before 的定义，如果 <code>e1</code> 发生在 <code>e2</code> 之前，那么我们就说 <code>e2</code> 发生在 <code>e1</code> 之后，如果 <code>e1</code> 既不在 <code>e2</code> 前，也不在 <code>e2</code> 之后，那我们就说这俩是并发的</p><blockquote><p>Within a single goroutine, the happens-before order is the order expressed by the program.</p></blockquote><p>这就是我们前面提到的，在单个 goroutine 当中，事件发生的顺序，就是程序所表达的顺序</p><blockquote><p>A read r of a variable <code>v</code> is allowed to observe a write <code>w</code> to <code>v</code> if both of the following hold:</p><ol><li>r does not happen before <code>w</code>.</li><li>There is no other write <code>w&#39;</code> to <code>v</code> that happens after w but before <code>r</code>.</li></ol></blockquote><p>假设我们现在有一个变量 <code>v</code>，然后只要满足下面的两个条件，那么读取操作 <code>r</code> 就可以对这个变量 <code>v</code> 的写入操作 <code>w</code> 进行监测</p><ol><li>读取操作 <code>v</code> 发生在写入操作 <code>w</code> 之后</li><li>并且在 <code>w</code> 之后，<code>r</code> 之前没有其他对 <code>v</code> 的写入操作 <code>w&#39;</code></li></ol><p>注意这里说的只是读取操作 r 可以对 w 进行监测，但是能不能读到呢，可能可以也可能不行</p><blockquote><p>To guarantee that a read <code>r</code> of a variable <code>v</code> observes a particular write <code>w</code> to <code>v</code>, ensure that <code>w</code> is the only write <code>r</code> is allowed to observe. That is, <code>r</code> is guaranteed to observe <code>w</code> if both of the following hold:</p><ol><li><code>w</code> happens before <code>r</code>.</li><li>Any other write to the shared variable <code>v</code> either happens before <code>w</code> or after <code>r</code>.</li></ol></blockquote><p>为确保对变量 <code>v</code> 的读取操作 <code>r</code> 能够监测到特定的对 <code>v</code> 进行写入的操作 <code>w</code>，需确保 <code>w</code> 是唯一允许被 <code>r</code> 监测的写入操作。也就是说，若以下条件均成立，则 <code>r</code> 能保证监测到 <code>w</code>：</p><ol><li><code>w</code> 发生在 <code>r</code> 之前。</li><li>对共享变量 <code>v</code> 的其它任何写入操作都只能发生在 <code>w</code> 之前或 <code>r</code> 之后。</li></ol><p>这对条件的要求比第一个条件更强，它需要确保没有其它写入操作与 <code>w</code> 或 <code>r</code> 并发。<br>在单个 goroutine 当中这两个条件是等价的，因为单个 goroutine 中不存在并发，在多个 goroutine 中就必须使用同步语义来确保顺序，这样才能到保证能够监测到预期的写入<br><strong>单个 goroutine 的情况</strong>：<br>我们可以发现在单个 goroutine 当中，读取操作 r 总是可以读取到上一次 w 写入的值的<br><img src="https://lailin.xyz/images/1608372439492-359ad5bf-1b06-4f4f-ae77-84e96d9f6a7f.png" srcset="/img/loading.gif" alt="image.png"><br><strong>多个 goroutine 的情况</strong>:<br>但是存在多个 goroutine 的时候这个就不一定了，r0 读到的是 哪一次写入的值呢？如果看图的话像是 w4 的，但其实不一定，因为图中的两个 goroutine 所表达的时间维度可能是不一致的，所以 r0 可能读到的是 w0 w3 w4 甚至是 w5 的结果，当然按照我们前面说的理论，读到的不可能是 w1 的结果的<br><img src="https://lailin.xyz/images/1608372753766-f3b66fe5-ac34-4f5e-a1b2-c74e7d3dfbc9.png" srcset="/img/loading.gif" alt="image.png"><br><strong>添加一些同步点</strong><br>如下图所示我们通过 sync 包中的一些同步语义或者是 channel 为多个 goroutine 加入了 同步点，那么这个时候对于 r1 而言，他就是晚于 w4 并且早于 w1 和 w5 执行的，所以它读取到的是写入操作是可以确定的，是 w4<br><img src="https://lailin.xyz/images/1608373281116-271c756e-386e-490b-aa7b-0fb2b741ed40.png" srcset="/img/loading.gif" alt="image.png"></p><blockquote><p>The initialization of variable <code>v</code> with the zero value for <code>v</code>‘s type behaves as a write in the memory model.</p></blockquote><p>以变量 <code>v</code> 所属类型的零值来对 <code>v</code> 进行初始化，其表现如同在内存模型中进行的写入操作。</p><h4 id="机器字"><a href="#机器字" class="headerlink" title="机器字"></a>机器字</h4><blockquote><p>Reads and writes of values larger than a single machine word behave as multiple machine-word-sized operations in an unspecified order.</p></blockquote><p>对大于单个机器字的值进行读取和写入，其表现如同以不确定的顺序对多个机器字大小的值进行操作。要理解这个我们首先要理解什么是机器字。<br>我们现在常见的还有 32 位系统和 64 位的系统，cpu 在执行一条指令的时候对于单个机器字长的的数据的写入可以保证是原子的，对于 32 位的就是 4 个字节，对于 64 位的就是 8 个字节，对于在 32 位情况下去写入一个 8 字节的数据时就需要执行两次写入操作，这两次操作之间就没有原子性，那就可能出现先写入后半部分的数据再写入前半部分，或者是写入了一半数据然后写入失败的情况。<br>也就是说虽然有时候我们看着仅仅只做了一次写入但是还是会有并发问题，因为它本身不是原子的</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><blockquote><p>Program initialization runs in a single goroutine, but that goroutine may create other goroutines, which run concurrently.<br>If a package <code>p</code> imports package <code>q</code>, the completion of <code>q</code>‘s <code>init</code> functions happens before the start of any of <code>p</code>‘s.<br>The start of the function <code>main.main</code> happens after all <code>init</code> functions have finished.</p></blockquote><ul><li>程序的初始化运行在单个 goroutine 中，但该 goroutine 可能会创建其它并发运行的 goroutine</li><li>若包 p 导入了包 q，则 q 的 init 函数会在 p 的任何函数启动前完成。</li><li>函数 main.main 会在所有的 init 函数结束后启动。<div style="background:#fffbe6;padding:10px;border:1px solid #c3c3c3;border-radius:5px;margin-bottom:5px">注意: 在实际的应用代码中不要隐式的依赖这个启动顺序</div></li></ul><h4 id="goroutine-的创建"><a href="#goroutine-的创建" class="headerlink" title="goroutine 的创建"></a>goroutine 的创建</h4><blockquote><p>The <code>go</code> statement that starts a new goroutine happens before the goroutine’s execution begins.</p></blockquote><p><code>go</code> 语句会在当前 goroutine 开始执行前启动新的 goroutine</p><h4 id="goroutine-的销毁"><a href="#goroutine-的销毁" class="headerlink" title="goroutine 的销毁"></a>goroutine 的销毁</h4><blockquote><p>The exit of a goroutine is not guaranteed to happen before any event in the program。</p></blockquote><p>goroutine 无法确保在程序中的任何事件发生之前退出</p><p>注意 <a href="https://golang.org/ref/mem" target="_blank" rel="noopener">《The Go Memory Model》</a>原文中还有关于 channel， 锁相关的阐述，因为篇幅原因在本文中就不多讲了，后面我们还有单独的文章详细讲 channel 和 锁 相关的使用，在强调一遍，原文一定要多看几遍</p><h2 id="内存重排"><a href="#内存重排" class="headerlink" title="内存重排"></a>内存重排</h2><p>在上面我们讲到了编译器重排，以及在最开始的例子中我们提到了可能会存在 <code>2 0</code> 这个答案，接下来我们就来看看为什么。如果大家购买电脑的时候有去对比 cpu 的话应该可以看到，每个 cpu 都会写一下一级缓存，二级缓存，三级缓存的大小，这个缓存就是这里的一个关键点，一般而言，越往下缓存的大小越大速度越慢，这是 cpu 为了提高执行速度做的缓存体系，就像我们平时在应用当中引入 redis 作为缓存类似，都是为了加速。同时这就会带来一些数据不一致的问题。<br><img src="https://lailin.xyz/images/1608385154319-591875fe-fc6f-457f-8fd0-966b8e603310.png" srcset="/img/loading.gif" alt="02_Go进阶03_blog_img.drawio-第 4 页.png"><br><strong>如上图所示：</strong></p><ol><li>C1 执行 a = 1 将 store buffer 中 a 的值写为 1</li><li>C1 执行 b = 2 将 store buffer 中 b 的值写为 2, 然后由于某种原因将 b 的值写入到了内存中</li><li>C2 去读取 b 的值，发现缓存中没有，就去内存中读，这时候 print 出来 2</li><li>C2 去读取 a 的值，发现缓存中没有，就去内存中读，这时候 print 出来 0</li></ol><p>了解到这里之后可能会有一些疑问，既然会存在这种不确定性，我们有没有什么办法去保证一致呢？CPU 的一致性具体又是怎么回事？<br>保证一致从程序上来讲我们必须使用同步语义的工具确保一致，如果深入到底层的话就是使用 cpu 提供的内存屏障命令，保证所有对内存的操作都必须要“扩散”到 memory 之后才能继续执行其他对 memory 的操作。<br>CPU 一致性的原理建议看一下 MSI(E)协议的实现，我在参考文献中列出的最后两篇文章讲的已经比较通俗易懂了，在本文就不再叙述</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>Go 的并发编程非常的简单，只需要使用 go func 就能启动一个新的协程，但是并发编程本身就是很容易出现 bug 的，而且由于并发导致的 bug 还不太容易发现，所以我们在写并发逻辑的时候一定要非常小心，用官方的一句话就是<strong>使用显示的同步</strong></li><li>本文更多是抛砖引玉这里面提到了很多有意思的名词都值得好好研究</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a> 官方文档一定要多读几遍</li><li><a href="https://go-zh.org/ref/mem" target="_blank" rel="noopener">https://go-zh.org/ref/mem</a> 官方文档的中文翻译，英文比较吃力可以看这篇</li><li><a href="https://qcrao.com/2019/06/17/cch-says-memory-reorder/" target="_blank" rel="noopener">https://qcrao.com/2019/06/17/cch-says-memory-reorder/</a></li><li><a href="https://cch123.github.io/ooo/" target="_blank" rel="noopener">https://cch123.github.io/ooo/</a></li><li><a href="https://www.cs.utexas.edu/~bornholt/post/memory-models.html" target="_blank" rel="noopener">https://www.cs.utexas.edu/~bornholt/post/memory-models.html</a></li><li><a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%AD%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%AD%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a>&gt;)</li><li><a href="https://zhuanlan.zhihu.com/p/65245043" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/65245043</a></li><li><a href="https://zhuanlan.zhihu.com/p/94811032" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/94811032</a></li></ul><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新</h2><p>看到这里了还不关注点赞走一波</p><ul><li><a href="https://lailin.xyz">博客</a> 可以订阅 RSS</li><li><a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a> Follow me</li><li><a href="https://www.zhihu.com/people/mo-hui-shou-76" target="_blank" rel="noopener">知乎</a> 关注账号，顺便点个 👍</li><li><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a> 订阅订阅号，顺便点个 👍</li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li><li><a href="https://lailin.xyz/post/go-training-03.html">Week02: Go错误处理最佳实践</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Go并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Week03: Go并发编程(一) goroutine</title>
    <link href="/post/go-training-week3-goroutine.html"/>
    <url>/post/go-training-week3-goroutine.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为极客时间 Go 进阶训练营笔记，同步直播更新，预计一周更新 1 ~ 2 篇文章，到 202103 月更新完成</p></blockquote><p>接下来会一共会有 4 - 6 篇文章讲解 Go 并发编程，并发编程本身是一个挺大的话题，在第四周的两节课，毛老师花了将近 7 个小时讲解这些内容，我也结合自己的一些微不足道的经验，再加上一些大神们的文章，整理出了这一部分的笔记。<br>当然这里更多的是抛砖引玉的作用，更多的还是我们自己要有相关的意识避免踩坑，在各个坑的边缘反复横跳，可能我们有缘会在同一个坑中发现，咦，原来你也在这里 😄</p><h2 id="请对你创建的-goroutine-负责"><a href="#请对你创建的-goroutine-负责" class="headerlink" title="请对你创建的 goroutine 负责"></a>请对你创建的 goroutine 负责</h2><h3 id="不要创建一个你不知道何时退出的-goroutine"><a href="#不要创建一个你不知道何时退出的-goroutine" class="headerlink" title="不要创建一个你不知道何时退出的 goroutine"></a>不要创建一个你不知道何时退出的 goroutine</h3><p>请阅读下面这段代码，看看有什么问题？</p><blockquote><p>为什么先从下面这段代码出发，是因为在之前的经验里面我们写了大量类似的代码，之前没有意识到这个问题，并且还因为这种代码出现过短暂的事故</p></blockquote><pre><code class="hljs go"><span class="hljs-comment">// Week03/blog/01/01.go</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"log"</span><span class="hljs-string">"net/http"</span>_ <span class="hljs-string">"net/http/pprof"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 这里面有一些初始化的操作</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;setup()<span class="hljs-comment">// 主服务</span>server()<span class="hljs-comment">// for debug</span>pprof()<span class="hljs-keyword">select</span> &#123;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;mux := http.NewServeMux()mux.HandleFunc(<span class="hljs-string">"/ping"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">"pong"</span>))&#125;)<span class="hljs-comment">// 主服务</span><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">":8080"</span>, mux); err != <span class="hljs-literal">nil</span> &#123;log.Panicf(<span class="hljs-string">"http server err: %+v"</span>, err)<span class="hljs-keyword">return</span>&#125;&#125;()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pprof</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 辅助服务，监听了其他端口，这里是 pprof 服务，用于 debug</span><span class="hljs-keyword">go</span> http.ListenAndServe(<span class="hljs-string">":8081"</span>, <span class="hljs-literal">nil</span>)&#125;</code></pre><p>灵魂拷问来了，请问：</p><ul><li>如果 <code>server</code> 是在其他包里面，如果没有特殊说明，你知道这是一个异步调用么？</li><li><code>main</code> 函数当中最后在哪里空转干什么？会不会存在浪费？</li><li>如果线上出现事故，debug 服务已经退出，你想要 debug 这时你是否很茫然？</li><li>如果某一天服务突然重启，你却找不到事故日志，你是否能想起这个 <code>8081</code> 端口的服务？</li></ul><h4 id="请将选择权留给对方，不要帮别人做选择"><a href="#请将选择权留给对方，不要帮别人做选择" class="headerlink" title="请将选择权留给对方，不要帮别人做选择"></a>请将选择权留给对方，不要帮别人做选择</h4><p>请把是否并发的选择权交给你的调用者，而不是自己就直接悄悄的用上了 goroutine<br>下面这次改动将两个函数是否并发操作的选择权留给了 main 函数</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"log"</span><span class="hljs-string">"net/http"</span>_ <span class="hljs-string">"net/http/pprof"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 这里面有一些初始化的操作</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;setup()<span class="hljs-comment">// for debug</span><span class="hljs-keyword">go</span> pprof()<span class="hljs-comment">// 主服务</span><span class="hljs-keyword">go</span> server()<span class="hljs-keyword">select</span> &#123;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">()</span></span> &#123;mux := http.NewServeMux()mux.HandleFunc(<span class="hljs-string">"/ping"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">"pong"</span>))&#125;)<span class="hljs-comment">// 主服务</span><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">":8080"</span>, mux); err != <span class="hljs-literal">nil</span> &#123;log.Panicf(<span class="hljs-string">"http server err: %+v"</span>, err)<span class="hljs-keyword">return</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pprof</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 辅助服务，监听了其他端口，这里是 pprof 服务，用于 debug</span>http.ListenAndServe(<span class="hljs-string">":8081"</span>, <span class="hljs-literal">nil</span>)&#125;</code></pre><h4 id="请不要作为一个旁观者"><a href="#请不要作为一个旁观者" class="headerlink" title="请不要作为一个旁观者"></a>请不要作为一个旁观者</h4><p>一般情况下，不要让主进程成为一个旁观者，明明可以干活，但是最后使用了一个 <code>select</code> 在那儿空跑<br>感谢上一步将是否异步的选择权交给了我( <code>main</code> )，在旁边看着也怪尴尬的</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"log"</span><span class="hljs-string">"net/http"</span>_ <span class="hljs-string">"net/http/pprof"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 这里面有一些初始化的操作</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;setup()<span class="hljs-comment">// for debug</span><span class="hljs-keyword">go</span> pprof()<span class="hljs-comment">// 主服务</span>server()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">()</span></span> &#123;mux := http.NewServeMux()mux.HandleFunc(<span class="hljs-string">"/ping"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">"pong"</span>))&#125;)<span class="hljs-comment">// 主服务</span><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">":8080"</span>, mux); err != <span class="hljs-literal">nil</span> &#123;log.Panicf(<span class="hljs-string">"http server err: %+v"</span>, err)<span class="hljs-keyword">return</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pprof</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 辅助服务，监听了其他端口，这里是 pprof 服务，用于 debug</span>http.ListenAndServe(<span class="hljs-string">":8081"</span>, <span class="hljs-literal">nil</span>)&#125;</code></pre><h4 id="不要创建一个你永远不知道什么时候会退出的-goroutine"><a href="#不要创建一个你永远不知道什么时候会退出的-goroutine" class="headerlink" title="不要创建一个你永远不知道什么时候会退出的 goroutine"></a>不要创建一个你永远不知道什么时候会退出的 goroutine</h4><p>我们再做一些改造，使用 <code>channel</code> 来控制，解释都写在代码注释里面了</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"context"</span><span class="hljs-string">"fmt"</span><span class="hljs-string">"log"</span><span class="hljs-string">"net/http"</span>_ <span class="hljs-string">"net/http/pprof"</span><span class="hljs-string">"time"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 这里面有一些初始化的操作</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;setup()<span class="hljs-comment">// 用于监听服务退出</span>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> error, <span class="hljs-number">2</span>)<span class="hljs-comment">// 用于控制服务退出，传入同一个 stop，做到只要有一个服务退出了那么另外一个服务也会随之退出</span>stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">0</span>)<span class="hljs-comment">// for debug</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;done &lt;- pprof(stop)&#125;()<span class="hljs-comment">// 主服务</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;done &lt;- app(stop)&#125;()<span class="hljs-comment">// stoped 用于判断当前 stop 的状态</span><span class="hljs-keyword">var</span> stoped <span class="hljs-keyword">bool</span><span class="hljs-comment">// 这里循环读取 done 这个 channel</span><span class="hljs-comment">// 只要有一个退出了，我们就关闭 stop channel</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">cap</span>(done); i++ &#123;<span class="hljs-keyword">if</span> err := &lt;-done; err != <span class="hljs-literal">nil</span> &#123;log.Printf(<span class="hljs-string">"server exit err: %+v"</span>, err)&#125;<span class="hljs-keyword">if</span> !stoped &#123;stoped = <span class="hljs-literal">true</span><span class="hljs-built_in">close</span>(stop)&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">app</span><span class="hljs-params">(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;mux := http.NewServeMux()mux.HandleFunc(<span class="hljs-string">"/ping"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">"pong"</span>))&#125;)<span class="hljs-keyword">return</span> server(mux, <span class="hljs-string">":8080"</span>, stop)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pprof</span><span class="hljs-params">(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-comment">// 注意这里主要是为了模拟服务意外退出，用于验证一个服务退出，其他服务同时退出的场景</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;server(http.DefaultServeMux, <span class="hljs-string">":8081"</span>, stop)&#125;()time.Sleep(<span class="hljs-number">5</span> * time.Second)<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"mock pprof exit"</span>)&#125;<span class="hljs-comment">// 启动一个服务</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">(handler http.Handler, addr <span class="hljs-keyword">string</span>, stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;s := http.Server&#123;Handler: handler,Addr:    addr,&#125;<span class="hljs-comment">// 这个 goroutine 我们可以控制退出，因为只要 stop 这个 channel close 或者是写入数据，这里就会退出</span><span class="hljs-comment">// 同时因为调用了 s.Shutdown 调用之后，http 这个函数启动的 http server 也会优雅退出</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&lt;-stoplog.Printf(<span class="hljs-string">"server will exiting, addr: %s"</span>, addr)s.Shutdown(context.Background())&#125;()<span class="hljs-keyword">return</span> s.ListenAndServe()&#125;</code></pre><p>我们看一下返回结果，这个代码启动 5s 之后就会退出程序</p><pre><code class="hljs go">❯ <span class="hljs-keyword">go</span> run ./<span class="hljs-number">01</span>_goroutine/<span class="hljs-number">04</span><span class="hljs-number">2020</span>/<span class="hljs-number">12</span>/<span class="hljs-number">08</span> <span class="hljs-number">21</span>:<span class="hljs-number">49</span>:<span class="hljs-number">43</span> server exit err: mock pprof exit<span class="hljs-number">2020</span>/<span class="hljs-number">12</span>/<span class="hljs-number">08</span> <span class="hljs-number">21</span>:<span class="hljs-number">49</span>:<span class="hljs-number">43</span> server will exiting, addr: :<span class="hljs-number">8081</span><span class="hljs-number">2020</span>/<span class="hljs-number">12</span>/<span class="hljs-number">08</span> <span class="hljs-number">21</span>:<span class="hljs-number">49</span>:<span class="hljs-number">43</span> server will exiting, addr: :<span class="hljs-number">8080</span><span class="hljs-number">2020</span>/<span class="hljs-number">12</span>/<span class="hljs-number">08</span> <span class="hljs-number">21</span>:<span class="hljs-number">49</span>:<span class="hljs-number">43</span> server exit err: http: Server closed</code></pre><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>虽然我们已经经过了三轮优化，但是这里还是有一些需要注意的地方，可以思考一下怎么做</p><ul><li>虽然我们调用了 <code>Shutdown</code> 方法，但是我们其实并没有实现优雅退出，相信聪明的你可以完成这项工作。可以参考上一篇笔记：<a href="https://lailin.xyz/post/go-training-03.html">Go 错误处理最佳实践</a></li><li>在 <code>server</code> 方法中我们并没有处理 <code>panic</code> 的逻辑，这里需要处理么？如果需要那该如何处理呢？</li></ul><h3 id="不要创建一个永远都无法退出的-goroutine-goroutine-泄漏"><a href="#不要创建一个永远都无法退出的-goroutine-goroutine-泄漏" class="headerlink" title="不要创建一个永远都无法退出的 goroutine [goroutine 泄漏]"></a>不要创建一个永远都无法退出的 goroutine [goroutine 泄漏]</h3><p>再来看下面一个例子，这也是常常会用到的操作</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">leak</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>, <span class="hljs-number">0</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">"异步任务做一些操作"</span>)&lt;-ch&#125;()w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">"will leak"</span>))&#125;</code></pre><p>复用一下上面的 server 代码，我们经常会写出这种类似的代码</p><ul><li>http 请求来了，我们启动一个 goroutine 去做一些耗时一点的工作</li><li>然后返回了</li><li>然后之前创建的那个 <strong>goroutine 阻塞</strong>了</li><li>然后就泄漏了</li></ul><p>绝大部分的 goroutine 泄漏都是因为 goroutine 当中因为各种原因阻塞了，我们在外面也没有控制它退出的方式，所以就泄漏了，具体导致阻塞的常见原因会在接下来的 sync 包、channel 中讲到，这里就不过多赘述了<br>接下来我们验证一下是不是真的泄漏了<br>启动之后我们访问一下: <a href="http://localhost:8081/debug/pprof/goroutine?debug=1" target="_blank" rel="noopener">http://localhost:8081/debug/pprof/goroutine?debug=1</a> 查看当前的 goroutine 个数为 7</p><pre><code class="hljs go">goroutine profile: total <span class="hljs-number">7</span><span class="hljs-number">2</span> @ <span class="hljs-number">0x43b945</span> <span class="hljs-number">0x40814f</span> <span class="hljs-number">0x407d8b</span> <span class="hljs-number">0x770998</span> <span class="hljs-number">0x470381</span>#<span class="hljs-number">0x770997</span>main.server.func1+<span class="hljs-number">0x37</span>/home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">01</span>_goroutine/<span class="hljs-number">05</span>/<span class="hljs-number">05.</span><span class="hljs-keyword">go</span>:<span class="hljs-number">71</span></code></pre><p>然后我们再访问几次 <a href="http://localhost:8080/leak" target="_blank" rel="noopener">http://localhost:8080/leak</a> 可以发现 goroutine 增加到了 15 个，而且一直不会下降</p><pre><code class="hljs go">goroutine profile: total <span class="hljs-number">15</span><span class="hljs-number">7</span> @ <span class="hljs-number">0x43b945</span> <span class="hljs-number">0x40814f</span> <span class="hljs-number">0x407d8b</span> <span class="hljs-number">0x770ad0</span> <span class="hljs-number">0x470381</span>#<span class="hljs-number">0x770acf</span>main.leak.func1+<span class="hljs-number">0x8f</span>/home/ll/project/Go<span class="hljs-number">-000</span>/Week03/blog/<span class="hljs-number">01</span>_goroutine/<span class="hljs-number">05</span>/<span class="hljs-number">05.</span><span class="hljs-keyword">go</span>:<span class="hljs-number">83</span></code></pre><h3 id="确保创建出的-goroutine-的工作已经完成"><a href="#确保创建出的-goroutine-的工作已经完成" class="headerlink" title="确保创建出的 goroutine 的工作已经完成"></a>确保创建出的 goroutine 的工作已经完成</h3><p>这个其实就是优雅退出的问题，我们可能启动了很多的 goroutine 去处理一些问题，但是服务退出的时候我们并没有考虑到就直接退出了。例如退出前日志没有 flush 到磁盘，我们的请求还没完全关闭，异步 worker 中还有 job 在执行等等。<br>我们也来看一个例子，假设现在有一个埋点服务，每次请求我们都会上报一些信息到埋点服务上</p><pre><code class="hljs go"><span class="hljs-comment">// Reporter 埋点服务上报</span><span class="hljs-keyword">type</span> Reporter <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-keyword">var</span> reporter Reporter<span class="hljs-comment">// 模拟耗时</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r Reporter)</span> <span class="hljs-title">report</span><span class="hljs-params">(data <span class="hljs-keyword">string</span>)</span></span> &#123;time.Sleep(time.Second)fmt.Printf(<span class="hljs-string">"report: %s\n"</span>, data)&#125;mux.HandleFunc(<span class="hljs-string">"/ping"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;    <span class="hljs-comment">// 在请求中异步调用</span>    <span class="hljs-keyword">go</span> reporter.report(<span class="hljs-string">"ping pong"</span>)    fmt.Println(<span class="hljs-string">"ping"</span>)    w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">"pong"</span>))&#125;)</code></pre><p>我在发送了一次请求之后直接退出了，异步上报的逻辑根本没执行上</p><pre><code class="hljs go">❯ <span class="hljs-keyword">go</span> run ./<span class="hljs-number">01</span>_goroutine/<span class="hljs-number">06</span>ping^Csignal: interrupt</code></pre><p>这个有两种改法，一种是给 reporter 加上 shutdown 方法，类似 http 的 shutdown，等待所有的异步上报完成之后，我们再退出，另外一种是我们直接使用 一些 worker 来执行，在当然这个 worker 也要实现类似 shutdown 的方法。一般推荐后一种，因为这样可以避免请求量比较大时，创建大量 goroutine，当然如果请求量比较小，不会很大，用第一种也是可以的。<br>我们给一个第二种的简单实现，第一种可以参考 <a href="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html</a></p><pre><code class="hljs go"><span class="hljs-comment">// Reporter 埋点服务上报</span><span class="hljs-keyword">type</span> Reporter <span class="hljs-keyword">struct</span> &#123;worker   <span class="hljs-keyword">int</span>messages <span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>wg       sync.WaitGroupclosed   <span class="hljs-keyword">bool</span>&#125;<span class="hljs-comment">// NewReporter NewReporter</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewReporter</span><span class="hljs-params">(worker, buffer <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Reporter</span></span> &#123;<span class="hljs-keyword">return</span> &amp;Reporter&#123;worker: worker, messages: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, buffer)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reporter)</span> <span class="hljs-title">run</span><span class="hljs-params">(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&lt;-stopr.shutdown()&#125;()<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r.worker; i++ &#123;r.wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> r.messages &#123;time.Sleep(<span class="hljs-number">5</span> * time.Second)fmt.Printf(<span class="hljs-string">"report: %s\n"</span>, msg)&#125;r.wg.Done()&#125;()&#125;r.wg.Wait()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reporter)</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span> &#123;r.closed = <span class="hljs-literal">true</span><span class="hljs-comment">// 注意，这个一定要在主服务结束之后再执行，避免关闭 channel 还有其他地方在啊写入</span><span class="hljs-built_in">close</span>(r.messages)&#125;<span class="hljs-comment">// 模拟耗时</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reporter)</span> <span class="hljs-title">report</span><span class="hljs-params">(data <span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">if</span> r.closed &#123;<span class="hljs-keyword">return</span>&#125;r.messages &lt;- data&#125;</code></pre><p>然后在 main 函数中我们加上</p><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;    reporter.run(stop)    done &lt;- <span class="hljs-literal">nil</span>&#125;()</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下这一部分讲到的几个要点，这也是我们</p><ol><li><strong>请将是否异步调用的选择权交给调用者</strong>，不然很有可能大家并不知道你在这个函数里面使用了 goroutine</li><li>如果你要启动一个 goroutine 请对它负责<ol><li><strong>永远不要启动一个你无法控制它退出，或者你无法知道它何时推出的 goroutine</strong></li><li>还有上一篇提到的，启动 goroutine 时请加上 panic recovery 机制，避免服务直接不可用</li><li>造成 goroutine 泄漏的主要原因就是 goroutine 中造成了阻塞，并且没有外部手段控制它退出</li></ol></li><li><strong>尽量避免在请求中直接启动 goroutine 来处理问题</strong>，而应该通过启动 worker 来进行消费，这样可以避免由于请求量过大，而导致大量创建 goroutine 从而导致 oom，当然如果请求量本身非常小，那当我没说</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 这篇 dave 在 Qcon China 上的文章值得好好拜读几遍</li><li><a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html</a></li><li><a href="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html</a></li><li><a href="https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html</a></li></ul><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新</h2><p>看到这里了还不关注点赞走一波</p><ul><li><a href="https://lailin.xyz">博客</a> 可以订阅 RSS</li><li><a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a> Follow me</li><li><a href="https://www.zhihu.com/people/mo-hui-shou-76" target="_blank" rel="noopener">知乎</a> 关注账号，顺便点个 👍</li><li><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a> 订阅订阅号，顺便点个 👍</li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-03.html">Week02: Go错误处理最佳实践</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
      <category>Go并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Week02: Go错误处理最佳实践</title>
    <link href="/post/go-training-03.html"/>
    <url>/post/go-training-03.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为极客时间 Go 进阶训练营笔记，同步直播更新，预计一周更新 1 ~ 2 篇文章，到 202103 月更新完成</p></blockquote><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>太长不看系列，我们总结一下在 go 中 如何处理 error，具体的原因我们会在下面的内容中进行详细的解释</p><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><ol><li>在程序启动的时候，如果有强依赖的服务出现故障时 <code>panic</code> 退出</li><li>在程序启动的时候，如果发现有配置明显不符合要求， 可以 <code>panic</code> 退出（防御编程）</li><li>其他情况下只要不是不可恢复的程序错误，都不应该直接 <code>panic</code> 应该返回 <code>error</code></li><li>在程序入口处，例如 <code>gin</code> 中间件需要使用 <code>recovery</code> 预防 <code>panic</code> 程序退出</li><li>在程序中我们应该避免使用野生的 <code>goroutine</code><ol><li>如果是在请求中需要执行异步任务，应该使用异步 <code>worker</code> ，消息通知的方式进行处理，避免请求量大时大量 <code>goroutine</code> 创建</li><li>如果需要使用 <code>goroutine</code> 时，应该使用同一的 <code>Go</code> 函数进行创建，这个函数中会进行 <code>recovery</code> ，避免因为野生 <code>goroutine</code> panic 导致主进程退出</li></ol></li></ol><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Go</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span>&#123;    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;            <span class="hljs-keyword">if</span> err := recovery(); err != <span class="hljs-literal">nil</span> &#123;                log.Printf(<span class="hljs-string">"panic: %+v"</span>, err)            &#125;        &#125;()        f()    &#125;()&#125;</code></pre><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><ol><li>我们在应用程序中使用 <code>github.com/pkg/errors</code> 处理应用错误，<strong>注意在公共库当中，我们一般不使用这个</strong></li><li><code>error</code> 应该是函数的最后一个返回值，当 <code>error</code> 不为 <code>nil</code> 时，函数的其他返回值是不可用的状态，不应该对其他返回值做任何期待<ol><li><code>func f() (io.Reader, *S1, error)</code> 在这里，我们不知道 <code>io.Reader</code> 中是否有数据，可能有，也有可能有一部分</li></ol></li><li>错误处理的时候应该先判断错误， <code>if err != nil</code> 出现错误及时返回，使代码是一条流畅的直线，避免过多的嵌套</li></ol><pre><code class="hljs go"><span class="hljs-comment">// good case</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;    a, err := A()    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> err    &#125;    <span class="hljs-comment">// ... 其他逻辑</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// bad case</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;    a, err := A()    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;    <span class="hljs-comment">// 其他逻辑</span>    &#125;    <span class="hljs-keyword">return</span> err&#125;</code></pre><ol start="4"><li>在<strong>应用程序</strong>中出现错误时，使用 <code>errors.New</code> 或者 <code>errors.Errorf</code> 返回错误</li></ol><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *usecese)</span> <span class="hljs-title">usecase1</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;    money := u.repo.getMoney(uid)    <span class="hljs-keyword">if</span> money &lt; <span class="hljs-number">10</span> &#123;        errors.Errorf(<span class="hljs-string">"用户余额不足, uid: %d, money: %d"</span>, uid, money)    &#125;    <span class="hljs-comment">// 其他逻辑</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><ol start="5"><li>如果是调用<strong>应用程序的</strong>其他函数出现错误，请直接返回，如果需要携带信息，请使用 <code>errors.WithMessage</code></li></ol><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *usecese)</span> <span class="hljs-title">usecase2</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;    name, err := u.repo.getUserName(uid)    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> errors.WithMessage(err, <span class="hljs-string">"其他附加信息"</span>)    &#125;    <span class="hljs-comment">// 其他逻辑</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><ol start="6"><li>如果是调用其他库（标准库、企业公共库、开源第三方库等）获取到错误时，请使用 <code>errors.Wrap</code> 添加堆栈信息<ol><li>切记，不要每个地方都是用 <code>errors.Wrap</code> 只需要在错误第一次出现时进行 <code>errors.Wrap</code> 即可</li><li>根据场景进行判断是否需要将其他库的原始错误吞掉，例如可以把 <code>repository</code> 层的数据库相关错误吞掉，返回业务错误码，避免后续我们分割微服务或者更换 <code>ORM</code> 库时需要去修改上层代码</li><li>注意我们在基础库，被大量引入的第三方库编写时一般不使用 <code>errors.Wrap</code> 避免堆栈信息重复</li></ol></li></ol><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;    err := json.Unmashal(&amp;a, data)    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">"其他附加信息"</span>)    &#125;    <span class="hljs-comment">// 其他逻辑</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><ol start="7"><li><strong>禁止</strong>每个出错的地方都打日志，<strong>只需要</strong>在进程的最开始的地方使用 <code>%+v</code> 进行统一打印，例如 http/rpc 服务的中间件</li><li>错误判断使用 <code>errors.Is</code> 进行比较</li></ol><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;    err := A()    <span class="hljs-keyword">if</span> errors.Is(err, io.EOF)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    <span class="hljs-comment">// 其他逻辑</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><ol start="9"><li>错误类型判断，使用 <code>errors.As</code> 进行赋值</li></ol><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;    err := A()    <span class="hljs-keyword">var</span> errA errorA    <span class="hljs-keyword">if</span> errors.As(err, &amp;errA)&#123;    <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-comment">// 其他逻辑</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><ol start="10"><li>如何判定错误的信息是否足够，想一想当你的代码出现问题需要排查的时候你的错误信息是否可以帮助你快速的定位问题，例如我们在请求中一般会输出参数信息，用于辅助判断错误</li><li>对于业务错误，推荐在一个统一的地方创建一个错误字典，错误字典里面应该包含错误的 code，并且在日志中作为独立字段打印，方便做业务告警的判断，错误必须有清晰的错误文档</li><li>不需要返回，被忽略的错误<strong>必须</strong>输出日志信息</li><li>同一个地方不停的报错，最好不要不停输出错误日志，这样可能会导致被大量的错误日志信息淹没，无法排查问题，比较好的做法是打印一次错误详情，然后打印出错误出现的次数</li><li>对同一个类型的错误，采用相同的模式，例如参数错误，不要有的返回 404 有的返回 200</li><li>处理错误的时候，需要处理已分配的资源，使用 <code>defer</code> 进行清理，例如文件句柄</li></ol><h2 id="panic-or-error"><a href="#panic-or-error" class="headerlink" title="panic or error?"></a>panic or error?</h2><ol><li>在 Go 中 panic 会导致程序直接退出，是一个致命的错误，如果使用 <code>panic</code> <code>recovery</code> 进行处理的话，会存在很多问题<ol><li>性能问题，频繁 panic recovery 性能不好</li><li>容易导致程序异常退出，只要有一个地方没有处理到就会导致程序进程整个退出</li><li>不可控，一旦 panic 就将处理逻辑移交给了外部，我们并不能预设外部包一定会进行处理</li></ol></li><li>什么时候使用 panic 呢？<ol><li>对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic</li></ol></li><li>使用 error 处理有哪些好处？<ol><li>简单。</li><li>考虑失败，而不是成功(Plan for failure, not success)。</li><li>没有隐藏的控制流。</li><li>完全交给你来控制 error。</li><li>Error are values。</li></ol></li></ol><h2 id="为什么标准库中-errors-New-会返回一个指针"><a href="#为什么标准库中-errors-New-会返回一个指针" class="headerlink" title="为什么标准库中 errors.New 会返回一个指针"></a>为什么标准库中 errors.New 会返回一个指针</h2><p>翻看标准库的源代码我们可以发现， <code>errors</code> 库中的 <code>errorString</code> 结构体实现了 <code>error</code> 接口，为什么在 <code>New</code> 一个 error 的时候会返回一个结构体的指针呢？</p><pre><code class="hljs go"><span class="hljs-comment">// New returns an error that formats as the given text.</span><span class="hljs-comment">// Each call to New returns a distinct error value even if the text is identical.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> &amp;errorString&#123;text&#125;&#125;<span class="hljs-comment">// errorString is a trivial implementation of error.</span><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;s <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> e.s&#125;</code></pre><p>我们先来看一个例子，我们同样创建了 errorString 的结构体，我们自定义的和标准库中的唯一不同就是，自建的这个返回的是值，而不是指针。<br>在 <code>main</code> 函数的对比中我们就可以发现，我们自定义的 <code>errorString</code> 在对比的时候只要对应的字符串相同就会返回 true，但是标准库的包不会。<br>这是因为，在对比两个 struct 是否相同的时候，会去对比，这两个 struct 里面的各个字段是否是相同的，如果相同就返回 true，但是对比指针的时候会去判断两个指针的地址是否一致。<br><strong>如果字符串相等就返回 true 会导致什么问题呢？</strong><br>如果我有两个包定义了字符串相同的想个错误，在其他库调用对比的时候，可能会由于不同的书写顺序走进不同的分支导致一些不可预期的奇奇怪怪的错误</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;text <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e errorString)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> e.text&#125;<span class="hljs-comment">// New 创建一个自定义错误</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> errorString&#123;text: s&#125;&#125;<span class="hljs-keyword">var</span> errorString1 = New(<span class="hljs-string">"test a"</span>)<span class="hljs-keyword">var</span> err1 = errors.New(<span class="hljs-string">"test b"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> errorString1 == New(<span class="hljs-string">"test a"</span>) &#123;fmt.Println(<span class="hljs-string">"err string a"</span>) <span class="hljs-comment">// 会输出</span>&#125;<span class="hljs-keyword">if</span> err1 == errors.New(<span class="hljs-string">"test b"</span>) &#123;fmt.Println(<span class="hljs-string">"err b"</span>) <span class="hljs-comment">// 不会输出</span>&#125;&#125;</code></pre><h2 id="error-type-错误定义与判断"><a href="#error-type-错误定义与判断" class="headerlink" title="error type: 错误定义与判断"></a>error type: 错误定义与判断</h2><h3 id="Sentinel-Error"><a href="#Sentinel-Error" class="headerlink" title="Sentinel Error"></a>Sentinel Error</h3><p>哨兵错误，就是定义一些包级别的错误变量，然后在调用的时候外部包可以直接对比变量进行判定，在标准库当中大量的使用了这种方式<br>例如下方 <code>io</code> 库中定义的错误</p><pre><code class="hljs go"><span class="hljs-comment">// EOF is the error returned by Read when no more input is available.</span><span class="hljs-comment">// Functions should return EOF only to signal a graceful end of input.</span><span class="hljs-comment">// If the EOF occurs unexpectedly in a structured data stream,</span><span class="hljs-comment">// the appropriate error is either ErrUnexpectedEOF or some other error</span><span class="hljs-comment">// giving more detail.</span><span class="hljs-keyword">var</span> EOF = errors.New(<span class="hljs-string">"EOF"</span>)<span class="hljs-comment">// ErrUnexpectedEOF means that EOF was encountered in the</span><span class="hljs-comment">// middle of reading a fixed-size block or data structure.</span><span class="hljs-keyword">var</span> ErrUnexpectedEOF = errors.New(<span class="hljs-string">"unexpected EOF"</span>)<span class="hljs-comment">// ErrNoProgress is returned by some clients of an io.Reader when</span><span class="hljs-comment">// many calls to Read have failed to return any data or error,</span><span class="hljs-comment">// usually the sign of a broken io.Reader implementation.</span><span class="hljs-keyword">var</span> ErrNoProgress = errors.New(<span class="hljs-string">"multiple Read calls return no data or error"</span>)</code></pre><p>我们在外部判定的时候一般使用等值判定或者使用 <code>errors.Is</code> 进行判断</p><pre><code class="hljs go"><span class="hljs-keyword">if</span> err == io.EOF &#123;<span class="hljs-comment">//...</span>&#125;<span class="hljs-keyword">if</span> errors.Is(err, io.EOF)&#123;<span class="hljs-comment">//...</span>&#125;</code></pre><p>这种错误处理方式有一个问题是，将 error 当做包的 API 暴露给了第三方，这样会导致在做重构或者升级的时候很麻烦，并且这种方式包含的错误信息会十分的有限</p><h3 id="error-types"><a href="#error-types" class="headerlink" title="error types"></a>error types</h3><p>这个就类似我们前面定义的 <code>errorString</code> 一样实现了 <code>error</code> 的接口，然后在外部是否类型断言来判断是否是这种错误类型</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStruct <span class="hljs-keyword">struct</span> &#123;s <span class="hljs-keyword">string</span>    name <span class="hljs-keyword">string</span>    path <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// 使用的时候</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">switch</span> err.(<span class="hljs-keyword">type</span>) &#123;        <span class="hljs-keyword">case</span> *MyStruct:        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">case</span> others:        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre><p>这种方式相对于哨兵来说，可以包含更加丰富的信息，但是同样也将错误的类型暴露给了外部，例如标准库中的 <code>os.PathError</code></p><h3 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h3><p>不透明的错误处理，这种方式最大的特点就是只返回错误，暴露错误判定接口，不返回类型，这样可以减少 API 的暴露，后续的处理会比较灵活，这个一般用在公共库会比较好</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> temporary <span class="hljs-keyword">interface</span> &#123;Temporary() <span class="hljs-keyword">bool</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsTemporary</span><span class="hljs-params">(err error)</span> <span class="hljs-title">bool</span></span> &#123;te, ok := err.(temporary)<span class="hljs-keyword">return</span> ok &amp;&amp; te.Temporary()&#125;</code></pre><p>这种方式我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值</p><h2 id="error-handle-错误处理优化"><a href="#error-handle-错误处理优化" class="headerlink" title="error handle: 错误处理优化"></a>error handle: 错误处理优化</h2><p>在 go 中常常会存在大量的 <code>if err</code> 代码，下面介绍两种常见的减少这种代码的方式</p><h3 id="bufio-scan"><a href="#bufio-scan" class="headerlink" title="bufio.scan"></a>bufio.scan</h3><p>对比下面两个函数的处理我们可以发现， <code>count2</code> 使用 <code>sc.Scan</code> 之后一个 <code>if err</code> 的判断都没有，极大的简化了代码，这是因为在 <code>sc.Scan</code> 做了很多处理，像很多类似的，需要循环读取的都可以考虑像这样包装之后进行处理，这样外部包调用的时候就会非常简洁</p><pre><code class="hljs go"><span class="hljs-comment">// 统计文件行数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">count</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<span class="hljs-keyword">var</span> (br    = bufio.NewReader(r)lines <span class="hljs-keyword">int</span>err   error)<span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">// 读取到换行符就说明是一行</span>_, err = br.ReadString(<span class="hljs-string">'\n'</span>)lines++<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">break</span>&#125;&#125;<span class="hljs-comment">// 当错误是 EOF 的时候说明文件读取完毕了</span><span class="hljs-keyword">if</span> err != io.EOF &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err&#125;<span class="hljs-keyword">return</span> lines, err&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">count2</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<span class="hljs-keyword">var</span> (sc    = bufio.NewScanner(r)lines <span class="hljs-keyword">int</span>)<span class="hljs-keyword">for</span> sc.Scan() &#123;lines++&#125;<span class="hljs-keyword">return</span> lines, sc.Err()&#125;</code></pre><h3 id="error-writer"><a href="#error-writer" class="headerlink" title="error writer"></a>error writer</h3><p>看一个来自 go blog 的例子：<a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">https://blog.golang.org/errors-are-values</a><br>一般代码</p><pre><code class="hljs go">_, err = fd.Write(p0[a:b])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> err&#125;_, err = fd.Write(p1[c:d])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> err&#125;_, err = fd.Write(p2[e:f])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> err&#125;<span class="hljs-comment">// and so on</span></code></pre><p>errWriter</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> errWriter <span class="hljs-keyword">struct</span> &#123;    w   io.Writer    err error&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ew *errWriter)</span> <span class="hljs-title">write</span><span class="hljs-params">(buf []<span class="hljs-keyword">byte</span>)</span></span> &#123;    <span class="hljs-keyword">if</span> ew.err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    _, ew.err = ew.w.Write(buf)&#125;<span class="hljs-comment">// 使用时</span>ew := &amp;errWriter&#123;w: fd&#125;ew.write(p0[a:b])ew.write(p1[c:d])ew.write(p2[e:f])<span class="hljs-comment">// and so on</span><span class="hljs-keyword">if</span> ew.err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> ew.err&#125;</code></pre><p>如果去翻 标准库中 bufio.Writer 的源代码，你会发现也有这种用法，这种就是将重复的逻辑进行了封装，然后把 error 暂存，然后我们就只需要在最后判断一下 error 就行了</p><h2 id="wrap-error-错误包装"><a href="#wrap-error-错误包装" class="headerlink" title="wrap error: 错误包装"></a>wrap error: 错误包装</h2><h3 id="errors-wrap-有何作用，为什么不用标准库的-fmt-Errorf-quot-w-quot"><a href="#errors-wrap-有何作用，为什么不用标准库的-fmt-Errorf-quot-w-quot" class="headerlink" title="errors.wrap 有何作用，为什么不用标准库的 fmt.Errorf(&quot;%w&quot;)"></a>errors.wrap 有何作用，为什么不用标准库的 <code>fmt.Errorf(&quot;%w&quot;)</code></h3><p>我们先看一下标准库的源码，我们可以发现当 <code>p.wrappedErr != nil</code> 的时候（也就是有 %w）的时候，会使用一个 <code>wrapError</code> 将错误包装，看 <code>wrapError</code> 的源码可以发现，这个方法只是包装了一下原始错误，并且可以做到附加一些文本信息，但是没有堆栈信息。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;p := newPrinter()p.wrapErrs = <span class="hljs-literal">true</span>p.doPrintf(format, a)s := <span class="hljs-keyword">string</span>(p.buf)<span class="hljs-keyword">var</span> err error<span class="hljs-keyword">if</span> p.wrappedErr == <span class="hljs-literal">nil</span> &#123;err = errors.New(s)&#125; <span class="hljs-keyword">else</span> &#123;err = &amp;wrapError&#123;s, p.wrappedErr&#125;&#125;p.free()<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">type</span> wrapError <span class="hljs-keyword">struct</span> &#123;msg <span class="hljs-keyword">string</span>err error&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> e.msg&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span> <span class="hljs-title">Unwrap</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> e.err&#125;</code></pre><p>在看一下 pkg/errors 的源码，我肯可以发现除了使用 <code>withMessage</code> 附加了错误信息之外还使用 <code>withStack</code> 附加了堆栈信息，这样我们在程序入口处打印日志信息的时候就可以将堆栈信息一并打出了</p><pre><code class="hljs go"><span class="hljs-comment">// Wrap returns an error annotating err with a stack trace</span><span class="hljs-comment">// at the point Wrap is called, and the supplied message.</span><span class="hljs-comment">// If err is nil, Wrap returns nil.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Wrap</span><span class="hljs-params">(err error, message <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;err = &amp;withMessage&#123;cause: err,msg:   message,&#125;<span class="hljs-keyword">return</span> &amp;withStack&#123;err,callers(),&#125;&#125;</code></pre><h3 id="为什么不允许处处使用-errors-Wrap"><a href="#为什么不允许处处使用-errors-Wrap" class="headerlink" title="为什么不允许处处使用 errors.Wrap"></a>为什么不允许处处使用 errors.Wrap</h3><p>因为每一次 <code>errors.Wrap</code> 的调用都会为错误添加堆栈信息，如果处处调用那会有大量的无用堆栈<br>我们先看一下只有一处 wrap</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">"err: %+v"</span>, c())&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> errors.Wrap(fmt.Errorf(<span class="hljs-string">"xxx"</span>), <span class="hljs-string">"test"</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> a()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> b()&#125;</code></pre><p>看结果我们可以发现已经可以打印出全部的堆栈信息了</p><pre><code class="hljs go">err: xxxtestmain.a        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>main.b        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">18</span>main.c        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span>main.main        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>runtime.main        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span>runtime.goexit        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span></code></pre><p>再看多处 wrap 的现象</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">"err: %+v"</span>, c())&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> errors.Wrap(fmt.Errorf(<span class="hljs-string">"xxx"</span>), <span class="hljs-string">"a"</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> errors.Wrap(a(), <span class="hljs-string">"b"</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> errors.Wrap(b(), <span class="hljs-string">"c"</span>)&#125;</code></pre><p>可以看到每一处 wrap 都添加了一次堆栈信息</p><pre><code class="hljs go">err: xxxamain.a        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>main.b        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">18</span>main.c        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span>main.main        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>runtime.main        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span>runtime.goexit        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span>bmain.b        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">18</span>main.c        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span>main.main        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>runtime.main        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span>runtime.goexit        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span>cmain.c        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span>main.main        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>runtime.main        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span>runtime.goexit        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span></code></pre><h2 id="标准库-errors-Is-As-怎么判断错误"><a href="#标准库-errors-Is-As-怎么判断错误" class="headerlink" title="标准库 errors.Is / As 怎么判断错误"></a>标准库 errors.Is / As 怎么判断错误</h2><h3 id="errors-Is"><a href="#errors-Is" class="headerlink" title="errors.Is"></a>errors.Is</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Is</span><span class="hljs-params">(err, target error)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> target == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err == target&#125;<span class="hljs-comment">// 通过反射判读 target 是否可以被比较</span>isComparable := reflectlite.TypeOf(target).Comparable()<span class="hljs-keyword">for</span> &#123;        <span class="hljs-comment">// 循环判断是否相等</span><span class="hljs-keyword">if</span> isComparable &amp;&amp; err == target &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;        <span class="hljs-comment">// 判断是否实现了 is 接口，如果有实现就直接判断</span><span class="hljs-keyword">if</span> x, ok := err.(<span class="hljs-keyword">interface</span>&#123; Is(error) <span class="hljs-keyword">bool</span> &#125;); ok &amp;&amp; x.Is(target) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">// 去判断是否实现了 unwrap 的接口，如果实现了就进行 unwrap</span><span class="hljs-keyword">if</span> err = Unwrap(err); err == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;&#125;</code></pre><h3 id="errors-As"><a href="#errors-As" class="headerlink" title="errors.As"></a>errors.As</h3><p>和 is 的逻辑类似，就是不断的进行 unwrap 进行比较，只要有一个相同就返回，如果一直到底都不行就返回 false</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">As</span><span class="hljs-params">(err error, target <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> target == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"errors: target cannot be nil"</span>)&#125;val := reflectlite.ValueOf(target)typ := val.Type()<span class="hljs-keyword">if</span> typ.Kind() != reflectlite.Ptr || val.IsNil() &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"errors: target must be a non-nil pointer"</span>)&#125;<span class="hljs-keyword">if</span> e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;&amp; !e.Implements(errorType) &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"errors: *target must be interface or implement error"</span>)&#125;targetType := typ.Elem()<span class="hljs-keyword">for</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> reflectlite.TypeOf(err).AssignableTo(targetType) &#123;val.Elem().Set(reflectlite.ValueOf(err))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">if</span> x, ok := err.(<span class="hljs-keyword">interface</span>&#123; As(<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">bool</span> &#125;); ok &amp;&amp; x.As(target) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;err = Unwrap(err)&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新</h2><p>看到这里了还不点个关注走一波</p><ul><li><a href="https://lailin.xyz">博客</a> 可以订阅 RSS</li><li><a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a> Follow me</li><li><a href="https://www.zhihu.com/people/mo-hui-shou-76" target="_blank" rel="noopener">知乎</a> 关注账号，顺便点个 👍</li><li><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a> 订阅订阅号，顺便点个 👍</li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>error</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Week01: 微服务(二) 服务发现&amp;多租户</title>
    <link href="/post/go-training-02.html"/>
    <url>/post/go-training-02.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为极客时间 Go 进阶训练营笔记，同步直播更新，预计一周更新 1 ~ 2 篇文章，到 202103 月更新完成</p></blockquote><p>上篇文章我们讲到微服务的定义，优缺点，对外暴露等，服务除了对外暴露之外，服务之间还需要相互进行调用，不同的服务之间通过什么样的协议进行交互，服务发现如何实现，如何保证服务的平滑发布与重启，测试环境的问题如何解决等。</p><h2 id="服务间通信方式-gRPC"><a href="#服务间通信方式-gRPC" class="headerlink" title="服务间通信方式: gRPC"></a>服务间通信方式: gRPC</h2><ul><li><strong>为什么采用 gRPC?</strong><ul><li><strong>多语言：</strong>语言中立，支持多种语言。</li><li><strong>轻量级、高性能：</strong>序列化支持 PB(Protocol Buffer)和 JSON，PB 是一种语言无关的高性能序列化框架。</li><li><strong>可插拔</strong></li><li><strong>IDL：</strong>基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub。</li><li>移动端：基于<strong>标准的 HTTP2 设计，支持双向流、消息头压缩、单 TCP 的多路复用</strong>、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加<strong>省电和节省网络流量</strong>。</li><li><strong>服务而非对象、消息而非引用：</strong>促进微服务的系统间粗粒度消息交互设计理念。</li><li><strong>负载无关的：</strong>不同的服务需要使用不同的消息类型和编码，例如 protocol buffers、JSON、XML 和 Thrift。</li><li>流：Streaming API。</li><li><strong>阻塞式和非阻塞式：</strong>支持异步和同步处理在客户端和服务端间交互的消息序列。</li><li><strong>元数据交换：</strong>常见的横切关注点，如认证或跟踪，依赖数据交换。<ul><li>metadata</li></ul></li><li><strong>标准化状态码：</strong>客户端通常以有限的方式响应 API 调用返回的错误。</li></ul></li><li><strong>为什么不使用 restful</strong><ul><li>每个客户端都需要单独写 SDK，复杂麻烦</li><li>需要单独写文档，常常会因为代码更新了但是文档没更新陷入坑中</li><li>性能不太好，json 传递相对于 pb 更耗流量，性能更低</li><li>http1.1 是一个单连接的请求，在内部网络环境，使用 http 比较浪费</li><li><strong>restful 是一个松散约束的协议，非常灵活，每个人，每个团队出来的代码都不太一样，比较容易出错</strong></li></ul></li></ul><h2 id="优雅启动与优雅中止（健康检查）"><a href="#优雅启动与优雅中止（健康检查）" class="headerlink" title="优雅启动与优雅中止（健康检查）"></a>优雅启动与优雅中止（健康检查）</h2><h3 id="优雅启动"><a href="#优雅启动" class="headerlink" title="优雅启动"></a>优雅启动</h3><p><img src="https://lailin.xyz/images/1606735520428-1f37cd30-225e-4b2c-a104-7ba3bbfe17c2.svg" srcset="/img/loading.gif" alt="01_Go进阶训练营_微服务_v1.svg"></p><ol><li>Provider 启动，k8s 中的启动脚本会定时去检查服务的健康检查接口</li><li>健康检查通过之后，服务注册脚本向注册中心注册服务（rpc://ip:port）</li><li>消费者定时从服务注册中心获取服务方地址信息</li><li>获取成功后，会定时的向服务方发起健康检查，健康检查通过后才会向这个地址发起请求<ol><li>在运行过程中如果健康检查出现问题，会从消费者本地的负载均衡中移除</li></ol></li></ol><h3 id="优雅中止"><a href="#优雅中止" class="headerlink" title="优雅中止"></a>优雅中止</h3><p><img src="https://lailin.xyz/images/1606742744880-38b16366-6370-408b-8619-7a67d56c0c49.svg" srcset="/img/loading.gif" alt="01_Go进阶训练营_微服务_v1.drawio.svg"></p><ol><li>触发下线操作: 首先用户在发布平台点击发版/下线按钮</li><li>发布部署平台向注册中心发起服务注销请求，在注册中心下线服务的这个节点<ul><li>这里在发布部署平台实现有个好处，不用每个应用都去实现一遍相同的逻辑</li><li>在应用受到退出信号之后由应用主动发起注销操作也是可以的</li></ul></li></ol><ul><li>2.1 注册中心下线应用之后，消费者会获取到服务注销的事件，然后将服务方的节点从本地负载均衡当中移除<ol><li>注意这一步操作会有一段时间，下面的第四步并不是这一步结束了才开始</li></ol></li></ul><ol start="3"><li>发布部署平台向应用发送 <code>SIGTERM</code> 信号，应用捕获到之后执行<ol><li>将健康检查接口设置为不健康，返回错误<ol><li>这个时候如果消费者还在调用应用程序，调用健康检查接口发现无法通过，也会将服务节点从本地负载均衡当中移除</li></ol></li><li>调用 grpc/http 的 shutdown 接口，并且传递超时时间，等待连接全部关闭后退出<ol><li>这个超时时间一般为 2 个心跳周期</li></ol></li></ol></li><li>发布部署平台如果发现应用程序长时间没有完成退出，发送 <code>SIGKILL</code> 强制退出应用<ol><li>这个超时时间根据应用进行设置一般为 10 - 60s</li></ol></li></ol><h3 id="实战-在-gin-中实现优雅启动和优雅中止"><a href="#实战-在-gin-中实现优雅启动和优雅中止" class="headerlink" title="实战-在 gin 中实现优雅启动和优雅中止"></a>实战-在 gin 中实现优雅启动和优雅中止</h3><p>源码可以在这里找到<br><a href="https://github.com/mohuishou/Go-000/tree/main/Week01" target="_blank" rel="noopener">https://github.com/mohuishou/Go-000/tree/main/Week01</a></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"context"</span><span class="hljs-string">"log"</span><span class="hljs-string">"net/http"</span><span class="hljs-string">"os"</span><span class="hljs-string">"os/signal"</span><span class="hljs-string">"syscall"</span><span class="hljs-string">"time"</span><span class="hljs-string">"github.com/gin-gonic/gin"</span>)<span class="hljs-comment">// 模拟慢请求</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sleep</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;t := ctx.Query(<span class="hljs-string">"t"</span>)s, err := strconv.Atoi(t)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;ctx.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">"msg"</span>: <span class="hljs-string">"参数错误: "</span> + t&#125;)<span class="hljs-keyword">return</span>&#125;time.Sleep(time.Duration(s) * time.Second)ctx.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">"msg"</span>: fmt.Sprintf(<span class="hljs-string">"sleep %d s"</span>, s)&#125;)&#125;<span class="hljs-keyword">const</span> (stateHealth   = <span class="hljs-string">"health"</span>stateUnHealth = <span class="hljs-string">"unhealth"</span>)<span class="hljs-keyword">var</span> state = stateHealth<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">health</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;status := http.StatusOK<span class="hljs-keyword">if</span> state == stateUnHealth &#123;status = http.StatusServiceUnavailable&#125;ctx.JSON(status, gin.H&#123;<span class="hljs-string">"data"</span>: state&#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;e := gin.Default()e.GET(<span class="hljs-string">"/health"</span>, health)e.GET(<span class="hljs-string">"/sleep"</span>, sleep)server := &amp;http.Server&#123;Addr:    <span class="hljs-string">":8080"</span>,Handler: e,&#125;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> err := server.ListenAndServe(); err != <span class="hljs-literal">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;log.Fatalf(<span class="hljs-string">"server run err: %+v"</span>, err)&#125;&#125;()<span class="hljs-comment">// 用于捕获退出信号</span>quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal)<span class="hljs-comment">// kill (no param) default send syscall.SIGTERM</span><span class="hljs-comment">// kill -2 is syscall.SIGINT</span><span class="hljs-comment">// kill -9 is syscall.SIGKILL but can't be catch, so don't need add it</span>signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)&lt;-quitlog.Println(<span class="hljs-string">"Shutting down server..."</span>)<span class="hljs-comment">// 捕获到退出信号之后将健康检查状态设置为 unhealth</span>state = stateUnHealthlog.Println(<span class="hljs-string">"Shutting down state: "</span>, state)<span class="hljs-comment">// 设置超时时间，两个心跳周期，假设一次心跳 3s</span>ctx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">6</span>*time.Second)<span class="hljs-keyword">defer</span> cancel()<span class="hljs-comment">// Shutdown 接口，如果没有新的连接了就会释放，传入超时 context</span><span class="hljs-comment">// 调用这个接口会关闭服务，但是不会中断活动连接</span><span class="hljs-comment">// 首先会将端口监听移除</span><span class="hljs-comment">// 然后会关闭所有的空闲连接</span><span class="hljs-comment">// 然后等待活动的连接变为空闲后关闭</span><span class="hljs-comment">// 如果等待时间超过了传入的 context 的超时时间，就会强制退出</span><span class="hljs-comment">// 调用这个接口 server 监听端口会返回 ErrServerClosed 错误</span><span class="hljs-comment">// 注意，这个接口不会关闭和等待websocket这种被劫持的链接，如果做一些处理。可以使用 RegisterOnShutdown 注册一些清理的方法</span><span class="hljs-keyword">if</span> err := server.Shutdown(ctx); err != <span class="hljs-literal">nil</span> &#123;log.Fatal(<span class="hljs-string">"Server forced to shutdown:"</span>, err)&#125;log.Println(<span class="hljs-string">"Server exiting"</span>)&#125;</code></pre><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p><img src="https://lailin.xyz/images/1606744144537-0fe881ca-5716-4b80-8800-0dee0a266c5f.png" srcset="/img/loading.gif" alt="image.png"></p><h3 id="客户端发现"><a href="#客户端发现" class="headerlink" title="客户端发现"></a>客户端发现</h3><ul><li>直连，比服务端服务发现少一次网络跳转</li><li>Consumer 需要内置特定的服务发现客户端和发现逻辑<ul><li>可以将负载均衡逻辑下放到 sidecar 中进行解耦</li></ul></li></ul><h3 id="服务端发现"><a href="#服务端发现" class="headerlink" title="服务端发现"></a>服务端发现</h3><ul><li>Consumer 无需关注服务发现具体细节，只需知道服务的 DNS 域名即可</li><li>支持异构语言开发，需要基础设施支撑，多了一次网络跳转，可能有性能损失，基础设施会比较复杂<blockquote><p>B 站这边采用的是客户端发现的模式，我们公司用的更多的是服务端发现的模式</p></blockquote></li></ul><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p><strong>CP、CA、还是 AP</strong><br>实际场景是海量服务发现和注册，服务状态可以弱一致, 需要的是 AP 系统，只需最终一致性即可</p><ul><li>注册的事件延迟<ul><li>高可用的服务在这方面问题不大</li></ul></li><li>注销的事件延迟<ul><li>因为有上文提到的健康检查的机制，即使注销延迟，客户端也会主动的将节点移除</li></ul></li><li>相关文档<ul><li>多个注册中心的对比：<a href="https://developer.aliyun.com/article/698930" target="_blank" rel="noopener">https://developer.aliyun.com/article/698930</a></li><li><a href="https://nacos.io/zh-cn/index.html" target="_blank" rel="noopener">https://nacos.io/zh-cn/index.html</a> 阿里开源的注册中心，毛老师推荐 😂</li></ul></li></ul><p><strong>eureka 实现原理</strong></p><blockquote><p>b 站仿照用 go 写了一个 <a href="https://github.com/bilibili/discovery" target="_blank" rel="noopener">https://github.com/bilibili/discovery</a></p></blockquote><p><strong><img src="https://lailin.xyz/images/1606745349658-c7638390-9cbd-4eca-b2ad-4baa15449c3f.png" srcset="/img/loading.gif" alt="image.png"></strong></p><ul><li>服务注册<ul><li><strong>注册：</strong>服务方启动后向注册中心任意一个节点发送注册请求，然后这个节点会向其他节点进行广播同步</li><li><strong>心跳：</strong>注册后定期（30s）向注册中心发送心跳</li><li><strong>下线：</strong>下线时向注册中心发送下线请求</li><li>注意：注册中心节点启东市需要加载缓存进行预热，所以不建议这个时候服务进行重启或者是发版</li></ul></li><li>服务发现<ul><li>消费者定期向注册中心长轮训获取节点信息，获取到之后缓存到本地</li></ul></li><li><strong>网络故障</strong><ul><li>服务方与注册中心<ul><li>注册中心会定期（60s）检测已失效（90s 未更新）的实例，失效之后就会移除，但是如果短时间内丢失大量心跳连接，（15min 内心跳低于期望值的 85%）就会开启自我保护模式，保留过期的服务不会进行删除</li></ul></li><li>注册中心与消费者<ul><li>消费者本地有缓存，问题不大</li></ul></li><li>服务方与消费者<ul><li>有健康检查，健康检查不通过时，会从消费者本地负载均衡中移除</li></ul></li></ul></li><li><strong>注册中心故障</strong><ul><li>不建议这个时候服务进行重启或者是发版，因为这个时候注册不上，会导致服务不可用，不发版短时间没有影响</li><li>如果全部挂掉，启动时必须要等两到三个心跳周期，等所有的服务都注册上之后再开始提供服务运行消费者拉取数据</li><li>如果挂掉一个，需要等其他的节点将信息同步到本机之后再提供服务</li><li>数据同步时会对比时间戳，会保证当前节点的数据是最新的</li></ul></li></ul><h2 id="多集群"><a href="#多集群" class="headerlink" title="多集群"></a>多集群</h2><blockquote><p>注意这里的多集群都是单个机房内的</p></blockquote><h3 id="多集群需求从何而来？"><a href="#多集群需求从何而来？" class="headerlink" title="多集群需求从何而来？"></a>多集群需求从何而来？</h3><p>对于类似账号服务的 L0 级别的服务，几乎所有的服务都有依赖，需要尽可能的提高服务的可用性</p><ul><li>从单一集群考虑，多个节点保证可用性，我们通常使用 N+2 的方式来冗余节点。<ul><li>N 一般通过压测得出</li></ul></li><li>从单一集群故障带来的影响面角度考虑冗余多套集群。<ul><li>例如依赖的 redis 出现问题，整个集群挂掉了</li></ul></li><li>单个机房内的机房故障导致的问题<ul><li>多机房部署，如果在云上可能是多个可用区</li></ul></li></ul><h3 id="什么是多集群？"><a href="#什么是多集群？" class="headerlink" title="什么是多集群？"></a>什么是多集群？</h3><ul><li>给某个服务部署多套，每一套都拥有独立的缓存，物理上相当于有多套资源，逻辑上划分为不同的集群，在服务注册的时候向注册中心注册的时候携带相关的集群标签</li></ul><h3 id="如何降低健康检查流量"><a href="#如何降低健康检查流量" class="headerlink" title="如何降低健康检查流量"></a>如何降低健康检查流量</h3><p>对于账号这种大量服务依赖的服务，仅仅是健康检查流量就会导致 30%以上的资源占用（B 站之前的真实情况）<br>可以使用子集算法，将后端的节点均分给所有的客户端</p><ul><li>通常 20-100 个后端，部分场景需要大子集，比如大批量读写操作。</li><li>后端平均分给客户端。</li><li>客户端重启，保持重新均衡，同时对后端重启保持透明，同时连接的变动最小<ul><li>消费者变化的时候需要 重新平衡</li></ul></li></ul><pre><code class="hljs go"><span class="hljs-comment">// from google sre</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Subset</span><span class="hljs-params">(backends []<span class="hljs-keyword">string</span>, clientID, subsetSize <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">string</span></span> &#123;subsetCount := <span class="hljs-built_in">len</span>(backends) / subsetSize<span class="hljs-comment">// Group clients into rounds; each round uses the same shuffled list:</span>round := clientID / subsetCountr := rand.New(rand.NewSource(<span class="hljs-keyword">int64</span>(round)))r.Shuffle(<span class="hljs-built_in">len</span>(backends), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123; backends[i], backends[j] = backends[j], backends[i] &#125;)<span class="hljs-comment">// The subset id corresponding to the current client:</span>subsetID := clientID % subsetCountstart := subsetID * subsetSize<span class="hljs-keyword">return</span> backends[start : start+subsetSize]&#125;</code></pre><p><strong>为什么上面这个算法可以保证可以均匀分布？</strong><br>首先，<strong>shuffle 算法保证在 round 一致的情况下，backend 的排列一定是一致的。</strong><br>因为每个实例拥有从 0 开始的连续唯一的自增 id，且计算过程能够保证每个 round 内所有实例拿到的服务列表的排列一致，因此在同一个 round 内的 client 会分别 backend 排列的不同部分的切片作为选中的后端服务来建立连接。<br>所以只要 client id 是连续的，那么 client 发向 后端的连接就一定是连续的<br><strong>参考资料:</strong><br><a href="https://sre.google/sre-book/load-balancing-datacenter/" target="_blank" rel="noopener">https://sre.google/sre-book/load-balancing-datacenter/</a><br><a href="https://xargin.com/limiting-conn-wih-subset/" target="_blank" rel="noopener">https://xargin.com/limiting-conn-wih-subset/</a></p><h2 id="多租户（如何解决多套测试环境的问题）"><a href="#多租户（如何解决多套测试环境的问题）" class="headerlink" title="多租户（如何解决多套测试环境的问题）"></a>多租户（如何解决多套测试环境的问题）</h2><p>在一个微服务架构中<strong>允许多系统共存</strong>是利用微服务稳定性以及模块化最有效的方式之一，这种方式一般被称为多租户(multi-tenancy)。租户可以是测试，金丝雀发布，影子系统(shadow systems)，甚至服务层或者产品线，使用租户能够保证代码的隔离性并且能够基于流量租户做路由决策。</p><h3 id="如何解决测试环境的问题"><a href="#如何解决测试环境的问题" class="headerlink" title="如何解决测试环境的问题"></a>如何解决测试环境的问题</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>假设现在有一个服务调用链 A -&gt; B -&gt; C，如果 C 同时有多个同学开发，如果甲同学的代码正在测试中，但是乙同学不小心发了一个版本，就会导致甲同学的代码被冲掉，导致测试同学测着测着就出现 bug。测试同学无法得知这个问题是由于环境导致的还是代码缺陷。</p><h4 id="解决方案-1：多套物理环境（类似上文的多集群）"><a href="#解决方案-1：多套物理环境（类似上文的多集群）" class="headerlink" title="解决方案 1：多套物理环境（类似上文的多集群）"></a>解决方案 1：多套物理环境（类似上文的多集群）</h4><p>搭建多套测试环境，可以做到物理隔离，但是也会存在一些问题：</p><ul><li>混用环境导致的不可靠测试。</li><li>多套环境带来的硬件成本。</li><li>难以做负载测试，仿真线上真实流量情况。</li><li>治标不治本，无法知道当前环境谁在使用，并且几套环境可以满足需求？万一又多几个人开发是不是又需要再来几套？</li></ul><h4 id="解决方案-2：多租户，染色发布"><a href="#解决方案-2：多租户，染色发布" class="headerlink" title="解决方案 2：多租户，染色发布"></a>解决方案 2：多租户，染色发布</h4><p><img src="https://lailin.xyz/images/1606799997241-a37aa06a-4d44-4001-96bb-b0287e9eead5.png" srcset="/img/loading.gif" alt="image.png"></p><ul><li>注册流程<ul><li>假设我们现在有一套问题的 <code>FAT1</code> 测试环境，然后现在对应用 B 做了修改</li><li>开发同学通过发布平台发布一个新的 B 应用 B<code>，并且带上环境标签，例如:</code>red`</li><li>应用 B<code>向注册中心进行注册时候会带上</code>red` 标签</li><li>消费者 A 在向注册中心获取服务节点数据的时候也会获取到这个标签，并且在本地的负载均衡当中使用 <code>map[string]pool</code> 的结构进行保存</li></ul></li><li>调用流程<ul><li>测试同学通过 A 进行调用测试，如果是 http 就在 header 中打上这个 <code>red</code> 标签，如果是 grpc 就在 metadata 中加入这个标签</li><li>A 调用 B 的时候，发现 header 中存在 <code>red</code> 标签就会去本地负载均衡查询，发现负载均衡中有 red 标签的连接，这个之后就直接调用到 B`，并且在调用的时候 A 会将 header 的标签信息进行透传</li><li>B` 收到请求之后，需要调用 C、D 这时候也是一样的会去负载均衡中进行查询，发现没有就会退回到默认的连接池中</li></ul></li><li>如何进行联调？<ul><li>需要联调的应用打上相同的标签就可以了</li></ul></li><li>注意事项<ul><li>应用版本发布时数据结构，例如 db 中的表，redis 中的 key，必须保证向下兼容</li><li>测试的时候需要使用不同的测试账号</li><li>注意来自外网的请求中的 header 必须删除，确保安全</li></ul></li><li><strong>核心思路</strong><ul><li>跨服务传递请求携带上下文(context)，数据隔离的流量路由方案。<ul><li>根据标签进行流量路由，并且要确保可以透传</li></ul></li><li>利用服务发现注册租户信息，注册成特定的租户。<ul><li>发布部署平台需要支持方便启动多套环境，以及标签注入</li><li>对不同的环境做了隔离，可以保证对关键业务没有影响</li></ul></li></ul></li></ul><h3 id="如何进行全链路压测"><a href="#如何进行全链路压测" class="headerlink" title="如何进行全链路压测"></a>如何进行全链路压测</h3><p><img src="https://lailin.xyz/images/1606802196792-9f605d74-4f29-458a-923f-6adc7a087e70.png" srcset="/img/loading.gif" alt="image.png"><br>和上面的测试环境的解决方案类似，但是我们需要搭建一套和线上一致的影子系统</p><ul><li>如何解决压测数据对线上数据的影响<ul><li>基础设施需要做改造，采用同样的基础设施节点</li><li>缓存：影子应用存储的数据放到影子库中，使用不同的 db</li><li>数据库：自动将线上的数据结构复制一份到影子数据库中。里面的表结构保持一致，数据库名做一些变化，例如 db_shadow</li><li>消息队列: 推送消息的时候使用不同的 topic 或者是携带一些 metadata 信息</li></ul></li><li>需要提前做一些数据初始化的操作，提前进行准备</li><li>压测时携带压测标签，将流量自动路由到影子服务进行压测</li></ul><p>这种方案同样可以用于灰度发版当中</p><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新</h2><p>看到这里了还不点个关注走一波</p><ul><li><a href="https://lailin.xyz">博客</a> 可以订阅 RSS</li><li><a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a> Follow me</li><li><a href="https://www.zhihu.com/people/mo-hui-shou-76" target="_blank" rel="noopener">知乎</a> 关注账号，顺便点个 👍</li><li><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a> 订阅订阅号，顺便点个 👍</li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Week01: 微服务(一) 微服务概览</title>
    <link href="/post/go-training-01.html"/>
    <url>/post/go-training-01.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为极客时间 Go 进阶训练营笔记，同步直播更新，预计一周更新 1 ~ 2 篇文章，到 202103 月更新完成</p></blockquote><h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><p>先问自己几个问题，看是否可以回答，下面我们就带着问题总结课程的内容</p><ul><li>为什么会有微服务？</li><li>微服务是什么？</li><li>微服务可以带来什么好处，又有那些缺点？</li><li>微服务如何构建？</li><li>微服务如何对外暴露？</li><li>微服务如何拆分？</li><li>如何保证微服务之间的安全？</li></ul><h2 id="Q1-为什么会有微服务？"><a href="#Q1-为什么会有微服务？" class="headerlink" title="Q1: 为什么会有微服务？"></a>Q1: 为什么会有微服务？</h2><ul><li>之前一般是一个单一的巨石架构，存在很多问题<ul><li>应用比较复杂，没有人能够搞懂</li><li>应用扩展比较复杂，可靠性比较低</li><li>无法进行敏捷开发和部署</li></ul></li><li>所以一般这个时候就会考虑按照服务、功能进行拆分</li></ul><h2 id="Q2-微服务是什么？"><a href="#Q2-微服务是什么？" class="headerlink" title="Q2: 微服务是什么？"></a>Q2: 微服务是什么？</h2><ul><li>SOA （面向服务）是什么？<ul><li>服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展</li><li><strong>单一职责，</strong>一个服务只做一件事情</li><li><strong>尽可能的早的创建原型，</strong>先定义 API，达成契约</li><li><strong>可移植性比效率更重要，</strong>通讯协议的可移植性更加重要</li></ul></li><li>SOA 和 微服务 是什么关系？<ul><li>微服务是 SOA 的一种实践，微服务也是面向服务的一种架构</li></ul></li><li>微服务是什么？<ul><li><strong>围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。</strong></li></ul></li></ul><h2 id="Q3-微服务可以带来那些好处，又有哪些缺点？"><a href="#Q3-微服务可以带来那些好处，又有哪些缺点？" class="headerlink" title="Q3: 微服务可以带来那些好处，又有哪些缺点？"></a>Q3: 微服务可以带来那些好处，又有哪些缺点？</h2><ul><li>优点<ul><li>服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展</li><li><strong>原子服务，</strong>一个服务只做一件事情，并且这个属于这个服务的也不应该拆分到其他服务去</li><li><strong>独立进程，</strong>一个服务只有一个独立进程，可以很好的和当前的容器化进行结合，无状态的服务可以很容易的享受到，k8s 上的故障转移，自动重启等好处</li><li><strong>隔离部署，</strong>每个服务之间独立部署，可以避免相互影响，并且和按需进行分配资源，节省成本</li><li><strong>去中心化服务治理</strong><ul><li>数据去中心化，每个服务独享数据库，缓存等设施，也有个别情况多个服务共享数据库，例如面向用户的管理后台和面向管理员的管理后台</li><li>治理去中心化</li><li>技术去中心化，每个服务可以使用适合自己的技术进行实施，但是注意如果技术栈过于发散对于企业或者团队本身也是不利的</li></ul></li></ul></li><li>缺点<ul><li><strong>服务之间的依赖关系复杂</strong>，成千上万个服务相互依赖就像一团乱麻一样，剪不断理还乱。<ul><li>常见的解决方案：全链路追踪，例如， opentracing</li></ul></li><li>微服务本身是分布式系统，需要使用 RPC 或者 消息进行通信，此外<strong>，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题</strong><ul><li>例子：服务调用流量会容易被放大，如果 服务 A -&gt; B -&gt;C 如果 A 有一个循环调用 B，B 也有一个循环调用 C，那么一个请求到达 C 之后就被放大了 100 倍甚至上千倍。这是扛不住的</li><li><strong>常见解决方案：粗粒度的进程间通信（batch 接口，批量请求，避免 n+1 问题），隔离，超时保护，负载保护，熔断、限流、降级、重试，负载均衡</strong></li></ul></li><li><strong>会有分布式事务问题，</strong>因为现在每个微服务之间都会有一个独立的数据库，事务在单体应用中很好处理，但是在跨服务时会变得很麻烦<ul><li>常见解决方案：两阶段提交、TCC 等</li><li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/" target="_blank" rel="noopener">小米信息部技术团队: 分布式事务，这一篇就够了</a></li></ul></li><li><strong>测试会非常复杂，</strong>由于依赖多，无法得知是因为功能异常还是依赖的某个服务发版出现问题<ul><li>常见解决方案：独立测试环境，后面会有一个解决方案</li></ul></li><li>服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。<ul><li>切记，在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，<strong>时刻谨记保持服务契约(接口)的兼容性</strong></li><li>发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</li></ul></li><li><strong>对基础建设的要求很高，</strong>基础设施需要自动化，日志采集，监控数据采集，告警，CICD，K8s 等<ul><li>常见解决方案：上云</li></ul></li></ul></li></ul><h2 id="Q4-微服务如何构建？"><a href="#Q4-微服务如何构建？" class="headerlink" title="Q4: 微服务如何构建？"></a>Q4: 微服务如何构建？</h2><blockquote><p>多个微服务组合(compose)完成了一个完整的用户场景(usecase)。</p></blockquote><ul><li>kit：一个微服务的基础库(框架)。</li><li>service：业务代码 + kit 依赖 + 第三方依赖组成的业务微服务</li><li>rpc + message queue：轻量级通讯</li></ul><h2 id="Q5-微服务如何对外暴露？"><a href="#Q5-微服务如何对外暴露？" class="headerlink" title="Q5: 微服务如何对外暴露？"></a>Q5: 微服务如何对外暴露？</h2><p><img src="https://lailin.xyz/images/1606552913072-f2ae26c9-6897-4dc8-9384-95f493ff5006.svg" srcset="/img/loading.gif" alt="01_Go进阶训练营_微服务_v1.svg"><br>流量链路是什么？</p><ul><li>移动端 -&gt; API Gateway -&gt; BFF -&gt; 微服务</li><li>不含 CDN、负载均衡（LB）</li><li>BFF 纯 web 的业务一般用 nodejs 做 SSR</li></ul><p>为什么我们的服务不直接对外进行暴露？</p><ul><li>前端（移动端、客户端、web）同学非常痛苦，需要对接多个服务，兼容性差，沟通效率低</li><li>后端同学也很痛苦，一年前的版本都有人使用，服务无法进行重构升级</li></ul><p>为什么需要最外层的 api gateway?</p><ul><li>基础库的同学非常同步，限流熔断安全等业务无关的功能需要进行升级的时候升不动</li></ul><h2 id="Q6-微服务如何拆分？"><a href="#Q6-微服务如何拆分？" class="headerlink" title="Q6: 微服务如何拆分？"></a>Q6: 微服务如何拆分？</h2><ul><li>在对业务领域不是特别熟悉的时候，按照<strong>部门职能进行划分，例如账号、财务等</strong><ul><li>注意划分的时候<strong>要闭环</strong>，不要相同的功能散落到几个部门当中</li></ul></li><li>在系统稳定之后，积累了相关的业务经验和微服务开发经验之后，再考虑使用 DDD 限界上下文进行划分</li><li>如果可以闭环的解决一个用户场景，那么它应该是一个微服务</li><li>还可以根据访问频率进行区分划分，将用户高频访问的部分划分为一个服务</li><li>还可以根据读写进行划分<ul><li>CQRS: 将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新</li><li><img src="https://lailin.xyz/images/1606631756304-ac2b31e1-771a-45e7-9b99-5234badc5d0d.svg" srcset="/img/loading.gif" alt="01_Go进阶训练营_微服务_v1.svg"></li></ul></li></ul><h2 id="Q7-如何保证微服务之间的安全？"><a href="#Q7-如何保证微服务之间的安全？" class="headerlink" title="Q7: 如何保证微服务之间的安全？"></a>Q7: 如何保证微服务之间的安全？</h2><p><img src="https://lailin.xyz/images/1606632869613-c887da17-ec2f-4221-822a-84bbd21e4d3f.svg" srcset="/img/loading.gif" alt="01_Go进阶训练营_微服务_v1.svg"><br>在内网主要看安全级别一般有三种：</p><ul><li>Full Trust：假定内网服务之间是安全的，在内网裸奔</li><li>Half Trust：内网服务之间需要进行认证鉴权，但是不需要所有的都进行加密</li><li>Zero Trust: 零信任，任务内部网络是不安全的，类似公网，所有的请求通过身份认证鉴权之后，都需要通过安全加密，防止被嗅探<ul><li><a href="https://www.microsoft.com/en-us/security/business/zero-trust" target="_blank" rel="noopener">https://www.microsoft.com/en-us/security/business/zero-trust</a></li></ul></li></ul><h2 id="关注我获取更新"><a href="#关注我获取更新" class="headerlink" title="关注我获取更新"></a>关注我获取更新</h2><p>看到这里了还不点个关注走一波</p><ul><li><a href="https://lailin.xyz">博客</a> 可以订阅 RSS</li><li><a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a> Follow me</li><li><a href="https://www.zhihu.com/people/mo-hui-shou-76" target="_blank" rel="noopener">知乎</a> 关注账号，顺便点个 👍</li><li><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a> 订阅订阅号，顺便点个 👍</li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>Go进阶训练营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>Go进阶训练营</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据结构与算法05-栈下: 深入理解 defer</title>
    <link href="/post/defer.html"/>
    <url>/post/defer.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 数据结构与算法系列文章，本系列文章主要会包括常见的数据结构与算法实现，同时会包括 Go 标准库代码的分析理解，讲到对应章节的时候优先学习分析 Go 的源码实现，例如 slice、list、sort 等，然后可能会有一些常见的案例实现，同时这也是 <a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener">极客时间-数据结构与算法之美</a> 的课程笔记</li><li><strong>本文代码仓库:</strong> <a href="https://github.com/mohuishou/go-algorithm" target="_blank" rel="noopener">https://github.com/mohuishou/go-algorithm</a> 🌟🌟🌟🌟🌟</li><li><strong>RoadMap: </strong>持续更新中，预计一周更新 1 ~ 2 篇文章，预计到 202101 月底前更新完成</li><li><strong>获取更新:</strong> <a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a>、<a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener">知乎</a>、<a href="https://lailin.xyz/atom.xml">RSS</a>、<a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a></li><li>上一个系列刚刚完成了 <a href="https://lailin.xyz/post/go-design-pattern.html">Go 设计模式</a>，如果感兴趣也可以进行查看</li></ul><h2 id="深入理解-go-defer"><a href="#深入理解-go-defer" class="headerlink" title="深入理解 go defer"></a>深入理解 go defer</h2><p>上篇文章中我们讲到栈的时候说到先入后出这种特性，在 Go 中第一时间想到的就是 <code>defer</code> 接下来我们就深入理解一下 defer</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>下面先回顾一下基本的用法以及较为常见的坑，文末会给出输出结果，可以先想想会输出什么</p><h4 id="基本用法-1-延迟处理，资源清理"><a href="#基本用法-1-延迟处理，资源清理" class="headerlink" title="基本用法 1: 延迟处理，资源清理"></a>基本用法 1: 延迟处理，资源清理</h4><pre><code class="hljs go"><span class="hljs-comment">// 基本用法：延迟调用，清理资源</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">"clean"</span>)fmt.Println(<span class="hljs-string">"hello"</span>)&#125;</code></pre><h4 id="基本用法-2-后进先出"><a href="#基本用法-2-后进先出" class="headerlink" title="基本用法 2: 后进先出"></a>基本用法 2: 后进先出</h4><pre><code class="hljs go"><span class="hljs-comment">// 基本用法1: 后进先出</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">"1"</span>)<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">"2"</span>)fmt.Println(<span class="hljs-string">"3"</span>)&#125;</code></pre><h4 id="基本用法-3-异常恢复"><a href="#基本用法-3-异常恢复" class="headerlink" title="基本用法 3: 异常恢复"></a>基本用法 3: 异常恢复</h4><pre><code class="hljs go"><span class="hljs-comment">// 基本用法2：异常恢复</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;fmt.Printf(<span class="hljs-string">"paniced: %+v \n"</span>, err)&#125;&#125;()<span class="hljs-built_in">panic</span>(<span class="hljs-string">"test"</span>)&#125;</code></pre><h4 id="容易掉坑-1-闭包变量"><a href="#容易掉坑-1-闭包变量" class="headerlink" title="容易掉坑 1: 闭包变量"></a>容易掉坑 1: 闭包变量</h4><pre><code class="hljs go"><span class="hljs-comment">// 容易掉坑之，函数变量修改</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> <span class="hljs-params">(res <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;res++&#125;()<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;</code></pre><h4 id="容易掉坑-2-参数传递"><a href="#容易掉坑-2-参数传递" class="headerlink" title="容易掉坑 2: 参数传递"></a>容易掉坑 2: 参数传递</h4><pre><code class="hljs go"><span class="hljs-comment">// 容易掉坑之，参数复制</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> <span class="hljs-params">(res <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(res <span class="hljs-keyword">int</span>)</span></span> &#123;res++&#125;(res)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;</code></pre><h3 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h3><p>想要看源码，我们需要先找到源码的位置，我们可以直接执行 <code>go tool compile -N -l -S main.go</code> 获取汇编代码</p><pre><code class="hljs bash">// .... 0x00d8 00216 (main_2.go:6)PCDATA<span class="hljs-variable">$1</span>, <span class="hljs-variable">$0</span>0x00d8 00216 (main_2.go:6)CALLruntime.deferprocStack(SB)0x00dd 00221 (main_2.go:6)NOP0x00e0 00224 (main_2.go:6)TESTLAX, AX0x00e2 00226 (main_2.go:6)JNE2520x00e4 00228 (main_2.go:6)JMP2300x00e6 00230 (main_2.go:7)XCHGLAX, AX0x00e7 00231 (main_2.go:7)CALLruntime.deferreturn(SB)0x00ec 00236 (main_2.go:7)MOVQ216(SP), BP0x00f4 00244 (main_2.go:7)ADDQ<span class="hljs-variable">$224</span>, SP0x00fb 00251 (main_2.go:7)RET0x00fc 00252 (main_2.go:6)XCHGLAX, AX0x00fd 00253 (main_2.go:6)NOP0x0100 00256 (main_2.go:6)CALLruntime.deferreturn(SB)</code></pre><p>我们可以看到主要是调用了 <code>runtime.deferprocStack</code> ， <code>runtime.deferreturn</code> 这两个运行时的方法</p><h4 id="defer-定义"><a href="#defer-定义" class="headerlink" title="defer 定义"></a>defer 定义</h4><pre><code class="hljs go"><span class="hljs-keyword">type</span> _defer <span class="hljs-keyword">struct</span> &#123;siz     <span class="hljs-keyword">int32</span> <span class="hljs-comment">// 所有传入参数和返回值的总大小</span>started <span class="hljs-keyword">bool</span>  <span class="hljs-comment">// defer 是否执行了</span>heap    <span class="hljs-keyword">bool</span>  <span class="hljs-comment">// 是否在堆上，这是 go1.13 新加的，划重点</span>sp        <span class="hljs-keyword">uintptr</span>  <span class="hljs-comment">// 函数栈指针寄存器，一般指向当前函数栈的栈顶</span>pc        <span class="hljs-keyword">uintptr</span>  <span class="hljs-comment">// 程序计数器，指向下一条需要执行的指令</span>fn        *funcval <span class="hljs-comment">// 指向传入的函数地址和参数</span>_panic    *_panic  <span class="hljs-comment">// 指向 panic 链表</span>link      *_defer  <span class="hljs-comment">// 指向 defer 链表</span>    <span class="hljs-comment">//...</span>&#125;</code></pre><h4 id="deferprocStack"><a href="#deferprocStack" class="headerlink" title="deferprocStack"></a>deferprocStack</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deferprocStack</span><span class="hljs-params">(d *_defer)</span></span> &#123;gp := getg() <span class="hljs-comment">// 获取 g，判断是否在用户栈上</span><span class="hljs-keyword">if</span> gp.m.curg != gp &#123;<span class="hljs-comment">// go code on the system stack can't defer</span>throw(<span class="hljs-string">"defer on system stack"</span>)&#125;<span class="hljs-comment">// siz and fn are already set.</span><span class="hljs-comment">// The other fields are junk on entry to deferprocStack and</span><span class="hljs-comment">// are initialized here.</span>d.started = <span class="hljs-literal">false</span>d.heap = <span class="hljs-literal">false</span>d.openDefer = <span class="hljs-literal">false</span>d.sp = getcallersp()d.pc = getcallerpc()d.framepc = <span class="hljs-number">0</span>d.varp = <span class="hljs-number">0</span><span class="hljs-comment">// The lines below implement:</span><span class="hljs-comment">//   d.panic = nil</span><span class="hljs-comment">//   d.fd = nil</span><span class="hljs-comment">//   d.link = gp._defer // 这两个是将当前 defer 插入到链表头部，也就是defer为什么时候先入后出的原因</span><span class="hljs-comment">//   gp._defer = d</span><span class="hljs-comment">// But without write barriers. The first three are writes to</span><span class="hljs-comment">// the stack so they don't need a write barrier, and furthermore</span><span class="hljs-comment">// are to uninitialized memory, so they must not use a write barrier.</span><span class="hljs-comment">// The fourth write does not require a write barrier because we</span><span class="hljs-comment">// explicitly mark all the defer structures, so we don't need to</span><span class="hljs-comment">// keep track of pointers to them with a write barrier.</span>*(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(&amp;d._panic)) = <span class="hljs-number">0</span>*(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(&amp;d.fd)) = <span class="hljs-number">0</span>*(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(&amp;d.link)) = <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(gp._defer))*(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(&amp;gp._defer)) = <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(d))return0()<span class="hljs-comment">// No code can go here - the C return register has</span><span class="hljs-comment">// been set and must not be clobbered.</span>&#125;</code></pre><p><strong>注意这几行</strong><br>说明这个 defer 不在堆上</p><pre><code class="hljs go">d.heap = <span class="hljs-literal">false</span></code></pre><p>这两个是将当前 defer 插入到链表头部，也就是 defer 为什么时候先入后出的原因</p><pre><code class="hljs go"><span class="hljs-comment">//   d.link = gp._defer</span><span class="hljs-comment">//   gp._defer = d</span></code></pre><h4 id="deferreturn"><a href="#deferreturn" class="headerlink" title="deferreturn"></a>deferreturn</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deferreturn</span><span class="hljs-params">(arg0 <span class="hljs-keyword">uintptr</span>)</span></span> &#123;gp := getg()d := gp._defer<span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;sp := getcallersp()<span class="hljs-keyword">if</span> d.sp != sp &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">if</span> d.openDefer &#123;done := runOpenDeferFrame(gp, d)<span class="hljs-keyword">if</span> !done &#123;throw(<span class="hljs-string">"unfinished open-coded defers in deferreturn"</span>)&#125;gp._defer = d.linkfreedefer(d)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">switch</span> d.siz &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-comment">// Do nothing.</span><span class="hljs-keyword">case</span> sys.PtrSize:*(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(&amp;arg0)) = *(*<span class="hljs-keyword">uintptr</span>)(deferArgs(d))<span class="hljs-keyword">default</span>:memmove(unsafe.Pointer(&amp;arg0), deferArgs(d), <span class="hljs-keyword">uintptr</span>(d.siz))&#125;fn := d.fnd.fn = <span class="hljs-literal">nil</span>gp._defer = d.linkfreedefer(d)<span class="hljs-comment">// If the defer function pointer is nil, force the seg fault to happen</span><span class="hljs-comment">// here rather than in jmpdefer. gentraceback() throws an error if it is</span><span class="hljs-comment">// called with a callback on an LR architecture and jmpdefer is on the</span><span class="hljs-comment">// stack, because the stack trace can be incorrect in that case - see</span><span class="hljs-comment">// issue #8153).</span>_ = fn.fnjmpdefer(fn, <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(&amp;arg0)))&#125;</code></pre><p>如果函数中存在 defer 编译器就会自动在函数的最后插入一个 deferreturn</p><ul><li>清空 defer 的调用信息</li><li>freedefer 将 defer 对象放入到 defer 池中，后面可以复用</li><li>如果存在延迟函数就会调用 runtime·jmpdefer 方法跳转到对应的方法上去</li><li>runtime·jmpdefer 方法会递归调用 deferreturn 一直执行到结束为止</li></ul><h4 id="deferproc"><a href="#deferproc" class="headerlink" title="deferproc"></a>deferproc</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deferproc</span><span class="hljs-params">(siz <span class="hljs-keyword">int32</span>, fn *funcval)</span></span> &#123; <span class="hljs-comment">// arguments of fn follow fn</span>gp := getg()<span class="hljs-keyword">if</span> gp.m.curg != gp &#123;<span class="hljs-comment">// go code on the system stack can't defer</span>throw(<span class="hljs-string">"defer on system stack"</span>)&#125;<span class="hljs-comment">// the arguments of fn are in a perilous state. The stack map</span><span class="hljs-comment">// for deferproc does not describe them. So we can't let garbage</span><span class="hljs-comment">// collection or stack copying trigger until we've copied them out</span><span class="hljs-comment">// to somewhere safe. The memmove below does that.</span><span class="hljs-comment">// Until the copy completes, we can only call nosplit routines.</span>sp := getcallersp()argp := <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(&amp;fn)) + unsafe.Sizeof(fn)callerpc := getcallerpc()d := newdefer(siz)<span class="hljs-keyword">if</span> d._panic != <span class="hljs-literal">nil</span> &#123;throw(<span class="hljs-string">"deferproc: d.panic != nil after newdefer"</span>)&#125;d.link = gp._defergp._defer = dd.fn = fnd.pc = callerpcd.sp = sp<span class="hljs-keyword">switch</span> siz &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-comment">// Do nothing.</span><span class="hljs-keyword">case</span> sys.PtrSize:*(*<span class="hljs-keyword">uintptr</span>)(deferArgs(d)) = *(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(argp))<span class="hljs-keyword">default</span>:memmove(deferArgs(d), unsafe.Pointer(argp), <span class="hljs-keyword">uintptr</span>(siz))&#125;<span class="hljs-comment">// deferproc returns 0 normally.</span><span class="hljs-comment">// a deferred func that stops a panic</span><span class="hljs-comment">// makes the deferproc return 1.</span><span class="hljs-comment">// the code the compiler generates always</span><span class="hljs-comment">// checks the return value and jumps to the</span><span class="hljs-comment">// end of the function if deferproc returns != 0.</span>return0()<span class="hljs-comment">// No code can go here - the C return register has</span><span class="hljs-comment">// been set and must not be clobbered.</span>&#125;</code></pre><p>除了 deferprocStack 还有 deferproc 这个方法，那这个方法和之前的方法有什么区别呢？<br>主要的区别就是这个方法将 defer 分配在了堆上，看下方的 <code>newdefer</code></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newdefer</span><span class="hljs-params">(siz <span class="hljs-keyword">int32</span>)</span> *_<span class="hljs-title">defer</span></span> &#123;    <span class="hljs-comment">// ...</span>    d.heap = <span class="hljs-literal">true</span><span class="hljs-keyword">return</span> d&#125;</code></pre><p>其他和 deferprocStack 类似这里就不赘述了</p><h4 id="什么时候-defer-会在堆上什么时候会在栈上？"><a href="#什么时候-defer-会在堆上什么时候会在栈上？" class="headerlink" title="什么时候 defer 会在堆上什么时候会在栈上？"></a>什么时候 defer 会在堆上什么时候会在栈上？</h4><p>那问题来了如何判断 defer 在堆上还是在栈上呢？<br><a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/escape.go#L743" target="_blank" rel="noopener">https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/escape.go#L743</a></p><pre><code class="hljs go">topLevelDefer := where != <span class="hljs-literal">nil</span> &amp;&amp; where.Op == ODEFER &amp;&amp; e.loopDepth == <span class="hljs-number">1</span><span class="hljs-keyword">if</span> topLevelDefer &#123;    <span class="hljs-comment">// force stack allocation of defer record, unless</span>    <span class="hljs-comment">// open-coded defers are used (see ssa.go)</span>    where.Esc = EscNever&#125;</code></pre><p><a href="https://github.com/golang/go/blob/6965b01ea248cabb70c3749fd218b36089a21efb/src/cmd/compile/internal/gc/ssa.go#L1116" target="_blank" rel="noopener">https://github.com/golang/go/blob/6965b01ea248cabb70c3749fd218b36089a21efb/src/cmd/compile/internal/gc/ssa.go#L1116</a></p><pre><code class="hljs go">d := callDefer<span class="hljs-keyword">if</span> n.Esc == EscNever &#123;    d = callDeferStack&#125;s.call(n.Left, d)</code></pre><p>可以看到主要是在逃逸分析的时候，发现 <code>e.loopDepth == 1</code> 并且不是 open-coded defer 就会分配到栈上。<br>这也是为什么 go 1.13 之后 defer 性能提升的原因，所以<strong>切记不要在循环中使用 defer 不然优化也享受不到</strong><br>我们来验证一下</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f6</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">"f6: %d\n"</span>, i)&#125;()&#125;&#125;</code></pre><p>看一下汇编结果</p><pre><code class="hljs go"><span class="hljs-number">0x0073</span> <span class="hljs-number">00115</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">67</span>)CALLruntime.deferproc(SB)<span class="hljs-number">0x0078</span> <span class="hljs-number">00120</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">67</span>)TESTLAX, AX<span class="hljs-number">0x007a</span> <span class="hljs-number">00122</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">67</span>)JNE<span class="hljs-number">151</span><span class="hljs-number">0x007c</span> <span class="hljs-number">00124</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">67</span>)JMP<span class="hljs-number">126</span><span class="hljs-number">0x007e</span> <span class="hljs-number">00126</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)PCDATA$<span class="hljs-number">1</span>, $<span class="hljs-number">-1</span><span class="hljs-number">0x007e</span> <span class="hljs-number">00126</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)NOP<span class="hljs-number">0x0080</span> <span class="hljs-number">00128</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)JMP<span class="hljs-number">130</span><span class="hljs-number">0x0082</span> <span class="hljs-number">00130</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)MOVQ<span class="hljs-string">""</span>.&amp;i+<span class="hljs-number">32</span>(SP), AX<span class="hljs-number">0x0087</span> <span class="hljs-number">00135</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)MOVQ(AX), AX<span class="hljs-number">0x008a</span> <span class="hljs-number">00138</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)MOVQ<span class="hljs-string">""</span>.&amp;i+<span class="hljs-number">32</span>(SP), CX<span class="hljs-number">0x008f</span> <span class="hljs-number">00143</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)INCQAX<span class="hljs-number">0x0092</span> <span class="hljs-number">00146</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)MOVQAX, (CX)<span class="hljs-number">0x0095</span> <span class="hljs-number">00149</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">66</span>)JMP<span class="hljs-number">68</span><span class="hljs-number">0x0097</span> <span class="hljs-number">00151</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">67</span>)PCDATA$<span class="hljs-number">1</span>, $<span class="hljs-number">0</span><span class="hljs-number">0x0097</span> <span class="hljs-number">00151</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">67</span>)XCHGLAX, AX<span class="hljs-number">0x0098</span> <span class="hljs-number">00152</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">67</span>)CALLruntime.deferreturn(SB)</code></pre><p>可以发现在循环嵌套的场景下，的确调用的是 <code>runtime.deferproc</code> 方法，被分配到栈上了</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据结构与算法04-栈上: 如何实现一个计算器</title>
    <link href="/post/stack.html"/>
    <url>/post/stack.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 数据结构与算法系列文章，本系列文章主要会包括常见的数据结构与算法实现，同时会包括 Go 标准库代码的分析理解，讲到对应章节的时候优先学习分析 Go 的源码实现，例如 slice、list、sort 等，然后可能会有一些常见的案例实现，同时这也是 <a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener">极客时间-数据结构与算法之美</a> 的课程笔记</li><li><strong>本文代码仓库:</strong> <a href="https://github.com/mohuishou/go-algorithm" target="_blank" rel="noopener">https://github.com/mohuishou/go-algorithm</a> 🌟🌟🌟🌟🌟</li><li><strong>RoadMap: </strong>持续更新中，预计一周更新 1 ~ 2 篇文章，预计到 202101 月底前更新完成</li><li><strong>获取更新:</strong> <a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a>、<a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener">知乎</a>、<a href="https://lailin.xyz/atom.xml">RSS</a>、<a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a></li><li>上一个系列刚刚完成了 <a href="https://lailin.xyz/post/go-design-pattern.html">Go 设计模式</a>，如果感兴趣也可以进行查看</li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>栈是一种“操作受限”的线性表，<strong>后进者先出，先进者后出。</strong><br>比较典型的例子就是我们在叠盘子的时候，叠的时候从下到上一个一个磊起来，取的时候，再从上到下一个一个的拿出来。<br>说到先入后出这种特性，在 Go 中你第一时间想到了什么？不知道是否和我的答案一样， <code>defer</code><br><img src="https://lailin.xyz/images/1606140416813-6b90944b-87c1-43eb-8443-c747e6559200.svg" srcset="/img/loading.gif" alt="01_stack.drawio.svg"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>存在两种实现方式，第一种是数组实现的顺序栈，第二种是链表链式栈</p><h4 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h4><p>数组实现我们直接使用了 <code>slice</code> ，并且借助 <code>slice</code> 实现了自动扩容</p><pre><code class="hljs go"><span class="hljs-comment">// Stack Stack</span><span class="hljs-keyword">type</span> Stack <span class="hljs-keyword">struct</span> &#123;items   []<span class="hljs-keyword">string</span>current <span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">// NewStack NewStack</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStack</span><span class="hljs-params">()</span> *<span class="hljs-title">Stack</span></span> &#123;<span class="hljs-keyword">return</span> &amp;Stack&#123;items:   <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">10</span>),current: <span class="hljs-number">0</span>,&#125;&#125;<span class="hljs-comment">// Push 入栈</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span> <span class="hljs-title">Push</span><span class="hljs-params">(item <span class="hljs-keyword">string</span>)</span></span> &#123;s.current++<span class="hljs-comment">// 判断底层 slice 是否满了，如果满了就 append</span><span class="hljs-keyword">if</span> s.current == <span class="hljs-built_in">len</span>(s.items) &#123;s.items = <span class="hljs-built_in">append</span>(s.items, item)<span class="hljs-keyword">return</span>&#125;s.items[s.current] = item&#125;<span class="hljs-comment">// Pop 出栈</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">if</span> s.current == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">""</span>&#125;item := s.items[s.current]s.current--<span class="hljs-keyword">return</span> item&#125;</code></pre><h4 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h4><p>链式栈的实现我们利用双向循环链表，简化栈的插入操作</p><pre><code class="hljs go"><span class="hljs-comment">// node 节点</span><span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;prev, next *nodevalue      <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// Stack 链式栈</span><span class="hljs-keyword">type</span> Stack <span class="hljs-keyword">struct</span> &#123;root *node<span class="hljs-built_in">len</span>  <span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">// NewStack NewStack</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStack</span><span class="hljs-params">()</span> *<span class="hljs-title">Stack</span></span> &#123;n := &amp;node&#123;&#125;n.next = nn.prev = n<span class="hljs-keyword">return</span> &amp;Stack&#123;root: n&#125;&#125;<span class="hljs-comment">// Push 入栈</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span> <span class="hljs-title">Push</span><span class="hljs-params">(item <span class="hljs-keyword">string</span>)</span></span> &#123;n := &amp;node&#123;value: item&#125;s.root.prev.next = nn.prev = s.root.prevn.next = s.roots.root.prev = ns.<span class="hljs-built_in">len</span>++&#125;<span class="hljs-comment">// Pop 出栈</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;item := s.root.prev<span class="hljs-keyword">if</span> item == s.root &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">""</span>&#125;s.root.prev = item.previtem.prev.next = s.root<span class="hljs-comment">// 避免内存泄漏</span>item.prev = <span class="hljs-literal">nil</span>item.next = <span class="hljs-literal">nil</span>s.<span class="hljs-built_in">len</span>--<span class="hljs-keyword">return</span> item.value&#125;</code></pre><h3 id="典型问题"><a href="#典型问题" class="headerlink" title="典型问题"></a>典型问题</h3><h4 id="实现一个计算器"><a href="#实现一个计算器" class="headerlink" title="实现一个计算器"></a>实现一个计算器</h4><p>我们实现了支持<code>+、-、*、/、(、)</code> 的计算器，这也是<a href="https://leetcode-cn.com/problems/basic-calculator/" target="_blank" rel="noopener">leetcode#244</a>的一种解法，并且我们这个实现更加复杂，原题只需要计算加减法</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> calculation<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"strconv"</span>)<span class="hljs-comment">// 操作符的优先级</span><span class="hljs-keyword">var</span> operatorPriority = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-string">"+"</span>: <span class="hljs-number">0</span>,<span class="hljs-string">"-"</span>: <span class="hljs-number">0</span>,<span class="hljs-string">"*"</span>: <span class="hljs-number">1</span>,<span class="hljs-string">"/"</span>: <span class="hljs-number">1</span>,<span class="hljs-string">"("</span>: <span class="hljs-number">2</span>,<span class="hljs-string">")"</span>: <span class="hljs-number">2</span>,&#125;<span class="hljs-comment">// Calculator 计算器</span><span class="hljs-keyword">type</span> Calculator <span class="hljs-keyword">struct</span> &#123;nums      *StackIntoperators *Stackexp       <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// NewCalculator NewCalculator</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCalculator</span><span class="hljs-params">(exp <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">Calculator</span></span> &#123;<span class="hljs-keyword">return</span> &amp;Calculator&#123;nums:      NewStackInt(),operators: NewStack(),exp:       exp,&#125;&#125;<span class="hljs-comment">// Calculate 获取计算结果</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Calculator)</span> <span class="hljs-title">Calculate</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;l := <span class="hljs-built_in">len</span>(c.exp)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l; i++ &#123;<span class="hljs-keyword">switch</span> e := (c.exp[i]); e &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">' '</span>:<span class="hljs-keyword">continue</span><span class="hljs-keyword">case</span> <span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span>:<span class="hljs-comment">// 一直往后获取数字，如果下一个还是数字说明这一个数还不完整</span>j := i<span class="hljs-keyword">for</span> j &lt; l &amp;&amp; c.exp[j] &lt;= <span class="hljs-string">'9'</span> &amp;&amp; c.exp[j] &gt;= <span class="hljs-string">'0'</span> &#123;j++&#125;n, _ := strconv.Atoi(c.exp[i:j])i = j - <span class="hljs-number">1</span>c.nums.Push(n)<span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>, <span class="hljs-string">'-'</span>, <span class="hljs-string">'*'</span>, <span class="hljs-string">'/'</span>:<span class="hljs-comment">// 从计算符栈中获取栈顶元素，如果当前操作符的优先级低于栈顶元素的优先级</span><span class="hljs-comment">// 并且栈顶元素不为空，和括号</span><span class="hljs-comment">// 那么从数据栈中取两个数据和栈顶操作符进行计算</span>pre := c.operators.Pop()<span class="hljs-keyword">for</span> pre != <span class="hljs-string">""</span> &amp;&amp; pre != <span class="hljs-string">"("</span> &amp;&amp; operatorPriority[<span class="hljs-keyword">string</span>(e)] &lt;= operatorPriority[pre] &#123;c.nums.Push(c.calc(pre))pre = c.operators.Pop()&#125;<span class="hljs-keyword">if</span> pre != <span class="hljs-string">""</span> &#123;c.operators.Push(pre)&#125;c.operators.Push(<span class="hljs-keyword">string</span>(e))<span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>:c.operators.Push(<span class="hljs-keyword">string</span>(e))<span class="hljs-keyword">case</span> <span class="hljs-string">')'</span>:<span class="hljs-comment">// 碰到右括号之后就一直不断操作符栈中弹出元素，并且取两个数据进行计算</span><span class="hljs-comment">// 直到碰到左括号为止</span><span class="hljs-keyword">for</span> o := c.operators.Pop(); o != <span class="hljs-string">"("</span> &amp;&amp; o != <span class="hljs-string">""</span>; o = c.operators.Pop() &#123;c.nums.Push(c.calc(o))&#125;<span class="hljs-keyword">default</span>:<span class="hljs-built_in">panic</span>(<span class="hljs-string">"invalid exp"</span>)&#125;&#125;<span class="hljs-comment">// 最后如果不存在操作符，说明数据栈中的栈顶元素就是最后结果</span>o := c.operators.Pop()<span class="hljs-keyword">if</span> o == <span class="hljs-string">""</span> &#123;<span class="hljs-keyword">return</span> c.nums.Pop()&#125;<span class="hljs-comment">// 如果存在，就把最后的数据进行计算后返回</span><span class="hljs-keyword">return</span> c.calc(o)&#125;<span class="hljs-comment">// calc 单次计算操作，o: 计算符</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Calculator)</span> <span class="hljs-title">calc</span><span class="hljs-params">(o <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;b := c.nums.Pop()a := c.nums.Pop()fmt.Printf(<span class="hljs-string">"%d %s %d\n"</span>, a, o, b)<span class="hljs-keyword">switch</span> o &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">"+"</span>:<span class="hljs-keyword">return</span> a + b<span class="hljs-keyword">case</span> <span class="hljs-string">"-"</span>:<span class="hljs-keyword">return</span> a - b<span class="hljs-keyword">case</span> <span class="hljs-string">"*"</span>:<span class="hljs-keyword">return</span> a * b<span class="hljs-keyword">case</span> <span class="hljs-string">"/"</span>:<span class="hljs-keyword">return</span> a / b&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<span class="hljs-comment">// calculate 计算器，支持加减乘除</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> NewCalculator(s).Calculate()&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Struct 初始化风格的抉择</title>
    <link href="/post/go-new-struct-style-select.html"/>
    <url>/post/go-new-struct-style-select.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在对之前的代码做重构，从之前的 <code>MVC</code> 结构切换到 <code>Clean Arch</code> 的结构，但是在切换的时候关于代码风格出现了一些困惑<br>在下面的代码中 <code>repository</code> 是存储库，主要用于封装数据库查询或者是第三方微服务的调用，它实现了 <code>domain.IAzRepository</code> 接口，其他层的代码都只依赖这个接口而不依赖具体的实现</p><h2 id="三种代码风格"><a href="#三种代码风格" class="headerlink" title="三种代码风格"></a>三种代码风格</h2><h3 id="风格一"><a href="#风格一" class="headerlink" title="风格一"></a>风格一</h3><p>在 Go 中我们常常“返回实现(struct)，依赖接口”，其实就是在函数返回的时候我们返回一个具体的实现，函数的参数或者是 Struct 的成员部分我们依赖接口，这个风格看起来是违背了这个原则的</p><pre><code class="hljs go"><span class="hljs-comment">// repository 存储库</span><span class="hljs-keyword">type</span> repository <span class="hljs-keyword">struct</span> &#123;db *gorm.DB&#125;<span class="hljs-comment">// NewAZRepository NewAZRepository</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAZRepository</span><span class="hljs-params">(db *gorm.DB)</span> <span class="hljs-title">domain</span>.<span class="hljs-title">IAzRepository</span></span> &#123;<span class="hljs-keyword">return</span> &amp;repository&#123;db: db&#125;&#125;</code></pre><h3 id="风格二"><a href="#风格二" class="headerlink" title="风格二"></a>风格二</h3><p>这个风格返回了实现，并且由于并没有导出看起来也具有封装的特性，但是如果你运行 golint 你就会发现会抛出错误，因为这么写，会导致我们用导出的方法将没有导出 struct 给暴露了出去</p><pre><code class="hljs go"><span class="hljs-comment">// repository 存储库</span><span class="hljs-keyword">type</span> repository <span class="hljs-keyword">struct</span> &#123;db *gorm.DB&#125;<span class="hljs-comment">// NewAZRepository NewAZRepository</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAZRepository</span><span class="hljs-params">(db *gorm.DB)</span> *<span class="hljs-title">repository</span></span> &#123;<span class="hljs-keyword">return</span> &amp;repository&#123;db: db&#125;&#125;</code></pre><h3 id="风格三"><a href="#风格三" class="headerlink" title="风格三"></a>风格三</h3><p>这个写法的主要问题是，由于 <code>Repository</code> 被导出，所以在外部其他的包中就可以直接通过 <code>&amp;Repository{}</code> 进行初始化，这样初始化之后使用就会导致 panic，因为成员函数是一个 nil 指针</p><pre><code class="hljs go"><span class="hljs-comment">// Repository 存储库</span><span class="hljs-keyword">type</span> Repository <span class="hljs-keyword">struct</span> &#123;db *gorm.DB&#125;<span class="hljs-comment">// NewAZRepository NewAZRepository</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAZRepository</span><span class="hljs-params">(db *gorm.DB)</span> *<span class="hljs-title">Repository</span></span> &#123;<span class="hljs-keyword">return</span> &amp;Repository&#123;db: db&#125;&#125;</code></pre><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>选择总是困难的，带着这个问题我咨询了同组的同事还有好几个 Go 语言交流群的同学，其中大部分都会选择风格三，小部分会选择风格一，风格二几乎没有人选择。最后我选什么呢？<br>最后我的选择是风格一，这是针对场景来的，因为我们的这个包其实不希望其他包直接依赖实现，因为后续有可能随着发展被单独拆分成一个微服务或者是需要更换存储库，如果外部有包直接依赖 repository 会导致后续的重构比较困难<br>除此之外，我们在其他地方一般还是会选择风格三，因为结构体名不导出，外部其实没有比较好的办法进行初始化，例如想要 <code>var r Repository</code>，至于前面提到的直接字面量初始化的问题，我们可以通过统一代码风格解决。</p><blockquote><p>在<strong>外部包</strong>中除了用于参数传递的 <code>Option</code> 结构之外，其余的不允许直接通过 &amp;XXX{} 的方式进行初始化</p></blockquote><p>最后感谢热心回答我的困惑的小伙伴们 🤗</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>代码风格</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据结构与算法03-数组下: 使用 GDB 调试 Golang 代码</title>
    <link href="/post/array_2.html"/>
    <url>/post/array_2.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 数据结构与算法系列文章，本系列文章主要会包括常见的数据结构与算法实现，同时会包括 Go 标准库代码的分析理解，讲到对应章节的时候优先学习分析 Go 的源码实现，例如 slice、list、sort 等，然后可能会有一些常见的案例实现，同时这也是 <a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener">极客时间-数据结构与算法之美</a> 的课程笔记</li><li><strong>本文代码仓库:</strong> <a href="https://github.com/mohuishou/go-algorithm" target="_blank" rel="noopener">https://github.com/mohuishou/go-algorithm</a> 🌟🌟🌟🌟🌟</li><li><strong>RoadMap: </strong>持续更新中，预计一周更新 1 ~ 2 篇文章，预计到 202101 月底前更新完成</li><li><strong>获取更新:</strong> <a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a>、<a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener">知乎</a>、<a href="https://lailin.xyz/atom.xml">RSS</a>、<a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a></li><li>上一个系列刚刚完成了 <a href="https://lailin.xyz/post/go-design-pattern.html">Go 设计模式</a>，如果感兴趣也可以进行查看</li></ul><h2 id="问题回顾"><a href="#问题回顾" class="headerlink" title="问题回顾"></a>问题回顾</h2><p>本文章主要是为了回答上一篇文章的问题，并且介绍一下在这个过程中以及后续都会使用到的调试工具 <code>gdb</code></p><ul><li>请查看下面一段代码，会输出什么，为什么？<ul><li>A: 5 8 B: 8 8 C: 5 5 D: 5 6</li></ul></li></ul><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s))&#125;</code></pre><ul><li>在讲解 slice 初始化的过程中，为什么 <code>s2</code> , <code>s3</code> 打印的数组指针都是 <code>0x587450</code> ?</li></ul><h2 id="slice-扩容算法是否遗漏了什么？"><a href="#slice-扩容算法是否遗漏了什么？" class="headerlink" title="slice 扩容算法是否遗漏了什么？"></a>slice 扩容算法是否遗漏了什么？</h2><p>首先我们回顾一下上一篇文章当中讲到的 slice 扩容的 算法:</p><ul><li>如果需要的最小容量比两倍原有容量大，那么就取需要的容量</li><li>如果原有 slice 长度小于 1024 那么每次就扩容为原来的两倍</li><li>如果原 slice 大于等于 1024 那么每次扩容就扩为原来的 1.25 倍</li></ul><p>按照这个逻辑进行套用:</p><ul><li><code>s</code> 初始化时 <code>len=2</code></li><li><code>s = append(s, 3, 4, 5)</code> 此时需要的最小容量为 <code>5 &gt; 2*2</code></li><li>按照这个逻辑最后的答案应该是 <code>C: 5 5</code></li><li>但是如果大家运行过这段代码应该会知道这个答案是 <code>D: 5 6</code> 为什么呢？这个逻辑和我们之前了解到的不太一样啊</li></ul><p>接下来我们就使用 gdb 调试一下看看结果</p><h2 id="使用-GDB-调试-Golang-代码"><a href="#使用-GDB-调试-Golang-代码" class="headerlink" title="使用 GDB 调试 Golang 代码"></a>使用 GDB 调试 Golang 代码</h2><p>调试 go 程序我们常用的调试工具其实是 <a href="https://github.com/go-delve/delve" target="_blank" rel="noopener">dlv</a> 这个工具非常好用，并且可以很好的和 <code>VS Code</code> <code>Goland</code> 等 IDE 进行结合，但是它无法调试 runtime 的代码，这个时候就要使用上 gdb 了，如果大家不需要调试 runtime 的代码的话还是建议使用 dlv</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code class="hljs bash">brew install gdb <span class="hljs-comment"># for mac</span></code></pre><p>如果是 linux 使用自带的包管理工具进行安装即可<br>注意安装完成之后需要在 home 目录上添加相关配置</p><pre><code class="hljs bash">vim ~/.gdbinit<span class="hljs-comment"># 输入下面</span>add-auto-load-safe-path <span class="hljs-variable">$GOROOT</span>/src/runtime/runtime-gdb.py <span class="hljs-comment"># 这里将 $GOROOT 替换为你的 GO 安装目录</span></code></pre><p>如果你是 mac 首次安装 gdb 需要给 gdb 签名，可以参考: <a href="https://gist.github.com/hlissner/898b7dfc0a3b63824a70e15cd0180154" target="_blank" rel="noopener">https://gist.github.com/hlissner/898b7dfc0a3b63824a70e15cd0180154</a></p><h3 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h3><ul><li>我们使用 <code>-gcflags=all=&quot;-N -l&quot;</code> 禁用内联优化方便后面调试</li><li>在 mac 上如果不加 <code>-ldflags=&#39;-compressdwarf=false&#39;</code> 在 gdb 调试的时候可能会提示 <code>No symbol table is loaded. Use the &quot;file&quot; command.</code><ul><li>这是因为为了减少二进制大小会默认压缩 <strong>DWARF</strong> 调试信息，这个在 mac 和 windows 上部分工具不支持，linux 一般没有这个问题</li><li>加上 <code>-ldflags=&#39;-compressdwarf=false&#39;</code> 这个标志可以禁用压缩方便调试</li></ul></li></ul><pre><code class="hljs bash">go build -o bin/03_q1_slice_cap -gcflags=all=<span class="hljs-string">"-N -l"</span> -ldflags=<span class="hljs-string">'-compressdwarf=false'</span> 02_array/03_q1_slice_cap/main.go</code></pre><h3 id="进入-GDB-调试窗口"><a href="#进入-GDB-调试窗口" class="headerlink" title="进入 GDB 调试窗口"></a>进入 GDB 调试窗口</h3><ul><li><code>-tui</code> 表示同时显示代码窗口</li></ul><pre><code class="hljs bash">gdb -tui ./bin/03_q1_slice_cap</code></pre><p>如下图所示，回车几次之后出现 <code>Loading Go Runtime support.</code> 就说明正常了<br><img src="https://lailin.xyz/images/1605939788051-1d907407-893d-4d1c-bf87-8b9a91dc2905.png" srcset="/img/loading.gif" alt="image.png"></p><h3 id="常用调试命令"><a href="#常用调试命令" class="headerlink" title="常用调试命令"></a>常用调试命令</h3><ul><li><code>b 文件名:行数</code> 打断点</li><li><code>info b</code> 当前的断点情况</li><li><code>r</code> 运行程序知道断点处</li><li><code>c</code> 继续执行到下一个断点</li><li><code>s</code> 单步执行，如果有调用函数则进入函数，注意和 n 的区别</li><li><code>n</code> 单步执行，如果有调用的函数不会进入函数内部</li><li><code>until</code> 退出循环</li><li><code>until:行号</code> 执行到指定行</li><li><code>info locals</code> 当前堆栈的所有变量</li><li><code>info args</code> 打印参数</li><li><code>info goroutines</code> 查看所有的 goroutine 及其 ID</li><li><code>help</code> 帮助</li><li><code>q</code> 退出</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>知道如何操作之后，我们开始干活</p><ol><li>首先给 append 函数打一个断点 <code>b main.go:11</code></li><li>然后执行到断点处 <code>r</code></li><li>如下图所示，单步运行进入到 <code>slice</code> 的扩容函数中 <code>s</code></li></ol><p><img src="https://lailin.xyz/images/1605942212393-f3cdd7f9-29a9-47ad-8d6b-f298dcf8a9e9.png" srcset="/img/loading.gif" alt="image.png"></p><ol start="4"><li>接下来我们使用 <code>n</code> 一直单步执行到扩容算法结束，使用 <code>info locals</code> 打印变量。我们可以发现这个时候计算出的 <code>newcap</code> 和我们最初预计的一样是 5，那哪里出了问题呢？我们继续使用 <code>n</code> 接着看</li></ol><p><img src="https://lailin.xyz/images/1605942355389-cee6e121-db45-4062-b100-7fc225346368.png" srcset="/img/loading.gif" alt="image.png"></p><ol start="5"><li>如下图所示，执行到这里我们发现， <code>newcap</code> 被重新赋值了，并且这个时候 <code>capmem=48</code> <code>PtrSize=8</code> 所以最后的出来了 <code>newcap</code> 等于 6</li></ol><p><img src="https://lailin.xyz/images/1605942584081-99ee845c-c590-48fe-8736-aafdc6088dbd.png" srcset="/img/loading.gif" alt="image.png"><br>知道问题出现在哪里之后我们可以再来看一下源代码，有一个内存对齐的函数</p><pre><code class="hljs go"><span class="hljs-comment">// Returns size of the memory block that mallocgc will allocate if you ask for the size.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">roundupsize</span><span class="hljs-params">(size <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">uintptr</span></span> &#123;<span class="hljs-keyword">if</span> size &lt; _MaxSmallSize &#123;<span class="hljs-keyword">if</span> size &lt;= smallSizeMax<span class="hljs-number">-8</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">uintptr</span>(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]])&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">uintptr</span>(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]])&#125;&#125;<span class="hljs-keyword">if</span> size+_PageSize &lt; size &#123;<span class="hljs-keyword">return</span> size&#125;<span class="hljs-keyword">return</span> alignUp(size, _PageSize)&#125;<span class="hljs-keyword">const</span> (_MaxSmallSize   = <span class="hljs-number">32768</span>smallSizeDiv    = <span class="hljs-number">8</span>smallSizeMax    = <span class="hljs-number">1024</span>largeSizeDiv    = <span class="hljs-number">128</span>_NumSizeClasses = <span class="hljs-number">67</span>_PageShift      = <span class="hljs-number">13</span>)<span class="hljs-keyword">var</span> class_to_size = [_NumSizeClasses]<span class="hljs-keyword">uint16</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">48</span>, <span class="hljs-number">64</span>, <span class="hljs-number">80</span>, <span class="hljs-number">96</span>, <span class="hljs-number">112</span>, ...&#125;<span class="hljs-keyword">var</span> class_to_allocnpages = [_NumSizeClasses]<span class="hljs-keyword">uint8</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, ...&#125;</code></pre><p>可以发现我们之前在计算 capmem 的时候传入的 <code>capmem = roundupsize(uintptr(newcap) * sys.PtrSize)</code> 值是 <code>5*8=40</code> 最后对齐出的结果就是 <code>48</code> 了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="slice-扩容算法"><a href="#slice-扩容算法" class="headerlink" title="slice 扩容算法"></a>slice 扩容算法</h3><ul><li><strong>如果需要的最小容量比两倍原有容量大，那么就取需要的容量</strong></li><li>如果原有 slice 长度小于 1024 那么每次就扩容为原来的两倍</li><li>如果原 slice 大于等于 1024 那么每次扩容就扩为原来的 1.25 倍</li><li><strong>除此之外扩容容量计算完成之后，还会进行一次内存对齐操作</strong></li></ul><p>搜索 slice 扩容策略很多都会说第 2、3 点但是没有说 1, 4 点就会造成一些困惑</p><h3 id="GDB-调试"><a href="#GDB-调试" class="headerlink" title="GDB 调试"></a>GDB 调试</h3><ul><li>mac 下安装使用 gdb 比较麻烦，建议使用 linux</li><li>一般情况下我们还是建议使用 dlv 进行调试，如果有 runtime 库的调试需求可以使用 gdb</li><li>学习了 gdb 的安装以及基本使用方式，你之前有类似的经历么？一般会在什么情况下使用 gdb 进行调试</li></ul><h3 id="问题-2-解答-在讲解-slice-初始化的过程中，为什么-s2-s3-打印的数组指针都是-0x587450"><a href="#问题-2-解答-在讲解-slice-初始化的过程中，为什么-s2-s3-打印的数组指针都是-0x587450" class="headerlink" title="问题 2 解答: 在讲解 slice 初始化的过程中，为什么 s2 , s3 打印的数组指针都是 0x587450 ?"></a>问题 2 解答: 在讲解 slice 初始化的过程中，为什么 <code>s2</code> , <code>s3</code> 打印的数组指针都是 <code>0x587450</code> ?</h3><p>在讲解 <code>makeslice</code> 的时候我们有说到最后一步会调用 <code>mallocgc</code> 分配内存，看这个函数的源码我们就能发现，有一步判断，如果容量为 0 会返回一个固定的地址</p><pre><code class="hljs go"><span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span> &#123;    <span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zerobase)&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据结构与算法02-数组上: 深入理解 slice</title>
    <link href="/post/array.html"/>
    <url>/post/array.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 数据结构与算法系列文章，本系列文章主要会包括常见的数据结构与算法实现，同时会包括 Go 标准库代码的分析理解，讲到对应章节的时候优先学习分析 Go 的源码实现，例如 slice、list、sort 等，然后可能会有一些常见的案例实现，同时这也是 <a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener">极客时间-数据结构与算法之美</a> 的课程笔记</li><li><strong>本文代码仓库:</strong> <a href="https://github.com/mohuishou/go-algorithm" target="_blank" rel="noopener">https://github.com/mohuishou/go-algorithm</a> 🌟🌟🌟🌟🌟</li><li><strong>RoadMap: </strong>持续更新中，预计一周更新 1 ~ 2 篇文章，预计到 202101 月底前更新完成</li><li><strong>获取更新:</strong> <a href="https://github.com/mohuishou" target="_blank" rel="noopener">Github</a>、<a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener">知乎</a>、<a href="https://lailin.xyz/atom.xml">RSS</a>、<a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a></li><li>上一个系列刚刚完成了 <a href="https://lailin.xyz/post/go-design-pattern.html">Go 设计模式</a>，如果感兴趣也可以进行查看</li></ul><h2 id="上期答案"><a href="#上期答案" class="headerlink" title="上期答案"></a>上期答案</h2><h3 id="Q-通过-Element-节点中的-List-结构来判断节点是否属于当前链表的方式，在某些情况下会出现-bug"><a href="#Q-通过-Element-节点中的-List-结构来判断节点是否属于当前链表的方式，在某些情况下会出现-bug" class="headerlink" title="Q: 通过 Element 节点中的 List 结构来判断节点是否属于当前链表的方式，在某些情况下会出现  bug"></a>Q: 通过 Element 节点中的 List 结构来判断节点是否属于当前链表的方式，在某些情况下会出现 <code>bug</code></h3><pre><code class="hljs go">l := list.List&#123;&#125;e := l.PushBack(<span class="hljs-number">10</span>)l = list.List&#123;&#125;l.Remove(e)fmt.Println(<span class="hljs-string">"list len: "</span>, l.Len())</code></pre><p>接着看下面之前，先想一想，你觉得这段代码会输出什么？<br>这个问题来自: <a href="https://github.com/golang/go/issues/39014" target="_blank" rel="noopener">https://github.com/golang/go/issues/39014</a><br>这段代码会输出 -1，但是我们期望的不应该是输出 0 么？<br>我们来看看发生了什么？<br><img src="https://lailin.xyz/images/1605409586875-e7ef8b69-b95a-4fb8-9d6a-27f33f8f689c.svg" srcset="/img/loading.gif" alt="01_链表.drawio.svg"></p><ul><li>当我们执行完 <code>l.PushBack(10)</code> 这段代码直接，就如左图所示了，节点 e 指向了链表 l，链表 l 的值的长度是 1</li><li>但是当我们执行完 <code>l = list.List{}</code> 我们重置了链表 l 的值，并没有修改他的地址，所以 e 还是指向的链表 l，当执行 <code>Remove</code> 方法的时候，e 的链表和当前执行的 l 的地址判断是可以对应的上的，但是实际上链表的值已经发生了变化，链表的长度已经不为 1 的，并且新的链表的根节点也没有指向 e</li><li>所以最后得到的长度才是 -1</li><li>最后细心的同学应该已经发现，这里其实还可能存在内存泄漏的问题，元素 e -&gt; root(0x2) 其实已经没有用到了</li></ul><h2 id="什么是数组？"><a href="#什么是数组？" class="headerlink" title="什么是数组？"></a>什么是数组？</h2><ul><li>数组大家应该都非常属性我们来简单的回顾一下</li><li>数组是一个具有连续的内存空间和相同类型的数据的数据结构</li><li>我们随机访问任意一个下标的数据的时间复杂度都是 O(1)</li><li>但是正是由于这种特性，导致它插入和删除元素的效率比较低，是 O(n)</li></ul><p><img src="https://lailin.xyz/images/1605409904549-b00a01d7-340f-4101-9e11-cdcea25528e1.svg" srcset="/img/loading.gif" alt="01_array.drawio.svg"></p><h2 id="Go-中的数组"><a href="#Go-中的数组" class="headerlink" title="Go 中的数组"></a>Go 中的数组</h2><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 初始化数组</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<span class="hljs-comment">// 查找元素</span>fmt.Printf(<span class="hljs-string">"arr[1]: %d\n"</span>, arr[<span class="hljs-number">1</span>])<span class="hljs-comment">// 删除元素</span>remove(&amp;arr, <span class="hljs-number">2</span>)<span class="hljs-comment">// remove(&amp;arr, 3) // will panic</span>fmt.Println(arr)&#125;<span class="hljs-comment">// 删除数组 arr 的某个元素</span><span class="hljs-comment">// index 为需要删除的索引</span><span class="hljs-comment">// 从需要删除的元素开始，依次将后面的元素往前移动一位即可</span><span class="hljs-comment">// 然后将最后一位修改为该类型的默认值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">(arr *[3]<span class="hljs-keyword">int</span>, index <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> index &gt;= <span class="hljs-built_in">len</span>(arr) &#123;log.Panicf(<span class="hljs-string">"%d remove out range arr"</span>, index)&#125;<span class="hljs-keyword">for</span> i := index; i &lt; <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>; i++ &#123;arr[i] = arr[i+<span class="hljs-number">1</span>]&#125;arr[<span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>&#125;</code></pre><h3 id="Q-为什么我们在-remove-函数当中的参数使用的是指针"><a href="#Q-为什么我们在-remove-函数当中的参数使用的是指针" class="headerlink" title="Q: 为什么我们在 remove 函数当中的参数使用的是指针"></a>Q: 为什么我们在 remove 函数当中的参数使用的是指针</h3><p>这是因为在 go 中参数的传递都是值传递，如果不用指针的话，那么就会复制一份数据到函数中，这样就无法做到删除的作用</p><pre><code class="hljs go"><span class="hljs-comment">// 在函数 main 中</span>fmt.Printf(<span class="hljs-string">"main: %p --&gt; %+v\n"</span>, &amp;arr, arr)p(arr)p2(&amp;arr)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">p</span><span class="hljs-params">(arr [3]<span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">"p: %p --&gt; %+v\n"</span>, &amp;arr, arr)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">p2</span><span class="hljs-params">(arr *[3]<span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">"p2: %p --&gt; %+v\n"</span>, arr, arr)&#125;</code></pre><p>输出:</p><pre><code class="hljs go">main: <span class="hljs-number">0xc0000c2000</span> --&gt; [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span>]p: <span class="hljs-number">0xc0000c2080</span> --&gt; [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span>]p2: <span class="hljs-number">0xc0000c2000</span> --&gt; &amp;[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span>]</code></pre><p>通过上面的例子我们就可以发现，在函数 p 中我们直接传递的数组，最后打印的变量地址是和 main 中不同的，就印证了我们之前的说法<br>在实际使用过程中，我们其实是很少使用到固定长度的数组的，而是使用可以自动扩容的 slice，接下来我们就深入的看一下 slice 当中的一些细节</p><h2 id="深入理解-Slice"><a href="#深入理解-Slice" class="headerlink" title="深入理解 Slice"></a>深入理解 Slice</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h4><pre><code class="hljs go"><span class="hljs-comment">// 初始化</span>s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>)fmt.Printf(<span class="hljs-string">"s1(%p): %v, len: %d, cap: %d\n"</span>, &amp;s1, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<span class="hljs-comment">// s1(0xc00000c080): [0 0], len: 2, cap: 2</span><span class="hljs-comment">// 赋值</span>s1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>s1[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>fmt.Printf(<span class="hljs-string">"s1(%p): %v, len: %d, cap: %d\n"</span>, &amp;s1, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<span class="hljs-comment">//s1(0xc00000c080): [1 2], len: 2, cap: 2</span><span class="hljs-comment">// 扩容</span>s1 = <span class="hljs-built_in">append</span>(s1, <span class="hljs-number">3</span>)fmt.Printf(<span class="hljs-string">"s1(%p): %v, len: %d, cap: %d\n"</span>, &amp;s1, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<span class="hljs-comment">// s1(0xc00000c080): [1 2 3], len: 3, cap: 4</span><span class="hljs-comment">// 删除元素</span>s1 = <span class="hljs-built_in">append</span>(s1[:<span class="hljs-number">1</span>], s1[<span class="hljs-number">2</span>:]...)fmt.Printf(<span class="hljs-string">"s1(%p): %v, len: %d, cap: %d\n"</span>, &amp;s1, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<span class="hljs-comment">// s1(0xc00000c080): [1 3], len: 2, cap: 4</span></code></pre><ul><li>可以发现，通过 append 之后 s1 的容量和长度都发生了变化，说明完成了自动扩容</li><li>删除元素之后我们的长度发生了变化，但是容量还是原本不变</li></ul><h4 id="常见坑"><a href="#常见坑" class="headerlink" title="常见坑"></a>常见坑</h4><pre><code class="hljs go"><span class="hljs-comment">// 复制一个 slice</span>s2 := s1[:<span class="hljs-number">2</span>]fmt.Printf(<span class="hljs-string">"s2(%p): %v, len: %d, cap: %d\n"</span>, &amp;s2, s2, <span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">cap</span>(s2))<span class="hljs-comment">// s2(0xc00000c120): [1 3], len: 2, cap: 4</span>s1[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span> <span class="hljs-comment">// 这里可以发现，s1[0] s2[0] 都被修改为了 10</span>fmt.Printf(<span class="hljs-string">"s1(%p): %v, len: %d, cap: %d\n"</span>, &amp;s1, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<span class="hljs-comment">// s1(0xc00000c080): [10 3], len: 2, cap: 4</span>fmt.Printf(<span class="hljs-string">"s2(%p): %v, len: %d, cap: %d\n"</span>, &amp;s2, s2, <span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">cap</span>(s2))<span class="hljs-comment">// s2(0xc00000c120): [10 3], len: 2, cap: 4</span>s1 = <span class="hljs-built_in">append</span>(s1, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>)s1[<span class="hljs-number">0</span>] = <span class="hljs-number">11</span> <span class="hljs-comment">// 这里可以发现，s1[0] 被修改为了 11, s2[0] 还是10</span>fmt.Printf(<span class="hljs-string">"s1(%p): %v, len: %d, cap: %d\n"</span>, &amp;s1, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<span class="hljs-comment">// s1(0xc00011c020): [11 3 5 6 7 8], len: 6, cap: 8</span>fmt.Printf(<span class="hljs-string">"s2(%p): %v, len: %d, cap: %d\n"</span>, &amp;s2, s2, <span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">cap</span>(s2))<span class="hljs-comment">// s2(0xc00011c0c0): [10 3], len: 2, cap: 4</span></code></pre><ul><li>这是一个常见的例子，我们从 s1 复制了一个 s2</li><li>修改 s1 的第一个元素之后，s2 的一个元素也被修改了</li><li>但是我们触发了 s1 的自动扩容之后，s2 的第一个元素就不会随着 s1 的修改而变化了</li><li>这也是当函数的参数是 slice 时我们不允许直接修改，如果需要修改需要返回这个 slice 的原因，因为函数的参数也是值的复制</li></ul><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sliceChange</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">// 不允许直接这么操作</span>s[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>&#125;</code></pre><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>大家如果使用过一段时间 golang 应该知道 slice 的底层结构其实是一个 struct<br><a href="https://github.com/golang/go/blob/go1.15/src/runtime/slice.go" target="_blank" rel="noopener">https://github.com/golang/go/blob/go1.15/src/runtime/slice.go</a></p><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;array unsafe.Pointer<span class="hljs-built_in">len</span>   <span class="hljs-keyword">int</span><span class="hljs-built_in">cap</span>   <span class="hljs-keyword">int</span>&#125;</code></pre><p><img src="https://lailin.xyz/images/1605449197795-9ca02de7-b129-4f7c-a0c3-930798b881c0.svg" srcset="/img/loading.gif" alt="02_slice_struct.drawio.svg"></p><ul><li>如图所示我们可以发现，slice 的底层结构是一个结构体<ul><li>它包含了一个指向一个数组的指针，数据实际上存储在这个指针指向的数组上</li><li>len 表示当前 slice 使用到的长度</li><li>cap 表示当前 slice 的容量，同时也是底层数组 array 的长度</li></ul></li><li>这也就回答了我们上面的发现的现象，在复制 slice 的时候，slice 中数组的指针也被复制了，在出发扩容逻辑之前，两个 slice 指向的是相同的数组，出发扩容逻辑之后指向的就是不同的数组了</li><li>同时因为结构体中 array 是一个指针所以在 slice 作为参数传递的时候，这个指针也会被复制一份，所以也会有相同的问题</li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre><code class="hljs go"><span class="hljs-comment">// 创建一个 slice</span><span class="hljs-comment">// et: 数据的类型</span><span class="hljs-comment">// len: slice 长度</span><span class="hljs-comment">// cap: slice 容量</span><span class="hljs-comment">// 返回一个指针</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeslice</span><span class="hljs-params">(et *_type, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;    <span class="hljs-comment">// 通过 cap 计算当前类型的 slice 需要的内存容量以及是否超出最大容量</span>mem, overflow := math.MulUintptr(et.size, <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">cap</span>))    <span class="hljs-comment">// 异常情况判断</span><span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc || <span class="hljs-built_in">len</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span> &gt; <span class="hljs-built_in">cap</span> &#123;<span class="hljs-comment">// 通过 len 计算当前类型的 slice 需要的内存容量以及是否超出最大容量</span>        <span class="hljs-comment">// 如果是 len 超过限制则抛出 len 的相关异常，否则抛出 cap 异常</span>mem, overflow := math.MulUintptr(et.size, <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">len</span>))<span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc || <span class="hljs-built_in">len</span> &lt; <span class="hljs-number">0</span> &#123;panicmakeslicelen()&#125;panicmakeslicecap()&#125;<span class="hljs-keyword">return</span> mallocgc(mem, et, <span class="hljs-literal">true</span>)&#125;</code></pre><p>还有一个 64 位的</p><ul><li>64 位对比默认的只是进行了一下数据格式转换，但是这个转换的对比还是很有意思的</li><li>如果是在 64 位的机器上，那么 int == int64 的</li><li>如果是在 32 位的机器上，那么 int == int32，如果 int64(int(len64)) != len64，那么就说明这个长度超出了当前机器的内存位数，直接抛出异常错误就好了</li></ul><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeslice64</span><span class="hljs-params">(et *_type, len64, cap64 <span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;<span class="hljs-built_in">len</span> := <span class="hljs-keyword">int</span>(len64)<span class="hljs-keyword">if</span> <span class="hljs-keyword">int64</span>(<span class="hljs-built_in">len</span>) != len64 &#123;panicmakeslicelen()&#125;<span class="hljs-built_in">cap</span> := <span class="hljs-keyword">int</span>(cap64)<span class="hljs-keyword">if</span> <span class="hljs-keyword">int64</span>(<span class="hljs-built_in">cap</span>) != cap64 &#123;panicmakeslicecap()&#125;<span class="hljs-keyword">return</span> makeslice(et, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span>)&#125;</code></pre><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><pre><code class="hljs go"><span class="hljs-comment">// 当 append 需要扩容的时候会调用这个函数</span><span class="hljs-comment">// et 是当前 slice 的类型</span><span class="hljs-comment">// old 是原有的 slice</span><span class="hljs-comment">// cap 是满足扩容所需的最小容量</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">growslice</span><span class="hljs-params">(et *_type, old slice, <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">slice</span></span> &#123;<span class="hljs-comment">// ... 一些校验逻辑，略过</span>    <span class="hljs-comment">// 下面这个就是扩容算法</span>newcap := old.<span class="hljs-built_in">cap</span>doublecap := newcap + newcap<span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;newcap = <span class="hljs-built_in">cap</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> old.<span class="hljs-built_in">len</span> &lt; <span class="hljs-number">1024</span> &#123;newcap = doublecap&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span><span class="hljs-comment">// and prevent an infinite loop.</span><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;newcap += newcap / <span class="hljs-number">4</span>&#125;<span class="hljs-comment">// Set newcap to the requested cap when</span><span class="hljs-comment">// the newcap calculation overflowed.</span><span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;newcap = <span class="hljs-built_in">cap</span>&#125;&#125;&#125;    <span class="hljs-comment">// 下面去计算新的数组所需要的内存</span>    <span class="hljs-comment">// 通过 old.len, cap, 以及 newcap 计算</span><span class="hljs-keyword">var</span> overflow <span class="hljs-keyword">bool</span><span class="hljs-keyword">var</span> lenmem, newlenmem, capmem <span class="hljs-keyword">uintptr</span><span class="hljs-comment">// Specialize for common values of et.size.</span><span class="hljs-comment">// For 1 we don't need any division/multiplication.</span><span class="hljs-comment">// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.</span><span class="hljs-comment">// For powers of 2, use a variable shift.</span><span class="hljs-keyword">switch</span> &#123;<span class="hljs-keyword">case</span> et.size == <span class="hljs-number">1</span>:lenmem = <span class="hljs-keyword">uintptr</span>(old.<span class="hljs-built_in">len</span>)newlenmem = <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">cap</span>)capmem = roundupsize(<span class="hljs-keyword">uintptr</span>(newcap))overflow = <span class="hljs-keyword">uintptr</span>(newcap) &gt; maxAllocnewcap = <span class="hljs-keyword">int</span>(capmem)<span class="hljs-comment">// ... 有好几个分支，看一个类似的就可以了</span>&#125;<span class="hljs-comment">// 检查是不是超过内存限制</span><span class="hljs-keyword">if</span> overflow || capmem &gt; maxAlloc &#123;<span class="hljs-built_in">panic</span>(errorString(<span class="hljs-string">"growslice: cap out of range"</span>))&#125;    <span class="hljs-comment">// 分配内存</span><span class="hljs-keyword">var</span> p unsafe.Pointer<span class="hljs-keyword">if</span> et.ptrdata == <span class="hljs-number">0</span> &#123;p = mallocgc(capmem, <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>)<span class="hljs-comment">// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).</span><span class="hljs-comment">// Only clear the part that will not be overwritten.</span>memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span>p = mallocgc(capmem, et, <span class="hljs-literal">true</span>)<span class="hljs-keyword">if</span> lenmem &gt; <span class="hljs-number">0</span> &amp;&amp; writeBarrier.enabled &#123;<span class="hljs-comment">// Only shade the pointers in old.array since we know the destination slice p</span><span class="hljs-comment">// only contains nil pointers because it has been cleared during alloc.</span>bulkBarrierPreWriteSrcOnly(<span class="hljs-keyword">uintptr</span>(p), <span class="hljs-keyword">uintptr</span>(old.array), lenmem-et.size+et.ptrdata)&#125;&#125;    <span class="hljs-comment">// 将原本的数组复制到新数组上</span>memmove(p, old.array, lenmem)<span class="hljs-keyword">return</span> slice&#123;p, old.<span class="hljs-built_in">len</span>, newcap&#125;&#125;</code></pre><p>我们重点看一下扩容的算法，可以发现有三种逻辑</p><ul><li>如果需要的最小容量比两倍原有容量大，那么就取需要的容量</li><li>如果原有 slice 长度小于 1024 那么每次就扩容为原来的两倍</li><li>如果原 slice 大于等于 1024 那么每次扩容就扩为原来的 1.25 倍</li></ul><pre><code class="hljs go">newcap := old.<span class="hljs-built_in">cap</span>doublecap := newcap + newcap<span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;    newcap = <span class="hljs-built_in">cap</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">if</span> old.<span class="hljs-built_in">len</span> &lt; <span class="hljs-number">1024</span> &#123;        newcap = doublecap    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span>        <span class="hljs-comment">// and prevent an infinite loop.</span>        <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;            newcap += newcap / <span class="hljs-number">4</span>        &#125;        <span class="hljs-comment">// Set newcap to the requested cap when</span>        <span class="hljs-comment">// the newcap calculation overflowed.</span>        <span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;            newcap = <span class="hljs-built_in">cap</span>        &#125;    &#125;&#125;</code></pre><h3 id="空-Slice"><a href="#空-Slice" class="headerlink" title="空 Slice"></a>空 Slice</h3><p>我们先看一下 Slice 初始化的方式</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> s1 []<span class="hljs-keyword">int</span>s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">uint</span>, <span class="hljs-number">0</span>)s3 := []<span class="hljs-keyword">int</span>&#123;&#125;<span class="hljs-comment">// fmt.Printf("%p: %v, len: %d, cap: %d\n", s1, s1, len(s1), cap(s1))</span><span class="hljs-comment">// 0x0: [], len: 0, cap: 0</span><span class="hljs-comment">// 0x587450: [], len: 0, cap: 0</span><span class="hljs-comment">// 0x587450: [], len: 0, cap: 0</span></code></pre><ul><li>tips: <code>%p</code> 打印 slice 会打印 slice 底层指向的数组的地址</li><li>我们可以发现，第一种方式进行初始化，出现的也就是 slice 的零值，底层的数组指针是一个 nil</li><li>第二种和第三种的底层指针都有一个值，不过没有实际分配内存</li><li>这三种方式初始化出来的 cap、和 len 的长度都是 0</li></ul><h3 id="规范技巧"><a href="#规范技巧" class="headerlink" title="规范技巧"></a>规范技巧</h3><ol><li>slice 作为参数时，不要直接存储它的引用，而是通过 <code>copy</code> 复制一份<ol><li>原因请查看上文，Slice 的结构</li><li>示例：<a href="https://github.com/xxjwxc/uber_go_guide_cn#nil-%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9C%89%E6%95%88%E7%9A%84-slice" target="_blank" rel="noopener">Uber Go 规范: nil-是一个有效的-slice</a></li></ol></li><li>要检查切片是否为空，请始终使用 <code>len(s) == 0</code> 。而非 <code>nil</code> 。<ol><li>原因请查看上文，Slice 初始化</li><li>示例：<a href="https://github.com/xxjwxc/uber_go_guide_cn#%E5%9C%A8%E8%BE%B9%E7%95%8C%E5%A4%84%E6%8B%B7%E8%B4%9D-Slices-%E5%92%8C-Maps" target="_blank" rel="noopener">Uber Go 规范: 在边界处拷贝-Slices-和-Maps</a></li></ol></li></ol><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><ul><li>在讲解 slice 初始化的过程中，为什么 <code>s2</code> , <code>s3</code> 打印的数组指针都是 <code>0x587450</code> ?</li><li>请查看下面一段代码，会输出什么，为什么？<ul><li>A: 5 8 B: 8 8 C: 5 5 D: 5 6</li></ul></li></ul><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s))&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据结构与算法01-链表: 深入理解container/list&amp;LRU缓存的实现</title>
    <link href="/post/list.html"/>
    <url>/post/list.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 数据结构与算法系列文章，本系列文章主要会包括常见的数据结构与算法实现，同时会包括 Go 标准库代码的分析理解，讲到对应章节的时候优先学习分析 Go 的源码实现，例如 slice、list、sort 等，然后可能会有一些常见的案例实现，同时这也是 <a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener">极客时间-数据结构与算法之美</a> 的课程笔记</li><li><strong>本文代码仓库:</strong> <a href="https://github.com/mohuishou/go-algorithm" target="_blank" rel="noopener">https://github.com/mohuishou/go-algorithm</a> 🌟🌟🌟🌟🌟</li><li><strong>RoadMap: </strong>持续更新中，预计一周更新 1 ~ 2 篇文章，预计到 202101 月底前更新完成</li><li><strong>获取更新:</strong> <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">Github</a>、<a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener">知乎</a>、<a href="https://lailin.xyz/atom.xml">RSS</a>、<a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener">开发者头条</a></li><li>上一个系列刚刚完成了 <a href="https://lailin.xyz/post/go-design-pattern.html">Go 设计模式</a>，如果感兴趣也可以进行查看</li></ul><h2 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><ul><li>链表通过指针将零散的内存数据联系在一起</li><li>如下图所示，包含两个结构，一个是数据 data，另外一个是下一个节点的内存地址</li><li>最后一个节点指向 NULL</li></ul><p><img src="https://lailin.xyz/images/1604804227362-0a6030ac-cf14-4052-8a4b-87eec4e1a904.jpeg" srcset="/img/loading.gif" alt="01_链表-单链表.jpg"></p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><ul><li>和单链表的区别就是，将尾节点指向的头结点，将整个链表组成了一个环状</li></ul><p><img src="https://lailin.xyz/images/1604804281440-be68f311-161b-42bf-b8ac-f48f917b8732.png" srcset="/img/loading.gif" alt="01_链表-循环链表.png"></p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ul><li>和在单链表的基础之上添加了一个指向上一个节点的指针，这样我们知道任意一个节点就可以同时知道他们的上下两个节点</li><li>这是实际使用的时候最常用的</li></ul><p><img src="https://lailin.xyz/images/1604804268492-79fe5525-be57-4eb8-bee7-0900e041af66.jpeg" srcset="/img/loading.gif" alt="01_链表-双向链表.jpg"></p><h3 id="和数组对比"><a href="#和数组对比" class="headerlink" title="和数组对比"></a>和数组对比</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>链表</strong></th><th style="text-align:center"><strong>数组</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>查找某个元素</strong></td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center"><strong>删除或者添加一个元素</strong></td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td></tr></tbody></table><h2 id="标准库-Container-list-的实现"><a href="#标准库-Container-list-的实现" class="headerlink" title="标准库 Container/list 的实现"></a>标准库 Container/list 的实现</h2><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><pre><code class="hljs go"><span class="hljs-comment">// Element 用于表示链表当中的节点</span><span class="hljs-keyword">type</span> Element <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// next, prev 分别表示上个节点和下个节点</span>next, prev *Element<span class="hljs-comment">// 表示节点所在的元素</span>list *List<span class="hljs-comment">// 节点所保存的数据，也就是上面图中的 data</span>Value <span class="hljs-keyword">interface</span>&#123;&#125;&#125;<span class="hljs-comment">// List 这是一个双向链表</span><span class="hljs-comment">// List 的零值是一个空链表</span><span class="hljs-keyword">type</span> List <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// 根节点，List 其实是一个双向循环链表，root， root.prev 是尾节点, 尾节点的下一个节点指向 root</span>    <span class="hljs-comment">// 根节点是一个哨兵节点，是为了用来简化节点操作使用的</span>root Element    <span class="hljs-comment">// 链表的长度，不包括哨兵节点，也就是根节点</span><span class="hljs-built_in">len</span>  <span class="hljs-keyword">int</span>&#125;</code></pre><p>看到这里我下意识的会有两个问题：</p><ul><li>为什么在 <code>Element</code> 当中会持有一个 <code>List</code> 结构？</li><li>为什么需要一个单独的 <code>List</code> 结构体，直接要一个 <code>Root</code> 节点不就完事了么？</li></ul><h3 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h3><pre><code class="hljs go">Remove(e *Element) <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 删除一个节点</span>PushFront(v <span class="hljs-keyword">interface</span>&#123;&#125;) *Element <span class="hljs-comment">// 将值插入到链表头部</span>PushBack(v <span class="hljs-keyword">interface</span>&#123;&#125;) *Element <span class="hljs-comment">// 将值插入到链表尾部</span>InsertBefore(v <span class="hljs-keyword">interface</span>&#123;&#125;, mark *Element) *Element <span class="hljs-comment">// 在 mark 节点之前插入值</span>InsertAfter(v <span class="hljs-keyword">interface</span>&#123;&#125;, mark *Element) *Element <span class="hljs-comment">// 在 mark 节点之后插入值</span>MoveToFront(e *Element) <span class="hljs-comment">// 将节点 e 移动至链表头部</span>MoveToBack(e *Element) <span class="hljs-comment">// 将节点 e 移动至链表尾部</span>MoveBefore(e, mark *Element) <span class="hljs-comment">// 将节点 e 移动到 mark 节点之前</span>MoveAfter(e, mark *Element) <span class="hljs-comment">// 将节点 e 移动到 mark 节点之后</span>PushBackList(other *List) <span class="hljs-comment">// 将链表 other 连接到当前链表之后</span>PushFrontList(other *List) <span class="hljs-comment">// 将链表 other 连接到当前链表之前</span></code></pre><p>看了暴露的方法集之后我们看一下这里面核心的几个方法，上诉暴露的方法实质上都是通过调用下面的方法实现的</p><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><pre><code class="hljs go"><span class="hljs-comment">// 将节点 e 插入 at 之后</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span> <span class="hljs-title">insert</span><span class="hljs-params">(e, at *Element)</span> *<span class="hljs-title">Element</span></span> &#123;    <span class="hljs-comment">// 假设 at.next 为 nt</span>    <span class="hljs-comment">// 1. 将节点 e 的上一个节点指向 at</span>e.prev = at    <span class="hljs-comment">// 2. 将节点 e 的下一个节点指向 nt</span>e.next = at.next    <span class="hljs-comment">// 3. 这个时候  e.prev.next == at.next</span>    <span class="hljs-comment">// 其实就是本来 at --&gt; nt，修改为 at --&gt; e</span>e.prev.next = e    <span class="hljs-comment">// 4. e.next.prev == nt.prev</span>    <span class="hljs-comment">// 本来 at &lt;--- nt，修改为 e &lt;--- nt</span>e.next.prev = ee.list = ll.<span class="hljs-built_in">len</span>++<span class="hljs-keyword">return</span> e&#125;</code></pre><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><pre><code class="hljs go"><span class="hljs-comment">// remove removes e from its list, decrements l.len, and returns e.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span> <span class="hljs-title">remove</span><span class="hljs-params">(e *Element)</span> *<span class="hljs-title">Element</span></span> &#123;e.prev.next = e.nexte.next.prev = e.prev    <span class="hljs-comment">// 这里为了避免内存泄漏的操作可以学习</span>e.next = <span class="hljs-literal">nil</span> <span class="hljs-comment">// avoid memory leaks</span>e.prev = <span class="hljs-literal">nil</span> <span class="hljs-comment">// avoid memory leaks</span>e.list = <span class="hljs-literal">nil</span>l.<span class="hljs-built_in">len</span>--<span class="hljs-keyword">return</span> e&#125;</code></pre><h4 id="move"><a href="#move" class="headerlink" title="move"></a>move</h4><pre><code class="hljs go"><span class="hljs-comment">// move moves e to next to at and returns e.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span> <span class="hljs-title">move</span><span class="hljs-params">(e, at *Element)</span> *<span class="hljs-title">Element</span></span> &#123;<span class="hljs-keyword">if</span> e == at &#123;<span class="hljs-keyword">return</span> e&#125;    <span class="hljs-comment">// 先把当前节点从原来的位置移除</span>e.prev.next = e.nexte.next.prev = e.prev    <span class="hljs-comment">// 再将当前节点 e 插入到 at 节点之后</span>e.prev = ate.next = at.nexte.prev.next = ee.next.prev = e<span class="hljs-keyword">return</span> e&#125;</code></pre><h3 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h3><p>我们在看一下最开始的两个问题<br><strong>1. 为什么在 <code>Element</code> 当中会持有一个 <code>List</code> 结构？</strong></p><ul><li>查看上方的 move 方法我们就可以知道，list 提供了讲节点移动到某个节点之后的方法，通过 e.List 进行对比我们就可以知道需要移动的节点是不是属于当前这个链表了，这也是 <code>MoveToFront</code> 等方法的实现方式</li></ul><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span> <span class="hljs-title">MoveToFront</span><span class="hljs-params">(e *Element)</span></span> &#123;<span class="hljs-keyword">if</span> e.list != l || l.root.next == e &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// see comment in List.Remove about initialization of l</span>l.move(e, &amp;l.root)&#125;</code></pre><p><strong>2. 为什么需要一个单独的 <code>List</code> 结构体，直接要一个 <code>Root</code> 节点不就完事了么？</strong></p><ul><li>看之前的 <code>List</code> 的结构我们可以发现，在结构体中包含了一个 <code>len</code> ，这样可以避免需要取长度的时候每次都需要从头到尾遍历一遍</li></ul><h2 id="如何实现一个并发安全的-Container-list？"><a href="#如何实现一个并发安全的-Container-list？" class="headerlink" title="如何实现一个并发安全的 Container/list？"></a>如何实现一个并发安全的 Container/list？</h2><p>接下来，我们使用 <code>go test -race .</code> 测试是否存在并发安全的问题</p><h3 id="标准库包"><a href="#标准库包" class="headerlink" title="标准库包"></a>标准库包</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestList</span><span class="hljs-params">(t *testing.T)</span></span> &#123;l := list.New()wg := sync.WaitGroup&#123;&#125;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;l.PushBack(i)&#125;wg.Done()&#125;()l.PushBack(<span class="hljs-number">11</span>)wg.Wait()&#125;</code></pre><p>测试结果如下，可以明显的看到存在并发问题</p><pre><code class="hljs go"> <span class="hljs-keyword">go</span> test  -v -timeout <span class="hljs-number">1</span>s -race -run ^TestList$ ./...=== RUN   TestList==================WARNING: DATA RACERead at <span class="hljs-number">0x00c00006e330</span> by goroutine <span class="hljs-number">8</span>:  container/list.(*List).lazyInit()      /usr/local/<span class="hljs-keyword">go</span>/src/container/list/list.<span class="hljs-keyword">go</span>:<span class="hljs-number">86</span> +<span class="hljs-number">0xb2</span></code></pre><h3 id="稍作改造"><a href="#稍作改造" class="headerlink" title="稍作改造"></a>稍作改造</h3><pre><code class="hljs go"><span class="hljs-comment">// List 链表</span><span class="hljs-keyword">type</span> List <span class="hljs-keyword">struct</span> &#123;*list.Listmu sync.Mutex&#125;<span class="hljs-comment">// New 新建链表</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span> *<span class="hljs-title">List</span></span> &#123;<span class="hljs-keyword">return</span> &amp;List&#123;List: list.New()&#125;&#125;<span class="hljs-comment">// PushBack 像链表尾部插入值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span> <span class="hljs-title">PushBack</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;    <span class="hljs-comment">// 加锁</span>l.mu.Lock()<span class="hljs-keyword">defer</span> l.mu.Unlock()l.List.PushBack(v)&#125;</code></pre><p>问题解决</p><pre><code class="hljs go"><span class="hljs-keyword">go</span> test  -v -timeout <span class="hljs-number">1</span>s -race -run ^TestList_PushBack$ ./...=== RUN   TestList_PushBack--- PASS: TestList_PushBack (<span class="hljs-number">0.00</span>s)PASSok      github.com/mohuishou/<span class="hljs-keyword">go</span>-algorithm/<span class="hljs-number">01</span>_list/list  (cached)</code></pre><h2 id="如何实现一个-LRU-缓存？"><a href="#如何实现一个-LRU-缓存？" class="headerlink" title="如何实现一个 LRU 缓存？"></a>如何实现一个 LRU 缓存？</h2><p>LRU: Least Recently Used 最近最少使用策略</p><blockquote><p>这里为了训练一下代码，就没有直接使用标准库的包了</p></blockquote><pre><code class="hljs go"><span class="hljs-keyword">package</span> lru<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span>)<span class="hljs-comment">// Node 链表的节点</span><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;prev, next *Nodelist *LRUkey   <span class="hljs-keyword">string</span>value <span class="hljs-keyword">interface</span>&#123;&#125;&#125;<span class="hljs-comment">// LRU 缓存</span><span class="hljs-keyword">type</span> LRU <span class="hljs-keyword">struct</span> &#123;root *Node <span class="hljs-comment">// 根节点</span><span class="hljs-built_in">cap</span>  <span class="hljs-keyword">int</span>   <span class="hljs-comment">// 当前缓存容量</span><span class="hljs-built_in">len</span>  <span class="hljs-keyword">int</span>   <span class="hljs-comment">// 缓存的长度</span>&#125;<span class="hljs-comment">// NewLRU NewLRU</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLRU</span><span class="hljs-params">(<span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">LRU</span></span> &#123;l := &amp;LRU&#123;root: &amp;Node&#123;&#125;,<span class="hljs-built_in">cap</span>:  <span class="hljs-built_in">cap</span>,&#125;l.root.prev = l.rootl.root.next = l.rootl.root.list = l<span class="hljs-keyword">return</span> l&#125;<span class="hljs-comment">// Get 获取缓存数据</span><span class="hljs-comment">// 如果获取到数据，就把这个节点移动到链表头部</span><span class="hljs-comment">// 如果没有获取到，就返回nil</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LRU)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<span class="hljs-keyword">defer</span> l.debug()n := l.get(key)<span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> n.value&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LRU)</span> <span class="hljs-title">get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">Node</span></span> &#123;<span class="hljs-keyword">for</span> n := l.root.next; n != l.root; n = n.next &#123;<span class="hljs-keyword">if</span> n.key == key &#123;n.prev.next = n.nextn.next.prev = n.prevn.next = l.root.nextl.root.next.prev = nl.root.next = nn.prev = l.root<span class="hljs-keyword">return</span> n&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// Put 写入缓存数据</span><span class="hljs-comment">// 如果 key 已经存在，那么更新值</span><span class="hljs-comment">// 如果 key 不存在，那么插入到第一个节点</span><span class="hljs-comment">// 当缓存容量满了的时候，会自动删除最后的数据</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LRU)</span> <span class="hljs-title">Put</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<span class="hljs-keyword">defer</span> l.debug()n := l.get(key)<span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;n.value = value<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 缓存满了</span><span class="hljs-keyword">if</span> l.<span class="hljs-built_in">len</span> == l.<span class="hljs-built_in">cap</span> &#123;last := l.root.prevlast.prev.next = l.rootl.root.prev = last.prevlast.list = <span class="hljs-literal">nil</span>last.prev = <span class="hljs-literal">nil</span>last.next = <span class="hljs-literal">nil</span>l.<span class="hljs-built_in">len</span>--&#125;node := &amp;Node&#123;key: key, value: value&#125;head := l.root.nexthead.prev = nodenode.next = headnode.prev = l.rootl.root.next = nodel.<span class="hljs-built_in">len</span>++node.list = l&#125;<span class="hljs-comment">// debug for debug</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LRU)</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">"lru len: "</span>, l.<span class="hljs-built_in">len</span>)fmt.Println(<span class="hljs-string">"lru cap: "</span>, l.<span class="hljs-built_in">cap</span>)<span class="hljs-keyword">for</span> n := l.root.next; n != l.root; n = n.next &#123;fmt.Printf(<span class="hljs-string">"%s:%v -&gt; "</span>, n.key, n.value)&#125;fmt.Println()fmt.Println()&#125;</code></pre><p>单元测试</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> lru<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewLRU</span><span class="hljs-params">(t *testing.T)</span></span> &#123;l := NewLRU(<span class="hljs-number">3</span>)assert.Equal(t, l.Get(<span class="hljs-string">""</span>), <span class="hljs-literal">nil</span>)l.Put(<span class="hljs-string">"1"</span>, <span class="hljs-number">1</span>)l.Put(<span class="hljs-string">"2"</span>, <span class="hljs-number">2</span>)l.Put(<span class="hljs-string">"3"</span>, <span class="hljs-number">3</span>)assert.Equal(t, <span class="hljs-number">3</span>, l.Get(<span class="hljs-string">"3"</span>))assert.Equal(t, <span class="hljs-number">1</span>, l.Get(<span class="hljs-string">"1"</span>))l.Put(<span class="hljs-string">"4"</span>, <span class="hljs-number">4</span>)assert.Equal(t, <span class="hljs-literal">nil</span>, l.Get(<span class="hljs-string">"2"</span>))l.Put(<span class="hljs-string">"3"</span>, <span class="hljs-number">31</span>)assert.Equal(t, <span class="hljs-number">31</span>, l.Get(<span class="hljs-string">"3"</span>))&#125;</code></pre><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><ul><li>前面讲到的 通过 Element 节点中的 List 结构来判断节点是否属于当前链表的方式，在某些情况下会出现 <code>bug</code> 你发现了么？</li><li>LRU 缓存可以参考 leetcode 进行测试，<a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU 缓存机制</a>，文中的 LRU 缓存实现有许多值得优化的地方，你认为有哪些可以优化的地方？</li><li>问题可以回复在评论区，将在下一篇文章中解答</li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>学习笔记</tag>
      
      <tag>Go</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式24-总结(更新完毕)</title>
    <link href="/post/go-design-pattern.html"/>
    <url>/post/go-design-pattern.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/intro/100039001" target="_blank" rel="noopener">设计模式之美</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 24/24 </strong>这是该系列的最后一篇文章啦，后续看情况可能会不定期补充一些实战的内容，但是正文就这么多了</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原本预计是在十月底更新完毕这个系列，到今天是 11-05，晚了几天，不过也还好，这是第一次这么密集的去更新博客上的内容，更多的是以笔记的形式来呈现，加上这篇一共 24 篇文章差不多两个半月的时间，平均每周输出两篇，感觉还是不错。后续可能会视情况不定期的更新一些实战内容，也有可能没有。接下来下一个系列应该是数据结构与算法，包含对 Go 中一些底层数据和标准库包的学习，例如 slice, sort 等等。</p><p>话说回来，回头再看学习设计模式我们究竟需要学习一些什么？</p><ul><li>写 Go 需要使用到设计模式么？<ul><li>需要，但是切记请勿使用其他语言的方式来写 Go</li><li>如果看过之前的一些文章，就会发现类似 JAVA 的这些面向对象语言中的某些设计模式的写法在 Go 中会十分的别扭</li><li>但是 Go 不需要设计模式么？不是的，设计模式的思想是想通的，并且我们一直都在使用，例如我们常见的对象创建方式 <code>NewXXX</code> 这其实就是一个简单工厂</li></ul></li><li>设计模式学习的重点是什么？<ul><li>设计原则，以及设计模式的使用场景和优缺点，实现相对来说还没有那么重要</li><li>如果是常见的设计模式是武术招式，那么设计原则就是内功心法，没有内功心法那么招式套路也就是花架子</li><li>熟练掌握不同设计模式的使用场景可以帮助我们学会见招拆招，灵活应用而不是只会套路</li></ul></li><li><strong>最后设计模式不是银弹，不要拿着 🔨 就觉得哪里都像是钉子，不要过早优化，持续重构才是正道</strong></li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><blockquote><p>同时这也是 Code Review 的重要标准之一</p></blockquote><p><img src="https://lailin.xyz/images/1604555465270-6b839dae-3cc4-43e8-bcad-b46ee314f0f7.png" srcset="/img/loading.gif" alt></p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><img src="https://lailin.xyz/images/1604555469082-5a1887e1-5640-4895-a018-8541ba78139e.png" srcset="/img/loading.gif" alt></p><h2 id="Go-设计模式"><a href="#Go-设计模式" class="headerlink" title="Go 设计模式"></a>Go 设计模式</h2><ul><li>单例模式包含饿汉式和懒汉式两种实现</li><li>工厂模式包含简单工厂、工厂方法、抽象工厂、DI 容器</li><li>代理模式包含静态代理、动态代理（采用 go generate 模拟）</li><li>观察者模式包含观察者模式、eventbus</li></ul><table><thead><tr><th style="text-align:center"><strong>类型</strong></th><th style="text-align:center"><strong>设计模式（Github）</strong></th><th style="text-align:center"><strong>常用</strong></th><th style="text-align:center"><strong>博客</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>创建型</strong></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/01_singleton" target="_blank" rel="noopener">单例模式(Singleton Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/singleton.html">Go 设计模式 01-单例模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/02_factory" target="_blank" rel="noopener">工厂模式(Factory Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/factory.html">Go 设计模式 02-工厂模式&amp;DI 容器</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/03_builder" target="_blank" rel="noopener">建造者模式(Builder Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/builder.html">Go 设计模式 03-建造者模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/04_prototype" target="_blank" rel="noopener">原型模式(Prototype Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/prototype.html">Go 设计模式 04-原型模式</a></td></tr><tr><td style="text-align:center"><strong>结构型</strong></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/05_proxy" target="_blank" rel="noopener">代理模式(Proxy Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/proxy.html">Go 设计模式 06-代理模式(generate 实现类似动态代理)</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/06_bridge" target="_blank" rel="noopener">桥接模式(Bridge Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/bridge.html">Go 设计模式 07-桥接模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/07_decorator" target="_blank" rel="noopener">装饰器模式(Decorator Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/decorator.html">Go 设计模式 08-装饰器模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/08_adapter" target="_blank" rel="noopener">适配器模式(Adapter Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/adapter.html">Go 设计模式 09-适配器模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/09_facade" target="_blank" rel="noopener">门面模式(Facade Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/facade.html">Go 设计模式 10-门面模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/10_composite" target="_blank" rel="noopener">组合模式(Composite Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/composite.html">Go 设计模式 11-组合模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/11_flyweight" target="_blank" rel="noopener">享元模式(Flyweight Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/flyweight.html">Go 设计模式 12-享元模式</a></td></tr><tr><td style="text-align:center"><strong>行为型</strong></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/12_observer" target="_blank" rel="noopener">观察者模式(Observer Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/observer.html">Go 设计模式 13-观察者模式(实现简单的 EventBus)</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/13_template" target="_blank" rel="noopener">模板模式(Template Method Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/template.html">Go 模板模式 14-模板模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/14_strategy" target="_blank" rel="noopener">策略模式(Strategy Method Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/strategy.html">Go 设计模式 15-策略模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/15_chain" target="_blank" rel="noopener">职责链模式(Chain Of Responsibility Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/chain.html">Go 设计模式 16-职责链模式(Gin 的中间件实现)</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/16_state" target="_blank" rel="noopener">状态模式(State Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/state.html">Go 设计模式 17-状态模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/17_iterator" target="_blank" rel="noopener">迭代器模式(Iterator Design Pattern)</a></td><td style="text-align:center">✅</td><td style="text-align:center"><a href="https://lailin.xyz/post/iterator.html">Go 设计模式 18-迭代器模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/18_visitor/visitor.go" target="_blank" rel="noopener">访问者模式(Visitor Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/visitor.html">Go 设计模式 19-访问者模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/19_memento" target="_blank" rel="noopener">备忘录模式(Memento Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/memento.html">Go 设计模式 20-备忘录模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/20_command" target="_blank" rel="noopener">命令模式(Command Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/command.html">Go 设计模式 21-命令模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/21_interpreter" target="_blank" rel="noopener">解释器模式(Interpreter Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/interpreter.html">Go 设计模式 22-解释器模式</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://github.com/mohuishou/go-design-pattern/blob/master/22_mediator" target="_blank" rel="noopener">中介模式(Mediator Design Pattern)</a></td><td style="text-align:center">❌</td><td style="text-align:center"><a href="https://lailin.xyz/post/mediator.html">Go 设计模式 23-中介模式</a></td></tr></tbody></table><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式23-中介模式</title>
    <link href="/post/mediator.html"/>
    <url>/post/mediator.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/226710" target="_blank" rel="noopener">73 | 中介模式：什么时候用中介模式？什么时候用观察者模式？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 23/24 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1604554249755-27489403-56d3-4128-a650-e81c68b1e621.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-comment">// Package mediator 中介模式</span><span class="hljs-comment">// 采用原课程的示例，并且做了一些裁剪</span><span class="hljs-comment">// 假设我们现在有一个较为复杂的对话框，里面包括，登录组件，注册组件，以及选择框</span><span class="hljs-comment">// 当选择框选择“登录”时，展示登录相关组件</span><span class="hljs-comment">// 当选择框选择“注册”时，展示注册相关组件</span><span class="hljs-keyword">package</span> mediator<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"reflect"</span>)<span class="hljs-comment">// Input 假设这表示一个输入框</span><span class="hljs-keyword">type</span> Input <span class="hljs-keyword">string</span><span class="hljs-comment">// String String</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i Input)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(i)&#125;<span class="hljs-comment">// Selection 假设这表示一个选择框</span><span class="hljs-keyword">type</span> Selection <span class="hljs-keyword">string</span><span class="hljs-comment">// Selected 当前选中的对象</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Selection)</span> <span class="hljs-title">Selected</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(s)&#125;<span class="hljs-comment">// Button 假设这表示一个按钮</span><span class="hljs-keyword">type</span> Button <span class="hljs-keyword">struct</span> &#123;onClick <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#125;<span class="hljs-comment">// SetOnClick 添加点击事件回调</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Button)</span> <span class="hljs-title">SetOnClick</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span> &#123;b.onClick = f&#125;<span class="hljs-comment">// IMediator 中介模式接口</span><span class="hljs-keyword">type</span> IMediator <span class="hljs-keyword">interface</span> &#123;HandleEvent(component <span class="hljs-keyword">interface</span>&#123;&#125;)&#125;<span class="hljs-comment">// Dialog 对话框组件</span><span class="hljs-keyword">type</span> Dialog <span class="hljs-keyword">struct</span> &#123;LoginButton         *ButtonRegButton           *ButtonSelection           *SelectionUsernameInput       *InputPasswordInput       *InputRepeatPasswordInput *Input&#125;<span class="hljs-comment">// HandleEvent HandleEvent</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dialog)</span> <span class="hljs-title">HandleEvent</span><span class="hljs-params">(component <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<span class="hljs-keyword">switch</span> &#123;<span class="hljs-keyword">case</span> reflect.DeepEqual(component, d.Selection):<span class="hljs-keyword">if</span> d.Selection.Selected() == <span class="hljs-string">"登录"</span> &#123;fmt.Println(<span class="hljs-string">"select login"</span>)fmt.Printf(<span class="hljs-string">"show: %s\n"</span>, d.UsernameInput)fmt.Printf(<span class="hljs-string">"show: %s\n"</span>, d.PasswordInput)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> d.Selection.Selected() == <span class="hljs-string">"注册"</span> &#123;fmt.Println(<span class="hljs-string">"select register"</span>)fmt.Printf(<span class="hljs-string">"show: %s\n"</span>, d.UsernameInput)fmt.Printf(<span class="hljs-string">"show: %s\n"</span>, d.PasswordInput)fmt.Printf(<span class="hljs-string">"show: %s\n"</span>, d.RepeatPasswordInput)&#125;<span class="hljs-comment">// others, 如果点击了登录按钮，注册按钮</span>&#125;&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> mediator<span class="hljs-keyword">import</span> <span class="hljs-string">"testing"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo</span><span class="hljs-params">(t *testing.T)</span></span> &#123;usernameInput := Input(<span class="hljs-string">"username input"</span>)passwordInput := Input(<span class="hljs-string">"password input"</span>)repeatPwdInput := Input(<span class="hljs-string">"repeat password input"</span>)selection := Selection(<span class="hljs-string">"登录"</span>)d := &amp;Dialog&#123;Selection:           &amp;selection,UsernameInput:       &amp;usernameInput,PasswordInput:       &amp;passwordInput,RepeatPasswordInput: &amp;repeatPwdInput,&#125;d.HandleEvent(&amp;selection)regSelection := Selection(<span class="hljs-string">"注册"</span>)d.Selection = &amp;regSelectiond.HandleEvent(&amp;regSelection)&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式22-解释器模式</title>
    <link href="/post/interpreter.html"/>
    <url>/post/interpreter.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/225904" target="_blank" rel="noopener">72 | 解释器模式：如何设计实现一个自定义接口告警规则功能？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 22/24 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1604554127547-78b30375-2e57-459b-95a5-d8479bf79c1c.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-comment">// Package interpreter 解释器模式</span><span class="hljs-comment">// 采用原课程的示例, 并且做了一下简化</span><span class="hljs-comment">// 假设我们现在有一个监控系统</span><span class="hljs-comment">// 现在需要实现一个告警模块，可以根据输入的告警规则来决定是否触发告警</span><span class="hljs-comment">// 告警规则支持 &amp;&amp;、&gt;、&lt; 3种运算符</span><span class="hljs-comment">// 其中 &gt;、&lt; 优先级比  &amp;&amp; 更高</span><span class="hljs-keyword">package</span> interpreter<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"regexp"</span><span class="hljs-string">"strconv"</span><span class="hljs-string">"strings"</span>)<span class="hljs-comment">// AlertRule 告警规则</span><span class="hljs-keyword">type</span> AlertRule <span class="hljs-keyword">struct</span> &#123;expression IExpression&#125;<span class="hljs-comment">// NewAlertRule NewAlertRule</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAlertRule</span><span class="hljs-params">(rule <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*AlertRule, error)</span></span> &#123;exp, err := NewAndExpression(rule)<span class="hljs-keyword">return</span> &amp;AlertRule&#123;expression: exp&#125;, err&#125;<span class="hljs-comment">// Interpret 判断告警是否触发</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r AlertRule)</span> <span class="hljs-title">Interpret</span><span class="hljs-params">(stats <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> r.expression.Interpret(stats)&#125;<span class="hljs-comment">// IExpression 表达式接口</span><span class="hljs-keyword">type</span> IExpression <span class="hljs-keyword">interface</span> &#123;Interpret(stats <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>) <span class="hljs-keyword">bool</span>&#125;<span class="hljs-comment">// GreaterExpression &gt;</span><span class="hljs-keyword">type</span> GreaterExpression <span class="hljs-keyword">struct</span> &#123;key   <span class="hljs-keyword">string</span>value <span class="hljs-keyword">float64</span>&#125;<span class="hljs-comment">// Interpret Interpret</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g GreaterExpression)</span> <span class="hljs-title">Interpret</span><span class="hljs-params">(stats <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">bool</span></span> &#123;v, ok := stats[g.key]<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">return</span> v &gt; g.value&#125;<span class="hljs-comment">// NewGreaterExpression NewGreaterExpression</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGreaterExpression</span><span class="hljs-params">(exp <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*GreaterExpression, error)</span></span> &#123;data := regexp.MustCompile(<span class="hljs-string">`\s+`</span>).Split(strings.TrimSpace(exp), <span class="hljs-number">-1</span>)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) != <span class="hljs-number">3</span> || data[<span class="hljs-number">1</span>] != <span class="hljs-string">"&gt;"</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"exp is invalid: %s"</span>, exp)&#125;val, err := strconv.ParseFloat(data[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"exp is invalid: %s"</span>, exp)&#125;<span class="hljs-keyword">return</span> &amp;GreaterExpression&#123;key:   data[<span class="hljs-number">0</span>],value: val,&#125;, <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// LessExpression &lt;</span><span class="hljs-keyword">type</span> LessExpression <span class="hljs-keyword">struct</span> &#123;key   <span class="hljs-keyword">string</span>value <span class="hljs-keyword">float64</span>&#125;<span class="hljs-comment">// Interpret Interpret</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g LessExpression)</span> <span class="hljs-title">Interpret</span><span class="hljs-params">(stats <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">bool</span></span> &#123;v, ok := stats[g.key]<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">return</span> v &lt; g.value&#125;<span class="hljs-comment">// NewLessExpression NewLessExpression</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLessExpression</span><span class="hljs-params">(exp <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*LessExpression, error)</span></span> &#123;data := regexp.MustCompile(<span class="hljs-string">`\s+`</span>).Split(strings.TrimSpace(exp), <span class="hljs-number">-1</span>)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) != <span class="hljs-number">3</span> || data[<span class="hljs-number">1</span>] != <span class="hljs-string">"&lt;"</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"exp is invalid: %s"</span>, exp)&#125;val, err := strconv.ParseFloat(data[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"exp is invalid: %s"</span>, exp)&#125;<span class="hljs-keyword">return</span> &amp;LessExpression&#123;key:   data[<span class="hljs-number">0</span>],value: val,&#125;, <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// AndExpression &amp;&amp;</span><span class="hljs-keyword">type</span> AndExpression <span class="hljs-keyword">struct</span> &#123;expressions []IExpression&#125;<span class="hljs-comment">// Interpret Interpret</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e AndExpression)</span> <span class="hljs-title">Interpret</span><span class="hljs-params">(stats <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">for</span> _, expression := <span class="hljs-keyword">range</span> e.expressions &#123;<span class="hljs-keyword">if</span> !expression.Interpret(stats) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">// NewAndExpression NewAndExpression</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAndExpression</span><span class="hljs-params">(exp <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*AndExpression, error)</span></span> &#123;exps := strings.Split(exp, <span class="hljs-string">"&amp;&amp;"</span>)expressions := <span class="hljs-built_in">make</span>([]IExpression, <span class="hljs-built_in">len</span>(exps))<span class="hljs-keyword">for</span> i, e := <span class="hljs-keyword">range</span> exps &#123;<span class="hljs-keyword">var</span> expression IExpression<span class="hljs-keyword">var</span> err error<span class="hljs-keyword">switch</span> &#123;<span class="hljs-keyword">case</span> strings.Contains(e, <span class="hljs-string">"&gt;"</span>):expression, err = NewGreaterExpression(e)<span class="hljs-keyword">case</span> strings.Contains(e, <span class="hljs-string">"&lt;"</span>):expression, err = NewLessExpression(e)<span class="hljs-keyword">default</span>:err = fmt.Errorf(<span class="hljs-string">"exp is invalid: %s"</span>, exp)&#125;<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;expressions[i] = expression&#125;<span class="hljs-keyword">return</span> &amp;AndExpression&#123;expressions: expressions&#125;, <span class="hljs-literal">nil</span>&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> interpreter<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span><span class="hljs-string">"github.com/stretchr/testify/require"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAlertRule_Interpret</span><span class="hljs-params">(t *testing.T)</span></span> &#123;stats := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>&#123;<span class="hljs-string">"a"</span>: <span class="hljs-number">1</span>,<span class="hljs-string">"b"</span>: <span class="hljs-number">2</span>,<span class="hljs-string">"c"</span>: <span class="hljs-number">3</span>,&#125;tests := []<span class="hljs-keyword">struct</span> &#123;name  <span class="hljs-keyword">string</span>stats <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>rule  <span class="hljs-keyword">string</span>want  <span class="hljs-keyword">bool</span>&#125;&#123;&#123;name:  <span class="hljs-string">"case1"</span>,stats: stats,rule:  <span class="hljs-string">"a &gt; 1 &amp;&amp; b &gt; 10 &amp;&amp; c &lt; 5"</span>,want:  <span class="hljs-literal">false</span>,&#125;,&#123;name:  <span class="hljs-string">"case2"</span>,stats: stats,rule:  <span class="hljs-string">"a &lt; 2 &amp;&amp; b &gt; 10 &amp;&amp; c &lt; 5"</span>,want:  <span class="hljs-literal">false</span>,&#125;,&#123;name:  <span class="hljs-string">"case3"</span>,stats: stats,rule:  <span class="hljs-string">"a &lt; 5 &amp;&amp; b &gt; 1 &amp;&amp; c &lt; 10"</span>,want:  <span class="hljs-literal">false</span>,&#125;,&#125;<span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;r, err := NewAlertRule(tt.rule)require.NoError(t, err)assert.Equal(t, tt.want, r.Interpret(tt.stats))&#125;)&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式21-命令模式</title>
    <link href="/post/command.html"/>
    <url>/post/command.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/224549" target="_blank" rel="noopener">71 | 命令模式：如何利用命令模式实现一个手游后端架构？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 21/24 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1604554065252-7fd51202-1ce7-48eb-8631-4061751f9b94.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>接下来会有两个例子，第一个是按照原文定义的方式，将函数封装成对象，第二个例子我们直接将函数作为参数传递。</p><h3 id="将函数封装为对象"><a href="#将函数封装为对象" class="headerlink" title="将函数封装为对象"></a>将函数封装为对象</h3><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><pre><code class="hljs go"><span class="hljs-comment">// Package command 命令模式</span><span class="hljs-comment">// Blog: https://lailin.xyz/post/command.html</span><span class="hljs-comment">// 这是示例一，采用将函数封装为对象的方式实现，</span><span class="hljs-comment">// 示例说明:</span><span class="hljs-comment">// 假设现在有一个游戏服务，我们正在实现一个游戏后端</span><span class="hljs-comment">// 使用一个 goroutine 不断接收来自客户端请求的命令，并且将它放置到一个队列当中</span><span class="hljs-comment">// 然后我们在另外一个 goroutine 中来执行它</span><span class="hljs-keyword">package</span> command<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-comment">// ICommand 命令</span><span class="hljs-keyword">type</span> ICommand <span class="hljs-keyword">interface</span> &#123;Execute() error&#125;<span class="hljs-comment">// StartCommand 游戏开始运行</span><span class="hljs-keyword">type</span> StartCommand <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// NewStartCommand NewStartCommand</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStartCommand</span><span class="hljs-params">( /*正常情况下这里会有一些参数*/ )</span> *<span class="hljs-title">StartCommand</span></span> &#123;<span class="hljs-keyword">return</span> &amp;StartCommand&#123;&#125;&#125;<span class="hljs-comment">// Execute Execute</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *StartCommand)</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;fmt.Println(<span class="hljs-string">"game start"</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// ArchiveCommand 游戏存档</span><span class="hljs-keyword">type</span> ArchiveCommand <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// NewArchiveCommand NewArchiveCommand</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewArchiveCommand</span><span class="hljs-params">( /*正常情况下这里会有一些参数*/ )</span> *<span class="hljs-title">ArchiveCommand</span></span> &#123;<span class="hljs-keyword">return</span> &amp;ArchiveCommand&#123;&#125;&#125;<span class="hljs-comment">// Execute Execute</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ArchiveCommand)</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;fmt.Println(<span class="hljs-string">"game archive"</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> command<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"testing"</span><span class="hljs-string">"time"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-comment">// 用于测试，模拟来自客户端的事件</span>eventChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;events := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"start"</span>, <span class="hljs-string">"archive"</span>, <span class="hljs-string">"start"</span>, <span class="hljs-string">"archive"</span>, <span class="hljs-string">"start"</span>, <span class="hljs-string">"start"</span>&#125;<span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> events &#123;eventChan &lt;- e&#125;&#125;()<span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(eventChan)<span class="hljs-comment">// 使用命令队列缓存命令</span>commands := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> ICommand, <span class="hljs-number">1000</span>)<span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(commands)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">// 从请求或者其他地方获取相关事件参数</span>event, ok := &lt;-eventChan<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">var</span> command ICommand<span class="hljs-keyword">switch</span> event &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">"start"</span>:command = NewStartCommand()<span class="hljs-keyword">case</span> <span class="hljs-string">"archive"</span>:command = NewArchiveCommand()&#125;<span class="hljs-comment">// 将命令入队</span>commands &lt;- command&#125;&#125;()<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> c := &lt;-commands:c.Execute()<span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">1</span> * time.Second):fmt.Println(<span class="hljs-string">"timeout 1s"</span>)<span class="hljs-keyword">return</span>&#125;&#125;&#125;</code></pre><h3 id="将函数直接作为参数"><a href="#将函数直接作为参数" class="headerlink" title="将函数直接作为参数"></a>将函数直接作为参数</h3><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><pre><code class="hljs go"><span class="hljs-comment">// Package command 命令模式</span><span class="hljs-comment">// Blog: https://lailin.xyz/post/command.html</span><span class="hljs-comment">// 这是示例二，采用将直接返回一个函数，不用对象</span><span class="hljs-comment">// 示例说明:</span><span class="hljs-comment">// 假设现在有一个游戏服务，我们正在实现一个游戏后端</span><span class="hljs-comment">// 使用一个 goroutine 不断接收来自客户端请求的命令，并且将它放置到一个队列当中</span><span class="hljs-comment">// 然后我们在另外一个 goroutine 中来执行它</span><span class="hljs-keyword">package</span> command<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-comment">// Command 命令</span><span class="hljs-keyword">type</span> Command <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span><span class="hljs-comment">// StartCommandFunc 返回一个 Command 命令</span><span class="hljs-comment">// 是因为正常情况下不会是这么简单的函数</span><span class="hljs-comment">// 一般都会有一些参数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StartCommandFunc</span><span class="hljs-params">()</span> <span class="hljs-title">Command</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;fmt.Println(<span class="hljs-string">"game start"</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;&#125;<span class="hljs-comment">// ArchiveCommandFunc ArchiveCommandFunc</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ArchiveCommandFunc</span><span class="hljs-params">()</span> <span class="hljs-title">Command</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;fmt.Println(<span class="hljs-string">"game archive"</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;&#125;</code></pre><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> command<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"testing"</span><span class="hljs-string">"time"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemoFunc</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-comment">// 用于测试，模拟来自客户端的事件</span>eventChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;events := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"start"</span>, <span class="hljs-string">"archive"</span>, <span class="hljs-string">"start"</span>, <span class="hljs-string">"archive"</span>, <span class="hljs-string">"start"</span>, <span class="hljs-string">"start"</span>&#125;<span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> events &#123;eventChan &lt;- e&#125;&#125;()<span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(eventChan)<span class="hljs-comment">// 使用命令队列缓存命令</span>commands := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Command, <span class="hljs-number">1000</span>)<span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(commands)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">// 从请求或者其他地方获取相关事件参数</span>event, ok := &lt;-eventChan<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">var</span> command Command<span class="hljs-keyword">switch</span> event &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">"start"</span>:command = StartCommandFunc()<span class="hljs-keyword">case</span> <span class="hljs-string">"archive"</span>:command = ArchiveCommandFunc()&#125;<span class="hljs-comment">// 将命令入队</span>commands &lt;- command&#125;&#125;()<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> c := &lt;-commands:c()<span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">1</span> * time.Second):fmt.Println(<span class="hljs-string">"timeout 1s"</span>)<span class="hljs-keyword">return</span>&#125;&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式20-备忘录模式</title>
    <link href="/post/memento.html"/>
    <url>/post/memento.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/223947" target="_blank" rel="noopener">70 | 备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 20/24 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1604554038423-9ec977cc-ec31-4b77-9644-14dd880c3836.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-comment">// Package memento 备忘录模式</span><span class="hljs-comment">// 下面这个例子采用原课程的例子，一个输入程序</span><span class="hljs-comment">// 如果输入 :list 则显示当前保存的内容</span><span class="hljs-comment">// 如果输入 :undo 则删除上一次的输入</span><span class="hljs-comment">// 如果输入其他的内容则追加保存</span><span class="hljs-keyword">package</span> memento<span class="hljs-comment">// InputText 用于保存数据</span><span class="hljs-keyword">type</span> InputText <span class="hljs-keyword">struct</span> &#123;content <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// Append 追加数据</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *InputText)</span> <span class="hljs-title">Append</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>)</span></span> &#123;in.content += content&#125;<span class="hljs-comment">// GetText 获取数据</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *InputText)</span> <span class="hljs-title">GetText</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> in.content&#125;<span class="hljs-comment">// Snapshot 创建快照</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *InputText)</span> <span class="hljs-title">Snapshot</span><span class="hljs-params">()</span> *<span class="hljs-title">Snapshot</span></span> &#123;<span class="hljs-keyword">return</span> &amp;Snapshot&#123;content: in.content&#125;&#125;<span class="hljs-comment">// Restore 从快照中恢复</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *InputText)</span> <span class="hljs-title">Restore</span><span class="hljs-params">(s *Snapshot)</span></span> &#123;in.content = s.GetText()&#125;<span class="hljs-comment">// Snapshot 快照，用于存储数据快照</span><span class="hljs-comment">// 对于快照来说，只能不能被外部（不同包）修改，只能获取数据，满足封装的特性</span><span class="hljs-keyword">type</span> Snapshot <span class="hljs-keyword">struct</span> &#123;content <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// GetText GetText</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Snapshot)</span> <span class="hljs-title">GetText</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> s.content&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> memento<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo</span><span class="hljs-params">(t *testing.T)</span></span> &#123;in := &amp;InputText&#123;&#125;snapshots := []*Snapshot&#123;&#125;tests := []<span class="hljs-keyword">struct</span> &#123;input <span class="hljs-keyword">string</span>want  <span class="hljs-keyword">string</span>&#125;&#123;&#123;input: <span class="hljs-string">":list"</span>,want:  <span class="hljs-string">""</span>,&#125;,&#123;input: <span class="hljs-string">"hello"</span>,want:  <span class="hljs-string">""</span>,&#125;,&#123;input: <span class="hljs-string">":list"</span>,want:  <span class="hljs-string">"hello"</span>,&#125;,&#123;input: <span class="hljs-string">"world"</span>,want:  <span class="hljs-string">""</span>,&#125;,&#123;input: <span class="hljs-string">":list"</span>,want:  <span class="hljs-string">"helloworld"</span>,&#125;,&#123;input: <span class="hljs-string">":undo"</span>,want:  <span class="hljs-string">""</span>,&#125;,&#123;input: <span class="hljs-string">":list"</span>,want:  <span class="hljs-string">"hello"</span>,&#125;,&#125;<span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;t.Run(tt.input, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">switch</span> tt.input &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">":list"</span>:assert.Equal(t, tt.want, in.GetText())<span class="hljs-keyword">case</span> <span class="hljs-string">":undo"</span>:in.Restore(snapshots[<span class="hljs-built_in">len</span>(snapshots)<span class="hljs-number">-1</span>])snapshots = snapshots[:<span class="hljs-built_in">len</span>(snapshots)<span class="hljs-number">-1</span>]<span class="hljs-keyword">default</span>:snapshots = <span class="hljs-built_in">append</span>(snapshots, in.Snapshot())in.Append(tt.input)&#125;&#125;)&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式19-访问者模式</title>
    <link href="/post/visitor.html"/>
    <url>/post/visitor.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/221852" target="_blank" rel="noopener">68 | 访问者模式（上）：手把手带你还原访问者模式诞生的思维过程</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 19/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1604553945001-618def5a-9566-4d09-99f3-a227691538cf.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>原课程中讲解访问者模式的时候用到了继承和函数重载这两个 Go 中没有的特性，接下来的呢，会通过继承实现。<br><strong>注意由于没有函数重载，所以我们并不知道传递过来的对象是什么类型，这个时候只能采用类型断言的方式来对不同的类型做不同的操作，但是正式由于没有函数重载，所以其实完全可以不用访问者模式直接传入参数就好了。</strong><br>以前我们经常说不要用写其他语言的方式来写 Go，Go 不需要太多的设计模式，这个就是一个比较鲜明的例子</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> visitor<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"path"</span>)<span class="hljs-comment">// Visitor 访问者</span><span class="hljs-keyword">type</span> Visitor <span class="hljs-keyword">interface</span> &#123;Visit(IResourceFile) error&#125;<span class="hljs-comment">// IResourceFile IResourceFile</span><span class="hljs-keyword">type</span> IResourceFile <span class="hljs-keyword">interface</span> &#123;Accept(Visitor) error&#125;<span class="hljs-comment">// NewResourceFile NewResourceFile</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewResourceFile</span><span class="hljs-params">(filepath <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(IResourceFile, error)</span></span> &#123;<span class="hljs-keyword">switch</span> path.Ext(filepath) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">".ppt"</span>:<span class="hljs-keyword">return</span> &amp;PPTFile&#123;path: filepath&#125;, <span class="hljs-literal">nil</span><span class="hljs-keyword">case</span> <span class="hljs-string">".pdf"</span>:<span class="hljs-keyword">return</span> &amp;PdfFile&#123;path: filepath&#125;, <span class="hljs-literal">nil</span><span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"not found file type: %s"</span>, filepath)&#125;&#125;<span class="hljs-comment">// PdfFile PdfFile</span><span class="hljs-keyword">type</span> PdfFile <span class="hljs-keyword">struct</span> &#123;path <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// Accept Accept</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *PdfFile)</span> <span class="hljs-title">Accept</span><span class="hljs-params">(visitor Visitor)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> visitor.Visit(f)&#125;<span class="hljs-comment">// PPTFile PPTFile</span><span class="hljs-keyword">type</span> PPTFile <span class="hljs-keyword">struct</span> &#123;path <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// Accept Accept</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *PPTFile)</span> <span class="hljs-title">Accept</span><span class="hljs-params">(visitor Visitor)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> visitor.Visit(f)&#125;<span class="hljs-comment">// Compressor 实现压缩功能</span><span class="hljs-keyword">type</span> Compressor <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// Visit 实现访问者模式方法</span><span class="hljs-comment">// 我们可以发现由于没有函数重载，我们只能通过断言来根据不同的类型调用不同函数</span><span class="hljs-comment">// 但是我们即使不采用访问者模式，我们其实也是可以这么操作的</span><span class="hljs-comment">// 并且由于采用了类型断言，所以如果需要操作的对象比较多的话，这个函数其实也会膨胀的比较厉害</span><span class="hljs-comment">// 后续可以考虑按照命名约定使用 generate 自动生成代码</span><span class="hljs-comment">// 或者是使用反射简化</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Compressor)</span> <span class="hljs-title">Visit</span><span class="hljs-params">(r IResourceFile)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">switch</span> f := r.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> *PPTFile:<span class="hljs-keyword">return</span> c.VisitPPTFile(f)<span class="hljs-keyword">case</span> *PdfFile:<span class="hljs-keyword">return</span> c.VisitPDFFile(f)<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"not found resource typr: %#v"</span>, r)&#125;&#125;<span class="hljs-comment">// VisitPPTFile VisitPPTFile</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Compressor)</span> <span class="hljs-title">VisitPPTFile</span><span class="hljs-params">(f *PPTFile)</span> <span class="hljs-title">error</span></span> &#123;fmt.Println(<span class="hljs-string">"this is ppt file"</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// VisitPDFFile VisitPDFFile</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Compressor)</span> <span class="hljs-title">VisitPDFFile</span><span class="hljs-params">(f *PdfFile)</span> <span class="hljs-title">error</span></span> &#123;fmt.Println(<span class="hljs-string">"this is pdf file"</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> visitor<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/require"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCompressor_Visit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;tests := []<span class="hljs-keyword">struct</span> &#123;name    <span class="hljs-keyword">string</span>path    <span class="hljs-keyword">string</span>wantErr <span class="hljs-keyword">string</span>&#125;&#123;&#123;name: <span class="hljs-string">"pdf"</span>,path: <span class="hljs-string">"./xx.pdf"</span>,&#125;,&#123;name: <span class="hljs-string">"ppt"</span>,path: <span class="hljs-string">"./xx.ppt"</span>,&#125;,&#123;name:    <span class="hljs-string">"404"</span>,path:    <span class="hljs-string">"./xx.xx"</span>,wantErr: <span class="hljs-string">"not found file type"</span>,&#125;,&#125;<span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;f, err := NewResourceFile(tt.path)<span class="hljs-keyword">if</span> tt.wantErr != <span class="hljs-string">""</span> &#123;require.Error(t, err)require.Contains(t, err.Error(), tt.wantErr)<span class="hljs-keyword">return</span>&#125;require.NoError(t, err)compressor := &amp;Compressor&#123;&#125;f.Accept(compressor)&#125;)&#125;&#125;<span class="hljs-comment">// 不用 Accept 其实也是可以的</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCompressor_Visit2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;tests := []<span class="hljs-keyword">struct</span> &#123;name    <span class="hljs-keyword">string</span>path    <span class="hljs-keyword">string</span>wantErr <span class="hljs-keyword">string</span>&#125;&#123;&#123;name: <span class="hljs-string">"pdf"</span>,path: <span class="hljs-string">"./xx.pdf"</span>,&#125;,&#123;name: <span class="hljs-string">"ppt"</span>,path: <span class="hljs-string">"./xx.ppt"</span>,&#125;,&#123;name:    <span class="hljs-string">"404"</span>,path:    <span class="hljs-string">"./xx.xx"</span>,wantErr: <span class="hljs-string">"not found file type"</span>,&#125;,&#125;<span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;f, err := NewResourceFile(tt.path)<span class="hljs-keyword">if</span> tt.wantErr != <span class="hljs-string">""</span> &#123;require.Error(t, err)require.Contains(t, err.Error(), tt.wantErr)<span class="hljs-keyword">return</span>&#125;require.NoError(t, err)compressor := &amp;Compressor&#123;&#125;compressor.Visit(f)&#125;)&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式18-迭代器模式</title>
    <link href="/post/iterator.html"/>
    <url>/post/iterator.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/219290" target="_blank" rel="noopener">65 | 迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些优势？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 18/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1604553899885-458fad92-2e72-4ec6-8a5b-61d313acd29a.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面是一个简单的自定义数组类型的例子</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> iterator<span class="hljs-comment">// Iterator 迭代器接口</span><span class="hljs-keyword">type</span> Iterator <span class="hljs-keyword">interface</span> &#123;HasNext() <span class="hljs-keyword">bool</span>Next()<span class="hljs-comment">// 获取当前元素，由于 Go 1.15 中还没有泛型，所以我们直接返回 interface&#123;&#125;</span>CurrentItem() <span class="hljs-keyword">interface</span>&#123;&#125;&#125;<span class="hljs-comment">// ArrayInt 数组</span><span class="hljs-keyword">type</span> ArrayInt []<span class="hljs-keyword">int</span><span class="hljs-comment">// Iterator 返回迭代器</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a ArrayInt)</span> <span class="hljs-title">Iterator</span><span class="hljs-params">()</span> <span class="hljs-title">Iterator</span></span> &#123;<span class="hljs-keyword">return</span> &amp;ArrayIntIterator&#123;arrayInt: a,index:    <span class="hljs-number">0</span>,&#125;&#125;<span class="hljs-comment">// ArrayIntIterator 数组迭代</span><span class="hljs-keyword">type</span> ArrayIntIterator <span class="hljs-keyword">struct</span> &#123;arrayInt ArrayIntindex    <span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">// HasNext 是否有下一个</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iter *ArrayIntIterator)</span> <span class="hljs-title">HasNext</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> iter.index &lt; <span class="hljs-built_in">len</span>(iter.arrayInt)<span class="hljs-number">-1</span>&#125;<span class="hljs-comment">// Next 游标加一</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iter *ArrayIntIterator)</span> <span class="hljs-title">Next</span><span class="hljs-params">()</span></span> &#123;iter.index++&#125;<span class="hljs-comment">// CurrentItem 获取当前元素</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iter *ArrayIntIterator)</span> <span class="hljs-title">CurrentItem</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<span class="hljs-keyword">return</span> iter.arrayInt[iter.index]&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> iterator<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestArrayInt_Iterator</span><span class="hljs-params">(t *testing.T)</span></span> &#123;data := ArrayInt&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;iterator := data.Iterator()<span class="hljs-comment">// i 用于测试</span>i := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> iterator.HasNext() &#123;assert.Equal(t, data[i], iterator.CurrentItem())iterator.Next()i++&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式17-状态模式</title>
    <link href="/post/state.html"/>
    <url>/post/state.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/218375" target="_blank" rel="noopener">64 | 状态模式：游戏、工作流引擎中常用的状态机是如何实现的？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 17/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1604553865908-d2176cad-7bd6-41df-83c3-a2a2edc3eaca.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>通过下面的例子可以发现，引入状态模式来写状态机会有引入比较多的结构体，并且改动代码的时候如果要新增或者是删除某一个状态的话，修改也需要在其他状态的结构体方法中修改，所以这个不太适合状态经常变更或者是状态很多的情况</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-comment">// Package state 状态模式</span><span class="hljs-comment">// 笔记请查看: https://lailin.xyz/state.html</span><span class="hljs-comment">// 这是一个工作流的例子，在企业内部或者是学校我们经常会看到很多审批流程</span><span class="hljs-comment">// 假设我们有一个报销的流程: 员工提交报销申请 -&gt; 直属部门领导审批 -&gt; 财务审批 -&gt; 结束</span><span class="hljs-comment">// 在这个审批流中，处在不同的环节就是不同的状态</span><span class="hljs-comment">// 而流程的审批、驳回就是不同的事件</span><span class="hljs-keyword">package</span> state<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-comment">// Machine 状态机</span><span class="hljs-keyword">type</span> Machine <span class="hljs-keyword">struct</span> &#123;state IState&#125;<span class="hljs-comment">// SetState 更新状态</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Machine)</span> <span class="hljs-title">SetState</span><span class="hljs-params">(state IState)</span></span> &#123;m.state = state&#125;<span class="hljs-comment">// GetStateName 获取当前状态</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Machine)</span> <span class="hljs-title">GetStateName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> m.state.GetName()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Machine)</span> <span class="hljs-title">Approval</span><span class="hljs-params">()</span></span> &#123;m.state.Approval(m)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Machine)</span> <span class="hljs-title">Reject</span><span class="hljs-params">()</span></span> &#123;m.state.Reject(m)&#125;<span class="hljs-comment">// IState 状态</span><span class="hljs-keyword">type</span> IState <span class="hljs-keyword">interface</span> &#123;<span class="hljs-comment">// 审批通过</span>Approval(m *Machine)<span class="hljs-comment">// 驳回</span>Reject(m *Machine)<span class="hljs-comment">// 获取当前状态名称</span>GetName() <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// leaderApproveState 直属领导审批</span><span class="hljs-keyword">type</span> leaderApproveState <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// Approval 获取状态名字</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(leaderApproveState)</span> <span class="hljs-title">Approval</span><span class="hljs-params">(m *Machine)</span></span> &#123;fmt.Println(<span class="hljs-string">"leader 审批成功"</span>)m.SetState(GetFinanceApproveState())&#125;<span class="hljs-comment">// GetName 获取状态名字</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(leaderApproveState)</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"LeaderApproveState"</span>&#125;<span class="hljs-comment">// Reject 获取状态名字</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(leaderApproveState)</span> <span class="hljs-title">Reject</span><span class="hljs-params">(m *Machine)</span></span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetLeaderApproveState</span><span class="hljs-params">()</span> <span class="hljs-title">IState</span></span> &#123;<span class="hljs-keyword">return</span> &amp;leaderApproveState&#123;&#125;&#125;<span class="hljs-comment">// financeApproveState 财务审批</span><span class="hljs-keyword">type</span> financeApproveState <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// Approval 审批通过</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f financeApproveState)</span> <span class="hljs-title">Approval</span><span class="hljs-params">(m *Machine)</span></span> &#123;fmt.Println(<span class="hljs-string">"财务审批成功"</span>)fmt.Println(<span class="hljs-string">"出发打款操作"</span>)&#125;<span class="hljs-comment">// 拒绝</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f financeApproveState)</span> <span class="hljs-title">Reject</span><span class="hljs-params">(m *Machine)</span></span> &#123;m.SetState(GetLeaderApproveState())&#125;<span class="hljs-comment">// GetName 获取名字</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f financeApproveState)</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"FinanceApproveState"</span>&#125;<span class="hljs-comment">// GetFinanceApproveState GetFinanceApproveState</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetFinanceApproveState</span><span class="hljs-params">()</span> <span class="hljs-title">IState</span></span> &#123;<span class="hljs-keyword">return</span> &amp;financeApproveState&#123;&#125;&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> state<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMachine_GetStateName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;m := &amp;Machine&#123;state: GetLeaderApproveState()&#125;assert.Equal(t, <span class="hljs-string">"LeaderApproveState"</span>, m.GetStateName())m.Approval()assert.Equal(t, <span class="hljs-string">"FinanceApproveState"</span>, m.GetStateName())m.Reject()assert.Equal(t, <span class="hljs-string">"LeaderApproveState"</span>, m.GetStateName())m.Approval()assert.Equal(t, <span class="hljs-string">"FinanceApproveState"</span>, m.GetStateName())m.Approval()&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式16-职责链模式(Gin的中间件实现)</title>
    <link href="/post/chain.html"/>
    <url>/post/chain.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/216278" target="_blank" rel="noopener">62 | 职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框架？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 16/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1604553820863-78020ed6-f3be-4fd1-8b0b-22a204027642.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先我们看一下一个简单的实现模板，然后我们再看看实际上我们常用 web 框架 gin 当中是如何处理请求的</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-comment">// Package chain 职责链模式</span><span class="hljs-comment">// 🌰 假设我们现在有个校园论坛，由于社区规章制度、广告、法律法规的原因需要对用户的发言进行敏感词过滤</span><span class="hljs-comment">//    如果被判定为敏感词，那么这篇帖子将会被封禁</span><span class="hljs-keyword">package</span> chain<span class="hljs-comment">// SensitiveWordFilter 敏感词过滤器，判定是否是敏感词</span><span class="hljs-keyword">type</span> SensitiveWordFilter <span class="hljs-keyword">interface</span> &#123;Filter(content <span class="hljs-keyword">string</span>) <span class="hljs-keyword">bool</span>&#125;<span class="hljs-comment">// SensitiveWordFilterChain 职责链</span><span class="hljs-keyword">type</span> SensitiveWordFilterChain <span class="hljs-keyword">struct</span> &#123;filters []SensitiveWordFilter&#125;<span class="hljs-comment">// AddFilter 添加一个过滤器</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *SensitiveWordFilterChain)</span> <span class="hljs-title">AddFilter</span><span class="hljs-params">(filter SensitiveWordFilter)</span></span> &#123;c.filters = <span class="hljs-built_in">append</span>(c.filters, filter)&#125;<span class="hljs-comment">// Filter 执行过滤</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *SensitiveWordFilterChain)</span> <span class="hljs-title">Filter</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">for</span> _, filter := <span class="hljs-keyword">range</span> c.filters &#123;<span class="hljs-comment">// 如果发现敏感直接返回结果</span><span class="hljs-keyword">if</span> filter.Filter(content) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// AdSensitiveWordFilter 广告</span><span class="hljs-keyword">type</span> AdSensitiveWordFilter <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// Filter 实现过滤算法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *AdSensitiveWordFilter)</span> <span class="hljs-title">Filter</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 实现算法</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// PoliticalWordFilter 政治敏感</span><span class="hljs-keyword">type</span> PoliticalWordFilter <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// Filter 实现过滤算法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *PoliticalWordFilter)</span> <span class="hljs-title">Filter</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 实现算法</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> chain<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSensitiveWordFilterChain_Filter</span><span class="hljs-params">(t *testing.T)</span></span> &#123;chain := &amp;SensitiveWordFilterChain&#123;&#125;chain.AddFilter(&amp;AdSensitiveWordFilter&#123;&#125;)assert.Equal(t, <span class="hljs-literal">false</span>, chain.Filter(<span class="hljs-string">"test"</span>))chain.AddFilter(&amp;PoliticalWordFilter&#123;&#125;)assert.Equal(t, <span class="hljs-literal">true</span>, chain.Filter(<span class="hljs-string">"test"</span>))&#125;</code></pre><h3 id="Gin-的中间件实现"><a href="#Gin-的中间件实现" class="headerlink" title="Gin 的中间件实现"></a>Gin 的中间件实现</h3><p>我们直接看一下 <code>gin Context</code> 的实现，其中 <code>Next()</code> 方法就是主要的执行方法，这里其实就是我们最上面说到的职责链模式的变体，因为它会在每一个处理函数中进行处理，而不是第一个接收到就停止了</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-comment">// handlers 是一个包含执行函数的数组</span>    <span class="hljs-comment">// type HandlersChain []HandlerFunc</span>handlers HandlersChain    <span class="hljs-comment">// index 表示当前执行到哪个位置了</span>index    <span class="hljs-keyword">int8</span>    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// Next 会按照顺序将一个个中间件执行完毕</span><span class="hljs-comment">// 并且 Next 也可以在中间件中进行调用，达到请求前以及请求后的处理</span><span class="hljs-comment">// Next should be used only inside middleware.</span><span class="hljs-comment">// It executes the pending handlers in the chain inside the calling handler.</span><span class="hljs-comment">// See example in GitHub.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span> <span class="hljs-title">Next</span><span class="hljs-params">()</span></span> &#123;c.index++<span class="hljs-keyword">for</span> c.index &lt; <span class="hljs-keyword">int8</span>(<span class="hljs-built_in">len</span>(c.handlers)) &#123;c.handlers[c.index](c)c.index++&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式15-策略模式</title>
    <link href="/post/strategy.html"/>
    <url>/post/strategy.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/214014" target="_blank" rel="noopener">60 | 策略模式（上）：如何避免冗长的 if-else/switch 分支判断代码？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 15/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1604553796652-924605d4-830b-41ba-ba8e-fe3725630d00.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>来个 🌰，我们在保存文件的时候，由于政策或者其他的原因可能需要选择不同的存储方式，敏感数据我们需要加密存储，不敏感的数据我们可以直接明文保存。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> strategy<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"io/ioutil"</span><span class="hljs-string">"os"</span>)<span class="hljs-comment">// StorageStrategy 存储策略</span><span class="hljs-keyword">type</span> StorageStrategy <span class="hljs-keyword">interface</span> &#123;Save(name <span class="hljs-keyword">string</span>, data []<span class="hljs-keyword">byte</span>) error&#125;<span class="hljs-keyword">var</span> strategys = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]StorageStrategy&#123;<span class="hljs-string">"file"</span>:         &amp;fileStorage&#123;&#125;,<span class="hljs-string">"encrypt_file"</span>: &amp;encryptFileStorage&#123;&#125;,&#125;<span class="hljs-comment">// NewStorageStrategy NewStorageStrategy</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStorageStrategy</span><span class="hljs-params">(t <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(StorageStrategy, error)</span></span> &#123;s, ok := strategys[t]<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"not found StorageStrategy: %s"</span>, t)&#125;<span class="hljs-keyword">return</span> s, <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// FileStorage 保存到文件</span><span class="hljs-keyword">type</span> fileStorage <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// Save Save</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *fileStorage)</span> <span class="hljs-title">Save</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> ioutil.WriteFile(name, data, os.ModeAppend)&#125;<span class="hljs-comment">// encryptFileStorage 加密保存到文件</span><span class="hljs-keyword">type</span> encryptFileStorage <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// Save Save</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *encryptFileStorage)</span> <span class="hljs-title">Save</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-comment">// 加密</span>data, err := encrypt(data)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">return</span> ioutil.WriteFile(name, data, os.ModeAppend)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">encrypt</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<span class="hljs-comment">// 这里实现加密算法</span><span class="hljs-keyword">return</span> data, <span class="hljs-literal">nil</span>&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> strategy<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_demo</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-comment">// 假设这里获取数据，以及数据是否敏感</span>data, sensitive := getData()strategyType := <span class="hljs-string">"file"</span><span class="hljs-keyword">if</span> sensitive &#123;strategyType = <span class="hljs-string">"encrypt_file"</span>&#125;storage, err := NewStorageStrategy(strategyType)assert.NoError(t, err)assert.NoError(t, storage.Save(<span class="hljs-string">"./test.txt"</span>, data))&#125;<span class="hljs-comment">// getData 获取数据的方法</span><span class="hljs-comment">// 返回数据，以及数据是否敏感</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, <span class="hljs-keyword">bool</span>)</span></span> &#123;<span class="hljs-keyword">return</span> []<span class="hljs-keyword">byte</span>(<span class="hljs-string">"test data"</span>), <span class="hljs-literal">false</span>&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go模板模式14-模板模式</title>
    <link href="/post/template.html"/>
    <url>/post/template.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/212049" target="_blank" rel="noopener">58 | 模板模式（上）：剖析模板模式在 JDK、Servlet、JUnit 等中的应用</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 14/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1604553729036-301028ae-d64e-42e2-91aa-0cfdf5b54409.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>举个 🌰，假设我现在要做一个短信推送的系统，那么需要</p><ol><li>检查短信字数是否超过限制</li><li>检查手机号是否正确</li><li>发送短信</li><li>返回状态</li></ol><p>我们可以发现，在发送短信的时候由于不同的供应商调用的接口不同，所以会有一些实现上的差异，但是他的算法（业务逻辑）是固定的</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> template<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-comment">// ISMS ISMS</span><span class="hljs-keyword">type</span> ISMS <span class="hljs-keyword">interface</span> &#123;send(content <span class="hljs-keyword">string</span>, phone <span class="hljs-keyword">int</span>) error&#125;<span class="hljs-comment">// SMS 短信发送基类</span><span class="hljs-keyword">type</span> sms <span class="hljs-keyword">struct</span> &#123;ISMS&#125;<span class="hljs-comment">// Valid 校验短信字数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sms)</span> <span class="hljs-title">Valid</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(content) &gt; <span class="hljs-number">63</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"content is too long"</span>)&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// Send 发送短信</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sms)</span> <span class="hljs-title">Send</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>, phone <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> err := s.Valid(content); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-comment">// 调用子类的方法发送短信</span><span class="hljs-keyword">return</span> s.send(content, phone)&#125;<span class="hljs-comment">// TelecomSms 走电信通道</span><span class="hljs-keyword">type</span> TelecomSms <span class="hljs-keyword">struct</span> &#123;*sms&#125;<span class="hljs-comment">// NewTelecomSms NewTelecomSms</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTelecomSms</span><span class="hljs-params">()</span> *<span class="hljs-title">TelecomSms</span></span> &#123;tel := &amp;TelecomSms&#123;&#125;<span class="hljs-comment">// 这里有点绕，是因为 go 没有继承，用嵌套结构体的方法进行模拟</span><span class="hljs-comment">// 这里将子类作为接口嵌入父类，就可以让父类的模板方法 Send 调用到子类的函数</span><span class="hljs-comment">// 实际使用中，我们并不会这么写，都是采用组合+接口的方式完成类似的功能</span>tel.sms = &amp;sms&#123;ISMS: tel&#125;<span class="hljs-keyword">return</span> tel&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tel *TelecomSms)</span> <span class="hljs-title">send</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>, phone <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;fmt.Println(<span class="hljs-string">"send by telecom success"</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> template<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_sms_Send</span><span class="hljs-params">(t *testing.T)</span></span> &#123;tel := NewTelecomSms()err := tel.Send(<span class="hljs-string">"test"</span>, <span class="hljs-number">1239999</span>)assert.NoError(t, err)&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式13-观察者模式(实现简单的EventBus)</title>
    <link href="/post/observer.html"/>
    <url>/post/observer.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/210170" target="_blank" rel="noopener">56 | 观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 13/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a> **</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1604553664374-ba397231-64a2-4a8e-bb2f-fbb54380806d.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> observer<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-comment">// ISubject subject</span><span class="hljs-keyword">type</span> ISubject <span class="hljs-keyword">interface</span> &#123;Register(observer IObsever)Remove(observer IObsever)Notify(observer IObsever)&#125;<span class="hljs-comment">// IObsever 观察者</span><span class="hljs-keyword">type</span> IObsever <span class="hljs-keyword">interface</span> &#123;Update(msg <span class="hljs-keyword">string</span>)&#125;<span class="hljs-comment">// Subject Subject</span><span class="hljs-keyword">type</span> Subject <span class="hljs-keyword">struct</span> &#123;observers []IObsever&#125;<span class="hljs-comment">// Register 注册</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sub *Subject)</span> <span class="hljs-title">Register</span><span class="hljs-params">(observer IObsever)</span></span> &#123;sub.observers = <span class="hljs-built_in">append</span>(sub.observers, observer)&#125;<span class="hljs-comment">// Remove 移除观察者</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sub *Subject)</span> <span class="hljs-title">Remove</span><span class="hljs-params">(observer IObsever)</span></span> &#123;<span class="hljs-keyword">for</span> i, ob := <span class="hljs-keyword">range</span> sub.observers &#123;<span class="hljs-keyword">if</span> ob == observer &#123;sub.observers = <span class="hljs-built_in">append</span>(sub.observers[:i], sub.observers[i+<span class="hljs-number">1</span>:]...)&#125;&#125;&#125;<span class="hljs-comment">// Notify 通知</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sub *Subject)</span> <span class="hljs-title">Notify</span><span class="hljs-params">(msg <span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> sub.observers &#123;o.Update(msg)&#125;&#125;<span class="hljs-comment">// Obsever1 Obsever1</span><span class="hljs-keyword">type</span> Obsever1 <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// Update 实现观察者接口</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Obsever1)</span> <span class="hljs-title">Update</span><span class="hljs-params">(msg <span class="hljs-keyword">string</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">"Obsever1: %s"</span>, msg)&#125;<span class="hljs-comment">// Obsever2 Obsever2</span><span class="hljs-keyword">type</span> Obsever2 <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// Update 实现观察者接口</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Obsever2)</span> <span class="hljs-title">Update</span><span class="hljs-params">(msg <span class="hljs-keyword">string</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">"Obsever2: %s"</span>, msg)&#125;</code></pre><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> observer<span class="hljs-keyword">import</span> <span class="hljs-string">"testing"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSubject_Notify</span><span class="hljs-params">(t *testing.T)</span></span> &#123;sub := &amp;Subject&#123;&#125;sub.Register(&amp;Obsever1&#123;&#125;)sub.Register(&amp;Obsever2&#123;&#125;)sub.Notify(<span class="hljs-string">"hi"</span>)&#125;</code></pre><h3 id="使用-Golang-实现-EventBus"><a href="#使用-Golang-实现-EventBus" class="headerlink" title="使用 Golang 实现 EventBus"></a>使用 Golang 实现 EventBus</h3><p>我们实现一个支持以下功能的事件总线</p><ol><li>异步不阻塞</li><li>支持任意参数值</li></ol><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> eventbus<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"reflect"</span><span class="hljs-string">"sync"</span>)<span class="hljs-comment">// Bus Bus</span><span class="hljs-keyword">type</span> Bus <span class="hljs-keyword">interface</span> &#123;Subscribe(topic <span class="hljs-keyword">string</span>, handler <span class="hljs-keyword">interface</span>&#123;&#125;) errorPublish(topic <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)&#125;<span class="hljs-comment">// AsyncEventBus 异步事件总线</span><span class="hljs-keyword">type</span> AsyncEventBus <span class="hljs-keyword">struct</span> &#123;handlers <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]reflect.Valuelock     sync.Mutex&#125;<span class="hljs-comment">// NewAsyncEventBus new</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAsyncEventBus</span><span class="hljs-params">()</span> *<span class="hljs-title">AsyncEventBus</span></span> &#123;<span class="hljs-keyword">return</span> &amp;AsyncEventBus&#123;handlers: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]reflect.Value&#123;&#125;,lock:     sync.Mutex&#123;&#125;,&#125;&#125;<span class="hljs-comment">// Subscribe 订阅</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bus *AsyncEventBus)</span> <span class="hljs-title">Subscribe</span><span class="hljs-params">(topic <span class="hljs-keyword">string</span>, f <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;bus.lock.Lock()<span class="hljs-keyword">defer</span> bus.lock.Unlock()v := reflect.ValueOf(f)<span class="hljs-keyword">if</span> v.Type().Kind() != reflect.Func &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"handler is not a function"</span>)&#125;handler, ok := bus.handlers[topic]<span class="hljs-keyword">if</span> !ok &#123;handler = []reflect.Value&#123;&#125;&#125;handler = <span class="hljs-built_in">append</span>(handler, v)bus.handlers[topic] = handler<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// Publish 发布</span><span class="hljs-comment">// 这里异步执行，并且不会等待返回结果</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bus *AsyncEventBus)</span> <span class="hljs-title">Publish</span><span class="hljs-params">(topic <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;handlers, ok := bus.handlers[topic]<span class="hljs-keyword">if</span> !ok &#123;fmt.Println(<span class="hljs-string">"not found handlers in topic:"</span>, topic)<span class="hljs-keyword">return</span>&#125;params := <span class="hljs-built_in">make</span>([]reflect.Value, <span class="hljs-built_in">len</span>(args))<span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args &#123;params[i] = reflect.ValueOf(arg)&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> handlers &#123;<span class="hljs-keyword">go</span> handlers[i].Call(params)&#125;&#125;</code></pre><h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> eventbus<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"testing"</span><span class="hljs-string">"time"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub1</span><span class="hljs-params">(msg1, msg2 <span class="hljs-keyword">string</span>)</span></span> &#123;time.Sleep(<span class="hljs-number">1</span> * time.Microsecond)fmt.Printf(<span class="hljs-string">"sub1, %s %s\n"</span>, msg1, msg2)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub2</span><span class="hljs-params">(msg1, msg2 <span class="hljs-keyword">string</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">"sub2, %s %s\n"</span>, msg1, msg2)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAsyncEventBus_Publish</span><span class="hljs-params">(t *testing.T)</span></span> &#123;bus := NewAsyncEventBus()bus.Subscribe(<span class="hljs-string">"topic:1"</span>, sub1)bus.Subscribe(<span class="hljs-string">"topic:1"</span>, sub2)bus.Publish(<span class="hljs-string">"topic:1"</span>, <span class="hljs-string">"test1"</span>, <span class="hljs-string">"test2"</span>)bus.Publish(<span class="hljs-string">"topic:1"</span>, <span class="hljs-string">"testA"</span>, <span class="hljs-string">"testB"</span>)time.Sleep(<span class="hljs-number">1</span> * time.Second)&#125;</code></pre><p>结果</p><pre><code class="hljs go">=== RUN   TestAsyncEventBus_Publishsub2, testA testBsub2, test1 test2sub1, testA testBsub1, test1 test2--- PASS: TestAsyncEventBus_Publish (<span class="hljs-number">1.01</span>s)</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式12-享元模式</title>
    <link href="/post/flyweight.html"/>
    <url>/post/flyweight.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/208572" target="_blank" rel="noopener">54 | 享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 12/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1604552127501-2af05ce0-8947-4853-9f7f-997d40758322.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>复用课程中的 🌰，如果我们现在正在做一个棋牌类的游戏，例如象棋，无论是什么对局，棋子的基本属性其实是固定的，并不会因为随着下棋的过程变化。那我们就可以把棋子变为享元，让所有的对局都共享这些对象，以此达到节省内存的目的。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> flyweight<span class="hljs-keyword">var</span> units = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*ChessPieceUnit&#123;<span class="hljs-number">1</span>: &#123;ID:    <span class="hljs-number">1</span>,Name:  <span class="hljs-string">"車"</span>,Color: <span class="hljs-string">"red"</span>,&#125;,<span class="hljs-number">2</span>: &#123;ID:    <span class="hljs-number">2</span>,Name:  <span class="hljs-string">"炮"</span>,Color: <span class="hljs-string">"red"</span>,&#125;,<span class="hljs-comment">// ... 其他棋子</span>&#125;<span class="hljs-comment">// ChessPieceUnit 棋子享元</span><span class="hljs-keyword">type</span> ChessPieceUnit <span class="hljs-keyword">struct</span> &#123;ID    <span class="hljs-keyword">uint</span>Name  <span class="hljs-keyword">string</span>Color <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// NewChessPieceUnit 工厂</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewChessPieceUnit</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ChessPieceUnit</span></span> &#123;<span class="hljs-keyword">return</span> units[id]&#125;<span class="hljs-comment">// ChessPiece 棋子</span><span class="hljs-keyword">type</span> ChessPiece <span class="hljs-keyword">struct</span> &#123;Unit *ChessPieceUnitX    <span class="hljs-keyword">int</span>Y    <span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">// ChessBoard 棋局</span><span class="hljs-keyword">type</span> ChessBoard <span class="hljs-keyword">struct</span> &#123;chessPieces <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*ChessPiece&#125;<span class="hljs-comment">// NewChessBoard 初始化棋盘</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewChessBoard</span><span class="hljs-params">()</span> *<span class="hljs-title">ChessBoard</span></span> &#123;board := &amp;ChessBoard&#123;chessPieces: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*ChessPiece&#123;&#125;&#125;<span class="hljs-keyword">for</span> id := <span class="hljs-keyword">range</span> units &#123;board.chessPieces[id] = &amp;ChessPiece&#123;Unit: NewChessPieceUnit(id),X:    <span class="hljs-number">0</span>,Y:    <span class="hljs-number">0</span>,&#125;&#125;<span class="hljs-keyword">return</span> board&#125;<span class="hljs-comment">// Move 移动棋子</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ChessBoard)</span> <span class="hljs-title">Move</span><span class="hljs-params">(id, x, y <span class="hljs-keyword">int</span>)</span></span> &#123;c.chessPieces[id].X = xc.chessPieces[id].Y = y&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> flyweight<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewChessBoard</span><span class="hljs-params">(t *testing.T)</span></span> &#123;board1 := NewChessBoard()board1.Move(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)board2 := NewChessBoard()board2.Move(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)assert.Equal(t, board1.chessPieces[<span class="hljs-number">1</span>].Unit, board2.chessPieces[<span class="hljs-number">1</span>].Unit)assert.Equal(t, board1.chessPieces[<span class="hljs-number">2</span>].Unit, board2.chessPieces[<span class="hljs-number">2</span>].Unit)&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式11-组合模式</title>
    <link href="/post/composite.html"/>
    <url>/post/composite.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/207456" target="_blank" rel="noopener">53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 11/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1604551967986-02f19644-e8c3-4d13-8f30-4f7eeb1034be.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>公司的人员组织就是一个典型的树状的结构，现在假设我们现在有部分，和员工，两种角色，一个部门下面可以存在子部门和员工，员工下面不能再包含其他节点。<br>我们现在要实现一个统计一个部门下员工数量的功能</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> composite<span class="hljs-comment">// IOrganization 组织接口，都实现统计人数的功能</span><span class="hljs-keyword">type</span> IOrganization <span class="hljs-keyword">interface</span> &#123;Count() <span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">// Employee 员工</span><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// Count 人数统计</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Employee)</span> <span class="hljs-title">Count</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;<span class="hljs-comment">// Department 部门</span><span class="hljs-keyword">type</span> Department <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-keyword">string</span>SubOrganizations []IOrganization&#125;<span class="hljs-comment">// Count 人数统计</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Department)</span> <span class="hljs-title">Count</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;c := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> _, org := <span class="hljs-keyword">range</span> d.SubOrganizations &#123;c += org.Count()&#125;<span class="hljs-keyword">return</span> c&#125;<span class="hljs-comment">// AddSub 添加子节点</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Department)</span> <span class="hljs-title">AddSub</span><span class="hljs-params">(org IOrganization)</span></span> &#123;d.SubOrganizations = <span class="hljs-built_in">append</span>(d.SubOrganizations, org)&#125;<span class="hljs-comment">// NewOrganization 构建组织架构 demo</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewOrganization</span><span class="hljs-params">()</span> <span class="hljs-title">IOrganization</span></span> &#123;root := &amp;Department&#123;Name: <span class="hljs-string">"root"</span>&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;root.AddSub(&amp;Employee&#123;&#125;)root.AddSub(&amp;Department&#123;Name: <span class="hljs-string">"sub"</span>, SubOrganizations: []IOrganization&#123;&amp;Employee&#123;&#125;&#125;&#125;)&#125;<span class="hljs-keyword">return</span> root&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> composite<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewOrganization</span><span class="hljs-params">(t *testing.T)</span></span> &#123;got := NewOrganization().Count()assert.Equal(t, <span class="hljs-number">20</span>, got)&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式10-门面模式</title>
    <link href="/post/facade.html"/>
    <url>/post/facade.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/206409" target="_blank" rel="noopener">52 | 门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: /22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1604551910336-ea49926e-a6d4-45e1-aabb-f668fc4309e5.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设现在我有一个网站，以前有登录和注册的流程，登录的时候调用用户的查询接口，注册时调用用户的创建接口。为了简化用户的使用流程，我们现在提供直接验证码登录/注册的功能，如果该手机号已注册那么我们就走登录流程，如果该手机号未注册，那么我们就创建一个新的用户。</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> facade<span class="hljs-comment">// IUser 用户接口</span><span class="hljs-keyword">type</span> IUser <span class="hljs-keyword">interface</span> &#123;Login(phone <span class="hljs-keyword">int</span>, code <span class="hljs-keyword">int</span>) (*User, error)Register(phone <span class="hljs-keyword">int</span>, code <span class="hljs-keyword">int</span>) (*User, error)&#125;<span class="hljs-comment">// IUserFacade 门面模式</span><span class="hljs-keyword">type</span> IUserFacade <span class="hljs-keyword">interface</span> &#123;LoginOrRegister(phone <span class="hljs-keyword">int</span>, code <span class="hljs-keyword">int</span>) error&#125;<span class="hljs-comment">// User 用户</span><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// UserService UserService</span><span class="hljs-keyword">type</span> UserService <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Login 登录</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u UserService)</span> <span class="hljs-title">Login</span><span class="hljs-params">(phone <span class="hljs-keyword">int</span>, code <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*User, error)</span></span> &#123;<span class="hljs-comment">// 校验操作 ...</span><span class="hljs-keyword">return</span> &amp;User&#123;Name: <span class="hljs-string">"test login"</span>&#125;, <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// Register 注册</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u UserService)</span> <span class="hljs-title">Register</span><span class="hljs-params">(phone <span class="hljs-keyword">int</span>, code <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*User, error)</span></span> &#123;<span class="hljs-comment">// 校验操作 ...</span><span class="hljs-comment">// 创建用户</span><span class="hljs-keyword">return</span> &amp;User&#123;Name: <span class="hljs-string">"test register"</span>&#125;, <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// LoginOrRegister 登录或注册</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u UserService)</span><span class="hljs-title">LoginOrRegister</span><span class="hljs-params">(phone <span class="hljs-keyword">int</span>, code <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*User, error)</span></span> &#123;user, err := u.Login(phone, code)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;<span class="hljs-keyword">if</span> user != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> user, <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> u.Register(phone, code)&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> facade<span class="hljs-keyword">import</span> (<span class="hljs-string">"github.com/stretchr/testify/assert"</span><span class="hljs-string">"testing"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestUserService_Login</span><span class="hljs-params">(t *testing.T)</span></span> &#123;service := UserService&#123;&#125;user, err := service.Login(<span class="hljs-number">13001010101</span>, <span class="hljs-number">1234</span>)assert.NoError(t, err)assert.Equal(t, &amp;User&#123;Name: <span class="hljs-string">"test login"</span>&#125;, user)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestUserService_LoginOrRegister</span><span class="hljs-params">(t *testing.T)</span></span> &#123;service := UserService&#123;&#125;user, err := service.LoginOrRegister(<span class="hljs-number">13001010101</span>, <span class="hljs-number">1234</span>)assert.NoError(t, err)assert.Equal(t, &amp;User&#123;Name: <span class="hljs-string">"test login"</span>&#125;, user)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestUserService_Register</span><span class="hljs-params">(t *testing.T)</span></span> &#123;service := UserService&#123;&#125;user, err := service.Register(<span class="hljs-number">13001010101</span>, <span class="hljs-number">1234</span>)assert.NoError(t, err)assert.Equal(t, &amp;User&#123;Name: <span class="hljs-string">"test register"</span>&#125;, user)&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式09-适配器模式</title>
    <link href="/post/adapter.html"/>
    <url>/post/adapter.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/205912" target="_blank" rel="noopener">51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 09/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1600352298306-7105ca29-089d-4f54-bb65-82d3c0c3b31c.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我现在有一个运维系统，需要分别调用阿里云和 AWS 的 SDK 创建主机，两个 SDK 提供的创建主机的接口不一致，此时就可以通过适配器模式，将两个接口统一。<br><strong>PS：AWS 和 阿里云的接口纯属虚构，没有直接用原始的 SDK，只是举个例子</strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> adapter<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-comment">// ICreateServer 创建云主机</span><span class="hljs-keyword">type</span> ICreateServer <span class="hljs-keyword">interface</span> &#123;CreateServer(cpu, mem <span class="hljs-keyword">float64</span>) error&#125;<span class="hljs-comment">// AWSClient aws sdk</span><span class="hljs-keyword">type</span> AWSClient <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// RunInstance 启动实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *AWSClient)</span> <span class="hljs-title">RunInstance</span><span class="hljs-params">(cpu, mem <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">error</span></span> &#123;fmt.Printf(<span class="hljs-string">"aws client run success, cpu： %f, mem: %f"</span>, cpu, mem)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// AwsClientAdapter 适配器</span><span class="hljs-keyword">type</span> AwsClientAdapter <span class="hljs-keyword">struct</span> &#123;Client AWSClient&#125;<span class="hljs-comment">// CreateServer 启动实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AwsClientAdapter)</span> <span class="hljs-title">CreateServer</span><span class="hljs-params">(cpu, mem <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">error</span></span> &#123;a.Client.RunInstance(cpu, mem)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// AliyunClient aliyun sdk</span><span class="hljs-keyword">type</span> AliyunClient <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// CreateServer 启动实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *AliyunClient)</span> <span class="hljs-title">CreateServer</span><span class="hljs-params">(cpu, mem <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;fmt.Printf(<span class="hljs-string">"aws client run success, cpu： %d, mem: %d"</span>, cpu, mem)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// AliyunClientAdapter 适配器</span><span class="hljs-keyword">type</span> AliyunClientAdapter <span class="hljs-keyword">struct</span> &#123;Client AliyunClient&#125;<span class="hljs-comment">// CreateServer 启动实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AliyunClientAdapter)</span> <span class="hljs-title">CreateServer</span><span class="hljs-params">(cpu, mem <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">error</span></span> &#123;a.Client.CreateServer(<span class="hljs-keyword">int</span>(cpu), <span class="hljs-keyword">int</span>(mem))<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> adapter<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAliyunClientAdapter_CreateServer</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-comment">// 确保 adapter 实现了目标接口</span><span class="hljs-keyword">var</span> a ICreateServer = &amp;AliyunClientAdapter&#123;Client: AliyunClient&#123;&#125;,&#125;a.CreateServer(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAwsClientAdapter_CreateServer</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-comment">// 确保 adapter 实现了目标接口</span><span class="hljs-keyword">var</span> a ICreateServer = &amp;AwsClientAdapter&#123;Client: AWSClient&#123;&#125;,&#125;a.CreateServer(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式08-装饰器模式</title>
    <link href="/post/decorator.html"/>
    <url>/post/decorator.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/204845" target="_blank" rel="noopener">50 | 装饰器模式：通过剖析 Java IO 类库源码学习装饰器模式</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 08/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1599665456992-83f8ee96-e608-492d-9390-c08cab4fa0cb.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面是一个简单的画画的例子，默认的 <code>Square</code> 只有基础的画画功能， <code>ColorSquare</code> 为他加上了颜色</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> decorator<span class="hljs-comment">// IDraw IDraw</span><span class="hljs-keyword">type</span> IDraw <span class="hljs-keyword">interface</span> &#123;Draw() <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// Square 正方形</span><span class="hljs-keyword">type</span> Square <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// Draw Draw</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Square)</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"this is a square"</span>&#125;<span class="hljs-comment">// ColorSquare 有颜色的正方形</span><span class="hljs-keyword">type</span> ColorSquare <span class="hljs-keyword">struct</span> &#123;square IDrawcolor  <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// NewColorSquare NewColorSquare</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewColorSquare</span><span class="hljs-params">(square IDraw, color <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">ColorSquare</span></span> &#123;<span class="hljs-keyword">return</span> ColorSquare&#123;color: color, square: square&#125;&#125;<span class="hljs-comment">// Draw Draw</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c ColorSquare)</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> c.square.Draw() + <span class="hljs-string">", color is "</span> + c.color&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestColorSquare_Draw</span><span class="hljs-params">(t *testing.T)</span></span> &#123;sq := Square&#123;&#125;csq := NewColorSquare(sq, <span class="hljs-string">"red"</span>)got := csq.Draw()assert.Equal(t, <span class="hljs-string">"this is a square, color is red"</span>, got)&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式07-桥接模式</title>
    <link href="/post/bridge.html"/>
    <url>/post/bridge.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/202786" target="_blank" rel="noopener">49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 07/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1599580037511-2ca9ca33-6990-417a-8a3d-735d16c4b284.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> bridge<span class="hljs-comment">// IMsgSender IMsgSender</span><span class="hljs-keyword">type</span> IMsgSender <span class="hljs-keyword">interface</span> &#123;Send(msg <span class="hljs-keyword">string</span>) error&#125;<span class="hljs-comment">// EmailMsgSender 发送邮件</span><span class="hljs-comment">// 可能还有 电话、短信等各种实现</span><span class="hljs-keyword">type</span> EmailMsgSender <span class="hljs-keyword">struct</span> &#123;emails []<span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// NewEmailMsgSender NewEmailMsgSender</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewEmailMsgSender</span><span class="hljs-params">(emails []<span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">EmailMsgSender</span></span> &#123;<span class="hljs-keyword">return</span> &amp;EmailMsgSender&#123;emails: emails&#125;&#125;<span class="hljs-comment">// Send Send</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *EmailMsgSender)</span> <span class="hljs-title">Send</span><span class="hljs-params">(msg <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-comment">// 这里去发送消息</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// INotification 通知接口</span><span class="hljs-keyword">type</span> INotification <span class="hljs-keyword">interface</span> &#123;Notify(msg <span class="hljs-keyword">string</span>) error&#125;<span class="hljs-comment">// ErrorNotification 错误通知</span><span class="hljs-comment">// 后面可能还有 warning 各种级别</span><span class="hljs-keyword">type</span> ErrorNotification <span class="hljs-keyword">struct</span> &#123;sender IMsgSender&#125;<span class="hljs-comment">// NewErrorNotification NewErrorNotification</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewErrorNotification</span><span class="hljs-params">(sender IMsgSender)</span> *<span class="hljs-title">ErrorNotification</span></span> &#123;<span class="hljs-keyword">return</span> &amp;ErrorNotification&#123;sender: sender&#125;&#125;<span class="hljs-comment">// Notify 发送通知</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *ErrorNotification)</span> <span class="hljs-title">Notify</span><span class="hljs-params">(msg <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> n.sender.Send(msg)&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestErrorNotification_Notify</span><span class="hljs-params">(t *testing.T)</span></span> &#123;sender := NewEmailMsgSender([]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"test@test.com"</span>&#125;)n := NewErrorNotification(sender)err := n.Notify(<span class="hljs-string">"test msg"</span>)assert.Nil(t, err)&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式06-代理模式(generate实现类似动态代理)</title>
    <link href="/post/proxy.html"/>
    <url>/post/proxy.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/201823" target="_blank" rel="noopener">48 | 代理模式：代理在 RPC、缓存、监控等场景中的应用</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 06/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1599405885948-ab2a5ede-bd05-49bd-a20d-6afea89e74c3.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>接下来会通过 golang 实现静态代理，有 Golang 和 java 的差异性，我们无法比较方便的利用反射实现动态代理，但是我们可以利用<strong> go generate </strong>实现类似的效果，并且这样实现有两个比较大的好处，一个是有静态代码检查，我们在编译期间就可以及早发现问题，第二个是性能会更好。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> proxy<span class="hljs-keyword">import</span> (<span class="hljs-string">"log"</span><span class="hljs-string">"time"</span>)<span class="hljs-comment">// IUser IUser</span><span class="hljs-keyword">type</span> IUser <span class="hljs-keyword">interface</span> &#123;Login(username, password <span class="hljs-keyword">string</span>) error&#125;<span class="hljs-comment">// User 用户</span><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Login 用户登录</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span> <span class="hljs-title">Login</span><span class="hljs-params">(username, password <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-comment">// 不实现细节</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// UserProxy 代理类</span><span class="hljs-keyword">type</span> UserProxy <span class="hljs-keyword">struct</span> &#123;user *User&#125;<span class="hljs-comment">// NewUserProxy NewUserProxy</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUserProxy</span><span class="hljs-params">(user *User)</span> *<span class="hljs-title">UserProxy</span></span> &#123;<span class="hljs-keyword">return</span> &amp;UserProxy&#123;user: user,&#125;&#125;<span class="hljs-comment">// Login 登录，和 user 实现相同的接口</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *UserProxy)</span> <span class="hljs-title">Login</span><span class="hljs-params">(username, password <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-comment">// before 这里可能会有一些统计的逻辑</span>start := time.Now()<span class="hljs-comment">// 这里是原有的业务逻辑</span><span class="hljs-keyword">if</span> err := p.user.Login(username, password); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-comment">// after 这里可能也有一些监控统计的逻辑</span>log.Printf(<span class="hljs-string">"user login cost time: %s"</span>, time.Now().Sub(start))<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> proxy<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/require"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestUserProxy_Login</span><span class="hljs-params">(t *testing.T)</span></span> &#123;proxy := NewUserProxy(&amp;User&#123;&#125;)err := proxy.Login(<span class="hljs-string">"test"</span>, <span class="hljs-string">"password"</span>)require.Nil(t, err)&#125;</code></pre><h3 id="Go-Generate-实现-“动态代理”"><a href="#Go-Generate-实现-“动态代理”" class="headerlink" title="Go Generate 实现 “动态代理”"></a>Go Generate 实现 “动态代理”</h3><p>关于 go generate 之前已经写过一篇入门的介绍文章: <a href="https://lailin.xyz/post/41140.html">go generate and ast</a>，这里就不再赘述了，如果对相关的知识点不太清楚，可以先看前面的那篇文章。<br><strong>注意: 在真实的项目中并不推荐这么做，因为有点得不偿失，本文只是在探讨一种可能性，并且可以复习一下 go 语法树先关的知识点</strong><br>接下来我们先来看看需求。</p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>动态代理相比静态代理主要就是为了解决生产力，将我们从繁杂的重复劳动中解放出来，正好，在 Go 中 Generate 也是干这个活的<br>如下面的代码所示，我们的 generate 会读取 struct 上的注释，如果出现 <code>@proxy 接口名</code> 的注释，我们就会为这个 struct 生成一个 proxy 类，同时实现相同的接口，这个接口就是在注释中指定的接口</p><pre><code class="hljs go"><span class="hljs-comment">// User 用户</span><span class="hljs-comment">// @proxy IUser</span><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;&#125;</code></pre><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><p>接来下我们会简单的实现这个需求，由于篇幅和时间的关系，我们会略过一些检查之类的代码，例如 <code>User</code> 是否真正实现了 <code>IUser</code> 这种情况。<br><strong>代码有点长，主要思路:</strong></p><ul><li>读取文件, 获取文件的 ast 语法树</li><li>通过 NewCommentMap 构建 node 和 comment 的关系</li><li>通过 comment 是否包含 <code>@proxy 接口名</code> 的接口，判断该节点是否需要生成代理类</li><li>通过 Lookup 方法找到接口</li><li>循环获取接口的每个方法的，方法名、参数、返回值信息</li><li>将方法信息，包名、需要代理类名传递给构建好的模板文件，生成代理类</li><li>最后用 format 包的方法格式化源代码</li></ul><pre><code class="hljs go"><span class="hljs-keyword">package</span> proxy<span class="hljs-keyword">import</span> (<span class="hljs-string">"bytes"</span><span class="hljs-string">"fmt"</span><span class="hljs-string">"go/ast"</span><span class="hljs-string">"go/format"</span><span class="hljs-string">"go/parser"</span><span class="hljs-string">"go/token"</span><span class="hljs-string">"strings"</span><span class="hljs-string">"text/template"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generate</span><span class="hljs-params">(file <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;fset := token.NewFileSet() <span class="hljs-comment">// positions are relative to fset</span>f, err := parser.ParseFile(fset, file, <span class="hljs-literal">nil</span>, parser.ParseComments)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">""</span>, err&#125;<span class="hljs-comment">// 获取代理需要的数据</span>data := proxyData&#123;Package: f.Name.Name,&#125;<span class="hljs-comment">// 构建注释和 node 的关系</span>cmap := ast.NewCommentMap(fset, f, f.Comments)<span class="hljs-keyword">for</span> node, group := <span class="hljs-keyword">range</span> cmap &#123;<span class="hljs-comment">// 从注释 @proxy 接口名，获取接口名称</span>name := getProxyInterfaceName(group)<span class="hljs-keyword">if</span> name == <span class="hljs-string">""</span> &#123;<span class="hljs-keyword">continue</span>&#125;<span class="hljs-comment">// 获取代理的类名</span>data.ProxyStructName = node.(*ast.GenDecl).Specs[<span class="hljs-number">0</span>].(*ast.TypeSpec).Name.Name<span class="hljs-comment">// 从文件中查找接口</span>obj := f.Scope.Lookup(name)<span class="hljs-comment">// 类型转换，注意: 这里没有对断言进行判断，可能会导致 panic</span>t := obj.Decl.(*ast.TypeSpec).Type.(*ast.InterfaceType)<span class="hljs-keyword">for</span> _, field := <span class="hljs-keyword">range</span> t.Methods.List &#123;fc := field.Type.(*ast.FuncType)<span class="hljs-comment">// 代理的方法</span>method := &amp;proxyMethod&#123;Name: field.Names[<span class="hljs-number">0</span>].Name,&#125;<span class="hljs-comment">// 获取方法的参数和返回值</span>method.Params, method.ParamNames = getParamsOrResults(fc.Params)method.Results, method.ResultNames = getParamsOrResults(fc.Results)data.Methods = <span class="hljs-built_in">append</span>(data.Methods, method)&#125;&#125;<span class="hljs-comment">// 生成文件</span>tpl, err := template.New(<span class="hljs-string">""</span>).Parse(proxyTpl)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">""</span>, err&#125;buf := &amp;bytes.Buffer&#123;&#125;<span class="hljs-keyword">if</span> err := tpl.Execute(buf, data); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">""</span>, err&#125;<span class="hljs-comment">// 使用 go fmt 对生成的代码进行格式化</span>src, err := format.Source(buf.Bytes())<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">""</span>, err&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(src), <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// getParamsOrResults 获取参数或者是返回值</span><span class="hljs-comment">// 返回带类型的参数，以及不带类型的参数，以逗号间隔</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getParamsOrResults</span><span class="hljs-params">(fields *ast.FieldList)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, <span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">var</span> (params     []<span class="hljs-keyword">string</span>paramNames []<span class="hljs-keyword">string</span>)<span class="hljs-keyword">for</span> i, param := <span class="hljs-keyword">range</span> fields.List &#123;<span class="hljs-comment">// 循环获取所有的参数名</span><span class="hljs-keyword">var</span> names []<span class="hljs-keyword">string</span><span class="hljs-keyword">for</span> _, name := <span class="hljs-keyword">range</span> param.Names &#123;names = <span class="hljs-built_in">append</span>(names, name.Name)&#125;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(names) == <span class="hljs-number">0</span> &#123;names = <span class="hljs-built_in">append</span>(names, fmt.Sprintf(<span class="hljs-string">"r%d"</span>, i))&#125;paramNames = <span class="hljs-built_in">append</span>(paramNames, names...)<span class="hljs-comment">// 参数名加参数类型组成完整的参数</span>param := fmt.Sprintf(<span class="hljs-string">"%s %s"</span>,strings.Join(names, <span class="hljs-string">","</span>),param.Type.(*ast.Ident).Name,)params = <span class="hljs-built_in">append</span>(params, strings.TrimSpace(param))&#125;<span class="hljs-keyword">return</span> strings.Join(params, <span class="hljs-string">","</span>), strings.Join(paramNames, <span class="hljs-string">","</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getProxyInterfaceName</span><span class="hljs-params">(groups []*ast.CommentGroup)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">for</span> _, commentGroup := <span class="hljs-keyword">range</span> groups &#123;<span class="hljs-keyword">for</span> _, comment := <span class="hljs-keyword">range</span> commentGroup.List &#123;<span class="hljs-keyword">if</span> strings.Contains(comment.Text, <span class="hljs-string">"@proxy"</span>) &#123;interfaceName := strings.TrimLeft(comment.Text, <span class="hljs-string">"// @proxy "</span>)<span class="hljs-keyword">return</span> strings.TrimSpace(interfaceName)&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-string">""</span>&#125;<span class="hljs-comment">// 生成代理类的文件模板</span><span class="hljs-keyword">const</span> proxyTpl = <span class="hljs-string">`package &#123;&#123;.Package&#125;&#125;type &#123;&#123; .ProxyStructName &#125;&#125;Proxy struct &#123;child *&#123;&#123; .ProxyStructName &#125;&#125;&#125;func New&#123;&#123; .ProxyStructName &#125;&#125;Proxy(child *&#123;&#123; .ProxyStructName &#125;&#125;) *&#123;&#123; .ProxyStructName &#125;&#125;Proxy &#123;return &amp;&#123;&#123; .ProxyStructName &#125;&#125;Proxy&#123;child: child&#125;&#125;&#123;&#123; range .Methods &#125;&#125;func (p *&#123;&#123;$.ProxyStructName&#125;&#125;Proxy) &#123;&#123; .Name &#125;&#125; (&#123;&#123; .Params &#125;&#125;) (&#123;&#123; .Results &#125;&#125;) &#123;// before 这里可能会有一些统计的逻辑start := time.Now()&#123;&#123; .ResultNames &#125;&#125; = p.child.&#123;&#123; .Name &#125;&#125;(&#123;&#123; .ParamNames &#125;&#125;)// after 这里可能也有一些监控统计的逻辑log.Printf("user login cost time: %s", time.Now().Sub(start))return &#123;&#123; .ResultNames &#125;&#125;&#125;&#123;&#123; end &#125;&#125;`</span><span class="hljs-keyword">type</span> proxyData <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// 包名</span>Package <span class="hljs-keyword">string</span><span class="hljs-comment">// 需要代理的类名</span>ProxyStructName <span class="hljs-keyword">string</span><span class="hljs-comment">// 需要代理的方法</span>Methods []*proxyMethod&#125;<span class="hljs-comment">// proxyMethod 代理的方法</span><span class="hljs-keyword">type</span> proxyMethod <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// 方法名</span>Name <span class="hljs-keyword">string</span><span class="hljs-comment">// 参数，含参数类型</span>Params <span class="hljs-keyword">string</span><span class="hljs-comment">// 参数名</span>ParamNames <span class="hljs-keyword">string</span><span class="hljs-comment">// 返回值</span>Results <span class="hljs-keyword">string</span><span class="hljs-comment">// 返回值名</span>ResultNames <span class="hljs-keyword">string</span>&#125;</code></pre><h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> proxy<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span><span class="hljs-string">"github.com/stretchr/testify/require"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_generate</span><span class="hljs-params">(t *testing.T)</span></span> &#123;want := <span class="hljs-string">`package proxytype UserProxy struct &#123;child *User&#125;func NewUserProxy(child *User) *UserProxy &#123;return &amp;UserProxy&#123;child: child&#125;&#125;func (p *UserProxy) Login(username, password string) (r0 error) &#123;// before 这里可能会有一些统计的逻辑start := time.Now()r0 = p.child.Login(username, password)// after 这里可能也有一些监控统计的逻辑log.Printf("user login cost time: %s", time.Now().Sub(start))return r0&#125;`</span>got, err := generate(<span class="hljs-string">"./static_proxy.go"</span>)require.Nil(t, err)assert.Equal(t, want, got)&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式05-创建型模式总结</title>
    <link href="/post/go-design-pattern-create.html"/>
    <url>/post/go-design-pattern-create.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含 23 种常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 05/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>耗时 2 周更新完了创建型的设计模式，回头思考一下，学习设计模式我们关注的是什么，如何实现么？是也不是。我认为比了解如何实现设计模式更重要的是这些设计模式的应用场景，什么场景下我们该用这种设计模式；以及这些设计模式所包含的思想，最终帮助我们把代码写“好”，可以帮助我们满足一系列的设计原则：</p><ul><li>单一职责</li><li>开闭原则</li><li>里式替换</li><li>接口隔离</li><li>依赖倒置</li><li>KISS</li><li>DRY：不要重复</li><li>高内聚、松耦合</li><li>迪米特法则: 不要依赖类，依赖接口</li><li><p>……<br><img src="https://lailin.xyz/images/1599038480370-ac7b0eef-eaf3-4f6b-bd53-0b464aa591da.png" srcset="/img/loading.gif" alt><strong>具体实现可以查看之前更新的文章</strong></p></li><li><p><a href="https://lailin.xyz/post/singleton.html">单例模式</a></p><ul><li>饿汉式</li><li>懒汉式</li></ul></li><li><a href="https://lailin.xyz/post/factory.html">工厂模式</a><ul><li>简单工厂</li><li>工厂方法</li><li>抽象工厂</li><li>DI 容器</li></ul></li><li><a href="https://lailin.xyz/post/builder.html">建造者模式</a></li><li><a href="https://lailin.xyz/post/prototype.html">原型模式</a></li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式04-原型模式</title>
    <link href="/post/prototype.html"/>
    <url>/post/prototype.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/200786" target="_blank" rel="noopener">47 | 原型模式：如何最快速地 clone 一个 HashMap 散列表？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 04/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1599027192070-e11cb300-094a-487c-9ab4-448a093dcc91.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li>这个模式在 Java、C++ 这种面向对象的语言不太常用，但是如果大家使用过 javascript 的话就会非常熟悉了，因为 js 本身是基于原型的面向对象语言，所以原型模式在 js 中应用非常广泛。</li><li>接下来会按照一个类似课程中的例子使用深拷贝和浅拷贝结合的方式进行实现</li><li>需求: 假设现在数据库中有大量数据，包含了关键词，关键词被搜索的次数等信息，模块 A 为了业务需要<ul><li>会在启动时加载这部分数据到内存中</li><li>并且需要定时更新里面的数据</li><li>同时展示给用户的数据每次必须要是相同版本的数据，不能一部分数据来自版本 1 一部分来自版本 2</li></ul></li></ul><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> prototype<span class="hljs-keyword">import</span> (<span class="hljs-string">"encoding/json"</span><span class="hljs-string">"time"</span>)<span class="hljs-comment">// Keyword 搜索关键字</span><span class="hljs-keyword">type</span> Keyword <span class="hljs-keyword">struct</span> &#123;word      <span class="hljs-keyword">string</span>visit     <span class="hljs-keyword">int</span>UpdatedAt *time.Time&#125;<span class="hljs-comment">// Clone 这里使用序列化与反序列化的方式深拷贝</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k *Keyword)</span> <span class="hljs-title">Clone</span><span class="hljs-params">()</span> *<span class="hljs-title">Keyword</span></span> &#123;<span class="hljs-keyword">var</span> newKeyword Keywordb, _ := json.Marshal(k)json.Unmarshal(b, &amp;newKeyword)<span class="hljs-keyword">return</span> &amp;newKeyword&#125;<span class="hljs-comment">// Keywords 关键字 map</span><span class="hljs-keyword">type</span> Keywords <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*Keyword<span class="hljs-comment">// Clone 复制一个新的 keywords</span><span class="hljs-comment">// updatedWords: 需要更新的关键词列表，由于从数据库中获取数据常常是数组的方式</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(words Keywords)</span> <span class="hljs-title">Clone</span><span class="hljs-params">(updatedWords []*Keyword)</span> <span class="hljs-title">Keywords</span></span> &#123;newKeywords := Keywords&#123;&#125;<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> words &#123;<span class="hljs-comment">// 这里是浅拷贝，直接拷贝了地址</span>newKeywords[k] = v&#125;<span class="hljs-comment">// 替换掉需要更新的字段，这里用的是深拷贝</span><span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> updatedWords &#123;newKeywords[word.word] = word.Clone()&#125;<span class="hljs-keyword">return</span> newKeywords&#125;</code></pre><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> prototype<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"time"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestKeywords_Clone</span><span class="hljs-params">(t *testing.T)</span></span> &#123;updateAt, _ := time.Parse(<span class="hljs-string">"2006"</span>, <span class="hljs-string">"2020"</span>)words := Keywords&#123;<span class="hljs-string">"testA"</span>: &amp;Keyword&#123;word:      <span class="hljs-string">"testA"</span>,visit:     <span class="hljs-number">1</span>,UpdatedAt: &amp;updateAt,&#125;,<span class="hljs-string">"testB"</span>: &amp;Keyword&#123;word:      <span class="hljs-string">"testB"</span>,visit:     <span class="hljs-number">2</span>,UpdatedAt: &amp;updateAt,&#125;,<span class="hljs-string">"testC"</span>: &amp;Keyword&#123;word:      <span class="hljs-string">"testC"</span>,visit:     <span class="hljs-number">3</span>,UpdatedAt: &amp;updateAt,&#125;,&#125;now := time.Now()updatedWords := []*Keyword&#123;&#123;word:      <span class="hljs-string">"testB"</span>,visit:     <span class="hljs-number">10</span>,UpdatedAt: &amp;now,&#125;,&#125;got := words.Clone(updatedWords)assert.Equal(t, words[<span class="hljs-string">"testA"</span>], got[<span class="hljs-string">"testA"</span>])assert.NotEqual(t, words[<span class="hljs-string">"testB"</span>], got[<span class="hljs-string">"testB"</span>])assert.NotEqual(t, updatedWords[<span class="hljs-number">0</span>], got[<span class="hljs-string">"testB"</span>])assert.Equal(t, words[<span class="hljs-string">"testC"</span>], got[<span class="hljs-string">"testC"</span>])&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式03-建造者模式</title>
    <link href="/post/builder.html"/>
    <url>/post/builder.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/199674" target="_blank" rel="noopener">46 | 建造者模式：详解构造函数、set 方法、建造者模式三种对象创建方式</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 03/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>关注我，获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a>**</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1599021006655-090c9fbc-fb5a-4c7c-ad23-a0d0a3e1ab65.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>其实在 Golang 中对于创建类参数比较多的对象的时候，我们常见的做法是必填参数直接传递，可选参数通过传递可变的方法进行创建。<br>本文会先实现课程中的建造者模式，然后再实现我们常用的方式。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>通过下面可以看到，使用 Go 编写建造者模式的代码其实会很长，这些是它的一个缺点，所以如果不是参数的校验逻辑很复杂的情况下一般我们在 Go 中不会采用这种方式，而会采用后面的另外一种方式</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> builder<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-keyword">const</span> (defaultMaxTotal = <span class="hljs-number">10</span>defaultMaxIdle  = <span class="hljs-number">9</span>defaultMinIdle  = <span class="hljs-number">1</span>)<span class="hljs-comment">// ResourcePoolConfig resource pool</span><span class="hljs-keyword">type</span> ResourcePoolConfig <span class="hljs-keyword">struct</span> &#123;name     <span class="hljs-keyword">string</span>maxTotal <span class="hljs-keyword">int</span>maxIdle  <span class="hljs-keyword">int</span>minIdle  <span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">// ResourcePoolConfigBuilder 用于构建 ResourcePoolConfig</span><span class="hljs-keyword">type</span> ResourcePoolConfigBuilder <span class="hljs-keyword">struct</span> &#123;name     <span class="hljs-keyword">string</span>maxTotal <span class="hljs-keyword">int</span>maxIdle  <span class="hljs-keyword">int</span>minIdle  <span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">// SetName SetName</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span> <span class="hljs-title">SetName</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> name == <span class="hljs-string">""</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"name can not be empty"</span>)&#125;b.name = name<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// SetMinIdle SetMinIdle</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span> <span class="hljs-title">SetMinIdle</span><span class="hljs-params">(minIdle <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> minIdle &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"max tatal cannot &lt; 0, input: %d"</span>, minIdle)&#125;b.minIdle = minIdle<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// SetMaxIdle SetMaxIdle</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span> <span class="hljs-title">SetMaxIdle</span><span class="hljs-params">(maxIdle <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> maxIdle &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"max tatal cannot &lt; 0, input: %d"</span>, maxIdle)&#125;b.maxIdle = maxIdle<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// SetMaxTotal SetMaxTotal</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span> <span class="hljs-title">SetMaxTotal</span><span class="hljs-params">(maxTotal <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> maxTotal &lt;= <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"max tatal cannot &lt;= 0, input: %d"</span>, maxTotal)&#125;b.maxTotal = maxTotal<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// Build Build</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *ResourcePoolConfigBuilder)</span> <span class="hljs-title">Build</span><span class="hljs-params">()</span> <span class="hljs-params">(*ResourcePoolConfig, error)</span></span> &#123;<span class="hljs-keyword">if</span> b.name == <span class="hljs-string">""</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"name can not be empty"</span>)&#125;<span class="hljs-comment">// 设置默认值</span><span class="hljs-keyword">if</span> b.minIdle == <span class="hljs-number">0</span> &#123;b.minIdle = defaultMinIdle&#125;<span class="hljs-keyword">if</span> b.maxIdle == <span class="hljs-number">0</span> &#123;b.maxIdle = defaultMaxIdle&#125;<span class="hljs-keyword">if</span> b.maxTotal == <span class="hljs-number">0</span> &#123;b.maxTotal = defaultMaxTotal&#125;<span class="hljs-keyword">if</span> b.maxTotal &lt; b.maxIdle &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"max total(%d) cannot &lt; max idle(%d)"</span>, b.maxTotal, b.maxIdle)&#125;<span class="hljs-keyword">if</span> b.minIdle &gt; b.maxIdle &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"max idle(%d) cannot &lt; min idle(%d)"</span>, b.maxIdle, b.minIdle)&#125;<span class="hljs-keyword">return</span> &amp;ResourcePoolConfig&#123;name:     b.name,maxTotal: b.maxTotal,maxIdle:  b.maxIdle,minIdle:  b.minIdle,&#125;, <span class="hljs-literal">nil</span>&#125;</code></pre><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> builder<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span><span class="hljs-string">"github.com/stretchr/testify/require"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestResourcePoolConfigBuilder_Build</span><span class="hljs-params">(t *testing.T)</span></span> &#123;tests := []<span class="hljs-keyword">struct</span> &#123;name    <span class="hljs-keyword">string</span>builder *ResourcePoolConfigBuilderwant    *ResourcePoolConfigwantErr <span class="hljs-keyword">bool</span>&#125;&#123;&#123;name: <span class="hljs-string">"name empty"</span>,builder: &amp;ResourcePoolConfigBuilder&#123;name:     <span class="hljs-string">""</span>,maxTotal: <span class="hljs-number">0</span>,&#125;,want:    <span class="hljs-literal">nil</span>,wantErr: <span class="hljs-literal">true</span>,&#125;,&#123;name: <span class="hljs-string">"maxIdle &lt; minIdle"</span>,builder: &amp;ResourcePoolConfigBuilder&#123;name:     <span class="hljs-string">"test"</span>,maxTotal: <span class="hljs-number">0</span>,maxIdle:  <span class="hljs-number">10</span>,minIdle:  <span class="hljs-number">20</span>,&#125;,want:    <span class="hljs-literal">nil</span>,wantErr: <span class="hljs-literal">true</span>,&#125;,&#123;name: <span class="hljs-string">"success"</span>,builder: &amp;ResourcePoolConfigBuilder&#123;name: <span class="hljs-string">"test"</span>,&#125;,want: &amp;ResourcePoolConfig&#123;name:     <span class="hljs-string">"test"</span>,maxTotal: defaultMaxTotal,maxIdle:  defaultMaxIdle,minIdle:  defaultMinIdle,&#125;,wantErr: <span class="hljs-literal">false</span>,&#125;,&#125;<span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;got, err := tt.builder.Build()require.Equalf(t, tt.wantErr, err != <span class="hljs-literal">nil</span>, <span class="hljs-string">"Build() error = %v, wantErr %v"</span>, err, tt.wantErr)assert.Equal(t, tt.want, got)&#125;)&#125;&#125;</code></pre><h3 id="Go-常用的参数传递方法"><a href="#Go-常用的参数传递方法" class="headerlink" title="Go 常用的参数传递方法"></a>Go 常用的参数传递方法</h3><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> builder<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-comment">// ResourcePoolConfigOption option</span><span class="hljs-keyword">type</span> ResourcePoolConfigOption <span class="hljs-keyword">struct</span> &#123;maxTotal <span class="hljs-keyword">int</span>maxIdle  <span class="hljs-keyword">int</span>minIdle  <span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">// ResourcePoolConfigOptFunc to set option</span><span class="hljs-keyword">type</span> ResourcePoolConfigOptFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(option *ResourcePoolConfigOption)</span></span><span class="hljs-comment">// NewResourcePoolConfig NewResourcePoolConfig</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewResourcePoolConfig</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, opts ...ResourcePoolConfigOptFunc)</span> <span class="hljs-params">(*ResourcePoolConfig, error)</span></span> &#123;<span class="hljs-keyword">if</span> name == <span class="hljs-string">""</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"name can not be empty"</span>)&#125;option := &amp;ResourcePoolConfigOption&#123;maxTotal: <span class="hljs-number">10</span>,maxIdle:  <span class="hljs-number">9</span>,minIdle:  <span class="hljs-number">1</span>,&#125;<span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> opts &#123;opt(option)&#125;<span class="hljs-keyword">if</span> option.maxTotal &lt; <span class="hljs-number">0</span> || option.maxIdle &lt; <span class="hljs-number">0</span> || option.minIdle &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"args err, option: %v"</span>, option)&#125;<span class="hljs-keyword">if</span> option.maxTotal &lt; option.maxIdle || option.minIdle &gt; option.maxIdle &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"args err, option: %v"</span>, option)&#125;<span class="hljs-keyword">return</span> &amp;ResourcePoolConfig&#123;name:     name,maxTotal: option.maxTotal,maxIdle:  option.maxIdle,minIdle:  option.minIdle,&#125;, <span class="hljs-literal">nil</span>&#125;</code></pre><h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> builder<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span><span class="hljs-string">"github.com/stretchr/testify/require"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewResourcePoolConfig</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>opts []ResourcePoolConfigOptFunc&#125;tests := []<span class="hljs-keyword">struct</span> &#123;name    <span class="hljs-keyword">string</span>args    argswant    *ResourcePoolConfigwantErr <span class="hljs-keyword">bool</span>&#125;&#123;&#123;name: <span class="hljs-string">"name empty"</span>,args: args&#123;name: <span class="hljs-string">""</span>,&#125;,want:    <span class="hljs-literal">nil</span>,wantErr: <span class="hljs-literal">true</span>,&#125;,&#123;name: <span class="hljs-string">"success"</span>,args: args&#123;name: <span class="hljs-string">"test"</span>,opts: []ResourcePoolConfigOptFunc&#123;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(option *ResourcePoolConfigOption)</span></span> &#123;option.minIdle = <span class="hljs-number">2</span>&#125;,&#125;,&#125;,want: &amp;ResourcePoolConfig&#123;name:     <span class="hljs-string">"test"</span>,maxTotal: <span class="hljs-number">10</span>,maxIdle:  <span class="hljs-number">9</span>,minIdle:  <span class="hljs-number">2</span>,&#125;,wantErr: <span class="hljs-literal">false</span>,&#125;,&#125;<span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;got, err := NewResourcePoolConfig(tt.args.name, tt.args.opts...)require.Equalf(t, tt.wantErr, err != <span class="hljs-literal">nil</span>, <span class="hljs-string">"error = %v, wantErr %v"</span>, err, tt.wantErr)assert.Equal(t, tt.want, got)&#125;)&#125;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实可以看到，绝大多数情况下直接使用后面的这种方式就可以了，并且在编写公共库的时候，<strong>强烈建议</strong>入口的参数都可以这么传递，这样可以最大程度的保证我们公共库的兼容性，避免在后续的更新的时候出现破坏性的更新的情况。</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式02-工厂模式&amp;DI容器</title>
    <link href="/post/factory.html"/>
    <url>/post/factory.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>注意：这篇文章代码比较多，包含了 简单工厂、工厂方法、抽象工厂、DI 容器的实现，由于内容具有关联性就不进行拆分了</li><li>Go 设计模式实现，包含 23 种常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/197254" target="_blank" rel="noopener">44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 02/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a><br><img src="https://lailin.xyz/images/1599020982679-472ce6a9-cc75-4fd1-b92e-bf643f4b2784.png" srcset="/img/loading.gif" alt></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>由于 Go 本身是没有构造函数的，一般而言我们采用 <code>NewName</code> 的方式创建对象/接口，当它返回的是接口的时候，其实就是简单工厂模式</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> factory<span class="hljs-comment">// IRuleConfigParser IRuleConfigParser</span><span class="hljs-keyword">type</span> IRuleConfigParser <span class="hljs-keyword">interface</span> &#123;Parse(data []<span class="hljs-keyword">byte</span>)&#125;<span class="hljs-comment">// jsonRuleConfigParser jsonRuleConfigParser</span><span class="hljs-keyword">type</span> jsonRuleConfigParser <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Parse Parse</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(J jsonRuleConfigParser)</span> <span class="hljs-title">Parse</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span></span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"implement me"</span>)&#125;<span class="hljs-comment">// yamlRuleConfigParser yamlRuleConfigParser</span><span class="hljs-keyword">type</span> yamlRuleConfigParser <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Parse Parse</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Y yamlRuleConfigParser)</span> <span class="hljs-title">Parse</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span></span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"implement me"</span>)&#125;<span class="hljs-comment">// NewIRuleConfigParser NewIRuleConfigParser</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewIRuleConfigParser</span><span class="hljs-params">(t <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">IRuleConfigParser</span></span> &#123;<span class="hljs-keyword">switch</span> t &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">"json"</span>:<span class="hljs-keyword">return</span> jsonRuleConfigParser&#123;&#125;<span class="hljs-keyword">case</span> <span class="hljs-string">"yaml"</span>:<span class="hljs-keyword">return</span> yamlRuleConfigParser&#123;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> factory<span class="hljs-keyword">import</span> (<span class="hljs-string">"reflect"</span><span class="hljs-string">"testing"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewIRuleConfigParser</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;t <span class="hljs-keyword">string</span>&#125;tests := []<span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>args argswant IRuleConfigParser&#125;&#123;&#123;name: <span class="hljs-string">"json"</span>,args: args&#123;t: <span class="hljs-string">"json"</span>&#125;,want: jsonRuleConfigParser&#123;&#125;,&#125;,&#123;name: <span class="hljs-string">"yaml"</span>,args: args&#123;t: <span class="hljs-string">"yaml"</span>&#125;,want: yamlRuleConfigParser&#123;&#125;,&#125;,&#125;<span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">if</span> got := NewIRuleConfigParser(tt.args.t); !reflect.DeepEqual(got, tt.want) &#123;t.Errorf(<span class="hljs-string">"NewIRuleConfigParser() = %v, want %v"</span>, got, tt.want)&#125;&#125;)&#125;&#125;</code></pre><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂</p><pre><code class="hljs go"><span class="hljs-comment">// IRuleConfigParserFactory 工厂方法接口</span><span class="hljs-keyword">type</span> IRuleConfigParserFactory <span class="hljs-keyword">interface</span> &#123;CreateParser() IRuleConfigParser&#125;<span class="hljs-comment">// yamlRuleConfigParserFactory yamlRuleConfigParser 的工厂类</span><span class="hljs-keyword">type</span> yamlRuleConfigParserFactory <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// CreateParser CreateParser</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(y yamlRuleConfigParserFactory)</span> <span class="hljs-title">CreateParser</span><span class="hljs-params">()</span> <span class="hljs-title">IRuleConfigParser</span></span> &#123;<span class="hljs-keyword">return</span> yamlRuleConfigParser&#123;&#125;&#125;<span class="hljs-comment">// jsonRuleConfigParserFactory jsonRuleConfigParser 的工厂类</span><span class="hljs-keyword">type</span> jsonRuleConfigParserFactory <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// CreateParser CreateParser</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonRuleConfigParserFactory)</span> <span class="hljs-title">CreateParser</span><span class="hljs-params">()</span> <span class="hljs-title">IRuleConfigParser</span></span> &#123;<span class="hljs-keyword">return</span> jsonRuleConfigParser&#123;&#125;&#125;<span class="hljs-comment">// NewIRuleConfigParserFactory 用一个简单工厂封装工厂方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewIRuleConfigParserFactory</span><span class="hljs-params">(t <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">IRuleConfigParserFactory</span></span> &#123;<span class="hljs-keyword">switch</span> t &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">"json"</span>:<span class="hljs-keyword">return</span> jsonRuleConfigParserFactory&#123;&#125;<span class="hljs-keyword">case</span> <span class="hljs-string">"yaml"</span>:<span class="hljs-keyword">return</span> yamlRuleConfigParserFactory&#123;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> factory<span class="hljs-keyword">import</span> (<span class="hljs-string">"reflect"</span><span class="hljs-string">"testing"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewIRuleConfigParserFactory</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;t <span class="hljs-keyword">string</span>&#125;tests := []<span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>args argswant IRuleConfigParserFactory&#125;&#123;&#123;name: <span class="hljs-string">"json"</span>,args: args&#123;t: <span class="hljs-string">"json"</span>&#125;,want: jsonRuleConfigParserFactory&#123;&#125;,&#125;,&#123;name: <span class="hljs-string">"yaml"</span>,args: args&#123;t: <span class="hljs-string">"yaml"</span>&#125;,want: yamlRuleConfigParserFactory&#123;&#125;,&#125;,&#125;<span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">if</span> got := NewIRuleConfigParserFactory(tt.args.t); !reflect.DeepEqual(got, tt.want) &#123;t.Errorf(<span class="hljs-string">"NewIRuleConfigParserFactory() = %v, want %v"</span>, got, tt.want)&#125;&#125;)&#125;&#125;</code></pre><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> factory<span class="hljs-comment">// IRuleConfigParser IRuleConfigParser</span><span class="hljs-keyword">type</span> IRuleConfigParser <span class="hljs-keyword">interface</span> &#123;Parse(data []<span class="hljs-keyword">byte</span>)&#125;<span class="hljs-comment">// jsonRuleConfigParser jsonRuleConfigParser</span><span class="hljs-keyword">type</span> jsonRuleConfigParser <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// Parse Parse</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonRuleConfigParser)</span> <span class="hljs-title">Parse</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span></span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"implement me"</span>)&#125;<span class="hljs-comment">// ISystemConfigParser ISystemConfigParser</span><span class="hljs-keyword">type</span> ISystemConfigParser <span class="hljs-keyword">interface</span> &#123;ParseSystem(data []<span class="hljs-keyword">byte</span>)&#125;<span class="hljs-comment">// jsonSystemConfigParser jsonSystemConfigParser</span><span class="hljs-keyword">type</span> jsonSystemConfigParser <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// Parse Parse</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonSystemConfigParser)</span> <span class="hljs-title">ParseSystem</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span></span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"implement me"</span>)&#125;<span class="hljs-comment">// IConfigParserFactory 工厂方法接口</span><span class="hljs-keyword">type</span> IConfigParserFactory <span class="hljs-keyword">interface</span> &#123;CreateRuleParser() IRuleConfigParserCreateSystemParser() ISystemConfigParser&#125;<span class="hljs-keyword">type</span> jsonConfigParserFactory <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonConfigParserFactory)</span> <span class="hljs-title">CreateRuleParser</span><span class="hljs-params">()</span> <span class="hljs-title">IRuleConfigParser</span></span> &#123;<span class="hljs-keyword">return</span> jsonRuleConfigParser&#123;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j jsonConfigParserFactory)</span> <span class="hljs-title">CreateSystemParser</span><span class="hljs-params">()</span> <span class="hljs-title">ISystemConfigParser</span></span> &#123;<span class="hljs-keyword">return</span> jsonSystemConfigParser&#123;&#125;&#125;</code></pre><h4 id="单元测试-2"><a href="#单元测试-2" class="headerlink" title="单元测试"></a>单元测试</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> factory<span class="hljs-keyword">import</span> (<span class="hljs-string">"reflect"</span><span class="hljs-string">"testing"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_jsonConfigParserFactory_CreateRuleParser</span><span class="hljs-params">(t *testing.T)</span></span> &#123;tests := []<span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>want IRuleConfigParser&#125;&#123;&#123;name: <span class="hljs-string">"json"</span>,want: jsonRuleConfigParser&#123;&#125;,&#125;,&#125;<span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;j := jsonConfigParserFactory&#123;&#125;<span class="hljs-keyword">if</span> got := j.CreateRuleParser(); !reflect.DeepEqual(got, tt.want) &#123;t.Errorf(<span class="hljs-string">"CreateRuleParser() = %v, want %v"</span>, got, tt.want)&#125;&#125;)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_jsonConfigParserFactory_CreateSystemParser</span><span class="hljs-params">(t *testing.T)</span></span> &#123;tests := []<span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>want ISystemConfigParser&#125;&#123;&#123;name: <span class="hljs-string">"json"</span>,want: jsonSystemConfigParser&#123;&#125;,&#125;,&#125;<span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;j := jsonConfigParserFactory&#123;&#125;<span class="hljs-keyword">if</span> got := j.CreateSystemParser(); !reflect.DeepEqual(got, tt.want) &#123;t.Errorf(<span class="hljs-string">"CreateSystemParser() = %v, want %v"</span>, got, tt.want)&#125;&#125;)&#125;&#125;</code></pre><h3 id="DI-容器"><a href="#DI-容器" class="headerlink" title="DI 容器"></a>DI 容器</h3><p>golang 现有的依赖注入框架:</p><ul><li>使用反射实现的: <a href="https://github.com/uber-go/dig" target="_blank" rel="noopener">https://github.com/uber-go/dig</a></li><li>使用 generate 实现的: <a href="https://github.com/google/wire" target="_blank" rel="noopener">https://github.com/google/wire</a></li></ul><p>下文将通过反射实现一个类似 dig 简单的 demo，在课程里面的例子是读取配置文件，然后进行生成，下面提供是通过 provider 进行构建依赖关系。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> di<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"reflect"</span>)<span class="hljs-comment">// Container DI 容器</span><span class="hljs-keyword">type</span> Container <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// 假设一种类型只能有一个 provider 提供</span>providers <span class="hljs-keyword">map</span>[reflect.Type]provider<span class="hljs-comment">// 缓存以生成的对象</span>results <span class="hljs-keyword">map</span>[reflect.Type]reflect.Value&#125;<span class="hljs-keyword">type</span> provider <span class="hljs-keyword">struct</span> &#123;value reflect.Valueparams []reflect.Type&#125;<span class="hljs-comment">// New 创建一个容器</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span> *<span class="hljs-title">Container</span></span> &#123;<span class="hljs-keyword">return</span> &amp;Container&#123;providers: <span class="hljs-keyword">map</span>[reflect.Type]provider&#123;&#125;,results:   <span class="hljs-keyword">map</span>[reflect.Type]reflect.Value&#123;&#125;,&#125;&#125;<span class="hljs-comment">// isError 判断是否是 error 类型</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isError</span><span class="hljs-params">(t reflect.Type)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> t.Kind() != reflect.Interface &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">return</span> t.Implements(reflect.TypeOf(reflect.TypeOf((*error)(<span class="hljs-literal">nil</span>)).Elem()))&#125;<span class="hljs-comment">// Provide 对象提供者，需要传入一个对象的工厂方法，后续会用于对象的创建</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Container)</span> <span class="hljs-title">Provide</span><span class="hljs-params">(constructor <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;v := reflect.ValueOf(constructor)<span class="hljs-comment">// 仅支持函数 provider</span><span class="hljs-keyword">if</span> v.Kind() != reflect.Func &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"constructor must be a func"</span>)&#125;vt := v.Type()<span class="hljs-comment">// 获取参数</span>params := <span class="hljs-built_in">make</span>([]reflect.Type, vt.NumIn())<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; vt.NumIn(); i++ &#123;params[i] = vt.In(i)&#125;<span class="hljs-comment">// 获取返回值</span>results := <span class="hljs-built_in">make</span>([]reflect.Type, vt.NumOut())<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; vt.NumOut(); i++ &#123;results[i] = vt.Out(i)&#125;provider := provider&#123;value:  v,params: params,&#125;<span class="hljs-comment">// 保存不同类型的 provider</span><span class="hljs-keyword">for</span> _, result := <span class="hljs-keyword">range</span> results &#123;<span class="hljs-comment">// 判断返回值是不是 error</span><span class="hljs-keyword">if</span> isError(result) &#123;<span class="hljs-keyword">continue</span>&#125;<span class="hljs-keyword">if</span> _, ok := c.providers[result]; ok &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"%s had a provider"</span>, result)&#125;c.providers[result] = provider&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// Invoke 函数执行入口</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Container)</span> <span class="hljs-title">Invoke</span><span class="hljs-params">(function <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;v := reflect.ValueOf(function)<span class="hljs-comment">// 仅支持函数 provider</span><span class="hljs-keyword">if</span> v.Kind() != reflect.Func &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"constructor must be a func"</span>)&#125;vt := v.Type()<span class="hljs-comment">// 获取参数</span><span class="hljs-keyword">var</span> err errorparams := <span class="hljs-built_in">make</span>([]reflect.Value, vt.NumIn())<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; vt.NumIn(); i++ &#123;params[i], err = c.buildParam(vt.In(i))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;&#125;v.Call(params)<span class="hljs-comment">// 获取 providers</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// buildParam 构建参数</span><span class="hljs-comment">// 1. 从容器中获取 provider</span><span class="hljs-comment">// 2. 递归获取 provider 的参数值</span><span class="hljs-comment">// 3. 获取到参数之后执行函数</span><span class="hljs-comment">// 4. 将结果缓存并且返回结果</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Container)</span> <span class="hljs-title">buildParam</span><span class="hljs-params">(param reflect.Type)</span> <span class="hljs-params">(val reflect.Value, err error)</span></span> &#123;<span class="hljs-keyword">if</span> result, ok := c.results[param]; ok &#123;<span class="hljs-keyword">return</span> result, <span class="hljs-literal">nil</span>&#125;provider, ok := c.providers[param]<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span> reflect.Value&#123;&#125;, fmt.Errorf(<span class="hljs-string">"can not found provider: %s"</span>, param)&#125;params := <span class="hljs-built_in">make</span>([]reflect.Value, <span class="hljs-built_in">len</span>(provider.params))<span class="hljs-keyword">for</span> i, p := <span class="hljs-keyword">range</span> provider.params &#123;params[i], err = c.buildParam(p)&#125;results := provider.value.Call(params)<span class="hljs-keyword">for</span> _, result := <span class="hljs-keyword">range</span> results &#123;<span class="hljs-comment">// 判断是否报错</span><span class="hljs-keyword">if</span> isError(result.Type()) &amp;&amp; !result.IsNil() &#123;<span class="hljs-keyword">return</span> reflect.Value&#123;&#125;, fmt.Errorf(<span class="hljs-string">"%s call err: %+v"</span>, provider, result)&#125;<span class="hljs-keyword">if</span> !isError(result.Type()) &amp;&amp; !result.IsNil() &#123;c.results[result.Type()] = result&#125;&#125;<span class="hljs-keyword">return</span> c.results[param], <span class="hljs-literal">nil</span>&#125;</code></pre><p>我们这里的实现比较粗糙，但是作为一个 demo 理解 di 容器也足够了，和 dig 相比还缺少很多东西，并且有许多的问题，例如 依赖关系，一种类型如果有多个 provider 如何处理等等等等。<br>可以看到我们总共就三个函数</p><ul><li>Provide: 获取对象工厂，并且使用一个 map 将对象工厂保存</li><li>Invoke: 执行入口</li><li>buildParam: 核心逻辑，构建参数<ul><li>从容器中获取 provider</li><li>递归获取 provider 的参数值</li><li>获取到参数之后执行函数</li><li>将结果缓存并且返回结果</li></ul></li></ul><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span>di <span class="hljs-string">"github.com/mohuishou/go-design-pattern/02_factory/024_di"</span>)<span class="hljs-comment">// A 依赖关系 A -&gt; B -&gt; C</span><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;B *B&#125;<span class="hljs-comment">// NewA NewA</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewA</span><span class="hljs-params">(b *B)</span> *<span class="hljs-title">A</span></span> &#123;<span class="hljs-keyword">return</span> &amp;A&#123;B: b,&#125;&#125;<span class="hljs-comment">// B B</span><span class="hljs-keyword">type</span> B <span class="hljs-keyword">struct</span> &#123;C *C&#125;<span class="hljs-comment">// NewB NewB</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewB</span><span class="hljs-params">(c *C)</span> *<span class="hljs-title">B</span></span> &#123;<span class="hljs-keyword">return</span> &amp;B&#123;C: c&#125;&#125;<span class="hljs-comment">// C C</span><span class="hljs-keyword">type</span> C <span class="hljs-keyword">struct</span> &#123;Num <span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">// NewC NewC</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewC</span><span class="hljs-params">()</span> *<span class="hljs-title">C</span></span> &#123;<span class="hljs-keyword">return</span> &amp;C&#123;Num: <span class="hljs-number">1</span>,&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;container := di.New()<span class="hljs-keyword">if</span> err := container.Provide(NewA); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;<span class="hljs-keyword">if</span> err := container.Provide(NewB); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;<span class="hljs-keyword">if</span> err := container.Provide(NewC); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;err := container.Invoke(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a *A)</span></span> &#123;fmt.Printf(<span class="hljs-string">"%+v: %d"</span>, a, a.B.C.Num)&#125;)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记-让你最快速地改善代码质量的20条编程规范</title>
    <link href="/post/fe1ma9.html"/>
    <url>/post/fe1ma9.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含 23 种常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/188622" target="_blank" rel="noopener">31 | 理论五：让你最快速地改善代码质量的 20 条编程规范（上）</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li></ul><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ul><li>命名的关键是能<strong>准确达意</strong>。对于不同作用域的命名，我们可以适当地选择不同的长度。</li><li>我们<strong>可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名</strong>。</li><li><strong>命名要可读、可搜索</strong>。不要使用生僻的、不好读的英文单词来命名。命名要符合项目的统一规范，也不要用些反直觉的命名。</li><li><strong>接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”</strong>。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li><strong>注释的内容主要包含这样三个方面：做什么、为什么、怎么做</strong>。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</li><li><strong>类和函数一定要写注释，而且要写得尽可能全面详细</strong>。<strong>函数内部的注释要相对少一些</strong>，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。</li></ul><h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><ul><li>函数、类多大才合适？<strong>函数的代码行数不要超过一屏幕的大小，比如 50 行</strong>。类的大小限制比较难确定。</li><li><strong>一行代码多长最合适？最好不要超过 IDE 的显示宽度</strong>。当然，也不能太小，否则会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</li><li><strong>善用空行分割单元块</strong>。对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。</li><li>四格缩进还是两格缩进？我个人比较推荐使用两格缩进，这样可以节省空间，尤其是在代码嵌套层次比较深的情况下。不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进。<em>(PS: Golang 没有这个问题，默认使用 Tab 缩进)</em></li><li>大括号是否要另起一行？将大括号放到跟上一条语句同一行，可以节省代码行数。但是将大括号另起新的一行的方式，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。<em>(PS: Golang 没有这个问题）</em></li><li>类中成员怎么排列？在 Google Java 编程规范中，<strong>依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列</strong>。</li></ul><h3 id="编码技巧"><a href="#编码技巧" class="headerlink" title="编码技巧"></a>编码技巧</h3><ul><li><strong>将复杂的逻辑提炼拆分成函数和类。</strong></li><li><strong>通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况</strong>。</li><li><strong>函数中不要使用参数来做代码执行逻辑的控制</strong>。</li><li><strong>函数设计要职责单一</strong>。</li><li><strong>移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数</strong>。</li><li>用字面常量取代魔法数。</li><li>用解释性变量来解释复杂表达式，以此提高代码可读性。</li></ul><h3 id="统一编码规范"><a href="#统一编码规范" class="headerlink" title="统一编码规范"></a>统一编码规范</h3><ul><li>除了这三节讲到的比较细节的知识点之外，最后，<strong>还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范</strong>，并且通过 Code Review 督促执行，这对提高代码质量有立竿见影的效果。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码规范很多情况下都是见仁见智的看法，我认为最主要的是统一，个人风格要统一，团队风格也需要统一，然后依靠工具进行管理。我常用的 Golang 代码风格工具：</p><ul><li>format: <a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">https://godoc.org/golang.org/x/tools/cmd/goimports</a></li><li>lint: <a href="https://github.com/golang/lint" target="_blank" rel="noopener">https://github.com/golang/lint</a></li><li><strong>ci:</strong> <a href="https://golangci-lint.run/" target="_blank" rel="noopener">https://golangci-lint.run/</a> 这个支持多个静态扫描工具，上面两种也是支持的，不在 ide 直接使用的主要原因是，插件开启较多的时候会比较慢，不太适合随时运行，但是 ci 上是需要的</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="golangci-lint-gitlab-ci-yml-配置"><a href="#golangci-lint-gitlab-ci-yml-配置" class="headerlink" title="golangci-lint .gitlab-ci.yml 配置"></a>golangci-lint .gitlab-ci.yml 配置</h3><pre><code class="hljs yaml"><span class="hljs-attr">lint:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">lint</span>  <span class="hljs-attr">image:</span> <span class="hljs-string">$CI_REGISTRY/library/golangci-lint:v1.27-alpine</span>  <span class="hljs-attr">script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">golangci-lint</span> <span class="hljs-string">run</span> <span class="hljs-string">./...</span>  <span class="hljs-attr">retry:</span>    <span class="hljs-attr">max:</span> <span class="hljs-number">1</span>    <span class="hljs-attr">when:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">runner_system_failure</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">stuck_or_timeout_failure</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">job_execution_timeout</span>  <span class="hljs-attr">tags:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">test</span></code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计模式01-单例模式</title>
    <link href="/post/singleton.html"/>
    <url>/post/singleton.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含 23 种常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">极客时间-设计模式之美</a> 的笔记，源课程采用 Java 实现，本系列会采用 Go 实现</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/194035" target="_blank" rel="noopener">41 | 单例模式（上为什么说支持懒加载的双重检测不比饿汉式更优？</a></li><li><strong>本文代码仓库: <a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener">https://github.com/mohuishou/go-design-pattern</a> </strong>🌟🌟🌟🌟🌟</li><li><strong>RoadMap: 01/22 </strong>持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li><li><strong>获取更新: </strong><a href="https://github.com/mohuishou/go-design-pattern" target="_blank" rel="noopener"><strong>Github</strong></a><strong>、</strong><a href="https://zhuanlan.zhihu.com/mohuishou" target="_blank" rel="noopener"><strong>知乎</strong></a><strong>、</strong><a href="https://lailin.xyz/atom.xml"><strong>RSS</strong></a><strong>、</strong><a href="https://toutiao.io/subjects/387401?f=new" target="_blank" rel="noopener"><strong>开发者头条</strong></a></li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><img src="https://lailin.xyz/images/1602256371513-0bcda0e2-68ed-4530-98fd-ecb97bd7f193.png" srcset="/img/loading.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>单例模式采用了 饿汉式 和 懒汉式 两种实现，个人其实更倾向于饿汉式的实现，简单，并且可以将问题及早暴露，懒汉式虽然支持延迟加载，但是这只是把冷启动时间放到了第一次使用的时候，并没有本质上解决问题，并且为了实现懒汉式还不可避免的需要加锁。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>代码实现:</strong></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<span class="hljs-comment">// Singleton 饿汉式单例</span><span class="hljs-keyword">type</span> Singleton <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-keyword">var</span> singleton *Singleton<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;singleton = &amp;Singleton&#123;&#125;&#125;<span class="hljs-comment">// GetInstance 获取实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> *<span class="hljs-title">Singleton</span></span> &#123;<span class="hljs-keyword">return</span> singleton&#125;</code></pre><p><strong>单元测试:</strong></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton_test<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span>singleton <span class="hljs-string">"github.com/mohuishou/go-design-pattern/01_singleton"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetInstance</span><span class="hljs-params">(t *testing.T)</span></span> &#123;assert.Equal(t, singleton.GetInstance(), singleton.GetInstance())&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkGetInstanceParallel</span><span class="hljs-params">(b *testing.B)</span></span> &#123;b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> &#123;<span class="hljs-keyword">for</span> pb.Next() &#123;<span class="hljs-keyword">if</span> singleton.GetInstance() != singleton.GetInstance() &#123;b.Errorf(<span class="hljs-string">"test fail"</span>)&#125;&#125;&#125;)&#125;</code></pre><h3 id="懒汉式（双重检测）"><a href="#懒汉式（双重检测）" class="headerlink" title="懒汉式（双重检测）"></a>懒汉式（双重检测）</h3><p><strong>代码实现:</strong></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<span class="hljs-keyword">import</span> <span class="hljs-string">"sync"</span><span class="hljs-keyword">var</span> (lazySingleton *Singletononce          = &amp;sync.Once&#123;&#125;)<span class="hljs-comment">// GetLazyInstance 懒汉式</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetLazyInstance</span><span class="hljs-params">()</span> *<span class="hljs-title">Singleton</span></span> &#123;<span class="hljs-keyword">if</span> lazySingleton == <span class="hljs-literal">nil</span> &#123;once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;lazySingleton = &amp;Singleton&#123;&#125;&#125;)&#125;<span class="hljs-keyword">return</span> lazySingleton&#125;</code></pre><p><strong>单元测试:</strong></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton_test<span class="hljs-keyword">import</span> (<span class="hljs-string">"testing"</span>singleton <span class="hljs-string">"github.com/mohuishou/go-design-pattern/01_singleton"</span><span class="hljs-string">"github.com/stretchr/testify/assert"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetLazyInstance</span><span class="hljs-params">(t *testing.T)</span></span> &#123;assert.Equal(t, singleton.GetLazyInstance(), singleton.GetLazyInstance())&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkGetLazyInstanceParallel</span><span class="hljs-params">(b *testing.B)</span></span> &#123;b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> &#123;<span class="hljs-keyword">for</span> pb.Next() &#123;<span class="hljs-keyword">if</span> singleton.GetLazyInstance() != singleton.GetLazyInstance() &#123;b.Errorf(<span class="hljs-string">"test fail"</span>)&#125;&#125;&#125;)&#125;</code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><blockquote><p>感谢 <a href="https://github.com/scuplus/blogComment/issues/231#issuecomment-706009469" target="_blank" rel="noopener">@lixianyang</a> 的指正</p></blockquote><p>可以看到直接 init 获取的性能要好一些</p><pre><code class="hljs bash">▶ C:\Users\laili\sdk\go1.15\bin\go.exe <span class="hljs-built_in">test</span> -benchmem -bench=<span class="hljs-string">"."</span> -v=== RUN   TestGetLazyInstance--- PASS: TestGetLazyInstance (0.00s)=== RUN   TestGetInstance--- PASS: TestGetInstance (0.00s)goos: windowsgoarch: amd64pkg: github.com/mohuishou/go-design-pattern/01_singletonBenchmarkGetLazyInstanceParallelBenchmarkGetLazyInstanceParallel-4      535702941                2.24 ns/op           0 B/op      0 allocs/opBenchmarkGetInstanceParallelBenchmarkGetInstanceParallel-4          1000000000               0.586 ns/op          0 B/op      0 allocs/opPASSok      github.com/mohuishou/go-design-pattern/01_singleton     3.161s</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一点拙见-如何写好一个技术预研报告?</title>
    <link href="/post/how-to-write-a-pre-research-report.html"/>
    <url>/post/how-to-write-a-pre-research-report.html</url>
    
    <content type="html"><![CDATA[<p>最近做了一些预研的工作，主要是一些技术调研，报告呈现的过程当中收到了许多建设性的建议，同时包含一点自己的拙见，如果能给你带来一些思考，那最好不过。</p><h2 id="明确面向对象"><a href="#明确面向对象" class="headerlink" title="明确面向对象"></a>明确面向对象</h2><p>一篇好的文章，一份好的报告一定要考虑一下的你面向对象，如何能够让他可以随着你的思路快速简要的理解你想要传达的内容。那么，技术预研报告一般是给谁看的呢？请注意，我们这里说的报告是<strong>内部的调研报告</strong>，而不是例如一些专门做咨询的公司，提供给外部公司购买使用。这种报告的面向对象一般而言是你的上级，或者是上上级，或者是更高层级的领导。<br>这个时候分为两种情况，他懂技术，但是可能不了解细节，需要一些数据帮助他做决策，还有一种是他没有太多的技术背景，不是特别了解。</p><ul><li>如果是不太了解技术的领导，要注意不能用过多的专业术语，在报告里面可以适当的添加一些说明，类比辅助理解，这个篇幅需要注意，也不能过长。</li><li>如果是比较了解的，可以更多的从技术方面进行分析，可以添加一些技术指标的对比。对于技术预研这种情况，一般还是这种情况居多。</li></ul><p>接下来我就会从技术预研报告的一个最基础的模板说明每个部分需要有哪些内容，这个不是标准答案，这是我认为的一个报告当中必要的一些元素。</p><h2 id="预研报告模板"><a href="#预研报告模板" class="headerlink" title="预研报告模板"></a>预研报告模板</h2><h3 id="理清现状"><a href="#理清现状" class="headerlink" title="理清现状"></a>理清现状</h3><p>技术预研一般是用来解决当下我们需要解决的一些问题的，可能这些问题用已有的系统或者技术暂时无法解决，或者是解决方法不够优雅，不够简洁等等。所以首先我们需要的是从现状出发，理清需求找准目标。问题来了怎么描述现状呢？我们先来看一个例子<em>（注意本文所有示例数据均来源于虚构）</em>:</p><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子:"></a>一个例子:</h4><ul><li><strong>反面教材: </strong>集群内应用的资源设置不合理</li><li><strong>正面教材: </strong>最近一个月某区域集群节点 NotReady 告警次数超过 200 次，导致 30 多个应用 POD 漂移。其原因是由于应用超配比例过高，配置不合理<ul><li>数据说话: 最近一个月某区域集群节点 NotReady 告警次数超过 200 次</li><li>影响范围: 导致 30 多个应用 POD 漂移</li><li>原因: 应用超配比例过高，配置不合理</li></ul></li></ul><p>上面这个示例是一个最常见的错误案例，在现状分析当中，经常<strong>喜欢直接说问题的原因，不说这个问题导致的现象，以及影响范围。</strong>我们需要明白查看我们调研报告的观看对象是谁？往往是我们的上级或者是上上级领导，他们管理的产品比较多，不一定能够理解到十分细节。所以我们要<strong>从场景触发，首先降低沟通成本，罗列历史数据，增强说服力的同时可以帮助他们了解当前产品的现状。</strong></p><h4 id="如何说明现状"><a href="#如何说明现状" class="headerlink" title="如何说明现状?"></a>如何说明现状?</h4><ul><li>从实际的场景出发，简明扼要的说明曾今出现过或者当前存在着的问题</li><li>用数据说话，统计历史数据，包含但不限于，影响范围，出现的次数，反馈用户人次等等</li></ul><h3 id="畅想未来"><a href="#畅想未来" class="headerlink" title="畅想未来"></a>畅想未来</h3><p>了解了现状之后，我们需要有一个心理预期的结果，我们期望理想状态下，能够达到什么程度，这一部分可以脑洞大一些，期望高一点，不要局限在眼前。</p><h4 id="一个例子-1"><a href="#一个例子-1" class="headerlink" title="一个例子"></a>一个例子</h4><ul><li><strong>反面教材: </strong>集群内应用随意漂移，可以减少集群中节点故障次数</li><li><strong>正面教材: </strong>为业务应用提供安全、可靠、稳定、舒心的服务，业务高峰时资源及时扩容，洪峰来临时，优先确保核心应用稳定，力争做到让开发早下班，运维不加班，周末无告警，假期无负担。</li></ul><p>这两个例子里面，反面教材太过于务实了，这个只能说是居于现状的改进，不能说是对未来场景的想象，另一个是一个常见的场景加上一些形而上的想象。</p><h4 id="如何畅享未来？"><a href="#如何畅享未来？" class="headerlink" title="如何畅享未来？"></a>如何畅享未来？</h4><ul><li>从场景出发，描绘理想状态下可以达到的状态</li><li>结合现状，切忌跑题，这是展望未来的时候，我最容易犯的一个错误，共勉。</li></ul><h3 id="行业实践"><a href="#行业实践" class="headerlink" title="行业实践"></a>行业实践</h3><p>站在巨人的肩膀上可以让我们看的更远，绝大部分的情况下调研时候的需求都会有一些业界的实践案例，甚至有一些开源的社区方案，例如 Google、亚马逊、阿里、腾讯等，这是说他们的方案是否适合我们，能否落地。<br>对于行业的实践这一块的内容，建议<strong>采用表格的方式进行对比</strong>，如果可以的话还可以做一些<strong>现场演示</strong>，或者是<strong>录制视频。</strong></p><table><thead><tr><th>维度</th><th>现状</th><th>方案 A</th><th>方案 B</th><th>方案 C</th></tr></thead><tbody><tr><td>维度 1</td><td>现状 1</td><td>❌ 方案 A</td><td>方案 B</td><td>✅ 方案 C</td></tr><tr><td>维度 2</td><td>现状 1</td><td>✅ 方案 A</td><td>❌ 方案 B</td><td>方案 C</td></tr></tbody></table><p>如上表所示，就是一个十分常见的一个对比表格，这里需要注意的是，一定<strong>不要忘记我们当前的现状是什么</strong>，最后可以有一个总结，说明不同方案的优劣之处，如果采用某个方案，后续是否需要更加深入的调研等等。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>调研一定要有结论!</strong><br>这里结论不是决策，也不是一定是方案，由于时间、精力以及了解到的信息等等限制，可能导致我们当下是无法得出一个决策，是否采用某个方案，但是一定要有结论，这个结论，既可以是一个方向上的建议，也可以是需要继续深入调研。切记不能仅为了调研而调研。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>“没有反思和进步的人生不值得一过”，最近挺喜欢这句 Slogan，我觉得反思和总结可以进步更快，我的一点拙见或许由于我的视野原因，会比较狭隘，但是如果你如果看了这篇文章能有一些思考，无论认同与否，那都很值得。</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/22757.html">2018年的一些小目标</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>反思</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</title>
    <link href="/post/auxvv1.html"/>
    <url>/post/auxvv1.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在更新内部的工具库的时候发现，工具仓库中其实包含了很多的模块，但是现在的版本发布都是合并在在一起发的，为了管理更加细致和直观，所以想要在一个仓库中实现实现多个模块的发布。<a id="more"></a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>单个仓库中包含多个 go module 模块</li><li>版本发布可以根据模块来发版，而不是整个仓库进行发版</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="仓库结构"><a href="#仓库结构" class="headerlink" title="仓库结构"></a>仓库结构</h3><p>假设我们现在有一个仓库 <code>github.com/mohuishou/go-test-multi-module</code> 目录结构如下图所示</p><pre><code class="hljs bash">.├── a│   ├── a.go│   └── go.mod└── b    ├── b.go    └── go.mod</code></pre><p>其中 <code>a/go.mod</code> 使用如下命令生成</p><pre><code class="hljs bash">go mod init github.com/mohuishou/go-test-multi-module/a</code></pre><h3 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h3><p>对模块进行发版时，只需打上 <code>[模块名]/版本号</code> 即可<br>以我们的示例为例，对模块 <code>a</code> 进行发版时我们只需要打上 tag <code>a/v1.0.0</code> ，同理对模块 b 进行发版时，需要打上 tag <code>b/v1.0.0</code> 即可</p><h3 id="用户使用"><a href="#用户使用" class="headerlink" title="用户使用"></a>用户使用</h3><p>用户在安装的时候只需要和普通模块一样执行命令即可</p><pre><code class="hljs bash">go get -u github.com/mohuishou/go-test-multi-module/a</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般情况下不推荐采用这种方式，还是一个仓库一个模块比较好，便于管理，但是对于一些工具库里面包含了较多的工具，想要不同类型单独发版也可以采用本文提到的方式</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/mohuishou/go-test-multi-module" target="_blank" rel="noopener">本文的示例仓库</a></li><li><a href="https://github.com/golang/tools/releases" target="_blank" rel="noopener">golang/tools</a> [官方的 gopls 也是这么发布版本的]</li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li><li><a href="https://lailin.xyz/post/38237.html">Go Web 小技巧（一）简化Gin接口代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>小技巧</tag>
      
      <tag>go mod</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Web 小技巧（三）Gin 参数绑定</title>
    <link href="/post/11996.html"/>
    <url>/post/11996.html</url>
    
    <content type="html"><![CDATA[<h2 id="楔-xie-子"><a href="#楔-xie-子" class="headerlink" title="楔(xiē)子"></a>楔(xiē)子</h2><p>在第一篇文章 <a href="https://lailin.xyz/post/38237.html">简化 Gin 接口代码</a> 当中为大家提供了一种抽象 <code>gin</code> 接口代码的思路，而这篇文章会为大家带来参数绑定的一些技巧。</p><p>在我们写的绝大部分的 API 代码当中，其实都是需要传递参数的，无论是通过 <code>path</code>、<code>query string</code> 还是 <code>body</code>，在 <code>gin</code> 当中，为我们提供了一系列的 <code>binding</code> 方法让我们可以把这些参数绑定到一个对象中，通过还可以通过 <code>struct tag</code> 来对参数进行校验，不知道到大家曾今是否和遇到过相同的困惑：</p><ul><li>我创建/更新接口有时候就仅仅只相差一个 id，我是不是可以复用代码？</li><li>是否可以直接用 model 层的 struct 绑定参数？</li></ul><p>接下来本文就从这些问题出发，利用 go 的组合特点，介绍一些参数绑定上的小技巧</p><a id="more"></a><h2 id="参数绑定技巧"><a href="#参数绑定技巧" class="headerlink" title="参数绑定技巧"></a>参数绑定技巧</h2><h3 id="1-复用创建-更新时的参数"><a href="#1-复用创建-更新时的参数" class="headerlink" title="1. 复用创建/更新时的参数"></a>1. 复用创建/更新时的参数</h3><pre><code class="hljs go"><span class="hljs-comment">// UserParams 用户参数</span><span class="hljs-keyword">type</span> UserParams <span class="hljs-keyword">struct</span> &#123;Name     <span class="hljs-keyword">string</span> <span class="hljs-string">`json:"name" binding:"required"`</span>Password <span class="hljs-keyword">string</span> <span class="hljs-string">`json:"password" binding:"required"`</span>&#125;<span class="hljs-comment">// CreateUserParams 创建用户</span><span class="hljs-keyword">type</span> CreateUserParams <span class="hljs-keyword">struct</span> &#123;UserParams&#125;<span class="hljs-comment">// UpdateUserParams 更新用户</span><span class="hljs-keyword">type</span> UpdateUserParams <span class="hljs-keyword">struct</span> &#123;UserParamsID <span class="hljs-keyword">uint</span> <span class="hljs-string">`json:"id" binding:"required"`</span>&#125;</code></pre><h3 id="2-用-model-层的-struct-绑定参数"><a href="#2-用-model-层的-struct-绑定参数" class="headerlink" title="2. 用 model 层的 struct 绑定参数"></a>2. 用 model 层的 struct 绑定参数</h3><p>如果我们在参数绑定的时候，向上面那样，每个参数单独创建一个绑定，这样在 Model 层创建数据库记录的时候就需要去手动的转换一道了，如果每个都需要这么写，会感觉很麻烦。</p><p>这是原本的 <code>user</code> 表</p><pre><code class="hljs go"><span class="hljs-comment">// model/model.go</span><span class="hljs-comment">// Model default model</span><span class="hljs-keyword">type</span> Model <span class="hljs-keyword">struct</span> &#123;ID        <span class="hljs-keyword">uint</span>       <span class="hljs-string">`json:"id" gorm:"primary_key"`</span>CreatedAt time.Time  <span class="hljs-string">`json:"created_at"`</span>UpdatedAt time.Time  <span class="hljs-string">`json:"updated_at"`</span>DeletedAt *time.Time <span class="hljs-string">`json:"deleted_at" sql:"index"`</span>&#125;<span class="hljs-comment">// model/user.go</span><span class="hljs-comment">// User 用户表</span><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;    ModelName     <span class="hljs-keyword">string</span> <span class="hljs-string">`json:"name"`</span>Password <span class="hljs-keyword">string</span> <span class="hljs-string">`json:"password"`</span>&#125;</code></pre><p>这时我们可以稍微改造一下, 利用 <code>binding:&quot;-&quot;</code> 忽略字段的功能，和 <code>struct</code> 组合，将 api 的参数和 model 关联在一起，减少一些结构体转换的代码</p><pre><code class="hljs go"><span class="hljs-comment">// model/model.go</span><span class="hljs-comment">// Model default model</span><span class="hljs-keyword">type</span> Model <span class="hljs-keyword">struct</span> &#123;    ID        <span class="hljs-keyword">uint</span>       <span class="hljs-string">`json:"id" gorm:"primary_key"`</span>CreatedAt time.Time  <span class="hljs-string">`json:"created_at" binding:"-"`</span>UpdatedAt time.Time  <span class="hljs-string">`json:"updated_at" binding:"-"`</span>DeletedAt *time.Time <span class="hljs-string">`json:"deleted_at" sql:"index" binding:"-"`</span>&#125;<span class="hljs-comment">// model/user.go</span><span class="hljs-comment">// User 用户表</span><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;    ModelName     <span class="hljs-keyword">string</span> <span class="hljs-string">`json:"name" binding:"required"`</span>Password <span class="hljs-keyword">string</span> <span class="hljs-string">`json:"password" binding:"required"`</span>&#125;<span class="hljs-comment">// api/user.go</span><span class="hljs-comment">// UserParams 用户参数</span><span class="hljs-keyword">type</span> UserParams <span class="hljs-keyword">struct</span> &#123;    model.User&#125;<span class="hljs-comment">// CreateUserParams 创建用户</span><span class="hljs-keyword">type</span> CreateUserParams <span class="hljs-keyword">struct</span> &#123;UserParams    ID    <span class="hljs-keyword">uint</span>    <span class="hljs-string">`json:"id" gorm:"primary_key" binding:"-"`</span>&#125;<span class="hljs-comment">// UpdateUserParams 更新用户</span><span class="hljs-keyword">type</span> UpdateUserParams <span class="hljs-keyword">struct</span> &#123;UserParams&#125;</code></pre><h3 id="3-使用-ShouldBind-而不是-Bind"><a href="#3-使用-ShouldBind-而不是-Bind" class="headerlink" title="3. 使用 ShouldBind 而不是 Bind"></a>3. 使用 <code>ShouldBind</code> 而不是 <code>Bind</code></h3><p><code>Bind</code> 方法会自动将 http status 设置为 400, 然后报错，但是我们往往会需要携带更多的信息返回，或者返回不同的 <code>status</code> 这时候往往会出现下面这样的警告，而使用 <code>ShouldBind</code> 可以避免此类问题</p><pre><code class="hljs bash">[WARNING] Headers were already written. Wanted to override status code 400 with 200</code></pre><h3 id="4-多次绑定-request-body-数据"><a href="#4-多次绑定-request-body-数据" class="headerlink" title="4. 多次绑定 request body 数据"></a>4. 多次绑定 request body 数据</h3><p>这是官方文档的一个示例，一般情况第二次读取 request body 的数据就会出现 EOF 的错误，因为 <code>c.Request.Body</code> 不可以重用</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> formA <span class="hljs-keyword">struct</span> &#123;  Foo <span class="hljs-keyword">string</span> <span class="hljs-string">`json:"foo" binding:"required"`</span>&#125;<span class="hljs-keyword">type</span> formB <span class="hljs-keyword">struct</span> &#123;  Bar <span class="hljs-keyword">string</span> <span class="hljs-string">`json:"bar" binding:"required"`</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SomeHandler</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;  objA := formA&#123;&#125;  objB := formB&#123;&#125;  <span class="hljs-comment">// c.ShouldBind 使用了 c.Request.Body，不可重用。</span>  <span class="hljs-keyword">if</span> errA := c.ShouldBind(&amp;objA); errA == <span class="hljs-literal">nil</span> &#123;    c.String(http.StatusOK, <span class="hljs-string">`the body should be formA`</span>)  <span class="hljs-comment">// 因为现在 c.Request.Body 是 EOF，所以这里会报错。</span>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> errB := c.ShouldBind(&amp;objB); errB == <span class="hljs-literal">nil</span> &#123;    c.String(http.StatusOK, <span class="hljs-string">`the body should be formB`</span>)  &#125; <span class="hljs-keyword">else</span> &#123;    ...  &#125;&#125;</code></pre><p>gin 1.4 之后官方提供了一个 <code>ShouldBindBodyWith</code> 的方法，可以支持重复绑定，原理就是将 body 的数据缓存了下来，但是二次取数据的时候还是得用 <code>ShouldBindBodyWith</code> 才行，直接用 <code>ShouldBind</code> 还是会报错的。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SomeHandler</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;  objA := formA&#123;&#125;  objB := formB&#123;&#125;  <span class="hljs-comment">// 读取 c.Request.Body 并将结果存入上下文。</span>  <span class="hljs-keyword">if</span> errA := c.ShouldBindBodyWith(&amp;objA, binding.JSON); errA == <span class="hljs-literal">nil</span> &#123;    c.String(http.StatusOK, <span class="hljs-string">`the body should be formA`</span>)  <span class="hljs-comment">// 这时, 复用存储在上下文中的 body。</span>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> errB := c.ShouldBindBodyWith(&amp;objB, binding.JSON); errB == <span class="hljs-literal">nil</span> &#123;    c.String(http.StatusOK, <span class="hljs-string">`the body should be formB JSON`</span>)  <span class="hljs-comment">// 可以接受其他格式</span>  &#125; <span class="hljs-keyword">else</span> &#123;    ...  &#125;&#125;</code></pre><p>这种方式其实有个问题，什么情况下我们会去多次读取 <code>body</code> 的数据，其实在中间件中我们是需要用到，有的中间件需要读取参数做一些处理，例如权限中间件需要获取当前资源的 id，判断当前用户是否有权限，如果这个时候直接使用 <code>ShouldBindBodyWith</code> 会导致之后的所有的接口都修改才行，十分的不优雅，下面提供一种不用影响后续使用的方法</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startPage</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<span class="hljs-keyword">var</span> (p1 Personp2 Person)buf := &amp;bytes.Buffer&#123;&#125;tea := io.TeeReader(c.Request.Body, buf)body, err := ioutil.ReadAll(tea)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Panicf(<span class="hljs-string">"read body err: %+v"</span>, err)&#125;c.Request.Body = ioutil.NopCloser(buf)<span class="hljs-comment">// read buf ...</span><span class="hljs-keyword">if</span> err := binding.JSON.BindBody(body, &amp;p1); err != <span class="hljs-literal">nil</span> &#123;log.Panic(<span class="hljs-string">"p1"</span>, err)&#125;log.Println(<span class="hljs-string">"p1"</span>, p1)<span class="hljs-comment">// use ShouldBind again ..</span><span class="hljs-keyword">if</span> err := c.ShouldBind(&amp;p2); err != <span class="hljs-literal">nil</span> &#123;log.Panic(<span class="hljs-string">"p2"</span>, err)&#125;log.Println(<span class="hljs-string">"p2"</span>, p2)c.String(<span class="hljs-number">200</span>, <span class="hljs-string">"Success"</span>)&#125;<span class="hljs-comment">// output</span><span class="hljs-comment">// 2019/11/06 23:10:04 p1 &#123;hello world&#125;</span><span class="hljs-comment">// 2019/11/06 23:10:04 p2 &#123;hello world&#125;</span><span class="hljs-comment">// [GIN] 2019/11/06 - 23:10:04 | 200 |   27.0400917s |             ::1 | POST     /testing</span></code></pre><p>这三行也适用于其他需要多次读取 <code>io.Reader</code> 的情况</p><pre><code class="hljs go">buf := &amp;bytes.Buffer&#123;&#125;tea := io.TeeReader(c.Request.Body, buf)body, err := ioutil.ReadAll(tea)</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章从参数绑定的问题出发，为大家介绍了两种组合参数的小技巧，提供了使用参数绑定的时候的一个建议，并且提出了非官方，侵入性小的的多次读取 request body 的方式。</p><p>下一篇文章给大家介绍 gorm 事务的一些小技巧</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://gin-gonic.com/zh-cn/" target="_blank" rel="noopener">gin 官方文档</a></p></li><li><p><a href="https://stackoverflow.com/questions/39791021/how-to-read-multiple-times-from-same-io-reader" target="_blank" rel="noopener">How to read multiple times from same io.Reader</a></p></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li><li><a href="https://lailin.xyz/post/38237.html">Go Web 小技巧（一）简化Gin接口代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>小技巧</tag>
      
      <tag>api</tag>
      
      <tag>gin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Web 小技巧（二）GORM 使用自定义类型</title>
    <link href="/post/17394.html"/>
    <url>/post/17394.html</url>
    
    <content type="html"><![CDATA[<p>不知道大家在使用 Gorm 的时候，是否有遇到过复杂类型 ( map, struct…) 如何映射到数据库的字段上的问题？</p><p>本文分别介绍通过实现通用接口和 Hook 的方式绑定复杂的数据类型。</p><a id="more"></a><h2 id="一、GORM-模型定义"><a href="#一、GORM-模型定义" class="headerlink" title="一、GORM 模型定义"></a>一、GORM 模型定义</h2><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;  gorm.Model  Name         <span class="hljs-keyword">string</span>  Age          sql.NullInt64  Birthday     *time.Time  Email        <span class="hljs-keyword">string</span>  <span class="hljs-string">`gorm:"type:varchar(100);unique_index"`</span>  Role         <span class="hljs-keyword">string</span>  <span class="hljs-string">`gorm:"size:255"`</span> <span class="hljs-comment">// 设置字段大小为255</span>  MemberNumber *<span class="hljs-keyword">string</span> <span class="hljs-string">`gorm:"unique;not null"`</span> <span class="hljs-comment">// 设置会员号（member number）唯一并且不为空</span>  Num          <span class="hljs-keyword">int</span>     <span class="hljs-string">`gorm:"AUTO_INCREMENT"`</span> <span class="hljs-comment">// 设置 num 为自增类型</span>  Address      <span class="hljs-keyword">string</span>  <span class="hljs-string">`gorm:"index:addr"`</span> <span class="hljs-comment">// 给address字段创建名为addr的索引</span>  IgnoreMe     <span class="hljs-keyword">int</span>     <span class="hljs-string">`gorm:"-"`</span> <span class="hljs-comment">// 忽略本字段</span>&#125;</code></pre><p>这是 GORM 官方文档当中模型定义的一个例子，但是我们在实际使用过程当中往往会遇到需要复杂类型例如 <code>map</code> 或者是一些自定义的类型进行绑定。</p><p>我们在文档的描述当中可以看到这么一段话：</p><blockquote><p>模型（Models）通常只是正常的 golang structs、基本的 go 类型或它们的指针。 同时也支持<a href="https://golang.org/pkg/database/sql/#Scanner" target="_blank" rel="noopener"><code>sql.Scanner</code></a>及<a href="https://golang.org/pkg/database/sql/driver/#Valuer" target="_blank" rel="noopener"><code>driver.Valuer</code></a> 接口（interfaces）。</p></blockquote><p>自已的数据类型只需要实现这两个接口就可以实现数据绑定了，文档只有一句话我们看看具体怎么做。</p><h2 id="二、通过实现-sql-Scanner-driver-Valuer-接口实现数据绑定"><a href="#二、通过实现-sql-Scanner-driver-Valuer-接口实现数据绑定" class="headerlink" title="二、通过实现 sql.Scanner,driver.Valuer 接口实现数据绑定"></a>二、通过实现 <code>sql.Scanner,driver.Valuer</code> 接口实现数据绑定</h2><h3 id="2-1-接口文档"><a href="#2-1-接口文档" class="headerlink" title="2.1 接口文档"></a>2.1 接口文档</h3><pre><code class="hljs go"><span class="hljs-comment">// sql.Scanner</span><span class="hljs-keyword">type</span> Scanner <span class="hljs-keyword">interface</span> &#123;    <span class="hljs-comment">// Scan assigns a value from a database driver.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// The src value will be of one of the following types:</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">//    int64</span>    <span class="hljs-comment">//    float64</span>    <span class="hljs-comment">//    bool</span>    <span class="hljs-comment">//    []byte</span>    <span class="hljs-comment">//    string</span>    <span class="hljs-comment">//    time.Time</span>    <span class="hljs-comment">//    nil - for NULL values</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// An error should be returned if the value cannot be stored</span>    <span class="hljs-comment">// without loss of information.</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Reference types such as []byte are only valid until the next call to Scan</span>    <span class="hljs-comment">// and should not be retained. Their underlying memory is owned by the driver.</span>    <span class="hljs-comment">// If retention is necessary, copy their values before the next call to Scan.</span>    Scan(src <span class="hljs-keyword">interface</span>&#123;&#125;) error&#125;<span class="hljs-comment">// driver.Valuer</span><span class="hljs-keyword">type</span> Valuer <span class="hljs-keyword">interface</span> &#123;    <span class="hljs-comment">// Value returns a driver Value.</span>    <span class="hljs-comment">// Value must not panic.</span>    Value() (Value, error)&#125;</code></pre><p>我们可以发现 <code>Valuer</code> 用于保存数据的时候，<code>Scaner</code> 用于数据从数据库映射到 model 的时候</p><h3 id="2-2-实现接口"><a href="#2-2-实现接口" class="headerlink" title="2.2 实现接口"></a>2.2 实现接口</h3><p>下面我们来一个实际的例子</p><pre><code class="hljs go"><span class="hljs-comment">// Args 参数</span><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span><span class="hljs-comment">// Scan Scanner</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(args Args)</span> <span class="hljs-title">Scan</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> value == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;b, ok := value.([]<span class="hljs-keyword">byte</span>)<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"value is not []byte, value: %v"</span>, value)&#125;<span class="hljs-keyword">return</span> json.Unmarshal(b, &amp;args)&#125;<span class="hljs-comment">// Value Valuer</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(args Args)</span> <span class="hljs-title">Value</span><span class="hljs-params">()</span> <span class="hljs-params">(driver.Value, error)</span></span> &#123;<span class="hljs-keyword">if</span> args == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> json.Marshal(args)&#125;</code></pre><p>在使用的时候我们只要再加上一个数据类型就 OK 了</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Data <span class="hljs-keyword">struct</span> &#123;  Args Args <span class="hljs-string">`json:"args" gorm:"type:text"`</span>&#125;</code></pre><h3 id="2-3-抽象通用工具函数"><a href="#2-3-抽象通用工具函数" class="headerlink" title="2.3 抽象通用工具函数"></a>2.3 抽象通用工具函数</h3><p>在实际的使用中我们可能会有许多的类型的需要这样存储，所以我们直接抽象一个公用的工具函数</p><pre><code class="hljs go"><span class="hljs-comment">// scan for scanner helper</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scan</span><span class="hljs-params">(data <span class="hljs-keyword">interface</span>&#123;&#125;, value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> value == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">switch</span> value.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> []<span class="hljs-keyword">byte</span>:<span class="hljs-keyword">return</span> json.Unmarshal(value.([]<span class="hljs-keyword">byte</span>), data)<span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:<span class="hljs-keyword">return</span> json.Unmarshal([]<span class="hljs-keyword">byte</span>(value.(<span class="hljs-keyword">string</span>)), data)<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"val type is valid, is %+v"</span>, value)&#125;&#125;<span class="hljs-comment">// for valuer helper</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">(data <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;vi := reflect.ValueOf(data)<span class="hljs-comment">// 判断是否为 0 值</span><span class="hljs-keyword">if</span> vi.IsZero() &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> json.Marshal(data)&#125;</code></pre><p>使用的时候只需要调用一下</p><pre><code class="hljs go"><span class="hljs-comment">// Args 参数</span><span class="hljs-keyword">type</span> Args <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span><span class="hljs-comment">// Scan Scanner</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(args Args)</span> <span class="hljs-title">Scan</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> scan(&amp;args, value)&#125;<span class="hljs-comment">// Value Valuer</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(args Args)</span> <span class="hljs-title">Value</span><span class="hljs-params">()</span> <span class="hljs-params">(driver.Value, error)</span></span> &#123;<span class="hljs-keyword">return</span> value(args)&#125;</code></pre><h2 id="三、通过-hook-实现数据绑定"><a href="#三、通过-hook-实现数据绑定" class="headerlink" title="三、通过 hook 实现数据绑定"></a>三、通过 hook 实现数据绑定</h2><p>除了上面的这种方法有没有其他的实现方式呢？</p><p>当然是有的，从上面的例子我们可以发现，实现方式就是保存数据的时候将数据转换为基本类型，然后在取出来绑定数据的时候再转换一下，这个过程我们也可以通过 <a href="http://gorm.io/docs/hooks.html" target="_blank" rel="noopener">GORM 的 Hook</a> 实现。利用 <code>BeforeSave</code> 在数据保存前转换，再利用 <code>AfterFind</code> 在数据取出来之后转换即可。但是这种方式我们需要在 struct 中定义一个用于实际映射数据库数据的字段。</p><pre><code class="hljs go"><span class="hljs-comment">// Data Data</span><span class="hljs-keyword">type</span> Data <span class="hljs-keyword">struct</span> &#123;Args    <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-string">`json:"args" gorm:"-"`</span>ArgsStr <span class="hljs-keyword">string</span>                 <span class="hljs-string">`json:"-" gorm:"column:args"`</span>&#125;<span class="hljs-comment">// BeforeSave 数据保存前</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(data *Data)</span> <span class="hljs-title">BeforeSave</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> data.Args == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;b, err := json.Marshal(&amp;data.Args)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;data.ArgsStr = <span class="hljs-keyword">string</span>(b)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// AfterFind 查询之后</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(data *Data)</span> <span class="hljs-title">AfterFind</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> data.ArgsStr == <span class="hljs-string">""</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> json.Unmarshal([]<span class="hljs-keyword">byte</span>(data.ArgsStr), &amp;data.Args)&#125;</code></pre><p>这样同样可以达到相似的效果</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章介绍了两种通用数据类型在 GORM 中的绑定方式：</p><ul><li>通过实现相关的接口实现，并且抽象了一个通用的辅助函数</li><li>通过 hook 实现</li></ul><p>一般推荐使用第一种方法，只是需要单独定义数据类型，第二种方法需要多一个辅助字段，这种方式如果相关的字段过多会很不优雅。</p><p>感谢阅读，这是 Go Web 小技巧系列的第二篇文章，下一篇为大家介绍参数绑定当中的一些小技巧</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/38237.html">Go Web 小技巧（一）简化Gin接口代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>gorm</tag>
      
      <tag>小技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Web 小技巧（一）简化Gin接口代码</title>
    <link href="/post/38237.html"/>
    <url>/post/38237.html</url>
    
    <content type="html"><![CDATA[<p>不知道大家在使用 Gin 构建 API 服务时有没有这样的问题:</p><ol><li>参数绑定的环节可不可以自动处理？</li><li>错误可不可以直接返回，不想写空 <code>return</code>, 漏写就是 <code>bug</code></li></ol><p>本文通过简单地封装，利用 go 的接口特性，提供一个解决上述两个问题的思路</p><a id="more"></a><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h3 id="刚开始时写-API-服务时"><a href="#刚开始时写-API-服务时" class="headerlink" title="刚开始时写 API 服务时"></a>刚开始时写 API 服务时</h3><p>我们刚开始使用 Gin 写 API 服务时，一般会按照官方文档上的 🌰 这么写</p><pre><code class="hljs go"><span class="hljs-comment">// User 用户结构</span><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;UserName <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// CreateUser 创建用户</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateUser</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<span class="hljs-keyword">var</span> params User<span class="hljs-keyword">if</span> err := ctx.ShouldBind(&amp;params); err != <span class="hljs-literal">nil</span> &#123;ctx.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">"code"</span>: <span class="hljs-number">400</span>,<span class="hljs-string">"msg"</span>:  <span class="hljs-string">"参数错误"</span>,&#125;)logrus.Errorf(<span class="hljs-string">"params err, %v"</span>, params)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 一些其他的业务逻辑 ...</span>ctx.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">"code"</span>: <span class="hljs-number">0</span>,<span class="hljs-string">"msg"</span>:  <span class="hljs-string">"创建成功"</span>,&#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;r := gin.Default()r.POST(<span class="hljs-string">"user"</span>, CreateUser)<span class="hljs-keyword">if</span> err := r.Run(<span class="hljs-string">":8080"</span>); err != <span class="hljs-literal">nil</span> &#123;logrus.Fatalf(<span class="hljs-string">"can not start serve: %v"</span>, err)&#125;&#125;</code></pre><h3 id="封装返回值"><a href="#封装返回值" class="headerlink" title="封装返回值"></a>封装返回值</h3><p>我们写了一段时间之后，会发现，我们的返回值的结构是固定的，为什么不抽象一下呢，所以我们创建了一个结构体 <code>Resp</code> ，并且封装了两个方法用于成功和失败这两种状态的返回</p><pre><code class="hljs go"><span class="hljs-comment">// resp.go</span><span class="hljs-comment">// Resp 返回</span><span class="hljs-keyword">type</span> Resp <span class="hljs-keyword">struct</span> &#123;Code <span class="hljs-keyword">int</span>Msg  <span class="hljs-keyword">string</span>Data <span class="hljs-keyword">interface</span>&#123;&#125;&#125;<span class="hljs-comment">// ErrorResp 错误返回值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ErrorResp</span><span class="hljs-params">(ctx *gin.Context, code <span class="hljs-keyword">int</span>, msg <span class="hljs-keyword">string</span>, data ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;resp(ctx, code, msg, data...)&#125;<span class="hljs-comment">// SuccessResp 正确返回值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SuccessResp</span><span class="hljs-params">(ctx *gin.Context, msg <span class="hljs-keyword">string</span>, data ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;resp(ctx, <span class="hljs-number">0</span>, msg, data...)&#125;<span class="hljs-comment">// resp 返回</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resp</span><span class="hljs-params">(ctx *gin.Context, code <span class="hljs-keyword">int</span>, msg <span class="hljs-keyword">string</span>, data ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;resp := Resp&#123;Code: code,Msg:  msg,Data: data,&#125;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">1</span> &#123;resp.Data = data[<span class="hljs-number">0</span>]&#125;ctx.JSON(http.StatusOK, resp)&#125;</code></pre><p>添加这个方法之后，我们再看一下 <code>CreateUser</code> 这个方法，成功的从 16 行变到了 12 行</p><pre><code class="hljs go"><span class="hljs-comment">// main.go</span><span class="hljs-comment">// CreateUser 创建用户</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateUser</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<span class="hljs-keyword">var</span> params User<span class="hljs-keyword">if</span> err := ctx.ShouldBind(&amp;params); err != <span class="hljs-literal">nil</span> &#123;ErrorResp(ctx, <span class="hljs-number">400</span>, <span class="hljs-string">"参数错误"</span>)logrus.Errorf(<span class="hljs-string">"params err, %v"</span>, params)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 一些其他的业务逻辑 ...</span>SuccessResp(ctx, <span class="hljs-string">"创建成功"</span>)&#125;</code></pre><h3 id="两个痛点"><a href="#两个痛点" class="headerlink" title="两个痛点"></a>两个痛点</h3><p>上面的方法还不够完整，我们还是有许多重复的逻辑，可以发现我们在写的绝大多数 API 大概都是这样：</p><ol><li>参数绑定 &amp; 校验</li><li>业务逻辑</li><li>返回</li></ol><p>这里面有两个痛点：</p><ol><li>参数绑定的环节可不可以自动处理？</li><li><p>错误可不可以直接返回，不想写空 <code>return</code>, 漏写就是 <code>bug</code></p><pre><code class="hljs go"><span class="hljs-comment">// 不想写大量这种重复的代码</span><span class="hljs-keyword">var</span> params User<span class="hljs-keyword">if</span> err := ctx.ShouldBind(&amp;params); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// 下面这三行是不是可以合并成一行</span>ErrorResp(ctx, <span class="hljs-number">400</span>, <span class="hljs-string">"参数错误"</span>)logrus.Errorf(<span class="hljs-string">"params err, %v"</span>, params)<span class="hljs-keyword">return</span>&#125;</code></pre></li></ol><h3 id="使用接口封装请求"><a href="#使用接口封装请求" class="headerlink" title="使用接口封装请求"></a>使用接口封装请求</h3><p>上面的这两个痛点我们可以通过一个辅助函数解决</p><pre><code class="hljs go"><span class="hljs-comment">// Requester 请求</span><span class="hljs-keyword">type</span> Requester <span class="hljs-keyword">interface</span> &#123;Request(ctx *gin.Context) (*Resp, error)&#125;<span class="hljs-comment">// Handle 请求</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handle</span><span class="hljs-params">(r Requester)</span> <span class="hljs-title">gin</span>.<span class="hljs-title">HandlerFunc</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;resp, err := request(r, ctx)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">var</span> code *errcode.Error<span class="hljs-keyword">if</span> !errors.As(err, &amp;code) &#123;code = errcode.Unknown.Wrap(err)&#125;resp = &amp;Resp&#123;Code: code.Code,Msg:  code.String(),&#125;_ = ctx.Error(err)&#125;ctx.JSON(http.StatusOK, resp)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">request</span><span class="hljs-params">(r Requester, ctx *gin.Context)</span> <span class="hljs-params">(*controller.Resp, error)</span></span> &#123;<span class="hljs-comment">// 参数绑定</span><span class="hljs-keyword">if</span> err := ctx.ShouldBind(r); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errcode.ErrParams.Wrap(err)&#125;<span class="hljs-keyword">return</span> r.Request(ctx)&#125;</code></pre><p>这样我们只需要实现这个 <code>Requester</code>, 写 API 时只需要关注业务逻辑就可以了</p><pre><code class="hljs go"><span class="hljs-comment">// CreateUser 创建用户</span><span class="hljs-keyword">type</span> CreateUser <span class="hljs-keyword">struct</span> &#123;UserName <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span> <span class="hljs-title">Request</span><span class="hljs-params">(ctx *gin.Context)</span> <span class="hljs-params">(*Resp, error)</span></span> &#123;<span class="hljs-comment">// 业务逻辑</span><span class="hljs-comment">// 返回成功值</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;r := gin.Default()r.POST(<span class="hljs-string">"user"</span>, Handle(&amp;CreateUser))<span class="hljs-keyword">if</span> err := r.Run(<span class="hljs-string">":8080"</span>); err != <span class="hljs-literal">nil</span> &#123;logrus.Fatalf(<span class="hljs-string">"can not start serve: %v"</span>, err)&#125;&#125;</code></pre><p>上面的代码有一个 bug 不知道大家发现没有，我们上一次请求的参数会被带到下一次请求当中</p><pre><code class="hljs go"><span class="hljs-comment">// Handle 请求</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handle</span><span class="hljs-params">(r Requester)</span> <span class="hljs-title">gin</span>.<span class="hljs-title">HandlerFunc</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<span class="hljs-comment">// 创建一个新的 Requester, 避免将上一次的参数带到下一次当中</span><span class="hljs-keyword">if</span> reflect.TypeOf(r).Kind() != reflect.Ptr &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"must be a pointer"</span>)&#125;req := reflect.New(reflect.ValueOf(r).Elem().Type()).Interface().(Requester)resp, err := request(req, ctx)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">var</span> code *errcode.Error<span class="hljs-keyword">if</span> !errors.As(err, &amp;code) &#123;code = errcode.Unknown.Wrap(err)&#125;resp = &amp;Resp&#123;Code: code.Code,Msg:  code.String(),&#125;_ = ctx.Error(err)&#125;ctx.JSON(http.StatusOK, resp)&#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大概这样差不多就 ok 了，还有很多可以完善的点，这里有一些思路，有的已经做了，有的还在路上</p><ol><li><p>每次注册都写 <code>Handle(&amp;CreateUser)</code> 还是有点麻烦?</p><p>可以封装一下 <code>gin.IRouter</code> 这个接口，这样注册接口就可以和原来一样了</p></li><li><p>参数绑定如果我需要多次绑定怎么办?</p><p>可以添加一个接口，如果实现了这个接口就执行以下，对于有特殊的参数校验之类的也可以采用类似的方式处理</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Binder <span class="hljs-keyword">interface</span> &#123;Bind(ctx *gin.Context) error&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">request</span><span class="hljs-params">(r Requester, ctx *gin.Context)</span> <span class="hljs-params">(*controller.Resp, error)</span></span> &#123;<span class="hljs-comment">// 参数绑定</span><span class="hljs-keyword">if</span> err := ctx.ShouldBind(r); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errcode.ErrParams.Wrap(err)&#125;<span class="hljs-comment">// 其余参数绑定</span><span class="hljs-keyword">if</span> b, ok := r.(Binder); ok &#123;<span class="hljs-keyword">if</span> err := b.Bind(api); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errcode.ErrParams.Wrap(err)&#125;&#125;<span class="hljs-keyword">return</span> r.Request(ctx)&#125;</code></pre></li><li><p>怎么输出 API 文档？</p><p>可以和 <code>swagger</code> 之类的 API 文档结合, 利用 <code>go generate</code> 自动生成，顺便可以连接口注册都不用了，添加一行注释，自动注册接口，并且输出接口文档</p><pre><code class="hljs go"><span class="hljs-comment">// @Router put /api/v1/user</span><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u *User)</span> <span class="hljs-title">Request</span><span class="hljs-params">(ctx *gin.Context)</span> <span class="hljs-params">(*Resp, error)</span></span></code></pre></li><li><p>能不能减少 CURD 代码?</p><p>可以实现，只需要采用约定的项目接口，可以 利用 <code>go generate</code> 直接自动生成简单的 CURD 代码</p></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>小技巧</tag>
      
      <tag>api</tag>
      
      <tag>gin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>善用工具之postman高级用法概述</title>
    <link href="/post/45050.html"/>
    <url>/post/45050.html</url>
    
    <content type="html"><![CDATA[<p>POSTMAN 是我在开发过程当中最常用到的 API 测试工具之一，虽然并不完美，但也是目前个人认为在 API 测试时最好用的客户端工具之一。</p><p>本文适用于后端，前端，移动端以及测试的同学，分三大部分从最简单的界面操作开讲，然后涉及到变量、脚本以及一些云服务相关的功能，最后将适配几个案例讲解怎么使用 POSTMAN 提高我们的工作效率。本文前半部分包含较多基础功能讲解，对已经比较熟悉使用的同学，可以选择性的跳过部分内容。</p><a id="more"></a><blockquote><p>PS: 本文包含大量示例图片，大屏食用效果最佳，postman 看这一篇文章就够用了</p></blockquote><h2 id="零、序"><a href="#零、序" class="headerlink" title="零、序"></a>零、序</h2><p>我所有的文章基本都来自平时开发中的需求，前段时间在公司通过网关调用接口，测试很麻烦，然后就想使用在本地直接调用，由于有签名机制，所以需要通过 SDK 进行调用，后面比较完整的看了一下<code>postman</code>的文档，感觉发现了新大陆。</p><blockquote><p>注: 本文会介绍 postman 的常用以及不太常用的高级用法，但是不会所有方面都去做细节介绍，希望可以起到的抛砖引玉的作用</p></blockquote><h2 id="一、简要介绍"><a href="#一、简要介绍" class="headerlink" title="一、简要介绍"></a>一、简要介绍</h2><p><code>postman</code>是一款强大的 API 接口测试工具，有 chrome app、chrome 扩展、桌面版，推荐使用最新最强大的桌面版本。主要包括以下功能，本文也会围绕以下功能点展开讲解:</p><blockquote><p>有 ☁ 标识表示为云服务</p></blockquote><ol><li>API 测试</li><li>变量</li><li>代码生成</li><li><strong>Script</strong></li><li>API 代理</li><li>☁️ API 文档</li><li>☁️ Mock Server</li><li>☁️ 接口监控</li><li>☁️ Postman API</li></ol><h2 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h2><h3 id="2-1、使用简介"><a href="#2-1、使用简介" class="headerlink" title="2.1、使用简介"></a>2.1、使用简介</h3><p>如下图所示，postman 界面十分丰富，基本上所有常用的功能都能一览无余</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/Snipaste_2019-06-04_01-25-22.png" srcset="/img/loading.gif" alt></p><h3 id="2-2、API-测试"><a href="#2-2、API-测试" class="headerlink" title="2.2、API 测试"></a>2.2、API 测试</h3><p>如下图所示，API 测试页面十分的易用，操作界面一目了然。</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190605235605.png" srcset="/img/loading.gif" alt></p><h4 id="2-2-1、认证"><a href="#2-2-1、认证" class="headerlink" title="2.2.1、认证"></a>2.2.1、认证</h4><p>接口的调用常常需要通过登录，postman 预设一些常见的认证方式，比较常用的 Basic Auth, OAuth2.0 等，这些预设的协议在实际使用过程中会十分的有用。</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190605235911.png" srcset="/img/loading.gif" alt></p><p>通过上图我们可以发现，默认选项是从父目录中继承，所以如下图所示，其实我们可以在一个 Collection 或者是下面的文件夹中设置认证方式，这时候整个目录下的所有的 API 默认都可以通过认证</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606000414.png" srcset="/img/loading.gif" alt></p><h4 id="2-2-2、参数"><a href="#2-2-2、参数" class="headerlink" title="2.2.2、参数"></a>2.2.2、参数</h4><p>所有 K-V 模式的参数都可以批量编辑, 包括 QueryString, Body, Header, 批量编辑的功能可以快速复制浏览器中的请求参数信息到 postman 中</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/1559750920570.png" srcset="/img/loading.gif" alt></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606001204.png" srcset="/img/loading.gif" alt></p><h3 id="2-3、变量"><a href="#2-3、变量" class="headerlink" title="2.3、变量"></a>2.3、变量</h3><p>postman 中一共存在五种变量类型， 全局变量，Collection/文件夹中的变量，环境变量，数据变量，本地变量</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606001837.png" srcset="/img/loading.gif" alt></p><p>如图所有变量层级从外到内，如果出现重复的变量名，里面的会覆盖外部的变量</p><h4 id="2-3-2、变量设置"><a href="#2-3-2、变量设置" class="headerlink" title="2.3.2、变量设置"></a>2.3.2、变量设置</h4><h5 id="2-3-2-1、Collection-变量"><a href="#2-3-2-1、Collection-变量" class="headerlink" title="2.3.2.1、Collection 变量"></a>2.3.2.1、Collection 变量</h5><p>点击编辑 Collection，如图所示</p><p>INITIAL VALUE: 这个值是用于分享给团队的成员的时候展示的值</p><p>CURRENT VALUE: 表示当前实际的值</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606002811.png" srcset="/img/loading.gif" alt></p><h5 id="2-3-2-2、环境变量-amp-全局变量"><a href="#2-3-2-2、环境变量-amp-全局变量" class="headerlink" title="2.3.2.2、环境变量 &amp; 全局变量"></a>2.3.2.2、环境变量 &amp; 全局变量</h5><p>环境变量和全局变量的设置在 postman 的右上角，设置界面和上图的 Collection 界面类似</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606003057.png" srcset="/img/loading.gif" alt></p><h4 id="2-3-2、变量的使用"><a href="#2-3-2、变量的使用" class="headerlink" title="2.3.2、变量的使用"></a>2.3.2、变量的使用</h4><p>变量通过 <code></code>, 在实际请求的时候变量可以设置为实际的值，变量也可以被脚本设置, 修改, 读取, 这个特性能够让我们有了很多可能</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606002133.png" srcset="/img/loading.gif" alt></p><h4 id="2-3-3、动态变量"><a href="#2-3-3、动态变量" class="headerlink" title="2.3.3、动态变量"></a>2.3.3、动态变量</h4><p>postman 预设了几个动态变量<code></code>, 可以获取当前的时间戳等信息</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606002440.png" srcset="/img/loading.gif" alt></p><h3 id="2-4、代码生成"><a href="#2-4、代码生成" class="headerlink" title="2.4、代码生成"></a>2.4、代码生成</h3><p>如图所示，postman 提供了很多语言以及一些常用框架的代码，我们在实际使用的过程中，可以直接复制代码节约许多时间</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190606003416.png" srcset="/img/loading.gif" alt></p><h3 id="2-5、Script-划重点"><a href="#2-5、Script-划重点" class="headerlink" title="2.5、Script(划重点)"></a>2.5、Script(划重点)</h3><h4 id="2-5-1、简介"><a href="#2-5-1、简介" class="headerlink" title="2.5.1、简介"></a>2.5.1、简介</h4><p>在 POSTMAN 中，你可以通过编写 JavaScript 脚本增强其功能，POSTMAN 的脚本运行在其提供的沙盒环境中，如下图所示，点击左下角按钮可以出现调试窗口，会显示脚本的 debug 信息</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190618000158.png" srcset="/img/loading.gif" alt></p><p>在 postman 中一共支持两种脚本，分别是 Pre Request Script, Test Script，这两种脚本分别在请求前以及请求后生效，第一种我常用于生成各种签名或者是需要提前请求获取一些 token，后面一种更常见于集成测试中，用于控制测试的前后顺序，例如后面会讲到的案例，在 CD 前集成接口回归测试，确保主流程无误再上线等。</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190618000827.png" srcset="/img/loading.gif" alt></p><h4 id="2-5-2、API"><a href="#2-5-2、API" class="headerlink" title="2.5.2、API"></a>2.5.2、API</h4><p>postman 提供了一些 API，<code>pm.*</code>, 例如:</p><pre><code class="hljs bash">pm.global.* <span class="hljs-comment"># 全局变量相关</span>pm.environment.* <span class="hljs-comment"># 环境变量相关</span>pm.request.* <span class="hljs-comment"># 请求相关, 注意请求相关的信息时只读的不能修改</span>pm.sendRequest() <span class="hljs-comment"># 发送请求</span><span class="hljs-comment"># 下面这些只能用于 test script</span>pm.response.* <span class="hljs-comment"># 返回值相关</span>pm.cookies.* <span class="hljs-comment"># cookies</span>pm.test() <span class="hljs-comment"># 执行测试</span>...</code></pre><p>除此之外还内置了一些常用的 npm 包可以直接使用，例如:</p><pre><code class="hljs bash">ajv → v6.6.2atob → v2.1.2btoa → v1.2.1chai → v4.2.0cheerio → v0.22.0...</code></pre><p>更多 API 信息可以访问官方文档查看: <a href="https://learning.getpostman.com/docs/postman/scripts/postman_sandbox_api_reference" target="_blank" rel="noopener">Postman Sandbox API reference</a></p><h4 id="2-5-3、Pre-Request-Script"><a href="#2-5-3、Pre-Request-Script" class="headerlink" title="2.5.3、Pre Request Script"></a>2.5.3、Pre Request Script</h4><p>请求前执行该脚本，一般用于提前设置一些签名信息，上文提到过虽然 postman 将请求的信息暴露给了我们，但是我们并不能修改，那我们要如何才能够将我们生成的值放在请求之中呢？</p><p>答案是： 变量，如果签名信息仅在 header 之中使用，也可以直接插入新的 header 信息</p><p>下面我们来看一个例子</p><p>调用第三方服务的时候往往需要生成一个 Token 进行鉴权，这个示例会分别生成一个时间戳，以及利用自带的<code>CryptoJS</code>库进行<code>AES</code>加密签名，并且分别使用设置环境变量，新增 header 的方式注入到请求之中</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710224627.png" srcset="/img/loading.gif" alt></p><pre><code class="hljs javascript"><span class="hljs-comment">// 从环境变量中获取密钥与appid</span><span class="hljs-keyword">let</span> secret = pm.environment.get(<span class="hljs-string">"secret"</span>);<span class="hljs-keyword">let</span> appid = pm.environment.get(<span class="hljs-string">"appid"</span>);<span class="hljs-comment">// 获取当前时间戳</span><span class="hljs-keyword">let</span> time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"time:"</span>, time + <span class="hljs-string">""</span>);<span class="hljs-comment">// 直接向 Header 中插入一条新的记录</span>pm.request.headers.upsert(&#123; <span class="hljs-attr">key</span>: <span class="hljs-string">"time"</span>, <span class="hljs-attr">value</span>: time &#125;);<span class="hljs-comment">// 签名</span><span class="hljs-keyword">let</span> sign = CryptoJS.AES.encrypt(time + appid, secret);<span class="hljs-comment">// 设置环境变量</span>pm.environment.set(<span class="hljs-string">"sign"</span>, sign.ciphertext.toString().toUpperCase());</code></pre><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710224357.png" srcset="/img/loading.gif" alt></p><h4 id="2-5-4、Test-Script"><a href="#2-5-4、Test-Script" class="headerlink" title="2.5.4、Test Script"></a>2.5.4、Test Script</h4><p>测试脚本和一半的单元测试大同小异，这里简要介绍比较常用和重要的两个功能，详细了解可以<a href="https://learning.getpostman.com/docs/postman/scripts/test_examples/" target="_blank" rel="noopener">点击查看文档</a></p><ul><li><p>基本的测试语句</p><pre><code class="hljs javascript">pm.test(<span class="hljs-string">"测试名称"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 断言</span>  pm.expect(pm.response.responseTime).to.be.below(<span class="hljs-number">200</span>);&#125;);</code></pre></li><li><p>流程控制，可以对 API 测试的顺序进行控制</p><pre><code class="hljs javascript"><span class="hljs-comment">// 设置下一个会被执行的请求</span>postman.setNextRequest(<span class="hljs-string">"request_name"</span>);<span class="hljs-comment">// 终端流程</span>postman.setNextRequest(<span class="hljs-literal">null</span>);</code></pre></li></ul><p>运行一共有两种方式，分别是 Collection Run 以及 newman cli 执行， newman 会在后文的案例之中提到</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190712004751.png" srcset="/img/loading.gif" alt></p><p>可以看到执行结果详细的信息，也可以导出</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190712005755.png" srcset="/img/loading.gif" alt></p><h3 id="2-6、API-代理"><a href="#2-6、API-代理" class="headerlink" title="2.6、API 代理"></a>2.6、API 代理</h3><blockquote><p>这个功能对于客户端调试的同学十分有用，可以通过 POSTMAN 提供的代理功能，将客户端的请求保存在历史记录或者是一个 Collection 中</p></blockquote><p>首先我们在 POSTMAN 进行如下设置，点击 Filters 还可以对请求的方法，URL 进行一些过滤的操作</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710225227.png" srcset="/img/loading.gif" alt></p><p>接下来，以安卓手机为例，我们需要和电脑处于同一网段，并且在 WIFI 设置里加上代理</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/Screenshot_2019-07-11-23-43-13-112_com.android.se.png?x-oss-process=image/resize,h_600" srcset="/img/loading.gif" alt></p><p>然后再到我们之前设置的 Collection 中就可以看到请求的记录了，如下图所示在手机上设置了代理之后访问了一下百度，所有的请求链接以及参数都会展示在 postman 中</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190711234614.png" srcset="/img/loading.gif" alt></p><h3 id="2-7、☁️-API-文档"><a href="#2-7、☁️-API-文档" class="headerlink" title="2.7、☁️ API 文档"></a>2.7、☁️ API 文档</h3><blockquote><p>接下来，将会是云服务相关的功能，如果不能使用云服务这一趴可以跳过</p></blockquote><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710231728.png" srcset="/img/loading.gif" alt></p><p>如图所示文档发布成功之后，即可看到文档的详情，已经 API 详情，并且右侧有代码生成器，可以直接复制对应的代码，十分方便</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710231917.png" srcset="/img/loading.gif" alt></p><p>详细示例可以点击查看 <a href="https://documenter.getpostman.com/view/364695/RWaGUpsy?version=latest" target="_blank" rel="noopener">We 川大 API</a> ，需要注意的是截止到文章发布时，postman 对免费账户文档有一定的限制每月公开文档只能有 1000 的访问</p><h3 id="2-8、☁️-Mock-Server"><a href="#2-8、☁️-Mock-Server" class="headerlink" title="2.8、☁️ Mock Server"></a>2.8、☁️ Mock Server</h3><p>同样十分的简单，右键 Collection 点击 mock 并按照如图所示，进行一些简单的配置即可，注意 mock server 的数据是请求的时候 save example 的数据，并且同样免费账户，一个月只能调用 1000 次 API，可以点击查看 <a href="https://documenter.getpostman.com/view/364695/RWaGUpsy?version=latest" target="_blank" rel="noopener">We 川大 API</a> ，里面的文档示例就是使用的 Mock Server</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710232547.png" srcset="/img/loading.gif" alt></p><h3 id="2-9、☁️-接口监控"><a href="#2-9、☁️-接口监控" class="headerlink" title="2.9、☁️ 接口监控"></a>2.9、☁️ 接口监控</h3><p>同样十分的简单，右键 Collection 点击 monitor collection 并按照如图所示进行一些配置，可以选择 频率，接口监控的位置，触发时间等字段</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710232823.png" srcset="/img/loading.gif" alt></p><h3 id="2-10、☁️-Postman-API"><a href="#2-10、☁️-Postman-API" class="headerlink" title="2.10、☁️ Postman API"></a>2.10、☁️ Postman API</h3><p>除此之外 POSTMAN 还提供开放的 API 使其有更多的可能，如图所示获取 API Key，具体的使用请点<a href="https://docs.api.getpostman.com/?_ga=2.113542607.916957680.1562768130-1454391695.1559579723&amp;version=latest" target="_blank" rel="noopener">击查看 API 文档</a>， 通过 API 我们可以实现一些自动化的操作，也可以自动生成文档，然后用 github pages 进行部署，不受账户限制等等，由于文章篇幅有限，这里就不展开讲了。</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190710233355.png" srcset="/img/loading.gif" alt></p><h2 id="三、使用案例"><a href="#三、使用案例" class="headerlink" title="三、使用案例"></a>三、使用案例</h2><h3 id="3-1、和-CI-CD-联动，进行接口自动化测试"><a href="#3-1、和-CI-CD-联动，进行接口自动化测试" class="headerlink" title="3.1、和 CI/CD 联动，进行接口自动化测试"></a>3.1、和 CI/CD 联动，进行接口自动化测试</h3><blockquote><p>postman 提供了一个命名行工具，newman, 通过它我们可以在我们的 CI /CD 的流程上加入接口自动化回归的流程，确保服务的稳定性</p></blockquote><p>接下来，我们以 gitlab ci/cd 为例，配置一个简单的接口回归</p><p>newman 具体的使用方法可以查看官方的文档或者是<a href="https://github.com/postmanlabs/newman" target="_blank" rel="noopener">github 仓库</a>的介绍, 这里不再赘述，我们直接看一下简单的使用</p><p>首先是 <code>.gitlab-ci.yml</code> 的配置</p><pre><code class="hljs yaml"><span class="hljs-attr">stages:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">test</span><span class="hljs-attr">api_test:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">test</span>  <span class="hljs-attr">image:</span> <span class="hljs-string">node:11.15.0</span>  <span class="hljs-attr">before_script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">-g</span> <span class="hljs-string">newman</span>  <span class="hljs-attr">script:</span>    <span class="hljs-comment"># 此处执行的是官方的一个例子，run 后面可以是导出的Collection的文件，也可以是分享出来的Collection</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">newman</span> <span class="hljs-string">run</span> <span class="hljs-string">"https://www.getpostman.com/collections/631643-f695cab7-6878-eb55-7943-ad88e1ccfd65-JsLv"</span>  <span class="hljs-attr">tags:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">gitlab-org</span></code></pre><p>如下图所示我们可以看到具体的执行结果，返回的信息也比较详细，和上文的 Test Script 脚本结合就可以达到我们想要的接口回归测试的效果</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190712002216.png" srcset="/img/loading.gif" alt></p><p><a href="https://gitlab.com/mohuishou/postman-ci/pipelines" target="_blank" rel="noopener">点击可以查看这个 demo</a></p><h3 id="3-2、本地接口文档"><a href="#3-2、本地接口文档" class="headerlink" title="3.2、本地接口文档"></a>3.2、本地接口文档</h3><p>在上文我们有提到过，postman 的云文档比较好用，但是免费账户的限制比较大，并且很多时候在公司我们不能使用一些云的功能，这个时候，我们就可以通过导出 postman collection 并且使用一些第三方的工具，或者是自己实现一个接口文档的生成功能，来达到输出本地文档的目的</p><p>这里我们借助 <a href="https://github.com/thedevsaddam/docgen" target="_blank" rel="noopener">docgen</a> 这个轮子来输出一份本地的文档，类似的工具还有许多，实现上也不复杂，如果有格式上的一些需求完全可以一两个小时的功夫造出一个还能用的小工具</p><pre><code class="hljs bash"><span class="hljs-comment"># 只需要导出json文件，就可以输出在线文档，或者是生成html，markdown 文件了</span>$ ./docgen.exe server -f We川大.postman_collection.json2019/07/12 00:30:51 Listening on port:  90002019/07/12 00:30:51 Web Server is available at http://localhost:9000/</code></pre><p>生成的效果如下图所示：</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190712003222.png" srcset="/img/loading.gif" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章拖的稍微有点点久，内容有点超出最开始的预计，写的稍稍有点点多了，POSTMAN 还有需要有用的玩法，大家可以探索一下，除了上文讲到的之外，说一些我常用到的方式</p><ul><li>利用 collection run 批量提交请求，做一些批处理的工作</li><li>利用 pre request script 设置在 Collection 中，然后用不同的环境变量区分不同的项目，这种用在网关类的测试十分有</li></ul><p>文章比较长，感谢你的阅读</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://learning.getpostman.com/docs" target="_blank" rel="noopener">Postman 官方文档，很全面，基本上所有的操作都能在上面找到</a></li><li><a href="https://haofly.net/postman/" target="_blank" rel="noopener">Postman 高级用法</a></li><li><a href="https://www.twblogs.net/a/5bddb8542b717720b51ab853/zh-cn" target="_blank" rel="noopener">Postman 高级应用（9）：API 收集神器——请求拦截</a></li><li><a href="https://documenter.getpostman.com/view/364695/RWaGUpsy?version=latest" target="_blank" rel="noopener">We 川大 API</a></li><li><a href="https://github.com/postmanlabs/newman" target="_blank" rel="noopener">newman</a></li><li><a href="https://gitlab.com/mohuishou/postman-ci/pipelines" target="_blank" rel="noopener">gitlab ci demo</a></li><li><a href="https://github.com/thedevsaddam/docgen" target="_blank" rel="noopener">docgen</a></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/38237.html">Go Web 小技巧（一）简化Gin接口代码</a></li><li><a href="https://lailin.xyz/post/41140.html">go generate and ast</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>tool</tag>
      
      <tag>postman</tag>
      
      <tag>api</tag>
      
      <tag>rest</tag>
      
      <tag>test</tag>
      
      <tag>gatway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go generate and ast</title>
    <link href="/post/41140.html"/>
    <url>/post/41140.html</url>
    
    <content type="html"><![CDATA[<h2 id="楔-xie-子"><a href="#楔-xie-子" class="headerlink" title="楔(xiē)子"></a>楔(xiē)子</h2><p>最近写<code>API CURD</code>比较多，为了结构清晰，返回值需要统一错误码，所以在一个统一的<code>errcode</code>包中定义错误码常量，以及其错误信息.</p><a id="more"></a><p>如下图所示，由于常量是导出字符 -&gt; <code>golint</code> 检测需要编写注释 -&gt; 注释信息其实就是错误信息，已经在下文的<code>msg map[int]string</code>中定义，如果在写就得写两遍</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/assets/20190507235621.png" srcset="/img/loading.gif" alt></p><p>不写，就满屏波浪线，不能忍！</p><p>写了，就得<code>Copy</code>一份，还不利于维护，不能忍！</p><p>能不能只写一份注释，剩下的<code>msg</code>通过读取注释信息自动生成，将我们宝(hua)贵(diao)的生命，从这些重复繁杂无意义的劳动中解放出来。</p><p>为了实现这个<del>伟大的目标</del>, 需要以下两个关键的数据:</p><ol><li>解析源代码获取常量与注释之间的关系 -&gt; 🌲Go 抽象语法树: AST<sup><a href="https://golang.org/pkg/go/ast" target="_blank" rel="noopener">[3]</a></sup></li><li>从 Go 源码生成 Go 代码 -&gt; 👏 go generate<sup><a href="https://blog.golang.org/generate" target="_blank" rel="noopener">[5]</a></sup></li></ol><h2 id="👏-go-generate"><a href="#👏-go-generate" class="headerlink" title="👏 go generate"></a>👏 go generate</h2><p><code>golang</code>在<code>1.4</code>版本中引入了<code>go generate</code>命令，常用于文件生成，例如在 Golang 官方博客<sup><a href="https://blog.golang.org/generate" target="_blank" rel="noopener">[5]</a></sup>中介绍的<a href="https://golang.org/x/tools/cmd/stringer" target="_blank" rel="noopener">Stringer</a>可以为枚举自动实现<code>Stringer</code>的方法，从业务代码中解放出来</p><h3 id="💻-命令文档"><a href="#💻-命令文档" class="headerlink" title="💻 命令文档"></a>💻 命令文档</h3><p>使用<code>go help generate</code>我们可以查看一下命令的帮助文档</p><pre><code class="hljs bash">▶ go <span class="hljs-built_in">help</span> generateusage: go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]...</code></pre><p>解释很长，就不贴上来了，简要的概括一下:</p><ol><li><p>参数说明</p><ul><li>-run 正则表达式匹配命令行，仅执行匹配的命令(和<code>go test -run</code>类似)</li><li>-v 打印  已被检索处理的文件。</li><li>-n 打印出将被执行的命令，此时将不真实执行命令</li><li>-x 打印已执行的命令</li></ul></li><li><p>举个栗子</p><pre><code class="hljs bash"><span class="hljs-comment"># 对当前包下的Go文件进行处理, 并打印已被检索处理的文件。</span>go generate -v<span class="hljs-comment"># 打印当前目录下所有文件中将要被执行的命令(实际不会执行)</span>go generate -n ./...</code></pre></li><li><p><code>go generate</code>会扫描<code>.go</code>源码文件中的注释<code>//go:generate command args...</code>， 并且执行其命令，注意:</p><ul><li>这些命令是为了更新或者创建 Go 源文件</li><li><code>command</code>必须是可执行的指令，例如在 PATH 中或者使用绝对路径</li><li><code>arg</code>如果带引号会被识别成一个参数, 例如: <code>//go:generate command &quot;x1 x2&quot;</code>, 这条语句执行的命令只有一个参数</li><li><strong>注释中<code>//</code>和<code>go</code>之间没有空格</strong></li></ul></li><li><p><code>go generate</code>必须手动执行，如果想等着<code>go build</code>, <code>go test</code>, <code>go run</code> 命令执行的时候自动执行，可以洗洗睡了</p></li><li><p>为了让别人或者是 IDE 识别代码是通过<code>go generate</code>生成的，请在生成的代码中添加注释(一般放在文件开头)</p><pre><code class="hljs bash"><span class="hljs-comment"># PS: 这是一个正则表达式</span>^// Code generated .* DO NOT EDIT\.$</code></pre><p>举个栗子:</p><pre><code class="hljs go"><span class="hljs-comment">// Code generated by mohuishou DO NOT EDIT</span><span class="hljs-keyword">package</span> painkiller</code></pre></li><li><p><code>go generate</code>在执行的时候会自动注入以下环境变量:</p><pre><code class="hljs bash"><span class="hljs-variable">$GOARCH</span>系统架构: arm, amd64 等<span class="hljs-variable">$GOOS</span>操作系统: linux, windows 等<span class="hljs-variable">$GOFILE</span>当前执行的命令所处的文件名<span class="hljs-variable">$GOLINE</span>当前执行的命令在文件中的行号<span class="hljs-variable">$GOPACKAGE</span>执行的命令所处的文件的包名<span class="hljs-variable">$DOLLAR</span>$ 符号</code></pre></li></ol><h3 id="🌰-Go-官方博客中给出的栗子"><a href="#🌰-Go-官方博客中给出的栗子" class="headerlink" title="🌰 Go 官方博客中给出的栗子"></a>🌰 Go 官方博客中给出的栗子</h3><p>源文件: <code>painkiller.go</code></p><pre><code class="hljs go"><span class="hljs-comment">//go:generate stringer -type=Pill</span><span class="hljs-keyword">package</span> painkiller<span class="hljs-keyword">type</span> Pill <span class="hljs-keyword">int</span><span class="hljs-keyword">const</span> (    Placebo Pill = <span class="hljs-literal">iota</span>    Aspirin    Ibuprofen    Paracetamol    Acetaminophen = Paracetamol)</code></pre><p>执行命令</p><pre><code class="hljs bash">go generate</code></pre><p>生成文件: <code>painkiller_stringer.go</code></p><pre><code class="hljs go"><span class="hljs-comment">// generated by stringer -type Pill pill.go; DO NOT EDIT</span><span class="hljs-keyword">package</span> painkiller<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-keyword">const</span> _Pill_name = <span class="hljs-string">"PlaceboAspirinIbuprofenParacetamol"</span><span class="hljs-keyword">var</span> _Pill_index = [...]<span class="hljs-keyword">uint8</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">14</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i Pill)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || i+<span class="hljs-number">1</span> &gt;= Pill(<span class="hljs-built_in">len</span>(_Pill_index)) &#123;        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"Pill(%d)"</span>, i)    &#125;    <span class="hljs-keyword">return</span> _Pill_name[_Pill_index[i]:_Pill_index[i+<span class="hljs-number">1</span>]]&#125;</code></pre><p>从上面的 🌰，我们可以发现，在<code>.go</code>源文件中，添加了一行注释<code>go:generate stringer -type=Pill</code>, 执行命令<code>go generate</code>就调用<code>stringer</code>命令在同目录下生成了一个新的<code>_stringer.go</code>的文件</p><p>回想一下上文提到的需求，是不是感觉很类似，从 Go 源文件中，生成了一些不想重复写的业务逻辑</p><h2 id="🌲-AST"><a href="#🌲-AST" class="headerlink" title="🌲 AST"></a>🌲 AST</h2><p>回到前面的需求，我们需要从源代码中获取常量和注释之前的关系，这时就需要我们的 🌲AST 隆重登场了。</p><p>本文不对 AST 过多介绍，可以阅读参考资料中的 AST 标准库文档<sup><a href="https://golang.org/pkg/go/ast" target="_blank" rel="noopener">[3]</a></sup>，Go 的 AST(抽象语法树)<sup><a href="https://zhuanlan.zhihu.com/p/28516587" target="_blank" rel="noopener">[4]</a></sup></p><h3 id="简要介绍一下-AST-包"><a href="#简要介绍一下-AST-包" class="headerlink" title="简要介绍一下 AST 包"></a>简要介绍一下 AST 包</h3><p>基础的接口类型</p><pre><code class="hljs go"><span class="hljs-comment">// Node AST树节点</span><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">interface</span> &#123;  Pos() token.Pos  End() token.Pos&#125;<span class="hljs-comment">// Expr 所有的表达式都需要实现Expr接口</span><span class="hljs-keyword">type</span> Expr <span class="hljs-keyword">interface</span> &#123;  Node  exprNode()&#125;<span class="hljs-comment">// Stmt 所有的语句都需要实现Stmt接口</span><span class="hljs-keyword">type</span> Stmt <span class="hljs-keyword">interface</span> &#123;  Node  stmtNode()&#125;<span class="hljs-comment">// Decl 所有的声明都需要实现Decl接口</span><span class="hljs-keyword">type</span> Decl <span class="hljs-keyword">interface</span> &#123;  Node  declNode()&#125;</code></pre><p>等会儿可能会用到的<code>ValueSpec</code></p><pre><code class="hljs go"><span class="hljs-comment">// ValueSpec 表示常量声明或者变量声明</span><span class="hljs-keyword">type</span> ValueSpec <span class="hljs-keyword">struct</span> &#123;        Doc     *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span>        Names   []*Ident      <span class="hljs-comment">// value names (len(Names) &gt; 0)</span>        Type    Expr          <span class="hljs-comment">// value type; or nil</span>        Values  []Expr        <span class="hljs-comment">// initial values; or nil</span>        Comment *CommentGroup <span class="hljs-comment">// line comments; or nil</span>&#125;</code></pre><h3 id="CommentMap"><a href="#CommentMap" class="headerlink" title="CommentMap"></a>CommentMap</h3><p>在 godoc<sup><a href="https://golang.org/pkg/go/ast" target="_blank" rel="noopener">[3]</a></sup>的 Example 中可以发现有一个<a href="https://golang.org/pkg/go/ast/#example_CommentMap" target="_blank" rel="noopener">CommentMap</a>例子</p><pre><code class="hljs go"><span class="hljs-comment">// CommentMap把AST节点和其关联的注释列表进行映射</span><span class="hljs-keyword">type</span> CommentMap <span class="hljs-keyword">map</span>[Node][]*CommentGroup</code></pre><ol><li><p>通过<code>parse</code>读取源码创建一个 AST</p><pre><code class="hljs go">fset := token.NewFileSet() <span class="hljs-comment">// positions are relative to fset</span>f, err := parser.ParseFile(fset, <span class="hljs-string">"src.go"</span>, src, parser.ParseComments)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;</code></pre></li><li><p>从 AST 中新建一个<code>CommentMap</code></p><pre><code class="hljs go">cmap := ast.NewCommentMap(fset, f, f.Comments)</code></pre></li></ol><h2 id="需求实现"><a href="#需求实现" class="headerlink" title="需求实现"></a>需求实现</h2><h3 id="1-获取常量和注释的关联关系"><a href="#1-获取常量和注释的关联关系" class="headerlink" title="1. 获取常量和注释的关联关系"></a>1. 获取常量和注释的关联关系</h3><pre><code class="hljs go">file := os.Getenv(<span class="hljs-string">"GOFILE"</span>)<span class="hljs-comment">// 保存注释信息</span><span class="hljs-keyword">var</span> comments = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)<span class="hljs-comment">// 解析代码源文件，获取常量和注释之间的关系</span>fset := token.NewFileSet()f, err := parser.ParseFile(fset, file, <span class="hljs-literal">nil</span>, parser.ParseComments)checkErr(err)<span class="hljs-comment">// Create an ast.CommentMap from the ast.File's comments.</span><span class="hljs-comment">// This helps keeping the association between comments</span><span class="hljs-comment">// and AST nodes.</span>cmap := ast.NewCommentMap(fset, f, f.Comments)<span class="hljs-keyword">for</span> node := <span class="hljs-keyword">range</span> cmap &#123;  <span class="hljs-comment">// 仅支持一条声明语句，一个常量的情况</span>  <span class="hljs-keyword">if</span> spec, ok := node.(*ast.ValueSpec); ok &amp;&amp; <span class="hljs-built_in">len</span>(spec.Names) == <span class="hljs-number">1</span> &#123;    <span class="hljs-comment">// 仅提取常量的注释</span>    ident := spec.Names[<span class="hljs-number">0</span>]    <span class="hljs-keyword">if</span> ident.Obj.Kind == ast.Con &#123;      <span class="hljs-comment">// 获取注释信息</span>      comments[ident.Name] = getComment(ident.Name, spec.Doc)    &#125;  &#125;&#125;</code></pre><h3 id="2-获取注释信息"><a href="#2-获取注释信息" class="headerlink" title="2. 获取注释信息"></a>2. 获取注释信息</h3><pre><code class="hljs go"><span class="hljs-comment">// getComment 获取注释信息，来自AST标准库的summary方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getComment</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, group *ast.CommentGroup)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">var</span> buf bytes.Buffer<span class="hljs-keyword">for</span> _, comment := <span class="hljs-keyword">range</span> group.List &#123;    <span class="hljs-comment">// 注释信息会以 // 参数名，开始，我们实际使用时不需要，去掉</span>text := strings.TrimSpace(strings.TrimPrefix(comment.Text, fmt.Sprintf(<span class="hljs-string">"// %s"</span>, name)))buf.WriteString(text)&#125;<span class="hljs-comment">// replace any invisibles with blanks</span>bytes := buf.Bytes()<span class="hljs-keyword">for</span> i, b := <span class="hljs-keyword">range</span> bytes &#123;<span class="hljs-keyword">switch</span> b &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">'\t'</span>, <span class="hljs-string">'\n'</span>, <span class="hljs-string">'\r'</span>:bytes[i] = <span class="hljs-string">' '</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(bytes)&#125;</code></pre><h3 id="3-生成代码"><a href="#3-生成代码" class="headerlink" title="3. 生成代码"></a>3. 生成代码</h3><pre><code class="hljs go"><span class="hljs-keyword">const</span> suffix = <span class="hljs-string">"_msg_gen.go"</span><span class="hljs-comment">// tpl 生成代码需要用到模板</span><span class="hljs-keyword">const</span> tpl = <span class="hljs-string">`// Code generated by github.com/mohuishou/gen-const-msg DO NOT EDIT// &#123;&#123;.pkg&#125;&#125; const code comment msgpackage &#123;&#123;.pkg&#125;&#125;// noErrorMsg if code is not found, GetMsg will return thisconst noErrorMsg = "unknown error"// messages get msg from const commentvar messages = map[int]string&#123;&#123;&#123;range $key, $value := .comments&#125;&#125;&#123;&#123;$key&#125;&#125;: "&#123;&#123;$value&#125;&#125;",&#123;&#123;end&#125;&#125;&#125;// GetMsg get error msgfunc GetMsg(code int) string &#123;var (msg stringok  bool)if msg, ok = messages[code]; !ok &#123;msg = noErrorMsg&#125;return msg&#125;`</span><span class="hljs-comment">// gen 生成代码</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gen</span><span class="hljs-params">(comments <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;  <span class="hljs-keyword">var</span> buf = bytes.NewBufferString(<span class="hljs-string">""</span>)  data := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;    <span class="hljs-string">"pkg"</span>:      os.Getenv(<span class="hljs-string">"GOPACKAGE"</span>),    <span class="hljs-string">"comments"</span>: comments,  &#125;  t, err := template.New(<span class="hljs-string">""</span>).Parse(tpl)  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.Wrapf(err, <span class="hljs-string">"template init err"</span>)  &#125;  err = t.Execute(buf, data)  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.Wrapf(err, <span class="hljs-string">"template data err"</span>)  &#125;  <span class="hljs-keyword">return</span> format.Source(buf.Bytes())&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从一个简单的效率需求引申到<code>go generate</code>和<code>ast</code>的使用，顺便阅读了一下<code>ast</code>的源码，花费的时间其实可能是这个工具节约的时间的几倍了，但是收获也是之前没有想到的。</p><ol><li>使用了这么久的<code>go</code>命令，详细的阅读了<code>go help command</code>的说明之后，发现之前可能连了解都算不上</li><li>标准库的<code>godoc</code>是最好的使用说明，第二好的是它的源代码</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://github.com/mohuishou/go-const-msg" target="_blank" rel="noopener">go-const-msg 本文实现的源代码</a></p></li><li><p><a href="https://yushuangqi.com/blog/2017/go-command-generate.html" target="_blank" rel="noopener">Golang Generate 命令说明与使用</a></p></li><li><p><a href="https://golang.org/pkg/go/ast/" target="_blank" rel="noopener">AST 标准库文档</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/28516587" target="_blank" rel="noopener">Go 的 AST(抽象语法树)</a></p></li><li><p><a href="https://blog.golang.org/generate" target="_blank" rel="noopener">GO 官方博客: Generating code</a></p></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>tool</tag>
      
      <tag>generate</tag>
      
      <tag>ast</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo-next-algolia-search全文搜索</title>
    <link href="/post/27142.html"/>
    <url>/post/27142.html</url>
    
    <content type="html"><![CDATA[<p>在 hexo 中通过 algolia 实现全文搜索</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>The latest version of the Hexo-Algolia plugin removes the content indexing feature, given Algolia’s free account limitation.</p></blockquote><p>通过主题官方的<a href="https://theme-next.org/docs/third-party-services/search-services" target="_blank" rel="noopener">文档</a>我们发现，全文索引的功能已经被移除了，原因是因为会出现<code>Record Too Big</code>的报错，查阅 algolia 的<a href="https://www.algolia.com/doc/faq/basics/is-there-a-size-limit-for-my-index-records" target="_blank" rel="noopener">文档</a>我们可以发现免费账号，单条索引的上限为<code>10kB</code>, 商业版用户的索引上限为<code>20KB</code></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><blockquote><p>请先按照上文提到的主题配置说明配置之后进行如下操作</p></blockquote><ol><li><p>替换插件</p><p>在<code>package.json</code>中替换下面这一行</p><pre><code class="hljs json">"hexo-algolia": "https://github.com/mohuishou/hexo-algolia"</code></pre></li><li><p>修改主题文件<code>themes\next\source\js\algolia-search.js</code></p><p>将<code>instantsearch.widgets.hits</code>方法中, item 对应的返回值替换为以下内容</p><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> (  <span class="hljs-string">'&lt;a href="'</span> +  link +  <span class="hljs-string">'" class="algolia-hit-item-link"&gt;'</span> +  <span class="hljs-string">'&lt;div class="algolia-hit-item-title"&gt;'</span> +  data._highlightResult.title.value +  <span class="hljs-string">"&lt;/div&gt;"</span> +  <span class="hljs-string">'&lt;div class="algolia-hit-item-content"&gt;'</span> +  data._snippetResult.raw.value +  <span class="hljs-string">"&lt;/div&gt;"</span> +  <span class="hljs-string">"&lt;/a&gt;"</span>);</code></pre><p>这两步做完其实就已经完成的了全文索引，但是搜索结果会把所有内容返回，我们其实只需要匹配关键词附近的结果</p></li><li><p>开启 Attributes to snippet 特性</p><p>如下图所示点击索引-&gt;配置， 然后再到左侧列表中选中<code>Snippeting</code></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190410234147.png" srcset="/img/loading.gif" alt></p><p>然后如图所示添加字段<code>raw</code>, 右侧为显示的字符数，可以根据需求修改</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190410234453.png" srcset="/img/loading.gif" alt></p><p>到这里就大功告成了，但是关键词还不够突出，可以再做一些美化</p></li><li><p>美化搜索结果</p><p>在<code>source/_data</code>中新增<code>styles.styl</code>文件</p><pre><code class="hljs css"><span class="hljs-selector-tag">em</span> &#123;  <span class="hljs-attribute">color</span>: red;  <span class="hljs-attribute">font-style</span>: normal;&#125;<span class="hljs-selector-class">.algolia-hit-item-title</span> &#123;  <span class="hljs-attribute">font-weight</span>: bold;&#125;<span class="hljs-selector-class">.algolia-hit-item-content</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.8em</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#555</span>;&#125;</code></pre><p>修改<code>_config.yml</code></p><pre><code class="hljs yaml"><span class="hljs-attr">theme_config:</span>  <span class="hljs-attr">custom_file_path:</span>    <span class="hljs-attr">styles:</span> <span class="hljs-string">source/_data/styles.styl</span></code></pre><p>ok! 大功告成</p></li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ol><li><p>优化前:</p><blockquote><p>随意找了一个博客的截图，显示只有标题，没有的高亮以及详情<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190411000323.png" srcset="/img/loading.gif" alt></p></blockquote></li><li><p>优化后:<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190410235215.png" srcset="/img/loading.gif" alt></p></li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>原理其实很简单，获取文章原始<code>markdown</code>内容，判断大小如果超过指定大小(默认 8K)就进行截断</p><pre><code class="hljs javascript"><span class="hljs-comment">// 获取原始内容</span><span class="hljs-keyword">var</span> rawBuf = <span class="hljs-keyword">new</span> Buffer(data.raw);<span class="hljs-comment">// 获取大小限制</span><span class="hljs-keyword">var</span> rowSize = options.maxRawSize * <span class="hljs-number">1024</span>;<span class="hljs-keyword">if</span> (rawBuf.length &gt; rowSize) &#123;  <span class="hljs-comment">// 超出限制，进行截断</span>  storedPost.raw = rawBuf.toString(<span class="hljs-string">"utf8"</span>, <span class="hljs-number">0</span>, rowSize);  <span class="hljs-comment">// 去除最后一个字符</span>  <span class="hljs-comment">// 由于截断是按照字节截断的，但是一个中文字符不止一个字节，可能会导致最后一个字符乱码</span>  storedPost.raw = storedPost.raw.substring(<span class="hljs-number">0</span>, storedPost.raw.length - <span class="hljs-number">1</span>);&#125;</code></pre><p>详情可以查看 PR: <a href="https://github.com/oncletom/hexo-algolia/pull/39/files" target="_blank" rel="noopener">Feature/add raw max len</a></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/51252.html">docker镜像瘦身&优化</a></li><li><a href="https://lailin.xyz/post/60163.html">GORM避坑指南之含关联关系的更新</a></li><li><a href="https://lailin.xyz/post/28054.html">Github Actions介绍&自动构建Github Pages博客</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
      <tag>next</tag>
      
      <tag>algolia</tag>
      
      <tag>search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker镜像瘦身&amp;优化</title>
    <link href="/post/51252.html"/>
    <url>/post/51252.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>为什么在存储如此便宜的今天我们仍然需要对 Docker 镜像进行瘦身?</p></blockquote><a id="more"></a><blockquote><p>PS: 本文篇幅较长，请酌情观看</p></blockquote><h2 id="小镜像的优点"><a href="#小镜像的优点" class="headerlink" title="小镜像的优点"></a>小镜像的优点</h2><ol><li><p>加速构建/部署</p><p>虽然存储资源较为廉价，但是网络 IO 是有限的，在带宽有限的情况下，部署一个 1G 的镜像和 10M 的镜像带来的时间差距可能就是分钟级和秒级的差距。特别是在<strong>出现故障</strong>，服务被调度到其他节点时，这个时间尤为宝贵。</p></li><li><p>提高安全性，减少攻击面积</p><p>越小的镜像表示无用的程序越少，可以大大的减少被攻击的目标</p></li><li><p>减少存储开销</p></li></ol><h2 id="小镜像的制作原则"><a href="#小镜像的制作原则" class="headerlink" title="小镜像的制作原则"></a>小镜像的制作原则</h2><ol><li><p>选用最小的基础镜像</p></li><li><p>减少层，去除非必要的文件</p><p>在实际制作镜像的过程中，一味的合并层不可取，需要学会充分的利用 Docker 的缓存机制，提取公共层，加速构建。</p><ul><li><strong>依赖文件和实际的代码文件单独分层</strong></li><li><strong>团队/公司采用公共的基础镜像等</strong></li></ul></li><li><p>使用多阶段构建</p><p>往往我们在构建阶段和实际运行阶段需要的依赖环境是不同的，例如<code>golang</code>编写的程序实际运行的时候仅仅需要一个二进制文件即可，对于<code>Node</code>来说，可能最后运行的只是一些打包之后的<code>js</code>文件而不需要包含<code>node_modules</code>里成千上万的依赖</p></li></ol><h2 id="基础镜像"><a href="#基础镜像" class="headerlink" title="基础镜像"></a>基础镜像</h2><ul><li><p><a href="https://github.com/GoogleCloudPlatform/distroless" target="_blank" rel="noopener">distroless</a></p><blockquote><p>“Distroless” images contain only your application and its runtime dependencies. They do not contain package managers, shells or any other programs you would expect to find in a standard Linux distribution.</p></blockquote><p><code>distroless</code>是 Google 推出的一个仅仅包含运行时环境，不包含包管理器，<code>shell</code>等其他程序。如果你的程序没有其他依赖的话，这是一个不错的选择</p></li><li><p><a href="https://hub.docker.com/_/alpine" target="_blank" rel="noopener">alpine</a></p><blockquote><p>Alpine Linux is a security-oriented, lightweight Linux distribution based on musl libc and busybox.</p></blockquote><p>alpine 是一个基于<code>musl</code>, <code>busybox</code>的安全的<code>linux</code>发行版。麻雀虽小五脏俱全，虽然不到 10M, 但是包含了一个包管理器和<code>shell</code>环境，这在我们实际的使用调试当中将非常有用。</p><p>但是请注意，由于<code>alpine</code>使用了更小的<code>muslc</code>替代<code>glibc</code>，会导致某些应用无法使用，需要重新编译</p></li><li><p><a href="https://hub.docker.com/_/scratch" target="_blank" rel="noopener">scratch</a></p><p>scratch 是空白镜像，一般用于基础镜像构建，例如<code>alpine</code>镜像的<code>dockerfile</code>便是从<code>scratch</code>开始的</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> scratch<span class="hljs-keyword">ADD</span><span class="bash"> alpine-minirootfs-20190228-x86_64.tar.gz /</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"/bin/sh"</span>]</span></code></pre></li><li><p><a href="https://hub.docker.com/_/busybox" target="_blank" rel="noopener">busybox</a></p></li></ul><p>一般而言，<code>distroless</code>相对会更加的安全，但是在实际使用的过程中可能会遇到添加依赖以及调试方面的问题，<code>alpine</code>更小，自带包管理器，更加贴合使用习惯，但是<code>muslc</code>可能会带来兼容性的问题，一般而言我会选择<code>alpine</code>作为基础镜像使用。</p><p>除此之外，在<a href="https://hub.docker.com" target="_blank" rel="noopener">Docker Hub</a>当中我们可以发现常用的<code>Debian</code>的镜像也会提供的只包含基础功能的小镜像</p><h3 id="基础镜像对比"><a href="#基础镜像对比" class="headerlink" title="基础镜像对比"></a>基础镜像对比</h3><p>此处直接拉取基础镜像，查看镜像大小， 通过观察我们可以发现，<code>alpine</code>只有 5M 左右为<code>debian</code>的 20 分之一</p><pre><code class="hljs bash">alpine      latest    5cb3aa00f899        3 weeks ago         5.53MBdebian      latest    0af60a5c6dd0        3 weeks ago         101MBubuntu      18.04     47b19964fb50        7 weeks ago         88.1MBubuntu      latest    47b19964fb50        7 weeks ago         88.1MBalpine      3.8       3f53bb00af94        3 months ago        4.41MB</code></pre><p>似乎从上面看，感觉差距不大，实践中，不同语言的基础镜像都会提供一些采用不同基础镜像制作的 tag，下面我们以<code>ruby</code>的镜像为例，查看不同基础镜像的差异。可以看到默认的 latest 镜像<code>881MB</code>而<code>alpine</code>仅仅只有不到<code>50MB</code>这个差距就十分的可观了</p><pre><code class="hljs bash">ruby   latest   a5d26127d8d0        4 weeks ago         881MBruby   alpine   8d8f7d19d1fa        4 weeks ago         47.8MBruby   slim     58dd4d3c99da        4 weeks ago         125MB</code></pre><h2 id="减少层，去除非必要的文件"><a href="#减少层，去除非必要的文件" class="headerlink" title="减少层，去除非必要的文件"></a>减少层，去除非必要的文件</h2><ol><li>删除文件不要跨行</li></ol><pre><code class="hljs dockerfile"><span class="hljs-comment"># dockerfile 1</span><span class="hljs-keyword">FROM</span> alpine<span class="hljs-keyword">RUN</span><span class="bash"> wget https://github.com/mohuishou/scuplus-wechat/archive/1.0.0.zip</span><span class="hljs-comment"># dockerfile 2</span><span class="hljs-keyword">FROM</span> alpine<span class="hljs-keyword">RUN</span><span class="bash"> wget https://github.com/mohuishou/scuplus-wechat/archive/1.0.0.zip</span><span class="hljs-keyword">RUN</span><span class="bash"> rm 1.0.0.zip</span><span class="hljs-comment"># dockerfile 3</span><span class="hljs-keyword">FROM</span> alpine<span class="hljs-keyword">RUN</span><span class="bash"> wget https://github.com/mohuishou/scuplus-wechat/archive/1.0.0.zip &amp;&amp;  rm 1.0.0.zip</span></code></pre><pre><code class="hljs bash"><span class="hljs-built_in">test</span>   3  351a80e99c22        5 seconds ago        5.53MB<span class="hljs-built_in">test</span>   2  ad27e625b8e5        49 seconds ago       6.1MB<span class="hljs-built_in">test</span>   1  165e2e0df1d3        About a minute ago   6.1MB</code></pre><p>可以发现 1，2 两个大小一样，但是 3 小了 0.5MB，这是因为 docker 几乎每一行命令都会生成一个层，删除文件的时候：因为底下各层都是只读的，当需要删除这些层中的文件时，AUFS 使用 whiteout 机制，它的实现是通过在上层的可写的目录下建立对应的 whiteout 隐藏文件来实现的，所以在当前层去删除上一层的文件，只是会把这个文件隐藏掉罢了</p><ol start="2"><li>使用单行命令</li></ol><p>除了删除语句需要放在一行以外，由于层的机制，我们安装依赖的一些公共的语句最好也使用条<code>RUN</code>命令生成，减少最终的层数</p><ol start="3"><li><p>分离依赖包，以及源代码程序，充分利用层的缓存</p><p>这是一个<strong>最佳实践</strong>，在实际的开发过程中，我们的依赖包往往是变动不大的，但是我们正在开发的源码的变动是较为频繁，如果我们实际的代码只有<code>10M</code>，但是依赖项有<code>1G</code>, 如果在<code>COPY</code>的时候直接<code>COPY . .</code>会导致每次修改代码都会时这一层的缓存失效，导致浪费复制以及推送到镜像仓库的时间，将 COPY 语句分开，每次 push 就可以只变更我们频繁修改的代码层，而不是连着依赖一起</p></li><li><p>使用<code>.dockerignore</code></p><p>在使用<code>Git</code>时，我们可以通过<code>.gitignore</code>忽略文件，在 docker build 的时候也可以使用<code>.dockerignore</code>在 Docker 上下文中忽略文件，这样不仅可以减少一些非必要文件的导入，也可以提高安全性，避免将一些配置文件打包到镜像中</p></li></ol><h2 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h2><p>多阶段构建其实也是减少层的一种，通过多阶段构建，最终镜像可以仅包含最后生成的可执行文件，和必须的运行时依赖，大大减少镜像体积。</p><p>以<code>GO</code>语言为例，实际运行的过程中只需要最后编译生成的二进制文件即可，而<code>GO</code>语言本省以及扩展包，代码文件都是不必要的，但是我们在编译的时候这些依赖又是必须的，这时候就可以使用多阶段构建的方式，减少最终生成的镜像体积</p><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用golang镜像作为builder镜像</span><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.12</span> as builder<span class="hljs-keyword">WORKDIR</span><span class="bash"> /go/src/github.com/go/helloworld/</span><span class="hljs-keyword">COPY</span><span class="bash"> app.go .</span><span class="hljs-keyword">RUN</span><span class="bash"> go build -o app .</span><span class="hljs-comment"># 编译完成之后使用alpine镜像作为最终的基础镜像</span><span class="hljs-keyword">FROM</span> alpine:latest as prod<span class="hljs-keyword">RUN</span><span class="bash"> apk --no-cache add ca-certificates</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /root/</span><span class="hljs-comment"># 从builder中复制编译好的二进制文件</span><span class="hljs-keyword">COPY</span><span class="bash"> --from=builder /go/src/github.com/go/helloworld/app .</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"./app"</span>]</span></code></pre><p>由于本文篇幅较长，这里不对多阶段构建展开讲解，详情可以参考<a href="https://yeasy.gitbooks.io/docker_practice/image/multistage-builds/#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA" target="_blank" rel="noopener">多阶段构建</a></p><h2 id="奇淫技巧"><a href="#奇淫技巧" class="headerlink" title="奇淫技巧"></a>奇淫技巧</h2><ol><li><p>使用<a href="https://github.com/wagoodman/dive" target="_blank" rel="noopener">dive</a>查看 docker 镜像的层，可以帮助你分析减少镜像体积</p></li><li><p>使用<a href="https://github.com/docker-slim/docker-slim" target="_blank" rel="noopener">docker-slim</a> 可以自动帮助你减少镜像体积，对于 Web 应用较为有用</p></li><li><p>安装软件时去除依赖</p></li></ol><pre><code class="hljs bash"><span class="hljs-comment"># ubuntu</span>apt-get install -y — no-install-recommends<span class="hljs-comment">#alpine</span>apk add --no-cache &amp;&amp;  apk del build-dependencies<span class="hljs-comment"># centos</span>yum install -y ... &amp;&amp; yum clean all</code></pre><ol start="4"><li><p>使用<code>--flatten</code>参数，减少层(不推荐)</p></li><li><p>使用<a href="https://github.com/jwilder/docker-squash" target="_blank" rel="noopener">docker-squash</a>压缩层</p></li></ol><h2 id="不同语言的示例"><a href="#不同语言的示例" class="headerlink" title="不同语言的示例"></a>不同语言的示例</h2><blockquote><p>添加中……</p></blockquote><h3 id="Ruby-Rails"><a href="#Ruby-Rails" class="headerlink" title="Ruby(Rails)"></a>Ruby(Rails)</h3><ol><li><p>只安装生产所需的依赖</p></li><li><p>删除不需要的依赖文件</p></li></ol><pre><code class="hljs bash">bundle install --without development:<span class="hljs-built_in">test</span>:assets -j4 --retry 3 --path=vendor/bundle \    <span class="hljs-comment"># Remove unneeded files (cached *.gem, *.o, *.c)</span>    &amp;&amp; rm -rf vendor/bundle/ruby/2.5.0/cache/*.gem \    &amp;&amp; find vendor/bundle/ruby/2.5.0/gems/ -name <span class="hljs-string">"*.c"</span> -delete \    &amp;&amp; find vendor/bundle/ruby/2.5.0/gems/ -name <span class="hljs-string">"*.o"</span> -delete</code></pre><ol start="3"><li>删除前端的<code>node_modules</code>以及缓存文件</li></ol><pre><code class="hljs bash">rm -rf node_modules tmp/cache app/assets vendor/assets spec</code></pre><p>上述内容可以结合<strong>多阶段构建</strong>实现</p><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>Golang 在使用多阶段构建之后，只剩下了一个二进制文件，这时候再要优化，就只有使用<code>upx</code>之类的工具压缩二进制文件的体积了</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://dockone.io/article/8174" target="_blank" rel="noopener">Docker 容器镜像瘦身的三个小窍门</a></li><li><a href="https://liulantao.com/docker-base-images.html" target="_blank" rel="noopener">基础镜像 | 再谈 Docker 瘦身</a></li><li><a href="https://legacy.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="noopener">Docker —— 从入门到实践</a>这是一本很不错的 Docker 开源书</li><li><a href="https://jingwei.link/2018/07/18/docker-namespace-cgroups-aufs.html#aufs" target="_blank" rel="noopener">Docker 基本原理简析</a></li><li><a href="https://medium.com/@lemuelbarango/ruby-on-rails-smaller-docker-images-bff240931332" target="_blank" rel="noopener">Ruby on Rails — Smaller docker images</a></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/27142.html">hexo-next-algolia-search全文搜索</a></li><li><a href="https://lailin.xyz/post/60163.html">GORM避坑指南之含关联关系的更新</a></li><li><a href="https://lailin.xyz/post/28054.html">Github Actions介绍&自动构建Github Pages博客</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>docker</tag>
      
      <tag>cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GORM避坑指南之含关联关系的更新</title>
    <link href="/post/60163.html"/>
    <url>/post/60163.html</url>
    
    <content type="html"><![CDATA[<p>在 GORM 的<a href="http://gorm.io/docs/update.html" target="_blank" rel="noopener">文档</a>当中有说明，使用<code>Update</code>, <code>Updates</code>时只会更新改变的字段，但是出现关联关系的时候情况似乎有了一些微妙的变化</p><blockquote><p>If you only want to update changed Fields, you could use <code>Update</code>, <code>Updates</code></p></blockquote><a id="more"></a><h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><p><code>db.Model(&amp;user).Update(&quot;name&quot;, &quot;hello&quot;)</code>如果<code>user</code>包含关联关系，<code>user</code>的关联关系将被自动更新</p><h2 id="避坑"><a href="#避坑" class="headerlink" title="避坑"></a>避坑</h2><p><strong>1.如果确认不会使用到关联相关的回调，可以直接使用<code>UpdateColumn</code>,<code>UpdateColumns</code>方法</strong></p><p>下面是来自<a href="http://gorm.io/docs/update.html#Update-Columns-w-o-Hooks" target="_blank" rel="noopener">官方文档</a>的例子:</p><pre><code class="hljs go"><span class="hljs-comment">// Update single attribute, similar with `Update`</span>db.Model(&amp;user).UpdateColumn(<span class="hljs-string">"name"</span>, <span class="hljs-string">"hello"</span>)<span class="hljs-comment">//// UPDATE users SET name='hello' WHERE id = 111;</span><span class="hljs-comment">// Update multiple attributes, similar with `Updates`</span>db.Model(&amp;user).UpdateColumns(User&#123;Name: <span class="hljs-string">"hello"</span>, Age: <span class="hljs-number">18</span>&#125;)<span class="hljs-comment">//// UPDATE users SET name='hello', age=18 WHERE id = 111;</span></code></pre><p><strong>2.如果需要用到相关的回调，可以手动指定<code>Model</code>里面的结构体</strong></p><pre><code class="hljs go">db.Model(&amp;User&#123;Model: Model&#123;ID: <span class="hljs-number">1</span>&#125;&#125;).UpdateColumn(<span class="hljs-string">"name"</span>, <span class="hljs-string">"hello"</span>)</code></pre><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>下面这一段是官方文档中的例子，只会更新更新<code>users</code>表的<code>name</code>字段</p><pre><code class="hljs go"><span class="hljs-comment">// Update single attribute if it is changed</span>db.Model(&amp;user).Update(<span class="hljs-string">"name"</span>, <span class="hljs-string">"hello"</span>)<span class="hljs-comment">//// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111;</span></code></pre><p>但是如果<code>Model(&amp;struct)</code>,<code>struct</code>包含关联关系时，<code>struct</code>关联关系将被更新，如以下所示:</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Product <span class="hljs-keyword">struct</span> &#123;gorm.ModelCode         <span class="hljs-keyword">string</span>Price        <span class="hljs-keyword">uint</span>Applications []Application&#125;<span class="hljs-keyword">type</span> Application <span class="hljs-keyword">struct</span> &#123;gorm.ModelName      <span class="hljs-keyword">string</span>ProductID <span class="hljs-keyword">uint</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// Migrate the schema</span>db.AutoMigrate(&amp;Product&#123;&#125;, &amp;Application&#123;&#125;)<span class="hljs-comment">// Create</span>db.Create(&amp;Product&#123;Code: <span class="hljs-string">"L1212"</span>, Price: <span class="hljs-number">1000</span>&#125;)<span class="hljs-comment">// Read</span><span class="hljs-keyword">var</span> product Productdb.First(&amp;product, <span class="hljs-number">1</span>) <span class="hljs-comment">// find product with id 1</span>product.Applications = []Application&#123;&#123;Name: <span class="hljs-string">"test"</span>,&#125;,&#125;<span class="hljs-comment">// Update - update product's price to 2000</span>db.Model(&amp;product).Update(<span class="hljs-string">"Price"</span>, <span class="hljs-number">1000</span>)    <span class="hljs-comment">// UPDATE products SET price = '1000', updated_at = '2019-01-29 21:58:52'  WHERE products.deleted_at IS NULL</span><span class="hljs-comment">// INSERT INTO applications (created_at,updated_at,deleted_at,name,product_id) VALUES ('2019-01-29 21:58:52','2019-01-29 21:58:52',NULL,'test','0')</span>&#125;</code></pre><h2 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h2><blockquote><p>该部分默认对 GORM 的源码有一定的了解</p></blockquote><p>查看<code>Model</code>相关的源码，我们可以发现<code>Model</code>其实就是<code>clone</code>了一个<code>DB</code>对象然后将传入的指针赋值给<code>Value</code></p><pre><code class="hljs go"><span class="hljs-comment">// Model specify the model you would like to run db operations</span><span class="hljs-comment">//    // update all users's name to `hello`</span><span class="hljs-comment">//    db.Model(&amp;User&#123;&#125;).Update("name", "hello")</span><span class="hljs-comment">//    // if user's primary key is non-blank, will use it as condition, then will only update the user's name to `hello`</span><span class="hljs-comment">//    db.Model(&amp;user).Update("name", "hello")</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *DB)</span> <span class="hljs-title">Model</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> *<span class="hljs-title">DB</span></span> &#123;c := s.clone()c.Value = value<span class="hljs-keyword">return</span> c&#125;</code></pre><p>查看<code>Update/Updates</code>相关的源码我们可以发现，这里讲需要更新的字段通过<code>InstanceSet(&quot;gorm:update_interface&quot;, values)</code>保存了下来</p><pre><code class="hljs go"><span class="hljs-comment">// Update update attributes with callbacks, refer: https://jinzhu.github.io/gorm/crud.html#update</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *DB)</span> <span class="hljs-title">Update</span><span class="hljs-params">(attrs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> *<span class="hljs-title">DB</span></span> &#123;<span class="hljs-keyword">return</span> s.Updates(toSearchableMap(attrs...), <span class="hljs-literal">true</span>)&#125;<span class="hljs-comment">// Updates update attributes with callbacks, refer: https://jinzhu.github.io/gorm/crud.html#update</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *DB)</span> <span class="hljs-title">Updates</span><span class="hljs-params">(values <span class="hljs-keyword">interface</span>&#123;&#125;, ignoreProtectedAttrs ...<span class="hljs-keyword">bool</span>)</span> *<span class="hljs-title">DB</span></span> &#123;<span class="hljs-keyword">return</span> s.NewScope(s.Value).Set(<span class="hljs-string">"gorm:ignore_protected_attrs"</span>, <span class="hljs-built_in">len</span>(ignoreProtectedAttrs) &gt; <span class="hljs-number">0</span>).InstanceSet(<span class="hljs-string">"gorm:update_interface"</span>, values).callCallbacks(s.parent.callbacks.updates).db&#125;</code></pre><p>再看看关联关系更新的代码， 只有一个参数<code>scope</code>,<code>scope</code>哪儿来的呢，上面的<code>s.NewScope(s.Value)</code>,这个地方其实也是将最开始<code>Model</code>中的 <code>value</code>拷贝了一份</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">saveAfterAssociationsCallback</span><span class="hljs-params">(scope *Scope)</span></span> &#123;    <span class="hljs-comment">// 判断是否存在关系关系然后更新bala bala...</span>    <span class="hljs-keyword">for</span> _, field := <span class="hljs-keyword">range</span> scope.Fields() &#123;autoUpdate, autoCreate, saveReference, relationship := saveAssociationCheck(scope, field)        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-comment">//...</span>&#125;</code></pre><p>看到这个了差不多就可明白了，主要原因是因为<code>Model</code>的<code>value</code>一直跟随到了最后，导致最后执行关联关系更新回调的时候，检测到有关联数据数据表中不存在，就会自然的根据关联关系插入进去</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ol><li>目前还不清楚这是一个 bug 还是一个 feature，先提交了一个 issue: <a href="https://github.com/jinzhu/gorm/issues/2278" target="_blank" rel="noopener">https://github.com/jinzhu/gorm/issues/2278</a></li><li><a href="https://lailin.xyz/post/notes/%E4%B8%80%E4%B8%AA%E5%8D%81%E5%88%86%E8%BE%B9%E7%BC%98%E7%9A%84gorm%E7%9A%84bug/">一个十分边缘的 gorm 的 bug</a></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>go</tag>
      
      <tag>note</tag>
      
      <tag>gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github Actions介绍&amp;自动构建Github Pages博客</title>
    <link href="/post/28054.html"/>
    <url>/post/28054.html</url>
    
    <content type="html"><![CDATA[<p>本文将主要讲述如何创建一个自定义的 Github Actions， 并且使用 Github Actions 完成 CI/CD 的操作</p><a id="more"></a><blockquote><p>故事的起因就是，github 的私有仓库免费了, 打算将 blog 仓库切换为私有仓库，这样可以同时将笔记和博客放在一块，利用 hugo 的 draft 功能，将不想发布的文章设置 true 即可。</p><p>修改之后由于之前使用 Travis CI 自动构建博客的静态页面，而 Travis CI 对于私有仓库只能试用 100 次，正好之前获得了 Github Actions 的测试资格，但是一直都还没有使用过，本次记录一下 Github Actions 的使用过程</p></blockquote><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>actions 可以用来作为 CI/CD 使用，但是它不只是 CI/CD，因为它其实是一组 docker 容器所组成的 Workflow，Workflow 的触发条件，公共仓库目前仅支持 push，私有仓库则支持 check_run、create、delete、issue comment， commit comment, pull request 等许多事件, 通过这些事件，可以完成除了 CI/CD 之外的许多自动化操作，例如接收到 issue comment 之后使用 telegram bot 发送通知等等</p><h3 id="创建一个-Workflow"><a href="#创建一个-Workflow" class="headerlink" title="创建一个 Workflow"></a>创建一个 Workflow</h3><p>如果你有权限的话，在你的仓库下应该可以看到一个 Actions 的菜单</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190115223805.png" srcset="/img/loading.gif" alt></p><h3 id="Workflow-GUI"><a href="#Workflow-GUI" class="headerlink" title="Workflow GUI"></a>Workflow GUI</h3><p>如下图所示</p><ol><li>切换视图，从左到右分别是，GUI 的方式编辑，直接编辑文件，查看变动</li><li>workflow 区域，一个 main.workflow 文件下可以包含多个 workflow，每一个 workflow</li><li>每个 workflow 具体的编辑区域，每个 workflow 可以关联多个 action，每个 action 都有头尾两个点，点击下拉即可连接起来</li><li>保存提交按钮</li></ol><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190115224518.png" srcset="/img/loading.gif" alt></p><h4 id="Workflow-edit"><a href="#Workflow-edit" class="headerlink" title="Workflow edit"></a>Workflow edit</h4><p>如下图所示，workflow 只有两个可选的修改项，分别是 Name 以及触发条件，触发条件公共仓库目前仅支持 push，私有仓库则支持 check_run、create、delete、issue comment， commit comment, pull request 等许多事件。完整的触发条件可以查看 <a href="https://developer.github.com/actions/creating-workflows/workflow-configuration-options/#events-supported-in-workflow-files" target="_blank" rel="noopener">Events supported in workflow files</a></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190115230105.png" srcset="/img/loading.gif" alt></p><h4 id="action-edit"><a href="#action-edit" class="headerlink" title="action edit"></a>action edit</h4><p>如下图所示</p><ol><li>uses 使用的 docker 镜像, 在 <a href="https://github.com/actions" target="_blank" rel="noopener">https://github.com/actions</a> 提供了一些常用的 actions 可以直接使用<ol><li><code>{user}/{repo}/{path}@{ref}</code> 直接使用公开的仓库，仓库里必须包含 dockerfile, path 为可选项，没有 path 默认为根路径，e.g <code>actions/heroku@master</code>, <a href="mailto:`actions/aws/ec2@v2.0.1" target="_blank" rel="noopener">`actions/aws/ec2@v2.0.1</a>`</li><li><code>./path/to/dir</code>当前仓库的相对路径</li><li><code>docker://{host}/{image}:{tag}</code> docker 镜像地址，host 为可选项，不填 host 默认从 dockerhub 拉取，e.g <code>docker://mohuishou/hugo:0.53</code>, <code>docker://gcr.io/cloud-builders/gradle</code></li></ol></li><li>label 就是标签</li><li>runs 覆盖 dockerfile 中的 entrypoint</li><li>args 覆盖 dockerfile 中的 cmd</li><li>secret 读取该仓库保存的秘密变量，将以环境变量的形式注入到运行的容器中</li><li>env 注入到运行的容器中的环境变量，是可见的</li></ol><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/20190116000345.png" srcset="/img/loading.gif" alt></p><h3 id="创建-Action"><a href="#创建-Action" class="headerlink" title="创建 Action"></a>创建 Action</h3><p>Action 其实就是 Docker 镜像，按照 Docker 镜像的写法即可，需要关注以下几点</p><h4 id="1-Dockerfile-Lables"><a href="#1-Dockerfile-Lables" class="headerlink" title="1. Dockerfile Lables"></a>1. Dockerfile Lables</h4><p>github actions 会读取 dockerfile 的 label 在 Workflow GUI 上做一些展示</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">"com.github.actions.name"</span>=<span class="hljs-string">""</span> <span class="hljs-comment">#Github action 的名字</span></span><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">"com.github.actions.description"</span>=<span class="hljs-string">"desc"</span> <span class="hljs-comment">#说明</span></span><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">"com.github.actions.icon"</span>=<span class="hljs-string">"mic"</span> <span class="hljs-comment">#GUI上展示的图标</span></span><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">"com.github.actions.color"</span>=<span class="hljs-string">"purple"</span> <span class="hljs-comment"># GUI上展示的颜色</span></span><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">"repository"</span>=<span class="hljs-string">"http://github.com/mohuishou/hugo-action"</span> <span class="hljs-comment"># 仓库地址</span></span><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">"homepage"</span>=<span class="hljs-string">"http://github.com/mohuishou"</span> <span class="hljs-comment"># 主页</span></span><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">"maintainer"</span>=<span class="hljs-string">"mohuishou &lt;1@lailin.xyz&gt;"</span> <span class="hljs-comment"># 作者</span></span></code></pre><h4 id="2-Env"><a href="#2-Env" class="headerlink" title="2. Env"></a>2. Env</h4><p>默认的环境变量，以及如何读取</p><h5 id="默认环境变量"><a href="#默认环境变量" class="headerlink" title="默认环境变量"></a>默认环境变量</h5><p>所有的默认值可以参考这里 <a href="https://developer.github.com/actions/creating-github-actions/accessing-the-runtime-environment/#environment-variables" target="_blank" rel="noopener">Environment variables</a></p><p>常用的主要有</p><table><thead><tr><th>Environment variable</th><th>Description</th></tr></thead><tbody><tr><td><code>GITHUB_ACTOR</code></td><td>用户的名字</td></tr><tr><td><code>GITHUB_REPOSITORY</code></td><td>用户和仓库的地址 例如 <code>mohuishou/hugo-action</code></td></tr><tr><td><code>GITHUB_WORKSPACE</code></td><td>github 的工作区， 默认值为 <code>/github/workspace</code></td></tr><tr><td><code>GITHUB_TOKEN</code></td><td>workflow 的 github token 可以用来 clone 拉取数据，但是没有 push 的权限</td></tr></tbody></table><h5 id="读取环境变量"><a href="#读取环境变量" class="headerlink" title="读取环境变量"></a>读取环境变量</h5><p>读取环境变量时需要注意，环境变量是在容器运行时注入的，所以在 dockerfile 里面没有办法直接使用</p><h2 id="使用-hugo-action-自动-build-amp-push-博客"><a href="#使用-hugo-action-自动-build-amp-push-博客" class="headerlink" title="使用 hugo-action 自动 build&amp;push 博客"></a>使用 hugo-action 自动 build&amp;push 博客</h2><p><a href="https://github.com/mohuishou/hugo-action" target="_blank" rel="noopener">https://github.com/mohuishou/hugo-action</a></p><h3 id="遵循以下约定"><a href="#遵循以下约定" class="headerlink" title="遵循以下约定"></a>遵循以下约定</h3><ol><li>你的博客源代码地址和 github pages 地址不同</li><li>github pages 仓库地址为 <code>youname.github.io</code></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>创建文件 <code>.github/main.workflow</code></p><pre><code class="hljs bash">workflow <span class="hljs-string">"blog ci/cd"</span> &#123;  on = <span class="hljs-string">"push"</span>  resolves = [<span class="hljs-string">"hugo"</span>]&#125;action <span class="hljs-string">"hugo"</span> &#123;  uses = <span class="hljs-string">"docker://mohuishou/hugo-action:0.53"</span>  secrets = [    <span class="hljs-string">"TOKEN"</span>,  ]  env = &#123;    EMAIL = <span class="hljs-string">"1@lailin.xyz"</span>  &#125;&#125;</code></pre><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><table><thead><tr><th>Key</th><th>Value</th><th>Must</th></tr></thead><tbody><tr><td>TOKEN</td><td>你的 github token，需要有 push 权限，保存在密码变量中</td><td>yes</td></tr><tr><td>EMAIL</td><td>你的邮箱</td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://developer.github.com/actions/" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/TODO1/introducing-github-actions.md" target="_blank" rel="noopener">GitHub Actions 介绍，了解一下？</a></li><li><a href="https://github.com/actions" target="_blank" rel="noopener">Github Actions Repo</a></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/27142.html">hexo-next-algolia-search全文搜索</a></li><li><a href="https://lailin.xyz/post/51252.html">docker镜像瘦身&优化</a></li><li><a href="https://lailin.xyz/post/60163.html">GORM避坑指南之含关联关系的更新</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在blog中内嵌在线PPT</title>
    <link href="/post/7944.html"/>
    <url>/post/7944.html</url>
    
    <content type="html"><![CDATA[<p>有时我们会做一些分享，分享之后可以把 PPT 脱敏之后放在博客上面，可以使用 office online 直接内嵌 PPT, 巨硬大法好</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>在线播放</li><li>支持动画</li><li>支持播放内嵌视频</li><li>自适应</li></ol><p>上面的需求, WPS 云文档支持 1, 以及一些简单的动画，Office online 支持 1,2,3 第四点我们可以通过一个简单 js 脚本解决</p><h2 id="获取分享链接"><a href="#获取分享链接" class="headerlink" title="获取分享链接"></a>获取分享链接</h2><p>1.登录 <a href="https://onedrive.live.com" target="_blank" rel="noopener">https://onedrive.live.com</a> 上传需要分享的 PPT 2.如下图所示 打开刚刚上传的 PPT 文件<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/assets/20181208165037.png?x-oss-process=image/resize,w_800" srcset="/img/loading.gif" alt></p><p>3.点击右上角的文件 -&gt; 共享 -&gt; 嵌入<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/assets/20181208170149.png?x-oss-process=image/resize,w_800" srcset="/img/loading.gif" alt></p><p>4.获取分享链接，将代码中的分享链接复制<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/assets/20181208170334.png?x-oss-process=image/resize,w_800" srcset="/img/loading.gif" alt></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"这里是你的分享链接"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"350px"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"221px"</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"0"</span>  &gt;</span>这是嵌入  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://office.com"</span>&gt;</span>Microsoft Office<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 演示文稿，由  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://office.com/webapps"</span>&gt;</span>Office Online<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  支持。<span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></code></pre><p>5.修改代码自适应，将上一步获取到的链接替换到下方代码中，复制粘贴到博客中即可</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">"ppt"</span>  <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span>  <span class="hljs-attr">onload</span>=<span class="hljs-string">"autoChange()"</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">"在此处替换为你的PPT链接"</span>  <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"0"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">autoChange</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> ifm = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"ppt"</span>);    ifm.height = (ifm.clientWidth / <span class="hljs-number">16</span>) * <span class="hljs-number">9</span> + <span class="hljs-number">24</span>;  &#125;  <span class="hljs-built_in">window</span>.onresize = autoChange;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="https://lailin.xyz/post/notes/pprof-go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/">https://lailin.xyz/post/notes/pprof-go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Office Online 对于 PPT 支持相当的好，唯一的缺点可能就是在国内有些的确被墙，可能需要 FQ 才能访问</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/27142.html">hexo-next-algolia-search全文搜索</a></li><li><a href="https://lailin.xyz/post/51252.html">docker镜像瘦身&优化</a></li><li><a href="https://lailin.xyz/post/60163.html">GORM避坑指南之含关联关系的更新</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次net http内存泄漏</title>
    <link href="/post/44107.html"/>
    <url>/post/44107.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>使用 gin 作为文件下载服务器，内存占用突然从几十 M 到了 10G 以上，导致服务被 kill 重启</p></blockquote><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><code>server.go</code></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;r := gin.Default()r.GET(<span class="hljs-string">"/download"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;f, err := os.Open(<span class="hljs-string">"./win7.iso"</span>)log.Println(err)<span class="hljs-keyword">defer</span> f.Close()info, _ := f.Stat()b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, info.Size())f.Read(b)context.Data(<span class="hljs-number">200</span>, <span class="hljs-string">"application/octet-stream"</span>, b)&#125;)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;log.Println(http.ListenAndServe(<span class="hljs-string">"localhost:6060"</span>, <span class="hljs-literal">nil</span>))&#125;()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;time.Sleep(time.Second * <span class="hljs-number">30</span>)runtime.GC()log.Println(<span class="hljs-string">"gc"</span>)&#125;&#125;()runtime.MemProfileRate = <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>r.Run(<span class="hljs-string">":8080"</span>)&#125;</code></pre><p><code>client.go</code></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;resp, _ := http.Get(<span class="hljs-string">"http://localhost:8080/download"</span>)resp.Body.Close()log.Println(<span class="hljs-string">"ok"</span>)<span class="hljs-keyword">select</span> &#123;&#125;&#125;</code></pre><p>使用<code>pprof</code>我们可以发现内存占用高达<code>3GB</code>, 即使我主动调用了 GC 这个内存仍未释放</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/assets/profile001.gif" srcset="/img/loading.gif" alt></p><h2 id="追溯"><a href="#追溯" class="headerlink" title="追溯"></a>追溯</h2><p>通过查看代码我们可以发现请求已经结束，代码并没有其他地方对<code>[]byte</code>引用，一直追溯到最低层也不见其他引用。</p><p>但是结束<code>client</code>进程之后会有一个神奇的发现，结束 client 之后这一块内存就可以被 GC 掉</p><p>通过这个现象自然而然的就想到可能是 TCP 链接没有断开，导致这一块内存的引用并没有被释放掉</p><p>http 是一个本身是短连接，但是为了复用 TCP 连接所以有了<code>keep-alive</code>，但是对于下载服务来说我们其实不用复用 TCP 连接，只需要在文件下载完毕之后主动关闭这个连接即可，所以我分别在 client 加上了一个 header</p><pre><code class="hljs undefined">Connection: <span class="hljs-built_in">close</span></code></pre><p>再次通过<code>pprof</code>查看内存占用发现内存仍未得到释放</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>通过 rfc 文档，我们可以发现规范并没有规定由谁来关闭链接，Go net/http 希望客户端关闭链接</p><p><a href="https://tools.ietf.org/html/rfc2616#page-117" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616#page-117</a></p><blockquote><p>HTTP/1.1 defines the “close” connection option for the sender to signal that the connection will be closed after completion of the response.</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li>使用流而不是直接读内存，在<code>gin</code>中不要直接使用<code>c.Data</code>而是使用<code>c.DataFromReader</code></li><li>使用 AWS S3 等存储服务下发文件，减轻服务压力</li><li>尽量不使用官方的<code>net/http</code>处理文件</li><li><a href="https://jiajunhuang.com" target="_blank" rel="noopener">@jiajun 老师</a> 已经给 Go 官方提了一个 <a href="https://github.com/golang/go/pull/28936" target="_blank" rel="noopener">PR</a>，等待 PR Merge</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://jiajunhuang.com/articles/2018_11_24-memory_leak_in_net_http.md.html" target="_blank" rel="noopener">https://jiajunhuang.com/articles/2018_11_24-memory_leak_in_net_http.md.html</a></li><li><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616</a></li><li><a href="https://lailin.xyz/post/notes/pprof-go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/">https://lailin.xyz/post/notes/pprof-go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</a></li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>notes</tag>
      
      <tag>内存泄漏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pprof go性能分析工具</title>
    <link href="/post/40393.html"/>
    <url>/post/40393.html</url>
    
    <content type="html"><![CDATA[<p>PPT 分享(可能需要 FQ 方能访问，需要可以访问, onedrive.live.com)</p><a id="more"></a><iframe id="ppt" width="100%" onload="changeFrameHeight()" src="https://onedrive.live.com/embed?cid=9B44A0E26836C4FF&amp;resid=9B44A0E26836C4FF%211837&amp;authkey=AAoxyFlzZ39JQvM&amp;em=2&amp;wdAr=1.7777777777777777" frameborder="0">这是嵌入 <a target="_blank" href="https://office.com">Microsoft Office</a> 演示文稿，由 <a target="_blank" href="https://office.com/webapps">Office Online</a> 支持。</iframe><script>function changeFrameHeight(){var e=document.getElementById("ppt");console.log(e.width),e.height=e.clientWidth/16*9+24}window.onresize=changeFrameHeight</script><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/27142.html">hexo-next-algolia-search全文搜索</a></li><li><a href="https://lailin.xyz/post/51252.html">docker镜像瘦身&优化</a></li><li><a href="https://lailin.xyz/post/60163.html">GORM避坑指南之含关联关系的更新</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用TravisCI自动部署Blog</title>
    <link href="/post/52061.html"/>
    <url>/post/52061.html</url>
    
    <content type="html"><![CDATA[<p>之前博客的更新一直都是在本地运行<code>hugo</code>然后手动 push 到 github 仓库，虽然写了一个小脚本，但是本地还是多了一个 public 文件夹，最近看了 travis ci 可以和 github 完美的结合。关于 travis ci 不过多介绍，感兴趣的可以直接看官方文档，写的非常详细</p><pre><code class="hljs yaml"><span class="hljs-comment"># 指定运行语言为go</span><span class="hljs-attr">language:</span> <span class="hljs-string">go</span><span class="hljs-comment"># 指定go语言版本</span><span class="hljs-attr">go:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">"1.10.x"</span><span class="hljs-comment"># 安装依赖，安装hugo</span><span class="hljs-attr">install:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">wget</span> <span class="hljs-string">https://github.com/gohugoio/hugo/releases/download/v0.49/hugo_0.49_Linux-64bit.tar.gz</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">tar</span> <span class="hljs-string">-xzvf</span> <span class="hljs-string">hugo_0.49_Linux-64bit.tar.gz</span><span class="hljs-comment"># 在script执行前执行，设置git用户名，邮箱，从github把blog文件拉下来</span><span class="hljs-attr">before_script:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.email</span> <span class="hljs-string">"1@lailin.xyz"</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.name</span> <span class="hljs-string">"mohuishou"</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">clone</span> <span class="hljs-string">https://$GITHUB_TOKEN@github.com/mohuishou/mohuishou.github.io.git</span> <span class="hljs-string">public</span>  <span class="hljs-comment"># clone 主题</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">clone</span> <span class="hljs-string">https://github.com/laozhu/hugo-nuo</span> <span class="hljs-string">themes/hugo-nuo</span><span class="hljs-comment"># 生成静态网页</span><span class="hljs-attr">script:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">./hugo</span><span class="hljs-comment"># 运行成功之后将页面推送到github上</span><span class="hljs-attr">after_success:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">public</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">add</span> <span class="hljs-string">.</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">commit</span> <span class="hljs-string">-m</span> <span class="hljs-string">'travis auto update'</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">-u</span> <span class="hljs-string">origin</span> <span class="hljs-string">master</span></code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/28054.html">Github Actions介绍&自动构建Github Pages博客</a></li><li><a href="https://lailin.xyz/post/44107.html">记一次net http内存泄漏</a></li><li><a href="https://lailin.xyz/post/37449.html">一个十分边缘的gorm的bug</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>notes</tag>
      
      <tag>ci</tag>
      
      <tag>hugo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Goland调试Go程序</title>
    <link href="/post/37623.html"/>
    <url>/post/37623.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>在上一篇 Blog 当中发现了一个十分边缘的 GORM 的 bug，由于不熟悉工具，bug 的调试过程还是比较麻烦，这一篇讲一讲如何使用 Goland 强大的 debug 功能调试 Go 程序</p></blockquote><a id="more"></a><h2 id="Goland"><a href="#Goland" class="headerlink" title="Goland"></a>Goland</h2><p>Goland 是 jb 公司的 Go 语言 IDE，和 jb 家族的其他 IDE 一样的强大并且吃内存</p><p>下载地址: <a href="https://www.jetbrains.com/go" target="_blank" rel="noopener">https://www.jetbrains.com/go</a></p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>如下图所示，在<code>main</code>函数或者是单元测试函数的旁边会出现一个执行的按钮<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141140.jpg" srcset="/img/loading.gif" alt><br>在屏幕的右上角也可以看见一个小虫子的按钮，点击就可以开始 debug<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141151.jpg" srcset="/img/loading.gif" alt></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>如下图所示，点击 Edit 打开配置窗口<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141152.jpg" srcset="/img/loading.gif" alt><br>如下图所示，可以对当前的运行命令进行配置，或者点击下方 templates，对模板配置，修改模板配置，在当前项目之后再点击 go run 时，会自动采用模板的配置<br>配置可以对文件，环境变量，运行命令等进行配置，一般用的比较多的就是环境变量<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141153.jpg" srcset="/img/loading.gif" alt></p><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>如图所示点击行号和代码之间的空白即可添加断点<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141154.jpg" srcset="/img/loading.gif" alt><br>如图所示，右键点击红点，可以对断点进行一些高级的设定<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141155.jpg" srcset="/img/loading.gif" alt><br>点击 more 会出现如下弹窗<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141156.jpg" srcset="/img/loading.gif" alt></p><h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>点击 Debug 开始运行之后，会出现一个 debug 窗口，当前的窗口是 console 窗口<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141157.jpg" srcset="/img/loading.gif" alt><br>点击 debugger 可以看到整个程序的调用栈，点击相应的调用栈可以调转的相应的代码，并且显示当前的变量信息<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141158.jpg" srcset="/img/loading.gif" alt><br>如图所示可以在当前栈，执行相应的命令，但是暂时还不支持执行方法，只能查看变量或者是调用变量的属性<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141159.jpg" srcset="/img/loading.gif" alt></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个十分边缘的gorm的bug</title>
    <link href="/post/37449.html"/>
    <url>/post/37449.html</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="复现代码"><a href="#复现代码" class="headerlink" title="复现代码"></a>复现代码</h2><p>这个代码的触发条件比较严苛，首先必须要保证 gorm 执行的一行必须为<code>updates</code>语句，并且在<code>updates(struct)</code>,并且传入的这个<code>struct</code>必须要包含一个直接或者间接关联的一个多态表，这些条件缺一不可</p><a id="more"></a><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;gorm.ModelName <span class="hljs-keyword">string</span>B    B <span class="hljs-string">`gorm:"polymorphic:Owner"`</span>&#125;<span class="hljs-keyword">type</span> B <span class="hljs-keyword">struct</span> &#123;gorm.ModelOwnerID   <span class="hljs-keyword">uint</span>OwnerType <span class="hljs-keyword">string</span>&#125;a := A&#123;Name: <span class="hljs-string">"test"</span>&#125;db = db.Model(&amp;a)db.Where(a)db.Updates(A&#123;Name: <span class="hljs-string">"test2"</span>&#125;) <span class="hljs-comment">// panic</span></code></pre><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>先说现象，在一次代码联调的过程当中，发现调用一个更新接口的时候会报 500 错误（panic），但是在什么都不修改的情况下，再次调用接口，更新成功</p><p>错误日志如下，是由于一个空指针的调用:</p><pre><code class="hljs go"><span class="hljs-built_in">panic</span>: runtime error: invalid memory address or <span class="hljs-literal">nil</span> pointer dereferencegithub.com/jinzhu/gorm.(*DB).clone(<span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">715</span> +<span class="hljs-number">0x4e</span>github.com/jinzhu/gorm.(*DB).Model(<span class="hljs-number">0x0</span>, <span class="hljs-number">0x6cb460</span>, <span class="hljs-number">0xc00017c160</span>, <span class="hljs-number">0x0</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">445</span> +<span class="hljs-number">0x32</span>github.com/jinzhu/gorm.(*Scope).TableName(<span class="hljs-number">0xc000172100</span>, <span class="hljs-number">0xc00016c3c0</span>, <span class="hljs-number">0x6f894a</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.<span class="hljs-keyword">go</span>:<span class="hljs-number">325</span> +<span class="hljs-number">0x133</span>github.com/jinzhu/gorm.(*Scope).GetModelStruct.func2(<span class="hljs-number">0xc000170010</span>, <span class="hljs-number">0xc000172100</span>, <span class="hljs-number">0xc00017a050</span>, <span class="hljs-number">0xc0001749c0</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/model_struct.<span class="hljs-keyword">go</span>:<span class="hljs-number">420</span> +<span class="hljs-number">0x24c7</span>github.com/jinzhu/gorm.(*Scope).GetModelStruct(<span class="hljs-number">0xc000172100</span>, <span class="hljs-number">0xc00017a050</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/model_struct.<span class="hljs-keyword">go</span>:<span class="hljs-number">574</span> +<span class="hljs-number">0x140c</span>github.com/jinzhu/gorm.(*Scope).Fields(<span class="hljs-number">0xc000172100</span>, <span class="hljs-number">0xc000172100</span>, <span class="hljs-number">0x2030000</span>, <span class="hljs-number">0x2030000</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.<span class="hljs-keyword">go</span>:<span class="hljs-number">115</span> +<span class="hljs-number">0xaf</span>github.com/jinzhu/gorm.convertInterfaceToMap(<span class="hljs-number">0x6cb460</span>, <span class="hljs-number">0xc00017c160</span>, <span class="hljs-number">0xc00017c001</span>, <span class="hljs-number">0x199</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.<span class="hljs-keyword">go</span>:<span class="hljs-number">860</span> +<span class="hljs-number">0x4f8</span>github.com/jinzhu/gorm.(*Scope).updatedAttrsWithValues(<span class="hljs-number">0xc000172080</span>, <span class="hljs-number">0x6cb460</span>, <span class="hljs-number">0xc00017c160</span>, <span class="hljs-number">0x6cb460</span>, <span class="hljs-number">0xc00017c160</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.<span class="hljs-keyword">go</span>:<span class="hljs-number">877</span> +<span class="hljs-number">0x8b</span>github.com/jinzhu/gorm.assignUpdatingAttributesCallback(<span class="hljs-number">0xc000172080</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/callback_update.<span class="hljs-keyword">go</span>:<span class="hljs-number">25</span> +<span class="hljs-number">0x81</span>github.com/jinzhu/gorm.(*Scope).callCallbacks(<span class="hljs-number">0xc000172080</span>, <span class="hljs-number">0xc00012ff00</span>, <span class="hljs-number">0x9</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0xc00017c160</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.<span class="hljs-keyword">go</span>:<span class="hljs-number">831</span> +<span class="hljs-number">0x5c</span>github.com/jinzhu/gorm.(*DB).Updates(<span class="hljs-number">0xc00017e090</span>, <span class="hljs-number">0x6cb460</span>, <span class="hljs-number">0xc00017c160</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xc00017e090</span>)E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">383</span> +<span class="hljs-number">0x13b</span>main.main()E:/SoftFile/GOPATH/src/github.com/mohuishou/test/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">34</span> +<span class="hljs-number">0x269</span></code></pre><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>首先从 panic 的堆栈顶端往下看, 是调用<code>s.db</code>的时候报的错，推断应该是<code>s</code>的值为<code>nil</code>导致的错误</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *DB)</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span> *<span class="hljs-title">DB</span></span> &#123;db := &amp;DB&#123;db:                s.db, <span class="hljs-comment">// 从这一行开始panic</span>    &#125;&#125;</code></pre><p>接着往下看，这里的<code>s</code>应该也是一个<code>nil</code></p><pre><code class="hljs go"><span class="hljs-comment">// Model specify the model you would like to run db operations</span><span class="hljs-comment">//    // update all users's name to `hello`</span><span class="hljs-comment">//    db.Model(&amp;User&#123;&#125;).Update("name", "hello")</span><span class="hljs-comment">//    // if user's primary key is non-blank, will use it as condition, then will only update the user's name to `hello`</span><span class="hljs-comment">//    db.Model(&amp;user).Update("name", "hello")</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *DB)</span> <span class="hljs-title">Model</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> *<span class="hljs-title">DB</span></span> &#123;c := s.clone() <span class="hljs-comment">// 从这里调用</span>c.Value = value<span class="hljs-keyword">return</span> c&#125;</code></pre><p>接着走, 在获取表名的时候，需要调用<code>scope.db.Model</code>， 这里的 db 应该是一个<code>nil</code>导致调用失败</p><pre><code class="hljs go"><span class="hljs-comment">// TableName return table name</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(scope *Scope)</span> <span class="hljs-title">TableName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;    <span class="hljs-comment">// ...</span><span class="hljs-keyword">return</span> scope.GetModelStruct().TableName(scope.db.Model(scope.Value))&#125;</code></pre><p>从下面的调用，可以看到，实在获取<code>Struct</code>的结构的时候，由于有多态关联(<code>polymorphic</code>)的 tag，所以需要获取多态表的<code>TableName</code></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(scope *Scope)</span> <span class="hljs-title">GetModelStruct</span><span class="hljs-params">()</span> *<span class="hljs-title">ModelStruct</span></span> &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> polymorphic := field.TagSettings[<span class="hljs-string">"POLYMORPHIC"</span>]; polymorphic != <span class="hljs-string">""</span> &#123;        <span class="hljs-keyword">if</span> value, ok := field.TagSettings[<span class="hljs-string">"POLYMORPHIC_VALUE"</span>]; ok &#123;            relationship.PolymorphicValue = value        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 这里调用</span>            relationship.PolymorphicValue = scope.TableName()        &#125;    &#125;&#125;</code></pre><p>调用<code>GetModelStruct</code>的原因是因为需要获取<code>value</code>的所有字段，字段等于 nil 的时候，就会调用<code>GetModelStruct</code>去获取</p><pre><code class="hljs go"><span class="hljs-comment">// Fields get value's fields</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(scope *Scope)</span> <span class="hljs-title">Fields</span><span class="hljs-params">()</span> []*<span class="hljs-title">Field</span></span> &#123;<span class="hljs-keyword">if</span> scope.fields == <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// ...</span><span class="hljs-keyword">for</span> _, structField := <span class="hljs-keyword">range</span> scope.GetModelStruct().StructFields &#123;            <span class="hljs-comment">// ...</span>        &#125;    &#125;&#125;</code></pre><p>看这个函数可以发现，会把<code>interface</code>转为<code>map</code>, 由于我们最开始传入的是<code>db.Updates(A{Name: &quot;test2&quot;})</code>条件是一个 struct 所以会执行下面<code>case interface{} -&gt; default</code>分支。此时会调用<code>(&amp;Scope{Value: values}).Fields()</code>，这时候可以发现<code>Scope</code>这个对象在初始话的时候是没有<code>db</code>这个字段的，所以在获取 table name 的时候需要调用到<code>scope.db</code>这时候就会 panic</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convertInterfaceToMap</span><span class="hljs-params">(values <span class="hljs-keyword">interface</span>&#123;&#125;, withIgnoredField <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">map</span>[<span class="hljs-title">string</span>]<span class="hljs-title">interface</span></span>&#123;&#125; &#123;<span class="hljs-keyword">var</span> attrs = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;&#125;<span class="hljs-keyword">switch</span> value := values.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;:<span class="hljs-keyword">return</span> value<span class="hljs-keyword">case</span> []<span class="hljs-keyword">interface</span>&#123;&#125;:<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> value &#123;<span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> convertInterfaceToMap(v, withIgnoredField) &#123;attrs[key] = value&#125;&#125;<span class="hljs-keyword">case</span> <span class="hljs-keyword">interface</span>&#123;&#125;:reflectValue := reflect.ValueOf(values)<span class="hljs-keyword">switch</span> reflectValue.Kind() &#123;<span class="hljs-keyword">case</span> reflect.Map:<span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> reflectValue.MapKeys() &#123;attrs[ToDBName(key.Interface().(<span class="hljs-keyword">string</span>))] = reflectValue.MapIndex(key).Interface()&#125;<span class="hljs-keyword">default</span>:<span class="hljs-comment">// 在这里调用</span><span class="hljs-keyword">for</span> _, field := <span class="hljs-keyword">range</span> (&amp;Scope&#123;Value: values&#125;).Fields() &#123;<span class="hljs-keyword">if</span> !field.IsBlank &amp;&amp; (withIgnoredField || !field.IsIgnored) &#123;attrs[field.DBName] = field.Field.Interface()&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> attrs&#125;</code></pre><p>到这里这个 bug 就算结案了，但是接着看看，为什么会调用这个函数.</p><p>这个函数会获取需要更新的字段<code>map</code>,如果传入的是一个<code>struct</code>，会转换为<code>map</code></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(scope *Scope)</span> <span class="hljs-title">updatedAttrsWithValues</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(results <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, hasUpdate <span class="hljs-keyword">bool</span>)</span></span> &#123;<span class="hljs-keyword">if</span> scope.IndirectValue().Kind() != reflect.Struct &#123;<span class="hljs-keyword">return</span> convertInterfaceToMap(value, <span class="hljs-literal">false</span>), <span class="hljs-literal">true</span>&#125;results = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;&#125;<span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> convertInterfaceToMap(value, <span class="hljs-literal">true</span>) &#123;&#125;&#125;</code></pre><p>这个方法会把获取到需要更新的 map 保存下来</p><pre><code class="hljs go"><span class="hljs-comment">// assignUpdatingAttributesCallback assign updating attributes to model</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assignUpdatingAttributesCallback</span><span class="hljs-params">(scope *Scope)</span></span> &#123;<span class="hljs-keyword">if</span> attrs, ok := scope.InstanceGet(<span class="hljs-string">"gorm:update_interface"</span>); ok &#123;<span class="hljs-keyword">if</span> updateMaps, hasUpdate := scope.updatedAttrsWithValues(attrs); hasUpdate &#123;scope.InstanceSet(<span class="hljs-string">"gorm:update_attrs"</span>, updateMaps)&#125; <span class="hljs-keyword">else</span> &#123;scope.SkipLeft()&#125;&#125;&#125;</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><a href="https://github.com/jinzhu/gorm/pull/2105" target="_blank" rel="noopener">https://github.com/jinzhu/gorm/pull/2105</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="GORM，使用-map-而不是-struct"><a href="#GORM，使用-map-而不是-struct" class="headerlink" title="GORM，使用 map 而不是 struct"></a>GORM，使用 map 而不是 struct</h3><p>在使用的 GORM 的时候，需要更新一些字段的时候<strong>最好使用 map 而不是 struct</strong>，因为如果使用 struct，gorm 最终会把这个 struct 转换为 map，并且如果这个 struct 包含一些关联关系，gorm 会一直递归的查找转换下去，如果整个表的关联关系比较复杂，会导致效率比较低下</p><h3 id="为什么不需要修改代码，第二次运行就不会-panic"><a href="#为什么不需要修改代码，第二次运行就不会-panic" class="headerlink" title="为什么不需要修改代码，第二次运行就不会 panic"></a>为什么不需要修改代码，第二次运行就不会 panic</h3><p>这是由于 GORM 会对 struct 的结构有一个全局的缓存<code>modelStructsMap</code>，由于这个是因为查找关联关系的时候报错，其本身已经新建了一个<code>modelstruct</code>并且缓存了下来，所以再次调用的时候就不会执行后面的代码了</p><pre><code class="hljs go"><span class="hljs-comment">// GetModelStruct get value's model struct, relationships based on struct and tag definition</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(scope *Scope)</span> <span class="hljs-title">GetModelStruct</span><span class="hljs-params">()</span> *<span class="hljs-title">ModelStruct</span></span> &#123;<span class="hljs-comment">//...</span><span class="hljs-comment">// Get Cached model struct</span><span class="hljs-keyword">if</span> value := modelStructsMap.Get(reflectType); value != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> value&#125;<span class="hljs-comment">// ...</span>&#125;</code></pre><h3 id="调试总结"><a href="#调试总结" class="headerlink" title="调试总结"></a>调试总结</h3><p>调试的过程比写来的要艰辛很多，由于调试的时候是从自身的代码开始，通过<code>Goland</code>的 debug 不断的打断点，一遍一遍的执行，查找整个执行的过程，导致忽略了最直接找到错误代码的方式。</p><p>不过这也是一个宝贵的经历，这个 Bug 调试结束之后，<code>Goland</code>强大的调试功能已经可以玩的比较 6 了</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>gorm</tag>
      
      <tag>notes</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Httprouter介绍及源码阅读</title>
    <link href="/post/44029.html"/>
    <url>/post/44029.html</url>
    
    <content type="html"><![CDATA[<p>在上一篇文章当中阅读了 Go 语言的一个高性能的 Web 框架 Gin，Web 框架当中最重要的功能之一是路由，Gin 的路由就是由 httprouter 这个包实现的</p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><ul><li><a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">https://github.com/julienschmidt/httprouter</a></li><li><a href="https://godoc.org/github.com/julienschmidt/httprouter" target="_blank" rel="noopener">https://godoc.org/github.com/julienschmidt/httprouter</a></li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>基于基数树实现的高性能路由框架</li><li>仅支持精确匹配</li><li>不必关心 URL 结尾的斜线</li><li>路径自动校正，例如在 url 路径当中有<code>../</code>,<code>//</code>的时候</li><li>可以在 URL 当中设置参数，例如<code>/user/:id</code></li><li>零内存分配</li><li>不存在服务器崩溃，可以通过设置<code>panic handler</code>使服务器从 panic 当中恢复</li><li>适合 API 构建</li></ul><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h3><p>解决两个问题，就基本明白了这个路由框架</p><ul><li>路由是是如何注册？如何保存的？</li><li>当请求到来之后，路由是如何匹配，如何查找的？</li></ul><h3 id="一个-Demo"><a href="#一个-Demo" class="headerlink" title="一个 Demo"></a>一个 Demo</h3><p>还是从一个<code>Hello World</code>讲起</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;r := httprouter.New()r.GET(<span class="hljs-string">"/:name"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request, params httprouter.Params)</span></span> &#123;        fmt.Fprintf(writer, <span class="hljs-string">"hello, %s!\n"</span>, params.ByName(<span class="hljs-string">"name"</span>))&#125;)http.ListenAndServe(<span class="hljs-string">":8080"</span>,r)&#125;</code></pre><p><code>httprouter.New()</code>初始化了一个 Router，下面直接看一下 Router 的结构</p><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>在 Router 的源码当中有十分详尽的注释，这里按照我个人的理解注释一下</p><pre><code class="hljs go"><span class="hljs-comment">// Router实现了Http.Handler接口，用于注册分发路由</span><span class="hljs-keyword">type</span> Router <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// trees 是一个基数树集合，每一个HTTP方法对应一棵单独的路由树</span>    <span class="hljs-comment">// node是基数树的根节点</span>trees <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*node    <span class="hljs-comment">// 用于开启上文提到的自动处理URL尾部斜杆的特性</span>    <span class="hljs-comment">// 这个值为true时，如果/foo/没有被匹配到，会尝试匹配/foo</span>RedirectTrailingSlash <span class="hljs-keyword">bool</span><span class="hljs-comment">// 用于开启上文提到的路由校正的特性</span>    <span class="hljs-comment">// 这个值为true时，会对../和//这种路径进行校正</span>RedirectFixedPath <span class="hljs-keyword">bool</span>    <span class="hljs-comment">// 这个值为true时，如果当前方法的路由没有被匹配到，会尝试匹配其他方法的路由，</span>    <span class="hljs-comment">// 如果匹配到了则返回405，如果没有，就交给NotFound Handler处理</span>HandleMethodNotAllowed <span class="hljs-keyword">bool</span><span class="hljs-comment">// 这个值为true时，将开启OPTIONS自动匹配，注意: 手动匹配优先级更高</span>HandleOPTIONS <span class="hljs-keyword">bool</span>    <span class="hljs-comment">// 没有匹配到相应路由的时候会调用这个方法</span>    <span class="hljs-comment">// 如果没有注册这个方法会返回 NotFound</span>NotFound http.Handler<span class="hljs-comment">// 没有匹配到相应路由并且HandleMethodNotAllowed为true时会调用这个方法</span>MethodNotAllowed http.Handler    <span class="hljs-comment">// 用于从panic当中恢复</span>    <span class="hljs-comment">// 需要返回500错误，并且渲染相应的错误页面</span>PanicHandler <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request, <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>&#125;</code></pre><p>初始化 Router 之后看看路由是如何保存并且注册的</p><h3 id="路由是如何保存的"><a href="#路由是如何保存的" class="headerlink" title="路由是如何保存的?"></a>路由是如何保存的?</h3><p>这里以官方 Readme 当中的例子说明：<br>如果注册了以下路由</p><pre><code class="hljs go">r.GET(<span class="hljs-string">"/"</span>, f1)r.GET(<span class="hljs-string">"/search/"</span>, f2)r.GET(<span class="hljs-string">"/support/"</span>, f3)r.GET(<span class="hljs-string">"/blog/"</span>, f4)r.GET(<span class="hljs-string">"/blog/:post/"</span>, f5)r.GET(<span class="hljs-string">"/about_us/"</span>, f6)r.GET(<span class="hljs-string">"/about_us/team/"</span>, f7)r.GET(<span class="hljs-string">"/contact/"</span>, f8)</code></pre><p>那么这些路由会如下方所示，以一颗树的形式保存，并且这些路由的公共前缀会被抽离并且变为上一层节点<br>Priority 表示加上自身一共有多少个节点<br>Path 表示路径<br>Handle 表示路由注册的方法</p><pre><code class="hljs undefined"><span class="hljs-string">Priority</span>   <span class="hljs-string">Path</span>             <span class="hljs-string">Handle</span><span class="hljs-number">9</span>          <span class="hljs-string">\</span>                <span class="hljs-string">*&lt;1&gt;</span><span class="hljs-number">3</span>          <span class="hljs-string">├s</span>               <span class="hljs-string">nil</span><span class="hljs-number">2</span>          <span class="hljs-string">|├earch\</span>         <span class="hljs-string">*&lt;2&gt;</span><span class="hljs-number">1</span>          <span class="hljs-string">|└upport\</span>        <span class="hljs-string">*&lt;3&gt;</span><span class="hljs-number">2</span>          <span class="hljs-string">├blog\</span>           <span class="hljs-string">*&lt;4&gt;</span><span class="hljs-number">1</span>          <span class="hljs-string">|</span>    <span class="hljs-string">└:post</span>      <span class="hljs-string">nil</span><span class="hljs-number">1</span>          <span class="hljs-string">|</span>         <span class="hljs-string">└\</span>     <span class="hljs-string">*&lt;5&gt;</span><span class="hljs-number">2</span>          <span class="hljs-string">├about-us\</span>       <span class="hljs-string">*&lt;6&gt;</span><span class="hljs-number">1</span>          <span class="hljs-string">|</span>        <span class="hljs-string">└team\</span>  <span class="hljs-string">*&lt;7&gt;</span><span class="hljs-number">1</span>          <span class="hljs-string">└contact\</span>        <span class="hljs-string">*&lt;8&gt;</span></code></pre><h3 id="r-Handle"><a href="#r-Handle" class="headerlink" title="r.Handle"></a>r.Handle</h3><p><code>r.Get</code>, <code>r.Post</code>等方法实质都是通过调用 r.Handle 实现的</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Router)</span> <span class="hljs-title">Handle</span><span class="hljs-params">(method, path <span class="hljs-keyword">string</span>, handle Handle)</span></span> &#123;    <span class="hljs-comment">// 路径注册必须从/开始，否则直接报错</span><span class="hljs-keyword">if</span> path[<span class="hljs-number">0</span>] != <span class="hljs-string">'/'</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"path must begin with '/' in path '"</span> + path + <span class="hljs-string">"'"</span>)&#125;    <span class="hljs-comment">// 路由树map不存在需要新建</span><span class="hljs-keyword">if</span> r.trees == <span class="hljs-literal">nil</span> &#123;r.trees = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*node)&#125;    <span class="hljs-comment">// 获取当前方法所对应树的根节点，不存在则新建一个</span>root := r.trees[method]<span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;root = <span class="hljs-built_in">new</span>(node)r.trees[method] = root&#125;    <span class="hljs-comment">// 向路由树当中添加一条一条路由</span>root.addRoute(path, handle)&#125;</code></pre><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p>路由是注册到一颗路由树当中的，先看看节点的源码，再来分析，是如何添加路由的</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// 当前节点的路径</span>    path      <span class="hljs-keyword">string</span>    <span class="hljs-comment">// 是否为参数节点，参数节点用:name表示</span>    wildChild <span class="hljs-keyword">bool</span>    <span class="hljs-comment">// 当前节点类型， 一共有4种</span>    <span class="hljs-comment">// static: 静态节点，默认类型</span><span class="hljs-comment">// root: 根节点</span><span class="hljs-comment">// param: 其他节点</span><span class="hljs-comment">// catchAll: 带有*的节点，这里*的作用和正则当中的*一样</span>    nType     nodeType    <span class="hljs-comment">// 当前路径上最大参数的个数，不能超过255</span>    maxParams <span class="hljs-keyword">uint8</span>    <span class="hljs-comment">// 代表分支的首字母</span>    <span class="hljs-comment">// 上面的例子，当前节点为s</span>    <span class="hljs-comment">// 那么indices = eu</span>    <span class="hljs-comment">// ├s               nil</span>    <span class="hljs-comment">// |├earch\         *&lt;2&gt;</span>    <span class="hljs-comment">// |└upport\        *&lt;3&gt;</span>    indices   <span class="hljs-keyword">string</span>    <span class="hljs-comment">// 孩子节点</span>    children  []*node    <span class="hljs-comment">// 注册的路由</span>    handle    Handle    <span class="hljs-comment">// 权重，表示当前节点加上所有子节点的数目</span>priority  <span class="hljs-keyword">uint32</span>&#125;</code></pre><h3 id="路由树是如何生成的？"><a href="#路由树是如何生成的？" class="headerlink" title="路由树是如何生成的？"></a>路由树是如何生成的？</h3><p>未完待续</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin源码阅读 从0.1开始</title>
    <link href="/post/12338.html"/>
    <url>/post/12338.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近打算开始学习一下 Gin 的源代码，现在 Gin 已经是一个十分成熟的框架了，代码量也不少，阅读起来还是有一定的难度，所以我打算从 0.1 版本开始阅读学习，一直到最新的一个版本。跟随着 Gin 的源码一步一步的学习成长。</p></blockquote><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>Gin 0.1 的代码量十分的少, 主要代码一共也只有五个文件，代码中的注释也比较详细</p><pre><code class="hljs undefined">│  <span class="hljs-selector-tag">auth</span><span class="hljs-selector-class">.go</span>│  <span class="hljs-selector-tag">gin</span><span class="hljs-selector-class">.go</span>│  <span class="hljs-selector-tag">logger</span><span class="hljs-selector-class">.go</span>│  <span class="hljs-selector-tag">README</span><span class="hljs-selector-class">.md</span>│  <span class="hljs-selector-tag">recovery</span><span class="hljs-selector-class">.go</span>│  <span class="hljs-selector-tag">validation</span><span class="hljs-selector-class">.go</span></code></pre><h2 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h2><p>Gin 0.1 的代码量十分的少，但是还是先从<code>readme</code>的示例开始说起</p><p>首先下面这一段代码是直接跑不起来的，不知道是代码本身的 bug 还是因为 Go 语言的版本变化导致的，首先我们需要修改几个地方</p><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">"github.com/gin-gonic/gin"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    r := gin.Default()    r.GET(<span class="hljs-string">"ping"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span>&#123;        c.String(<span class="hljs-string">"pong"</span>)    &#125;)    <span class="hljs-comment">// Listen and server on 0.0.0.0:8080</span>    r.Run(<span class="hljs-string">":80"</span>)&#125;</code></pre><h3 id="第一次修改"><a href="#第一次修改" class="headerlink" title="第一次修改"></a>第一次修改</h3><p><code>main.go</code></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"github.com/gin-gonic/gin"</span><span class="hljs-string">"net/http"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;    r := gin.Default()    <span class="hljs-comment">// 在这儿必须在ping，前加上/，不然会导致panic</span>r.GET(<span class="hljs-string">"/ping"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span>&#123;        <span class="hljs-comment">// String 方法接受两个参数，但是实例只写了一个</span>c.String(http.StatusOK,<span class="hljs-string">"pong"</span>)&#125;)<span class="hljs-comment">// Listen and server on 0.0.0.0:8080</span>r.Run(<span class="hljs-string">":80"</span>)&#125;</code></pre><p><code>gin.go</code></p><pre><code class="hljs go"><span class="hljs-comment">// Returns a new blank Engine instance without any middleware attached.</span><span class="hljs-comment">// The most basic configuration</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span> *<span class="hljs-title">Engine</span></span> &#123;engine := &amp;Engine&#123;&#125;engine.RouterGroup = &amp;RouterGroup&#123;<span class="hljs-literal">nil</span>, <span class="hljs-string">""</span>, <span class="hljs-literal">nil</span>, engine&#125;    engine.router = httprouter.New()    <span class="hljs-comment">// NotFound 是一个http.Handler的接口，但是源码当中赋值了一个方法给他</span>    engine.router.NotFound = engine    <span class="hljs-comment">// engine.router.NotFound = engine.handle404</span><span class="hljs-keyword">return</span> engine&#125;</code></pre><p>好了修改完成之后就可以运行, <code>go run main.go</code>成功运行了，但是还有一个 bug，只能访问一次，就会因为<code>stack overflow</code>退出</p><p>查看一下<code>gin.go</code>, <code>ServeHTTP</code>可以发现，gin 是直接调用了<code>httprouter</code>的<code>ServeHTTP</code>方法</p><pre><code class="hljs go"><span class="hljs-comment">// ServeHTTP makes the router implement the http.Handler interface.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;engine.router.ServeHTTP(w, req)&#125;</code></pre><p>继续追踪，可以发现在<code>httprouter</code>的<code>ServeHTTP</code>方法最后有一段判定 404 的代码，这时候就可以发现这是之前修改<code>gin.go`</code> engine.router.NotFound = engine <code>这段代码造成的，由于 Chrome 浏览器访问的时候会尝试访问</code>/favicon.ico<code>这个文件，然而我们在路由当中并没有定义，此时就是 404，这时候由于之前我们在初始化的时候，给</code>router<code>传递的</code>NotFound<code>为</code>engine<code>，而</code>engine.ServeHTTP<code>调用了</code>router.ServeHTTP`这时候就造成了无限递归，导致最后退出</p><pre><code class="hljs go"><span class="hljs-comment">// Handle 404</span><span class="hljs-keyword">if</span> r.NotFound != <span class="hljs-literal">nil</span> &#123;r.NotFound.ServeHTTP(w, req)&#125; <span class="hljs-keyword">else</span> &#123;http.NotFound(w, req)&#125;</code></pre><h3 id="第二次修改"><a href="#第二次修改" class="headerlink" title="第二次修改"></a>第二次修改</h3><p><code>gin.go</code></p><pre><code class="hljs go"><span class="hljs-comment">// Returns a new blank Engine instance without any middleware attached.</span><span class="hljs-comment">// The most basic configuration</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span> *<span class="hljs-title">Engine</span></span> &#123;engine := &amp;Engine&#123;&#125;engine.RouterGroup = &amp;RouterGroup&#123;<span class="hljs-literal">nil</span>, <span class="hljs-string">""</span>, <span class="hljs-literal">nil</span>, engine&#125;    engine.router = httprouter.New()    <span class="hljs-comment">// NotFound 是一个http.Handler的接口，但是源码当中赋值了一个方法给他</span>    <span class="hljs-comment">// 注释掉即可</span>    <span class="hljs-comment">// engine.router.NotFound = engine.handle404</span><span class="hljs-keyword">return</span> engine&#125;</code></pre><p><code>go run main.go</code>成功运行，就没有问题了</p><h2 id="Gin-源码分析"><a href="#Gin-源码分析" class="headerlink" title="Gin 源码分析"></a>Gin 源码分析</h2><p>跑起来之后就具体看看源码,初始版本的 Gin 当中拥有三个比较重要的<code>struct</code>，也是核心的组成部分</p><p><code>Context</code></p><pre><code class="hljs go"><span class="hljs-comment">// Context是gin当中最为重要的一部分</span><span class="hljs-comment">// 它用于在中间件当中传递变量，管理流程。例如接受json请求，并返回json</span><span class="hljs-comment">// Context is the most important part of gin. It allows us to pass variables between middleware,</span><span class="hljs-comment">// manage the flow, validate the JSON of a request and render a JSON response for example.</span>Context <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// ServeHTTP 第二个参数，请求体</span>    Req      *http.Request    <span class="hljs-comment">// ServeHTTP 第一次参数，响应</span>    Writer   http.ResponseWriter    <span class="hljs-comment">// 可以设置的值</span>    Keys     <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;    <span class="hljs-comment">// 错误信息</span>    Errors   []ErrorMsg    <span class="hljs-comment">// 请求参数</span>    Params   httprouter.Params    <span class="hljs-comment">// = 中间件 + 请求处理函数(最后一个)</span>    handlers []HandlerFunc    <span class="hljs-comment">// Engine 实例</span>    engine   *Engine    <span class="hljs-comment">// 当前处理到的Handler下标</span>    index    <span class="hljs-keyword">int8</span>&#125;<span class="hljs-comment">// 下一个中间件</span>Next()<span class="hljs-comment">// 终止处理，直接返回</span>Abort(code <span class="hljs-keyword">int</span>)<span class="hljs-comment">// 添加错误信息，并且终止处理</span>Fail(code <span class="hljs-keyword">int</span>, err error)<span class="hljs-comment">// 添加错误信息</span>Error(err error, meta <span class="hljs-keyword">interface</span>&#123;&#125;)<span class="hljs-comment">// 给Context.Keys添加值</span>Set(key <span class="hljs-keyword">string</span>, item <span class="hljs-keyword">interface</span>&#123;&#125;)<span class="hljs-comment">// 获取Context.Keys的值，如果不存在会导致panic</span>Get(key <span class="hljs-keyword">string</span>) <span class="hljs-keyword">interface</span>&#123;&#125;<span class="hljs-comment">// 将请求体的参数作为json解析</span>ParseBody(item <span class="hljs-keyword">interface</span>&#123;&#125;) error<span class="hljs-comment">// 同ParseBody，但是如果不是一个可解析的json会调用Fail(400)终止请求</span>EnsureBody(item <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">bool</span><span class="hljs-comment">// 下面是和返回相关的函数，code 参数均表示http status</span><span class="hljs-comment">// 返回json</span>JSON(code <span class="hljs-keyword">int</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;)<span class="hljs-comment">// 返回xml</span>XML(code <span class="hljs-keyword">int</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;)<span class="hljs-comment">// HTML模板渲染，使用golang标准库的模板库</span>HTML(code <span class="hljs-keyword">int</span>, name <span class="hljs-keyword">string</span>, data <span class="hljs-keyword">interface</span>&#123;&#125;)<span class="hljs-comment">// 返回字符串</span>String(code <span class="hljs-keyword">int</span>, msg <span class="hljs-keyword">string</span>)<span class="hljs-comment">// 返回流数据</span>Data(code <span class="hljs-keyword">int</span>, data []<span class="hljs-keyword">byte</span>)</code></pre><p><code>RouterGroup</code></p><pre><code class="hljs go"><span class="hljs-comment">// RouterGroup用于管理路由，一个RouterGroup和一个前缀以及一组中间件关联</span><span class="hljs-comment">// Used internally to configure router, a RouterGroup is associated with a prefix</span><span class="hljs-comment">// and an array of handlers (middlewares)</span>RouterGroup <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// 中间件</span>    Handlers []HandlerFunc    <span class="hljs-comment">// 路径前缀</span>    prefix   <span class="hljs-keyword">string</span>    parent   *RouterGroup    <span class="hljs-comment">// Engine 实例</span>    engine   *Engine&#125;<span class="hljs-comment">// 新建一个Context，用于传递这个路由组的数据</span>createContext(w http.ResponseWriter, req *http.Request, params httprouter.Params, handlers []HandlerFunc) *Context<span class="hljs-comment">// 添加一个中间件到这个路由组</span>Use(middlewares ...HandlerFunc)<span class="hljs-comment">// 新建一个路由组</span>Group(component <span class="hljs-keyword">string</span>, handlers ...HandlerFunc) *RouterGroup<span class="hljs-comment">// 注册一个路由</span>Handle(method, p <span class="hljs-keyword">string</span>, handlers []HandlerFunc)<span class="hljs-comment">// 调用Handle方法注册一个POST路由</span>POST(path <span class="hljs-keyword">string</span>, handlers ...HandlerFunc)<span class="hljs-comment">// 调用Handle方法注册一个GET路由</span>GET(path <span class="hljs-keyword">string</span>, handlers ...HandlerFunc)<span class="hljs-comment">// 调用Handle方法注册一个DELETE路由</span>DELETE(path <span class="hljs-keyword">string</span>, handlers ...HandlerFunc)<span class="hljs-comment">// 调用Handle方法注册一个PATCH路由</span>PATCH(path <span class="hljs-keyword">string</span>, handlers ...HandlerFunc)<span class="hljs-comment">// 调用Handle方法注册一个PUT路由</span>PUT(path <span class="hljs-keyword">string</span>, handlers ...HandlerFunc)<span class="hljs-comment">// 组合中间件，将传入的Handlers放在已有的Handlers后面</span>combineHandlers(handlers []HandlerFunc) []HandlerFunc</code></pre><p><code>Engine</code></p><pre><code class="hljs go"><span class="hljs-comment">// 用于表示Web框架，包含了fast HTTProuter和一个全局的中间件列表</span><span class="hljs-comment">// Represents the web framework, it wrappers the blazing fast httprouter multiplexer and a list of global middlewares.</span>Engine <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// 路由组</span>    *RouterGroup    <span class="hljs-comment">// 404 处理</span>    handlers404   []HandlerFunc    <span class="hljs-comment">// http router 实例</span>    router        *httprouter.Router    <span class="hljs-comment">// 模板</span>    HTMLTemplates *template.Template&#125;<span class="hljs-comment">// 加载HTML模板</span>LoadHTMLTemplates(pattern <span class="hljs-keyword">string</span>)<span class="hljs-comment">// 设置404方法</span>NotFound404(handlers ...HandlerFunc)<span class="hljs-comment">// 默认的404方法，但是这个版本并没有使用上</span>handle404(w http.ResponseWriter, req *http.Request)<span class="hljs-comment">// 保存文件</span>ServeFiles(path <span class="hljs-keyword">string</span>, root http.FileSystem)<span class="hljs-comment">// 实现http.Handler接口</span>ServeHTTP(w http.ResponseWriter, req *http.Request)<span class="hljs-comment">// 调用http.ListenAndServe启动服务器</span>Run(addr <span class="hljs-keyword">string</span>)</code></pre><p>0.1 版本的 gin 只是一个极小，极为简单的工具箱，主要提供了一个简单的路由和简单的中间件实现，搞清楚下面这两个问题这个框架的也就明白了。</p><ol><li><p>一个使用了<code>Gin</code>的 Web 应用，从初始化到启动的流程？</p></li><li><p>一个请求从接收到返回经历了什么？</p></li></ol><h3 id="应用流程"><a href="#应用流程" class="headerlink" title="应用流程"></a>应用流程</h3><p>1.首先创建了一个<code>engine</code>实例，注册了两个两个基本的中间件</p><pre><code class="hljs go">gin.Default() -&gt; gin.New() -&gt; engine.Use(Recovery(), Logger())</code></pre><p>2.然后使用<code>group.Handle</code>方法注册路由, 关键代码如下，将路由添加到 http router 的树中，当执行 handler 方法的时候，会创建一个<code>Context</code>并且从头开始执行</p><pre><code class="hljs go">group.engine.router.Handle(method, p,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request, params httprouter.Params)</span></span> &#123;    group.createContext(w, req, params, handlers).Next()&#125;)</code></pre><p>3.调用<code>http.ListenAndServe</code>监听指定端口，启动服务器</p><h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><ol><li>当服务器收到请求时，会调用之前注册的<code>engine.ServeHTTP</code>方法，查找路由</li><li><code>engine.ServeHTTP</code>方法使用了<code>httprouter</code>的<code>ServeHTTP</code>方法，这是会通过请求的 path 从已注册的路由树上获取对应的路由，并且执行其 handler 方法，如上所示，handler 方法内部通过创建一个 router group 对应的 Context 从头开始执行所有的中间件以及注册路由时注册的请求处理函数</li><li>从请求处理函数中返回信息</li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>gin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>纯技术人员和投资者的一些区别</title>
    <link href="/post/61686.html"/>
    <url>/post/61686.html</url>
    
    <content type="html"><![CDATA[<p>以下都是流水账，感慨一下…</p><p>今天有幸参加了一位师兄的校友聚会，也很巧合，和很多大佬一起吃了一个饭，听大佬们聊天受益颇多。</p><p>今天有一位做技术很厉害的，专家级的师兄想创业，聊起了他的项目，另外几个做企业的师兄在旁边听并且给出建议。让我产生一种很强烈的对比，做技术的师兄考虑的最多的是技术十分的牛，技术拥有不可复制，或者说很高的复制成本。但是没有说到具体的牛在什么地方，而其他几个师兄在帮忙理清项目的思路，有没有做过市场调查，有没有成型的产品，产品具体的技术指标等等。</p><p>不同位置的人看问题的角度不一样，或许只有那个技术很牛的师兄一样才能把一门技术做到极致。</p><p>但是反过来思考一下做技术需不需要有一定的产品思维，需不需要了解市场动态，需不需要良好的一个语言表述和组织能力，虽然这些肯定不是最重要的，但是应该也是不可或缺的吧。</p><p>自勉</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/28054.html">Github Actions介绍&自动构建Github Pages博客</a></li><li><a href="https://lailin.xyz/post/44107.html">记一次net http内存泄漏</a></li><li><a href="https://lailin.xyz/post/52061.html">使用TravisCI自动部署Blog</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>notes</tag>
      
      <tag>杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018年的一些小目标</title>
    <link href="/post/22757.html"/>
    <url>/post/22757.html</url>
    
    <content type="html"><![CDATA[<p>时间过得很快，从一个学生到一个社会人只需要那么一瞬间，一个来不及反应的瞬间。虽然之前经历过大量的实习工作，也不是第一次只身一人千里迢迢来到这个陌生的城市，但是还是有那么一些的不适应。</p><p>开始工作了，时间变得少了，但是学习的紧迫性却是变得更高了</p><p>列一列剩下不到半年时间想要学习的东西吧，权当是一个备忘录</p><ul><li>阅读学习至少两个 Go Web 框架 <code>七八月</code><ul><li>Echo</li><li>Gin</li><li>Iris</li><li>Beego</li><li>…</li></ul></li><li>学习 Golang 调度源码 <code>七八月 or 九月</code></li><li>从零开始编写自己的第一个 Go Web 框架 <code>八九月</code></li><li>未完待续…</li></ul><p>希望能够养成记录学习过程的习惯，<code>好记性不如烂笔头</code></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/how-to-write-a-pre-research-report.html">一点拙见-如何写好一个技术预研报告?</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>规划总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go标准库——ioutil.ReadAll的实现</title>
    <link href="/post/47700.html"/>
    <url>/post/47700.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>最近准备学习一下 golang 的标准库，详细的阅读部分源码，这个目录记录一下学习的过程和心得</p></blockquote><p>go 语言的<code>ioutil</code>包提供了很多方便的 io 操作的工具集，本文主要详细分析<code>ReadAll</code>方法的源码实现。</p><p><code>ReadAll</code>是很常用的一个方法，用来一次性的读取<code>io.Reader</code>当中的数据。</p><h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><h5 id="1-ReadAll"><a href="#1-ReadAll" class="headerlink" title="1. ReadAll"></a>1. ReadAll</h5><p>阅读下方的源码我们可以发现，<code>ReadAll</code>其实调用了一个非导出的方法，我们一步一步的追踪</p><pre><code class="hljs go"><span class="hljs-comment">// ReadAll reads from r until an error or EOF and returns the data it read.</span><span class="hljs-comment">// A successful call returns err == nil, not err == EOF. Because ReadAll is</span><span class="hljs-comment">// defined to read from src until EOF, it does not treat an EOF from Read</span><span class="hljs-comment">// as an error to be reported.</span><span class="hljs-comment">// ReadAll从r读取数据直到EOF或遇到error，返回读取的数据和遇到的错误。</span><span class="hljs-comment">// 成功的调用返回的err为nil而非EOF。</span><span class="hljs-comment">// 因为本函数定义为读取r直到EOF，它不会将读取返回的EOF视为应报告的错误。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadAll</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<span class="hljs-keyword">return</span> readAll(r, bytes.MinRead)&#125;</code></pre><h5 id="2-readAll"><a href="#2-readAll" class="headerlink" title="2. readAll"></a>2. readAll</h5><p>阅读这个函数代码，可以发现，<code>ioutil.ReadAll</code>实质上是使用<code>bytes.buffer</code>实现的，在这里面调用了两个<code>bytes.buffer</code>的方法，一个用来初始化<code>buffer</code>的容量，一个用于读取所有的<code>io.Reader</code>数据</p><p>除此之外我们还可以学习到 go 当中 panic recover 的使用方法，在<code>buffer</code>当中，如果无法分配足够的内存的时候，会直接<code>panic bytes.ErrTooLarge</code>的错误，但是，这个方法我们期望把这个错误给返回回来，这个时候就可以使用<code>defer recover</code>从<code>panic</code>当中恢复回来</p><pre><code class="hljs go"><span class="hljs-comment">// readAll reads from r until an error or EOF and returns the data it read</span><span class="hljs-comment">// from the internal buffer allocated with a specified capacity.</span><span class="hljs-comment">// readAll从r读取到一个错误或EOF，并返回从指定容量分配的内部缓冲区中读取的数据。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readAll</span><span class="hljs-params">(r io.Reader, capacity <span class="hljs-keyword">int64</span>)</span> <span class="hljs-params">(b []<span class="hljs-keyword">byte</span>, err error)</span></span> &#123;    <span class="hljs-comment">// 新建了一个buffer</span><span class="hljs-keyword">var</span> buf bytes.Buffer<span class="hljs-comment">// If the buffer overflows, we will get bytes.ErrTooLarge.</span>    <span class="hljs-comment">// Return that as an error. Any other panic remains.</span>    <span class="hljs-comment">// 如果buffer溢出了，会得到一个bytes.ErrTooLarge的错误</span>    <span class="hljs-comment">// 如果得到的是bytes.ErrTooLarge错误，将其返回，其他panic错误，仍然panic</span><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;e := <span class="hljs-built_in">recover</span>()<span class="hljs-keyword">if</span> e == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">if</span> panicErr, ok := e.(error); ok &amp;&amp; panicErr == bytes.ErrTooLarge &#123;err = panicErr&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">panic</span>(e)&#125;    &#125;()    <span class="hljs-comment">// 判断capacity的值是否超过了int类型的上限</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">int64</span>(<span class="hljs-keyword">int</span>(capacity)) == capacity &#123;<span class="hljs-comment">// 向buffer当中增加capacity的容量</span>buf.Grow(<span class="hljs-keyword">int</span>(capacity))    &#125;    <span class="hljs-comment">// 使用buffer ReadFrom 方法读取所有的io.Reader数据</span>_, err = buf.ReadFrom(r)<span class="hljs-keyword">return</span> buf.Bytes(), err&#125;</code></pre><h5 id="3-buffer"><a href="#3-buffer" class="headerlink" title="3. buffer"></a>3. buffer</h5><p>要看<code>buffer</code>相关函数的实现，先看看<code>buffer</code>的定义，不然到时候可能会懵 B</p><p>主要会用到两个字段，一个是<code>buf</code>,<code>buf</code>的内容是用<code>off</code>到<code>len(buf)</code>的，<code>off</code>之前的表示已经读取了数据，<code>off</code>表示当前位置，<code>buffer</code>的<code>write和read</code>方法都会从这个位置开始</p><pre><code class="hljs go"><span class="hljs-comment">// A Buffer is a variable-sized buffer of bytes with Read and Write methods.</span><span class="hljs-comment">// The zero value for Buffer is an empty buffer ready to use.</span><span class="hljs-comment">// Buffer是一个实现了读写方法的可变大小的字节缓冲。</span><span class="hljs-comment">// 本类型的零值是一个空的可用于读写的缓冲。</span><span class="hljs-keyword">type</span> Buffer <span class="hljs-keyword">struct</span> &#123;buf      []<span class="hljs-keyword">byte</span> <span class="hljs-comment">// contents are the bytes buf[off : len(buf)]</span>off      <span class="hljs-keyword">int</span>    <span class="hljs-comment">// read at &amp;buf[off], write at &amp;buf[len(buf)]</span>lastRead readOp <span class="hljs-comment">// last read operation, so that Unread* can work correctly.</span><span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> lastRead can fit in a single byte</span><span class="hljs-comment">// memory to hold first slice; helps small buffers avoid allocation.</span><span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> it would be advisable to align Buffer to cachelines to avoid false</span><span class="hljs-comment">// sharing.</span>bootstrap [<span class="hljs-number">64</span>]<span class="hljs-keyword">byte</span>&#125;</code></pre><h5 id="4-buffer-Grow"><a href="#4-buffer-Grow" class="headerlink" title="4. buffer.Grow"></a>4. buffer.Grow</h5><p>这个方法主要用来增加缓冲区的内存，实际还是调用了非导出的<code>grow</code>方法</p><pre><code class="hljs go"><span class="hljs-comment">// Grow grows the buffer's capacity, if necessary, to guarantee space for</span><span class="hljs-comment">// another n bytes. After Grow(n), at least n bytes can be written to the</span><span class="hljs-comment">// buffer without another allocation.</span><span class="hljs-comment">// If n is negative, Grow will panic.</span><span class="hljs-comment">// If the buffer can't grow it will panic with ErrTooLarge.</span><span class="hljs-comment">// 必要时会增加缓冲的容量，以保证n字节的剩余空间。</span><span class="hljs-comment">// 调用Grow(n)后至少可以向缓冲中写入n字节数据而无需申请内存。</span><span class="hljs-comment">// 如果n小于零或者不能增加容量都会panic ErrTooLarge 错误。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Buffer)</span> <span class="hljs-title">Grow</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"bytes.Buffer.Grow: negative count"</span>)&#125;m := b.grow(n)b.buf = b.buf[<span class="hljs-number">0</span>:m]&#125;</code></pre><h5 id="5-buffer-ReadFrom"><a href="#5-buffer-ReadFrom" class="headerlink" title="5. buffer.ReadFrom"></a>5. buffer.ReadFrom</h5><p>主要看看这个方法的实现，实现了从<code>io.Reader</code>读取所有数据。</p><p>示意图:<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142743.png" srcset="/img/loading.gif" alt="示意图"></p><pre><code class="hljs go"><span class="hljs-comment">// ReadFrom reads data from r until EOF and appends it to the buffer, growing</span><span class="hljs-comment">// the buffer as needed. The return value n is the number of bytes read. Any</span><span class="hljs-comment">// error except io.EOF encountered during the read is also returned. If the</span><span class="hljs-comment">// buffer becomes too large, ReadFrom will panic with ErrTooLarge.</span><span class="hljs-comment">// ReadFrom从r中读取数据直到结束并将读取的数据写入缓冲中，如必要会增加缓冲容量。</span><span class="hljs-comment">// 返回值n为从r读取并写入b的字节数；会返回读取时遇到的除了io.EOF之外的错误。</span><span class="hljs-comment">// 如果缓冲太大，ReadFrom会采用错误值ErrTooLarge引发panic。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Buffer)</span> <span class="hljs-title">ReadFrom</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(n <span class="hljs-keyword">int64</span>, err error)</span></span> &#123;    <span class="hljs-comment">// const opInvalid = 0  // Non-read operation. 表示之前没有读操作</span>b.lastRead = opInvalid    <span class="hljs-comment">// If buffer is empty, reset to recover space.</span>    <span class="hljs-comment">// 如果缓冲区为空，重置为恢复空间。</span><span class="hljs-keyword">if</span> b.off &gt;= <span class="hljs-built_in">len</span>(b.buf) &#123;b.Reset()    &#125;    <span class="hljs-comment">// 循环读取io.Reader 的数据</span><span class="hljs-keyword">for</span> &#123;        <span class="hljs-comment">// 判断当前剩余空间是否小于MinRead，MinRead = 512</span><span class="hljs-keyword">if</span> free := <span class="hljs-built_in">cap</span>(b.buf) - <span class="hljs-built_in">len</span>(b.buf); free &lt; MinRead &#123;            <span class="hljs-comment">// not enough space at end</span>            <span class="hljs-comment">// 空间不足</span>            <span class="hljs-comment">// 新建一个buf</span>            newBuf := b.buf            <span class="hljs-comment">// 判断实际剩余容量是否小于MinRead = 512</span><span class="hljs-keyword">if</span> b.off+free &lt; MinRead &#123;<span class="hljs-comment">// not enough space using beginning of buffer;</span>                <span class="hljs-comment">// double buffer capacity</span>                <span class="hljs-comment">// 实际剩余空间不足，分配双倍的缓冲空间，缓冲的最小值为MinRead所以加上一个MinRead，避免双倍之后仍然比MinRead小</span>                <span class="hljs-comment">// makeSlice函数用于分配缓冲空间，如果分配失败会panic ErrTooLarge 错误</span>newBuf = makeSlice(<span class="hljs-number">2</span>*<span class="hljs-built_in">cap</span>(b.buf) + MinRead)            &#125;            <span class="hljs-comment">// 将原有buf数据复制到新的buf</span>            <span class="hljs-built_in">copy</span>(newBuf, b.buf[b.off:])            <span class="hljs-comment">// len(b.buf)-b.off 就等于buf当前内容的长度</span>            <span class="hljs-comment">// 例子: a:=make([]byte,20)</span>            <span class="hljs-comment">//      b:=a[:10]</span>            <span class="hljs-comment">//      len(b) // 10</span>            <span class="hljs-comment">//      cap(b) //20</span>            b.buf = newBuf[:<span class="hljs-built_in">len</span>(b.buf)-b.off]            <span class="hljs-comment">// 将off置0</span>b.off = <span class="hljs-number">0</span>        &#125;        <span class="hljs-comment">// 从io.Reader当中读取数据，传入buf的剩余空间</span>        <span class="hljs-comment">// 第一种情况，数据读取完毕，返回读取长度m以及,io.EOF错误</span>        <span class="hljs-comment">// 第二种情况, 数据未读完，遇到错误</span>        <span class="hljs-comment">// 第三种情况，数据未读完，缓冲区容量不够，返回读取数据长度m以及nil</span>        m, e := r.Read(b.buf[<span class="hljs-built_in">len</span>(b.buf):<span class="hljs-built_in">cap</span>(b.buf)])        <span class="hljs-comment">// 只获取有数据的buf，无数据的空间转化为cap</span>b.buf = b.buf[<span class="hljs-number">0</span> : <span class="hljs-built_in">len</span>(b.buf)+m]        n += <span class="hljs-keyword">int64</span>(m)        <span class="hljs-comment">// 数据读取完毕跳出循环</span><span class="hljs-keyword">if</span> e == io.EOF &#123;<span class="hljs-keyword">break</span>        &#125;        <span class="hljs-comment">// 遇到错误返回</span><span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> n, e&#125;&#125;<span class="hljs-keyword">return</span> n, <span class="hljs-literal">nil</span> <span class="hljs-comment">// err is EOF, so return nil explicitly</span>&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>go标准库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用chromedp解决反爬虫问题</title>
    <link href="/post/5431.html"/>
    <url>/post/5431.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近 We 川大上的教务处公告新闻已经很久没有更新了，想到可能是 ip 被封了，查了一下 log，发现并不是，而是获取到的页面全变成了混淆过的 js，下面放两个格式化的函数</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_$Es</span>(<span class="hljs-params">_$Cu</span>) </span>&#123;  _$Cu[<span class="hljs-number">14</span>] = _$v9();  _$Cu[_$yf(_$ox(), <span class="hljs-number">16</span>)] = _$Dn();  <span class="hljs-keyword">var</span> _$cR = _$CR();  _$cR = _$iT();  <span class="hljs-keyword">return</span> _$DA();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_$Dk</span>(<span class="hljs-params">_$Cu</span>) </span>&#123;  <span class="hljs-keyword">var</span> _$x5 = _$Dv();  <span class="hljs-keyword">var</span> _$x5 = _$EB();  <span class="hljs-keyword">if</span> (_$Ex()) &#123;    _$w9 = _$Dw();  &#125;  _$Cu[_$yf(_$EJ(), <span class="hljs-number">16</span>)] = _$ED();  _$Cu[_$yf(_$Ep(), <span class="hljs-number">16</span>)] = _$EP();  _$w9 = _$EB();  <span class="hljs-keyword">return</span> _$Cu[_$yf(_$v9(), <span class="hljs-number">16</span>)];&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_$rK</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> _$aJ = _$c0(_$DN());  _$aJ = _$BC(_$aJ, <span class="hljs-number">2</span>);  <span class="hljs-keyword">var</span> _$Ce = _$yr(_$qt());  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _$Cu = <span class="hljs-number">0</span>; _$Cu &lt; _$aJ[_$gX()]; _$Cu++) &#123;    _$aJ[_$Cu] = _$Ce + _$aJ[_$Cu];  &#125;  <span class="hljs-keyword">return</span> _$aJ;&#125;</code></pre><p>看着这一堆就头大，但是本着只要是浏览器能够渲染出来的页面爬虫就可以爬到的原则，一步一步的解决</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>先使用 postman 发送了一下请求，发现返回了上面一堆乱码</li><li>复制了正常渲染页面 request header 重新发送请求，可以得到正常的页面。考虑两个可能一个是 header 有什么特殊的处理，一个是 cookie 上的问题。</li><li>header 其他内容不变，去掉 cookie 重新发送请求，再一次得到一堆乱码。问题定位成功，应该就是 cookie 的问题了</li><li>清空 chrome 的缓存，重新加载页面，查看请求记录，可以看到这个页面一共加载了两次<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141634.png" srcset="/img/loading.gif" alt="第一次加载"><br>第一次加载没有返回 cookie<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141635.png" srcset="/img/loading.gif" alt="第二次加载"><br>第二次加载返回了一个<code>JSESSIONID</code>，这个应该就是最终需要的 cookie 了</li><li>观察两次请求的中间，我们可以发现还有两个请求，这两个请求应该就是第二次返回 cookie 的原因了，第一个请求是页面内的外链 js 文件，第二个请求应该就是混淆过的 js 发出的请求了。</li><li>因为实力有限，分析了几个小时都没有分析出来这个逻辑是怎么加载的。但是想到了直接从浏览器把 cookie 复制下来给爬虫使用不就可以了？但是这样也还有一个问题，就是不可能每一次都手动的去获取 cookie 这样达不到想要的效果。然后看到 Python 有使用<code>Selenium</code>来完全模拟浏览器渲染然后解析页面的爬虫案例，找了一下 golang 有没有类似的浏览器渲染方案，在万能的 gayhub 上找到了<code>chromedp</code>。下面使用 chromedp 来解决这个问题。</li></ol><h2 id="chromedp"><a href="#chromedp" class="headerlink" title="chromedp"></a>chromedp</h2><blockquote><p>Package chromedp is a faster, simpler way to drive browsers (Chrome, Edge, Safari, Android, etc) without external dependencies (ie, Selenium, PhantomJS, etc) using the Chrome Debugging Protocol.</p></blockquote><h5 id="1-install（建议使用梯子）"><a href="#1-install（建议使用梯子）" class="headerlink" title="1.install（建议使用梯子）"></a>1.install（建议使用梯子）</h5><pre><code class="hljs bash">go get -u github.com/chromedp/chromedp</code></pre><h5 id="2-code"><a href="#2-code" class="headerlink" title="2.code"></a>2.code</h5><p>运行下面这一段代码可以看到 chrome 会弹出一个窗口并且运行网页，最后在 console 输出期望的 html，但是我们其实只需要得到正确的 cookie，用来之后爬取网页使用。如果所有的页面都需要等待 chrome 渲染结束之后爬取，那么效率实在是太低了</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"context"</span><span class="hljs-string">"fmt"</span><span class="hljs-string">"io/ioutil"</span><span class="hljs-string">"log"</span><span class="hljs-string">"time"</span><span class="hljs-string">"github.com/chromedp/cdproto/cdp"</span><span class="hljs-string">"github.com/chromedp/chromedp"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> err error<span class="hljs-comment">// create context</span>ctxt, cancel := context.WithCancel(context.Background())<span class="hljs-keyword">defer</span> cancel()<span class="hljs-comment">// create chrome instance</span>c, err := chromedp.New(ctxt, chromedp.WithLog(log.Printf))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-comment">// run task list</span><span class="hljs-keyword">var</span> res <span class="hljs-keyword">string</span>err = c.Run(ctxt, chromedp.Tasks&#123;        <span class="hljs-comment">// 访问教务处页面</span>chromedp.Navigate(<span class="hljs-string">`http://jwc.scu.edu.cn/jwc/moreNotice.action`</span>),        <span class="hljs-comment">// 等待table渲染成功，成功则说明已经获取到了正确的页面</span>        chromedp.WaitVisible(<span class="hljs-string">`table`</span>, chromedp.ByQuery),        <span class="hljs-comment">// 获取body标签的html字符</span>chromedp.OuterHTML(<span class="hljs-string">"body"</span>, &amp;res),&#125;)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-comment">// 关闭chrome实例</span>err = c.Shutdown(ctxt)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-comment">// 等待chrome实例关闭</span>err = c.Wait()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;    <span class="hljs-comment">// 输出html字符串</span>log.Printf(res)&#125;</code></pre><h5 id="3-获取-cookie"><a href="#3-获取-cookie" class="headerlink" title="3.获取 cookie"></a>3.获取 cookie</h5><p>修改第 2 步当中 task list 的代码获取 cookie，修改之后可以看到 console 当中输出了一段 cookie 字符串，使用这个 cookie 在 postman 当中测试可以发现，可以获取到正确的页面。到了这一步其实就应该算基本完成了，但是还是有一个缺点：每次运行的时候都会弹出一个 chrome 窗口，爬虫在服务器上运行是没有 gui 页面的，并且每次打开一个 chrome 实例的时间开销也比较大。</p><pre><code class="hljs go"><span class="hljs-comment">// 将chromedp.OuterHTML("body", &amp;res) 替换为下面的代码</span>chromedp.ActionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, h cdp.Executor)</span> <span class="hljs-title">error</span></span> &#123;    <span class="hljs-comment">// 获取cookie</span>    cookies, err := network.GetAllCookies().Do(ctx, h)    <span class="hljs-comment">// 将cookie拼接成header请求中cookie字段的模式</span>    <span class="hljs-keyword">var</span> c <span class="hljs-keyword">string</span>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> cookies &#123;        c = c + v.Name + <span class="hljs-string">"="</span> + v.Value + <span class="hljs-string">";"</span>    &#125;    log.Println(c)    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> err    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;),</code></pre><h5 id="5-使用-chrome-的-headless-模式"><a href="#5-使用-chrome-的-headless-模式" class="headerlink" title="5.使用 chrome 的 headless 模式"></a>5.使用 chrome 的 headless 模式</h5><p>a.使用 docker 运行一个 headless 模式的 chrome</p><pre><code class="hljs bash">docker run -d -p 9222:9222 --rm --name chrome-headless knqz/chrome-headless</code></pre><p>b.修改代码</p><p>可以看到主要的区别就在创建 chrome 实例的时候没有去启动一个 chrome，当然最后也不需要去关闭它</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"context"</span><span class="hljs-string">"log"</span><span class="hljs-string">"github.com/chromedp/chromedp/client"</span><span class="hljs-string">"github.com/chromedp/cdproto/network"</span><span class="hljs-string">"github.com/chromedp/cdproto/cdp"</span><span class="hljs-string">"github.com/chromedp/chromedp"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> err error<span class="hljs-comment">// create context</span>ctxt, cancel := context.WithCancel(context.Background())<span class="hljs-keyword">defer</span> cancel()<span class="hljs-comment">// create chrome instance</span>c, err := chromedp.New(ctxt, chromedp.WithTargets(client.New().WatchPageTargets(ctxt)), chromedp.WithLog(log.Printf))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-comment">// run task list</span>err = c.Run(ctxt, chromedp.Tasks&#123;        <span class="hljs-comment">// 访问教务处页面</span>chromedp.Navigate(<span class="hljs-string">`http://jwc.scu.edu.cn/jwc/moreNotice.action`</span>),        <span class="hljs-comment">// 等待table渲染成功，成功则说明已经获取到了正确的页面</span>        chromedp.WaitVisible(<span class="hljs-string">`table`</span>, chromedp.ByQuery),        <span class="hljs-comment">// 获取body标签的html字符</span>chromedp.ActionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, h cdp.Executor)</span> <span class="hljs-title">error</span></span> &#123;            <span class="hljs-comment">// 获取cookie</span>            cookies, err := network.GetAllCookies().Do(ctx, h)            <span class="hljs-comment">// 将cookie拼接成header请求中cookie字段的模式</span>            <span class="hljs-keyword">var</span> c <span class="hljs-keyword">string</span>            <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> cookies &#123;                c = c + v.Name + <span class="hljs-string">"="</span> + v.Value + <span class="hljs-string">";"</span>            &#125;            log.Println(c)            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;                <span class="hljs-keyword">return</span> err            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>        &#125;),&#125;)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;&#125;</code></pre><p>到这里基本就可以使用了，获取到 cookie 之后可以使用喜欢的方式去获取页面</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/auxvv1.html">Go Web小技巧（四）在单个仓库中支持多个 go mod 模块</a></li><li><a href="https://lailin.xyz/post/11996.html">Go Web 小技巧（三）Gin 参数绑定</a></li><li><a href="https://lailin.xyz/post/17394.html">Go Web 小技巧（二）GORM 使用自定义类型</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>爬虫</tag>
      
      <tag>chromedp</tag>
      
      <tag>四川大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>We川大开发笔记@0.2.0</title>
    <link href="/post/62925.html"/>
    <url>/post/62925.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>可以搜索小程序<code>we川大</code>直接体验</p><p>这不是刚刚发完 0.1.0 的笔记么？怎么 0.2.0 都出来了？</p><p>没有看错，效率就是那么高，上一篇也提到了 0.1.0 审核通过的时候 0.2.0 就基本已经完成了，而且现在已经上线了(准确的说是 0.2.1 版本)，这一次的审核快了许多，只用了不到两天就已经审核通过了</p><h2 id="功能预览"><a href="#功能预览" class="headerlink" title="功能预览"></a>功能预览</h2><p>这一版主要新增三个功能，然后就是一些优化：</p><p><strong>1.反馈</strong></p><p>参考 we 重邮，直接和 github 的 issue 关联，所有提交的反馈信息，都会新建一条 issue，为了防止滥用，每天的反馈次数做了一定的限制</p><p>这个后端上直接采用了 Google 的 go-github 包，开发起来十分的方便，只是文档资料不是特别的丰富，之后会专门总结一下</p><p><strong>2.空闲教室查询</strong></p><p>学校的空闲教室查询页面：<a href="http://cir.scu.edu.cn/cir/index.html" target="_blank" rel="noopener">http://cir.scu.edu.cn/cir/index.html</a></p><p>这是学校难得做的比较友好的站点，对于这个需要后端做一次接口中转即可</p><p><strong>3.新闻 Tag 列表</strong></p><p>这一版可以直接通过点击列表的 tag，查看前 20 条包含该 tag 的新闻， 至于为什么是 20 条，因为一个很奇怪的 bug 现在还没有解决。</p><p>两个页面，A，B 包含了同一个模块 C，在模块 C 当中可以点击跳转到 B，现在的问题就是在 A 页面的 C 模块当中点击跳转到 B 页面之后，B 页面的 C 模块的 scroll-view 绑定的所有事件都会消失</p><h2 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h2><p><img src="https://user-images.githubusercontent.com/15172509/35327035-66a31fb8-0133-11e8-9694-862bb9580b95.png" srcset="/img/loading.gif" alt="screenshot_2018-01-24-18-19-17-192_com tencent mm"><br><img src="https://user-images.githubusercontent.com/15172509/35327038-672fd782-0133-11e8-821d-5e280bade960.png" srcset="/img/loading.gif" alt="screenshot_2018-01-24-18-18-56-360_com tencent mm"><br><img src="https://user-images.githubusercontent.com/15172509/35327040-67727a4c-0133-11e8-9173-7fcd92ff5c0a.png" srcset="/img/loading.gif" alt="screenshot_2018-01-24-18-19-02-187_com tencent mm"></p><h2 id="博客原文-amp-amp-开源地址"><a href="#博客原文-amp-amp-开源地址" class="headerlink" title="博客原文&amp;&amp;开源地址"></a>博客原文&amp;&amp;开源地址</h2><p><a href="https://github.com/mohuishou/scuplus-wechat" target="_blank" rel="noopener">https://github.com/mohuishou/scuplus-wechat</a><br><a href="http://lailin.xyz/post/We川大开发笔记@0.2.0/">http://lailin.xyz/post/We 川大开发笔记@0.2.0/</a></p><p>可以关注开发进度或者提交反馈或者是 PR，star 多多益善</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/62781.html">We川大开发笔记@0.1.0</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>we川大</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>We川大开发笔记@0.1.0</title>
    <link href="/post/62781.html"/>
    <url>/post/62781.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>微信小程序已经出来一年左右了，然后之前也写过一个 scuplus 的 web 项目，但是还没有正式上线就无疾而终了，当然也不是一点用处都没有，拆分出来了两个小的功能模块，一个是绩点计算器，一个快捷评教，绩点计算器的日 PV 快要破 3W 了，UV 已经破 1W 了，大家期末看成绩的心情依旧是那么的急迫。</p><p>按理来说，我即将毕业做这些其实不太好，毕业之后代码的维护以及运营都是一个大问题，但是川大一直缺少一个综合型的 APP 或者网站，学校官方的网站做的都及其的不友好，而且十分的分散，所以一直有这个想法，想做一个集新闻资讯、比赛资讯/找队友/拉票，教务查询，课程推荐/排名/评价/选课，书籍查询/借阅于一体的一个综合型网站。当然这个想法涉及到的东西有点多，吸取之前的教训，这次打算一步一步的来，前期做功能，后期做优化，分模块上线</p><p>使用微信小程序开发好处是不用考虑浏览器的兼容性也不用考虑去做两个 APP，以及各种型号的手机，但是不好的地方就是所有的界面都只能靠自己去实现，基本没有现成的 ui 框架，有时候写的有点蛋疼(PS 我是一个后端)。然后就是审核，微信的审核 0.1.0 版本用了 5 天才完成，这个时间我的 0.2.0 版本已经基本开发完成了</p><p>项目已经开源，可以关注开发进度或者提交反馈或者是 PR，star 多多益善<br><a href="https://github.com/mohuishou/scuplus-wechat" target="_blank" rel="noopener">https://github.com/mohuishou/scuplus-wechat</a></p><h2 id="扫码体验"><a href="#扫码体验" class="headerlink" title="扫码体验"></a>扫码体验</h2><p><img src="https://scuplus.oss-cn-shenzhen.aliyuncs.com/qcode.jpg" srcset="/img/loading.gif" alt></p><h2 id="功能预览"><a href="#功能预览" class="headerlink" title="功能预览"></a>功能预览</h2><p>0.1.0 版本只是完成了基本的框架，以及相对来说比较常用的功能：</p><ul><li>最新资讯（青春川大/scuinfo/教务处/学工部等）</li><li>成绩/GPA 查询</li><li>课表查询</li></ul><h2 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h2><p><img src="https://user-images.githubusercontent.com/15172509/34929988-07a91c84-fa02-11e7-9a67-c2399232f820.png" srcset="/img/loading.gif" alt="index"><br><img src="https://user-images.githubusercontent.com/15172509/34929987-07640356-fa02-11e7-8197-6dbeb5ac1dc1.jpg" srcset="/img/loading.gif" alt="grade"><br><img src="https://user-images.githubusercontent.com/15172509/34929989-07e6f7fc-fa02-11e7-9143-b7d9737b432d.png" srcset="/img/loading.gif" alt="news"><br><img src="https://user-images.githubusercontent.com/15172509/34929990-08246a24-fa02-11e7-832c-fa3be2681ba9.png" srcset="/img/loading.gif" alt="newslist"><br><img src="https://user-images.githubusercontent.com/15172509/34929991-085ae856-fa02-11e7-9fba-3355071ea3b5.png" srcset="/img/loading.gif" alt="schedule"></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/62925.html">We川大开发笔记@0.2.0</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>we川大</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>招银网络面试总结</title>
    <link href="/post/1358.html"/>
    <url>/post/1358.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>三面同时进行，每一面间隔不超过五分钟，前面两面技术面最后一面 HR，完全不会 JAVA，结果一直问 JAVA 心态爆炸</p></blockquote><h2 id="一面-20min"><a href="#一面-20min" class="headerlink" title="一面(20min)"></a>一面(20min)</h2><h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h3><h3 id="2-JAVA-用过么？准备去什么地方？"><a href="#2-JAVA-用过么？准备去什么地方？" class="headerlink" title="2. JAVA 用过么？准备去什么地方？"></a>2. JAVA 用过么？准备去什么地方？</h3><p>用过一天写了一个小 APP</p><h3 id="3-JAVA-的-HashMap-怎么实现？PUT-一次做了什么操作"><a href="#3-JAVA-的-HashMap-怎么实现？PUT-一次做了什么操作" class="headerlink" title="3. JAVA 的 HashMap 怎么实现？PUT 一次做了什么操作"></a>3. JAVA 的 HashMap 怎么实现？PUT 一次做了什么操作</h3><p>不会</p><h3 id="4-JAVA-的-GC-怎么实现"><a href="#4-JAVA-的-GC-怎么实现" class="headerlink" title="4. JAVA 的 GC 怎么实现"></a>4. JAVA 的 GC 怎么实现</h3><p>不会，强行说了一波 PHP 的 GC</p><h3 id="5-Mysql-的锁"><a href="#5-Mysql-的锁" class="headerlink" title="5. Mysql 的锁"></a>5. Mysql 的锁</h3><p>Innodb 支持到行级锁，MyISAM 只支持到表</p><h3 id="6-求一个二叉树任意两节点的距离，时间复杂度是多少？"><a href="#6-求一个二叉树任意两节点的距离，时间复杂度是多少？" class="headerlink" title="6. 求一个二叉树任意两节点的距离，时间复杂度是多少？"></a>6. 求一个二叉树任意两节点的距离，时间复杂度是多少？</h3><h3 id="7-设计模式了解不？装饰器模式解释一下，写一个"><a href="#7-设计模式了解不？装饰器模式解释一下，写一个" class="headerlink" title="7. 设计模式了解不？装饰器模式解释一下，写一个"></a>7. 设计模式了解不？装饰器模式解释一下，写一个</h3><p>解释了一下，没有写，后面让写了一个工厂</p><blockquote><p>还有一些忘了</p></blockquote><h2 id="二面-15min"><a href="#二面-15min" class="headerlink" title="二面(15min)"></a>二面(15min)</h2><h3 id="1-自我介绍-1"><a href="#1-自我介绍-1" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h3><h3 id="2-JAVA-的-GC-怎么实现。。。又来了"><a href="#2-JAVA-的-GC-怎么实现。。。又来了" class="headerlink" title="2. JAVA 的 GC 怎么实现。。。又来了"></a>2. JAVA 的 GC 怎么实现。。。又来了</h3><h3 id="3-Mysql-去除重复项"><a href="#3-Mysql-去除重复项" class="headerlink" title="3. Mysql 去除重复项"></a>3. Mysql 去除重复项</h3><h3 id="4-Mysql-触发器机制"><a href="#4-Mysql-触发器机制" class="headerlink" title="4. Mysql 触发器机制"></a>4. Mysql 触发器机制</h3><h3 id="5-设计一个无限极分类的数据库表"><a href="#5-设计一个无限极分类的数据库表" class="headerlink" title="5. 设计一个无限极分类的数据库表"></a>5. 设计一个无限极分类的数据库表</h3><h3 id="6-怎么把去处来的数据树型结构化"><a href="#6-怎么把去处来的数据树型结构化" class="headerlink" title="6. 怎么把去处来的数据树型结构化"></a>6. 怎么把去处来的数据树型结构化</h3><h2 id="三面-35min"><a href="#三面-35min" class="headerlink" title="三面(35min)"></a>三面(35min)</h2><h3 id="1-拿了一波简历，成绩单，自我介绍"><a href="#1-拿了一波简历，成绩单，自我介绍" class="headerlink" title="1. 拿了一波简历，成绩单，自我介绍"></a>1. 拿了一波简历，成绩单，自我介绍</h3><h3 id="2-为什么不想留在成都"><a href="#2-为什么不想留在成都" class="headerlink" title="2. 为什么不想留在成都"></a>2. 为什么不想留在成都</h3><h3 id="3-成绩单上很多-60-分，飘过还是重修"><a href="#3-成绩单上很多-60-分，飘过还是重修" class="headerlink" title="3. 成绩单上很多 60 分，飘过还是重修"></a>3. 成绩单上很多 60 分，飘过还是重修</h3><p>飘过</p><h3 id="4-现在面试了哪些公司，有没有收到-offer-意向"><a href="#4-现在面试了哪些公司，有没有收到-offer-意向" class="headerlink" title="4. 现在面试了哪些公司，有没有收到 offer 意向"></a>4. 现在面试了哪些公司，有没有收到 offer 意向</h3><h3 id="5-简单的介绍了一个项目"><a href="#5-简单的介绍了一个项目" class="headerlink" title="5. 简单的介绍了一个项目"></a>5. 简单的介绍了一个项目</h3><h3 id="6-介绍了社团研发部部长和学院团副经历"><a href="#6-介绍了社团研发部部长和学院团副经历" class="headerlink" title="6. 介绍了社团研发部部长和学院团副经历"></a>6. 介绍了社团研发部部长和学院团副经历</h3><blockquote><p>还有一些记不住了</p></blockquote><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/56757.html">百度面试总结</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>秋招</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell排序</title>
    <link href="/post/27243.html"/>
    <url>/post/27243.html</url>
    
    <content type="html"><![CDATA[<h1 id="Shell-排序"><a href="#Shell-排序" class="headerlink" title="Shell 排序"></a>Shell 排序</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>设置间隔（传统间隔为 N/2）</li><li>插入排序</li></ol><h2 id="图片示例"><a href="#图片示例" class="headerlink" title="图片示例"></a>图片示例</h2><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142753.gif" srcset="/img/loading.gif" alt></p><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><h3 id="传统实现"><a href="#传统实现" class="headerlink" title="传统实现"></a>传统实现</h3><pre><code class="hljs go"><span class="hljs-comment">//SortInt 传统shell排序,间隔为N/2</span><span class="hljs-comment">//相邻间隔可能不互质，可能会出现前置排序无用的情况</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SortInt</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;n := <span class="hljs-number">0</span>aLen := <span class="hljs-built_in">len</span>(a)<span class="hljs-comment">//定义间隔</span><span class="hljs-keyword">for</span> i := aLen / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i = i / <span class="hljs-number">2</span> &#123;<span class="hljs-comment">//插入排序</span><span class="hljs-keyword">for</span> j := i; j &lt; aLen; j++ &#123;tmp := a[j]k := j<span class="hljs-keyword">for</span> ; k &gt;= i &amp;&amp; tmp &lt; a[k-i]; k = k - i &#123;a[k] = a[k-i]n++&#125;a[k] = tmp&#125;&#125;<span class="hljs-keyword">return</span> a, n&#125;</code></pre><h3 id="Hibbard-算法"><a href="#Hibbard-算法" class="headerlink" title="Hibbard 算法"></a>Hibbard 算法</h3><pre><code class="hljs go"><span class="hljs-comment">//SortHibbardInt Hibbard算法，间隔为2^k-1</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SortHibbardInt</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;n, i := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>aLen := <span class="hljs-built_in">len</span>(a)<span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>; i &lt;= aLen<span class="hljs-number">-1</span>; i = i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span> &#123;&#125;<span class="hljs-comment">//定义间隔</span><span class="hljs-keyword">for</span> ; i &gt; <span class="hljs-number">0</span>; i = (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &#123;<span class="hljs-comment">// println(i)</span><span class="hljs-comment">//插入排序</span><span class="hljs-keyword">for</span> j := i; j &lt; aLen; j++ &#123;tmp := a[j]k := j<span class="hljs-keyword">for</span> ; k &gt;= i &amp;&amp; tmp &lt; a[k-i]; k = k - i &#123;a[k] = a[k-i]n++&#125;a[k] = tmp&#125;&#125;<span class="hljs-keyword">return</span> a, n&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/post/51203.html"/>
    <url>/post/51203.html</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/mohuishou/go-sort" target="_blank" rel="noopener">https://github.com/mohuishou/go-sort</a></p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141643.gif" srcset="/img/loading.gif" alt="示例图片"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> selection<span class="hljs-comment">//Sort 选择排序</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">var</span> LEN = <span class="hljs-built_in">len</span>(arr)minIndex := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; LEN; i++ &#123;minIndex = i<span class="hljs-keyword">for</span> j := i; j &lt; LEN; j++ &#123;<span class="hljs-keyword">if</span> arr[minIndex] &gt; arr[j] &#123;minIndex = j&#125;&#125;<span class="hljs-keyword">if</span> minIndex != i &#123;arr[minIndex], arr[i] = arr[i], arr[minIndex]&#125;&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/post/50190.html"/>
    <url>/post/50190.html</url>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤 2~5</li></ol><h2 id="图片示例"><a href="#图片示例" class="headerlink" title="图片示例"></a>图片示例</h2><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141645.gif" srcset="/img/loading.gif" alt></p><h2 id="程序示例（go）"><a href="#程序示例（go）" class="headerlink" title="程序示例（go）"></a>程序示例（go）</h2><pre><code class="hljs go"><span class="hljs-comment">//SortInt 插入排序</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SortInt</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;n := <span class="hljs-number">0</span>aLen := <span class="hljs-built_in">len</span>(a)<span class="hljs-comment">//从i=1开始，第一个数不用排序，一个数相当于已经有序了</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; aLen; i++ &#123;<span class="hljs-comment">//取出新数（类似摸牌）</span>tmp := a[i]<span class="hljs-comment">//将新数和之前的数从后往前（从大到小）一次比较，如果新数更小,就将以前的数往后移一位</span>j := i<span class="hljs-keyword">for</span> ; (j &gt; <span class="hljs-number">0</span>) &amp;&amp; (tmp &lt; a[j<span class="hljs-number">-1</span>]); j-- &#123;n++a[j] = a[j<span class="hljs-number">-1</span>] <span class="hljs-comment">//后移一位</span>&#125;<span class="hljs-comment">//新数插入</span>a[j] = tmp&#125;<span class="hljs-keyword">return</span> a, n&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/post/11306.html"/>
    <url>/post/11306.html</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/mohuishou/go-sort" target="_blank" rel="noopener">https://github.com/mohuishou/go-sort</a></p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(n log n)次比较。在最坏状况下则需要 Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来，且在大部分真实世界的数据，可以决定设计的选择，减少所需时间的二次方项之可能性。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>从数列中挑出一个元素，称为 “基准”（pivot），</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p><em>注意: 基准点采用三元素原则法，三元素选择之后一头一尾就已经有序了</em></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141632.gif" srcset="/img/loading.gif" alt="示例图片"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> quik<span class="hljs-comment">//Sort 快速排序</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;Quik(arr, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>)&#125;<span class="hljs-comment">//Quik 快速排序递归实现</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Quik</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, left <span class="hljs-keyword">int</span>, right <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> right-left &lt; <span class="hljs-number">2</span> &#123;<span class="hljs-keyword">return</span>&#125;p := middle3(arr, left, right)i := left + <span class="hljs-number">1</span>j := right - <span class="hljs-number">2</span><span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">for</span> arr[i] &lt; p &#123;i++&#125;<span class="hljs-keyword">for</span> arr[j] &gt; p &#123;j--&#125;<span class="hljs-keyword">if</span> i &lt; j &#123;arr[i], arr[j] = arr[j], arr[i]&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>&#125;&#125;arr[i], arr[right<span class="hljs-number">-1</span>] = arr[right<span class="hljs-number">-1</span>], arr[i]Quik(arr, left, i<span class="hljs-number">-1</span>)Quik(arr, i+<span class="hljs-number">1</span>, right)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middle3</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, left <span class="hljs-keyword">int</span>, right <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;center := (right + left) / <span class="hljs-number">2</span><span class="hljs-keyword">if</span> arr[left] &gt; arr[center] &#123;arr[left], arr[center] = arr[center], arr[left]&#125;<span class="hljs-keyword">if</span> arr[left] &gt; arr[right] &#123;arr[left], arr[right] = arr[right], arr[left]&#125;<span class="hljs-keyword">if</span> arr[center] &gt; arr[right] &#123;arr[center], arr[right] = arr[right], arr[center]&#125;arr[center], arr[right<span class="hljs-number">-1</span>] = arr[right<span class="hljs-number">-1</span>], arr[center]<span class="hljs-keyword">return</span> arr[right<span class="hljs-number">-1</span>]&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/post/63711.html"/>
    <url>/post/63711.html</url>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>归并排序:是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤 3 直到某一指针达到序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141633.gif" srcset="/img/loading.gif" alt="示例图片"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> merge<span class="hljs-comment">//INFINITY 一个比较大的值用作哨兵</span><span class="hljs-keyword">const</span> INFINITY = <span class="hljs-number">0xffff</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, start, end <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> start &lt; end &#123;<span class="hljs-comment">//从中间划分，分别左右两边排序</span>mid := (end + start) / <span class="hljs-number">2</span>merge(arr, start, mid)merge(arr, mid+<span class="hljs-number">1</span>, end)<span class="hljs-comment">//下面进行归并操作，将两个长度较小但是已经排序完成的数组合并成一个较长长度的排序数组</span><span class="hljs-comment">//新建一个数组用于存放左边的值</span>arr1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, mid-start+<span class="hljs-number">2</span>)<span class="hljs-built_in">copy</span>(arr1, arr[start:mid+<span class="hljs-number">1</span>])arr1[mid-start+<span class="hljs-number">1</span>] = INFINITY<span class="hljs-comment">//新建一个数组用于存放右边的值</span>arr2 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, end-mid+<span class="hljs-number">1</span>)<span class="hljs-built_in">copy</span>(arr2, arr[mid+<span class="hljs-number">1</span>:end+<span class="hljs-number">1</span>])arr2[end-mid] = INFINITY<span class="hljs-comment">//比较大小</span>j, k := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := start; i &lt;= end; i++ &#123;<span class="hljs-keyword">if</span> arr1[j] &lt;= arr2[k] &#123;arr[i] = arr1[j]j++&#125; <span class="hljs-keyword">else</span> &#123;arr[i] = arr2[k]k++&#125;&#125;&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序</title>
    <link href="/post/46698.html"/>
    <url>/post/46698.html</url>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>堆积排序： 是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>建堆，建堆是不断调整堆的过程，从 len/2 处开始调整，一直到第一个节点，此处 len 是堆中元素的个数。建堆的过程是线性的过程，从 len/2 到 0 处一直调用调整堆的过程，相当于 o(h1)+o(h2)…+o(hlen/2) 其中 h 表示节点的深度，len/2 表示节点的个数，这是一个求和的过程，结果是线性的 O(n)。</li><li>调整堆：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点 i 和它的孩子节点 left(i),right(i)，选出三者最大(或者最小)者，如果最大（小）值不是节点 i 而是它的一个孩子节点，那边交互节点 i 和该节点，然后再调用调整堆过程，这是一个递归的过程。调整堆的过程时间复杂度与堆的深度有关系，是 lgn 的操作，因为是沿着深度方向进行调整的。</li><li>堆排序：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面 len-1 个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。堆排序过程的时间复杂度是 O(nlgn)。因为建堆的时间复杂度是 O(n)（调用一次）；调整堆的时间复杂度是 lgn，调用了 n-1 次，所以堆排序的时间复杂度是 O(nlgn)[2]</li></ul><p><em>注意: 根节点在数组当中存放的位置是 0，所以第 i 个节点的左孩子是 2i+1,右孩子是 2i+2</em></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141622.gif" srcset="/img/loading.gif" alt="示例图片"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> HeapSort<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span>)<span class="hljs-comment">//HeapSort 堆排序</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>)</span></span> &#123;LEN := <span class="hljs-built_in">len</span>(arr)<span class="hljs-keyword">for</span> i := LEN/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;HeapAjust(arr, i, LEN)&#125;<span class="hljs-keyword">for</span> i := LEN - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;arr[i], arr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>], arr[i]HeapAjust(arr, <span class="hljs-number">0</span>, i)&#125;&#125;<span class="hljs-comment">//HeapAjust 堆调整</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HeapAjust</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, start <span class="hljs-keyword">int</span>, length <span class="hljs-keyword">int</span>)</span></span> &#123;tmp := arr[start]<span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>*start + <span class="hljs-number">1</span>; i &lt; length; i = i * <span class="hljs-number">2</span> &#123;<span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span> &lt; length &amp;&amp; arr[i] &lt; arr[i+<span class="hljs-number">1</span>] &#123;i++&#125;<span class="hljs-keyword">if</span> tmp &gt; arr[i] &#123;<span class="hljs-keyword">break</span>&#125;arr[start] = arr[i]start = i&#125;arr[start] = tmp&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百度面试总结</title>
    <link href="/post/56757.html"/>
    <url>/post/56757.html</url>
    
    <content type="html"><![CDATA[<h2 id="一面-40min"><a href="#一面-40min" class="headerlink" title="一面(40min)"></a>一面(40min)</h2><h3 id="0-自我介绍"><a href="#0-自我介绍" class="headerlink" title="0. 自我介绍"></a>0. 自我介绍</h3><h3 id="1-介绍-ImageOCR-的项目"><a href="#1-介绍-ImageOCR-的项目" class="headerlink" title="1. 介绍 ImageOCR 的项目"></a>1. 介绍 ImageOCR 的项目</h3><h3 id="2-知道有哪些排序算法？"><a href="#2-知道有哪些排序算法？" class="headerlink" title="2. 知道有哪些排序算法？"></a>2. 知道有哪些排序算法？</h3><p>冒泡、插入、shell、归并、快排、堆排序、选择排序等等</p><blockquote><p>有没有不会写的，排雷排掉了堆排序</p></blockquote><h3 id="3-手写插入排序并解释"><a href="#3-手写插入排序并解释" class="headerlink" title="3. 手写插入排序并解释"></a>3. 手写插入排序并解释</h3><h3 id="4-上面的排序算法哪些是稳定的，哪些是不稳定的"><a href="#4-上面的排序算法哪些是稳定的，哪些是不稳定的" class="headerlink" title="4. 上面的排序算法哪些是稳定的，哪些是不稳定的"></a>4. 上面的排序算法哪些是稳定的，哪些是不稳定的</h3><h3 id="还有一些忘了"><a href="#还有一些忘了" class="headerlink" title="还有一些忘了"></a>还有一些忘了</h3><h2 id="二面-1-2h"><a href="#二面-1-2h" class="headerlink" title="二面(1.2h)"></a>二面(1.2h)</h2><h3 id="0-介绍简历上的另外一个项目"><a href="#0-介绍简历上的另外一个项目" class="headerlink" title="0. 介绍简历上的另外一个项目"></a>0. 介绍简历上的另外一个项目</h3><h3 id="1-PHP-的基本数据类型以及基本数据类型内核如何实现"><a href="#1-PHP-的基本数据类型以及基本数据类型内核如何实现" class="headerlink" title="1. PHP 的基本数据类型以及基本数据类型内核如何实现?"></a>1. PHP 的基本数据类型以及基本数据类型内核如何实现?</h3><p><strong>基本数据类型</strong></p><pre><code class="hljs undefined"><span class="hljs-built_in">boolean</span>(布尔型)布尔型是最简单的数据类型，只有两个值 <span class="hljs-literal">false</span>(假) 和<span class="hljs-literal">true</span>(真)<span class="hljs-built_in">string</span>(字符串型)字符串就是连续的字符序列，如 ehco <span class="hljs-string">"string"</span>;<span class="hljs-built_in">integer</span>(整型)    整型数据类型只能包含整数，这些数据类型可以是负数或者正数folat(浮点型)浮点型类型用于存储数字，和整型不同的是浮点型可以有小数点<span class="hljs-built_in">array</span>（数组）一组相同类型的集合object（对象）对象是一个实力，使用<span class="hljs-literal">new</span>命令创建一个对象resource（资源）资源是一种特殊的变量，保存在外部资源的一个应用，资源是通过函数来进行建立的<span class="hljs-built_in">null</span>（ 空白）特殊的值，表示变量没有值，任何变量的初始值都是<span class="hljs-built_in">null</span></code></pre><p><strong>变量的在内核当中的保存方式：</strong></p><ul><li>php5.3: <a href="http://blog.csdn.net/qq_28602957/article/details/52959132" target="_blank" rel="noopener">http://blog.csdn.net/qq_28602957/article/details/52959132</a></li></ul><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> _zvalue_value &#123;    <span class="hljs-keyword">long</span> lval;                  <span class="hljs-comment">/* long value */</span>    <span class="hljs-keyword">double</span> dval;                <span class="hljs-comment">/* double value */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>        <span class="hljs-keyword">char</span> *val;        <span class="hljs-keyword">int</span> len;    &#125; str;    HashTable *ht;              <span class="hljs-comment">/* hash table value */</span>    zend_object_value obj;    zend_ast *ast;&#125; zvalue_value;<span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">zval_struct</span> &#123;</span>    <span class="hljs-comment">/* Variable information */</span>    zvalue_value value;     <span class="hljs-comment">/* value */</span>    zend_uint refcount__gc;    zend_uchar type;    <span class="hljs-comment">/* active type */</span>    zend_uchar is_ref__gc;&#125;;</code></pre><table><thead><tr><th style="text-align:center">PHP 语言层类型</th><th style="text-align:center">存在 zvalue_value 的成员变量</th></tr></thead><tbody><tr><td style="text-align:center">long,bool,resoure</td><td style="text-align:center">lval</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">dval</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center">str(len 保存字符串的长度，val 保存字符串的值)</td></tr><tr><td style="text-align:center">array</td><td style="text-align:center">ht（哈希表）</td></tr><tr><td style="text-align:center">object</td><td style="text-align:center">obj</td></tr></tbody></table><ul><li>php7: <a href="https://yq.aliyun.com/articles/27359" target="_blank" rel="noopener">https://yq.aliyun.com/articles/27359</a></li></ul><pre><code class="hljs C"><span class="hljs-comment">//存储变量的结构</span><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">zval_struct</span> &#123;</span>    zend_value        value;            <span class="hljs-comment">/* value */</span>    <span class="hljs-keyword">union</span> &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>            ZEND_ENDIAN_LOHI_4(                zend_uchar    type,         <span class="hljs-comment">/* active type */</span>                zend_uchar    type_flags,                zend_uchar    const_flags,                zend_uchar    reserved)     <span class="hljs-comment">/* call info for EX(This) */</span>        &#125; v;        <span class="hljs-keyword">uint32_t</span> type_info;    &#125; u1;    <span class="hljs-keyword">union</span> &#123;        <span class="hljs-keyword">uint32_t</span>     var_flags;        <span class="hljs-keyword">uint32_t</span>     next;                 <span class="hljs-comment">/* hash collision chain */</span>        <span class="hljs-keyword">uint32_t</span>     cache_slot;           <span class="hljs-comment">/* literal cache slot */</span>        <span class="hljs-keyword">uint32_t</span>     lineno;               <span class="hljs-comment">/* line number (for ast nodes) */</span>        <span class="hljs-keyword">uint32_t</span>     num_args;             <span class="hljs-comment">/* arguments number for EX(This) */</span>        <span class="hljs-keyword">uint32_t</span>     fe_pos;               <span class="hljs-comment">/* foreach position */</span>        <span class="hljs-keyword">uint32_t</span>     fe_iter_idx;          <span class="hljs-comment">/* foreach iterator index */</span>    &#125; u2;&#125;;<span class="hljs-comment">//变量的值</span><span class="hljs-comment">//通过上面的代码我们可以看到。变量是通过一个_zval_struct结构体方式存储的。其中结构体中的value存储的是变量的值。这个成员是zend_value类型的。zend_value类型的定义如下：</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> _zend_value &#123;    zend_long         lval;             <span class="hljs-comment">/* long value */</span>    <span class="hljs-keyword">double</span>            dval;             <span class="hljs-comment">/* double value */</span>    zend_refcounted  *counted;    zend_string      *str;    zend_array       *arr;    zend_object      *obj;    zend_resource    *res;    zend_reference   *ref;    zend_ast_ref     *ast;    zval             *zv;    <span class="hljs-keyword">void</span>             *ptr;    zend_class_entry *ce;    zend_function    *func;    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>        <span class="hljs-keyword">uint32_t</span> w1;        <span class="hljs-keyword">uint32_t</span> w2;    &#125; ww;&#125; zend_value;</code></pre><h3 id="2-PHP-如何与-nginx-通信，通信方式有什么异同"><a href="#2-PHP-如何与-nginx-通信，通信方式有什么异同" class="headerlink" title="2. PHP 如何与 nginx 通信，通信方式有什么异同"></a>2. PHP 如何与 nginx 通信，通信方式有什么异同</h3><ul><li><a href="https://vsxen.github.io/2017/05/30/phpcgi-socks-vs-tcp/" target="_blank" rel="noopener">https://vsxen.github.io/2017/05/30/phpcgi-socks-vs-tcp/</a></li></ul><h4 id="CGI-模式"><a href="#CGI-模式" class="headerlink" title="CGI 模式"></a>CGI 模式</h4><p>CGI CGI（common gateway interface）通常翻译为共同网关接口，是 HTTP 服务器与机器上的其他程序进行通信的一个接口，让 Web 服务器必要时启动额外的程序处理动态内容。CGI 是一种协议，它定义了 Webserver 与 CGI 程序的通信方式。Webserver 接受客户端的 HTTP 请求，然后建立进程执行 CGI 程序，客户端的请求被传递给 CGI 程序，CGI 执行后结果再返回 Webserver。 CGI 的出现让 WEB 从静态变为为动态，随着 Web 的越来越普及，很多的网站的都需要有动态的页面，以便与浏览者互交。随着网络技术的发展，CGI 方式的缺点也越来越突出。每次客户端请求都需要建立和销毁进程。因为 HTTP 要生成一个动态页面，系统就必须启动一个新的进程以运行 CGI 程序，不断地 fork 是一项很消耗时间和资源的工作。</p><h4 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h4><p>众所周知，CGI 解释器的反复加载是 CGI 性能低下的主要原因，如果 CGI 解释器保持在内存中 并接受 FastCGI 进程管理器调度，则可以提供良好的性能、伸缩性、Fail-Over 特性等等。</p><p>FastCGI 是一个常驻型的 CGI，可以一直执行，只要激活后，不会每次都花时间去 fork 一次，而且还支持分布式运算（使得 php 程序解释执行可以单独交给 php 服务器），即可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。</p><p>1、Web Server 启动时载入 FastCGI 进程管理器（IIS ISAPI 或 Apache Module）;<br>2、FastCGI 进程管理器自身初始化，启动多个 CGI 解释器进程 (在任务管理器中可见多个 php-cgi.exe)并等待来自 Web Server 的连接。<br>3、当客户端请求到达 Web Server 时，FastCGI 进程管理器选择并连接到一个 CGI 解释器。Web server 将 CGI 环境变量和标准输入发送到 FastCGI 子进程 php-cgi.exe。<br>4、FastCGI 子进程完成处理后将标准输出和错误信息从同一连接返回 Web Server。当 FastCGI 子进程关闭连接时，请求便告处理完成。FastCGI 子进程接着等待并处理来自 FastCGI 进程管理器（运行在 WebServer 中）的下一个连接。 在正常的 CGI 模式中，php-cgi.exe 在此便退出了</p><h4 id="Apache-模块"><a href="#Apache-模块" class="headerlink" title="Apache 模块"></a>Apache 模块</h4><p>MPM Multi Path Modules （多道处理模块）用于定义 apache 在响应多个用户请求时所工作的模型。有三种 MPM 模式：</p><p>prefork（一个请求一个进程响应）</p><p>worker（一个请求用一个线程响应，启动多个进程每个进程生成多个线程）</p><p>event（一个进程处理多个请求）</p><p>以模块安装的 php 没有独立的进程，是作为 apache 的模块和 apache 一起启动的。</p><p>以上三种 MPM 模式，worker 模式会比 prefork 模式占据更少的内存，高并发下的表现更好。而且使用多进程和多线程混合模式，即使有一个线程挂了，也只影响和该线程同进程的其他线程，不会影响到其他的进程。但是如果有特别多的线程都使用 keep-alive 的长连接方式，则线程会一直被占据直到超时才释放，导致在高并发场景下无可用线程。而 event 模式使用了一个专门的线程来处理这些 keep-alive 类线程，较好的解决了这个问题。</p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>Nginx 处理 PHP 文件 只有 FastCGI 一种<br>不过 Nginx 连接 fastcgi 的方式有 2 种：TCP 和 unix domain socket<br>Unix domain socket 或者 IPC socket 是一种终端，可以使同一台操作系统上的两个或多个进程进行数据通信。与管道相比，Unix domain sockets 既可以使用字节流和数据队列，而管道通信则只能通过字节流。Unix domain sockets 的接口和 Internet socket 很像，但它不使用网络底层协议来通信。Unix domain socket 的功能是 POSIX 操作系统里的一种组件。<br>Unix domain sockets 使用系统文件的地址来作为自己的身份。它可以被系统进程引用。所以两个进程可以同时打开一个 Unix domain sockets 来进行通信。不过这种通信方式是发生在系统内核里而不会在网络里传播。<br>TCP 和 unix domain socket 方式对比<br>TCP 是使用 TCP 端口连接 127.0.0.1:9000<br>Socket 是使用 unix domain socket 连接套接字/dev/shm/php-cgi.sock（很多教程使用路径/tmp，而路径/dev/shm 是个 tmpfs，速度比磁盘快得多）<br>测试机是个 1 核的 centos5.4，2 用户并发时系统资源消耗 50%左右，10 用户资源就跑得很满了</p><p>结论是在服务器压力不大的情况下，tcp 和 socket 差别不大，但在压力比较满的时候，用套接字方式，效果确实比较好。<br>下面是 php 5.3 以上版本将 TCP 改成 socket 方式的配置方法：<br>修改 php-fpm.conf（/usr/local/php/etc/php-fpm.conf）<br>;listen = 127.0.0.1:9000<br>listen = /dev/shm/php-cgi.sock<br>修改 nginx 配置文件 server 段的配置，将 http 的方式改为 socket 方式</p><p>从原理上来说，unix socket 方式肯定要比 tcp 的方式快而且消耗资源少，因为 socket 之间在 nginx 和 php-fpm 的进程之间通信，而 tcp 需要经过本地回环驱动，还要申请临时端口和 tcp 相关资源。<br>当然还是从原理上来说，unix socket 会显得不是那么稳定，当并发连接数爆发时，会产生大量的长时缓存，在没有面向连接协议支撑的情况下，大数据包很有可能就直接出错并不会返回异常。而 TCP 这样的面向连接的协议，多少可以保证通信的正确性和完整性。</p><h3 id="3-PHP-的执行模式有哪些"><a href="#3-PHP-的执行模式有哪些" class="headerlink" title="3. PHP 的执行模式有哪些"></a>3. PHP 的执行模式有哪些</h3><ul><li><a href="http://blog.csdn.net/xujingzhong0077/article/details/53316767" target="_blank" rel="noopener">http://blog.csdn.net/xujingzhong0077/article/details/53316767</a></li></ul><h4 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h4><p>关于 PHP 目前比较常见的五大运行模式：<br>1）CGI（通用网关接口/ Common Gateway Interface）<br>2）FastCGI（常驻型 CGI / Long-Live CGI）<br>3）CLI（命令行运行 / Command Line Interface）<br>4）Web 模块模式（Apache 等 Web 服务器运行的模式）<br>5）ISAPI（Internet Server Application Program Interface）</p><p>备注：在 PHP5.3 以后，PHP 不再有 ISAPI 模式，安装后也不再有 php5isapi.dll 这个文件。要在 IIS6 上使用高版本 PHP，必须安装 FastCGI 扩展，然后使 IIS6 支持 FastCGI。</p><h4 id="1-1、CGI-模式"><a href="#1-1、CGI-模式" class="headerlink" title="1.1、CGI 模式"></a>1.1、CGI 模式</h4><p>CGI 即通用网关接口（Common Gateway Interface），它是一段程序，通俗的讲 CGI 就象是一座桥，把网页和 Web 服务器中的执行程序连接起来，它把 HTML 接收的指令传递给服务器的执行程序，再把服务器执行程序的结果返还给 HTML 页。CGI 的跨平台性能极佳，几乎可以在任何操作系统上实现。CGI 已经是比较老的模式了，这几年都很少用了。</p><p>每有一个用户请求，都会先要创建 CGI 的子进程，然后处理请求，处理完后结束这个子进程，这就是 Fork-And-Execute 模式。 当用户请求数量非常多时，会大量挤占系统的资源如内存，CPU 时间等，造成效能低下。所以用 CGI 方式的服务器有多少连接请求就会有多少 CGI 子进程，子进程反复加载是 CGI 性能低下的主要原因。</p><p>如果不想把 PHP 嵌入到服务器端软件（如 Apache）作为一个模块安装的话，可以选择以 CGI 的模式安装。或者把 PHP 用于不同的 CGI 封装以便为代码创建安全的 chroot 和 setuid 环境。这样每个客户机请求一个 PHP 文件，Web 服务器就调用 php.exe（win 下是 php.exe,linux 是 php）去解释这个文件，然后再把解释的结果以网页的形式返回给客户机。 这种安装方式通常会把 PHP 的可执行文件安装到 web 服务器的 cgi-bin 目录。CERT 建议书 CA-96.11 建议不要把任何的解释器放到 cgi-bin 目录。 这种方式的好处是把 Web Server 和具体的程序处理独立开来，结构清晰，可控性强，同时缺点就是如果在高访问需求的情况下，CGI 的进程 Fork 就会成为很大的服务器负担，想 象一下数百个并发请求导致服务器 Fork 出数百个进程就明白了。这也是为什么 CGI 一直背负性能低下，高资源消耗的恶名的原因。</p><h4 id="1-2、FastCGI-模式"><a href="#1-2、FastCGI-模式" class="headerlink" title="1.2、FastCGI 模式"></a>1.2、FastCGI 模式</h4><p>FastCGI 是 CGI 的升级版本，FastCGI 像是一个常驻 (long-live)型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去 Fork 一次 （这是 CGI 最为人诟病的 fork-and-execute 模式）。<br>FastCGI 是一个可伸缩地、高速地在 HTTP server 和动态脚本语言间通信的接口。多数流行的 HTTP server 都支持 FastCGI，包括 Apache、Nginx 和 lighttpd 等，同时，FastCGI 也被许多脚本语言所支持，其中就有 PHP。<br>FastCGI 接口方式采用 C/S 结构，可以将 HTTP 服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当 HTTP 服务器每次遇到动态程序时，可以将其直接交付给 FastCGI 进程来执行，然后将得到的结果返回给浏览器。这种方式可以让 HTTP 服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。</p><p>【原理】<br>1）Web Server 启动时载入 FastCGI 进程管理器（IIS ISAPI 或 Apache Module)；<br>2）FastCGI 进程管理器自身初始化，启动多个 CGI 解释器进程 (可见多个 php-cgi.exe 或 php-cig)并等待来自 Web Server 的连接；<br>3）当客户端请求到达 Web Server 时，FastCGI 进程管理器选择并连接到一个 CGI 解释器。Web server 将 CGI 环境变量和标准输入发送到 FastCGI 子进程 php-cgi；<br>4）FastCGI 子进程完成处理后将标准输出和错误信息从同一连接返回 Web Server。当 FastCGI 子进程关闭连接时，请求便告处理完成。FastCGI 子进程接着等待并处理来自 FastCGI 进程管理器（运行在 WebServer 中）的下一个连接。在正常的 CGI 模式中，php-cgi.exe 在此便退出了。<br>在 CGI 模式中，你可以想象 CGI 通常有多慢。每一个 Web 请求 PHP 都必须重新解析 php.ini、重新载入全部 dll 扩展并重初始化全部数据结构。使用 FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接（Persistent database connection）可以工作。</p><p>备注：PHP 的 FastCGI 进程管理器是 PHP-FPM（PHP-FastCGI Process Manager）<br>【优点】<br>1）从稳定性上看，FastCGI 是以独立的进程池来运行 CGI，单独一个进程死掉，系统可以很轻易的丢弃，然后重新分配新的进程来运行逻辑；<br>2）从安全性上看，FastCGI 支持分布式运算。FastCGI 和宿主的 Server 完全独立，FastCGI 怎么 down 也不会把 Server 搞垮；<br>3）从性能上看，FastCGI 把动态逻辑的处理从 Server 中分离出来，大负荷的 IO 处理还是留给宿主 Server，这样宿主 Server 可以一心一意作 IO，对于一个普通的动态网页来说, 逻辑处理可能只有一小部分，大量的是图片等静态。</p><p>【缺点】<br>说完了好处，也来说说缺点。从我的实际使用来看，用 FastCGI 模式更适合生产环境的服务器。但对于开发用机器来说就不太合适。因为当使用 Zend Studio 调试程序时，由于 FastCGI 会认为 PHP 进程超时，从而在页面返回 500 错误。这一点让人非常恼火，所以我在开发机器上还是换回了 ISAPI 模式。对某些服务器的新版本支持不好，对分布式负载均衡没要求的模块化安装是否是更好的选择。目前的 FastCGI 和 Server 沟通还不够智能，一个 FastCGI 进程如果执行时间过长会被当成是死进程杀掉重起，这样在处理长时间任务的时候很麻烦，这样做也使得 FastCGI 无法允许联机调试。因为是多进程，所以比 CGI 多线程消耗更多的服务器内存，PHP-CGI 解释器每进程消耗 7 至 25 兆内存，将这个数字乘以 50 或 100 就是很大的内存数。</p><h4 id="1-3-CLI-模式"><a href="#1-3-CLI-模式" class="headerlink" title="1.3 CLI 模式"></a>1.3 CLI 模式</h4><p>PHP-CLI 是 PHP Command Line Interface 的简称，如同它名字的意思，就是 PHP 在命令行运行的接口，区别于在 Web 服务器上运行的 PHP 环境（PHP-CGI，ISAPI 等）。 也就是说，PHP 不单可以写前台网页，它还可以用来写后台的程序。 PHP 的 CLI Shell 脚本适用于所有的 PHP 优势，使创建要么支持脚本或系统甚至与 GUI 应用程序的服务端，在 Windows 和 Linux 下都是支持 PHP-CLI 模式的。<br>【优点】<br>1）使用多进程，子进程结束以后，内核会负责回收资源；<br>2）使用多进程，子进程异常退出不会导致整个进程 Thread 退出，父进程还有机会重建流程；<br>3）一个常驻主进程，只负责任务分发，逻辑更清楚。<br>我们在 Linux 下经常使用”php –m”查找 PHP 安装了那些扩展就是 PHP 命令行运行模式；有兴趣的同学可以输入”php –h”去深入研究该运行模式。</p><h4 id="1-4-模块模式"><a href="#1-4-模块模式" class="headerlink" title="1.4 模块模式"></a>1.4 模块模式</h4><p>模块模式是以 mod_php5 模块的形式集成，此时 mod_php5 模块的作用是接收 Apache 传递过来的 PHP 文件请求，并处理这些请求，然后将处理后的结果返回给 Apache。如果我们在 Apache 启动前在其配置文件中配置好了 PHP 模块<br>（mod_php5）， PHP 模块通过注册 apache2 的 ap_hook_post_config 挂钩，在 Apache 启动的时候启动此模块以接受 PHP 文件的请求。<br>除了这种启动时的加载方式，Apache 的模块可以在运行的时候动态装载，这意味着对服务器可以进行功能扩展而不需要重新对源代码进行编译，甚至根本不需要停止服务器。我们所需要做的仅仅是给服务器发送信号 HUP 或者 AP_SIG_GRACEFUL 通知服务器重新载入模块。但是在动态加载之前，我们需要将模块编译成为动态链接库。此时的动态加载就是加载动态链接库。 Apache 中对动态链接库的处理是通过模块 mod_so 来完成的，因此 mod_so 模块不能被动态加载，它只能被静态编译进 Apache 的核心。这意味着它是随着 Apache 一起启动的。<br>Apache 是如何加载模块的呢？我们以前面提到的 mod_php5 模块为例。首先我们需要在 Apache 的配置文件 httpd.conf 中添加一行：<br>LoadModule php5_module modules/mod_php5.so</p><p>这里我们使用了 LoadModule 命令，该命令的第一个参数是模块的名称，名称可以在模块实现的源码中找到。第二个选项是该模块所处的路径。如果需要在服务器运行时加载模块，可以通过发送信号 HUP 或者 AP_SIG_GRACEFUL 给服务器，一旦接受到该信号，Apache 将重新装载模块，而不需要重新启动服务器。<br>该运行模式是我们以前在 windows 环境下使用 apache 服务器经常使用的，而在模块化（DLL）中，PHP 是与 Web 服务器一起启动并运行的。（它是 apache 在 CGI 的基础上进行的一种扩展，加快 PHP 的运行效率）。</p><h4 id="1-5-ISAPI-模式"><a href="#1-5-ISAPI-模式" class="headerlink" title="1.5 ISAPI 模式"></a>1.5 ISAPI 模式</h4><p>ISAPI（Internet Server Application Program Interface）是微软提供的一套面向 Internet 服务的 API 接口，一个 ISAPI 的 DLL，可以在被用户请求激活后长驻内存，等待用户的另一个请求，还可以在一个 DLL 里设置多个用户请求处理函数，此外，ISAPI 的 DLL 应用程序和 WWW 服务器处于同一个进程中，效率要显著高于 CGI。（由于微软的排他性，只能运行于 windows 环境）<br>PHP 作为 Apache 模块，Apache 服务器在系统启动后，预先生成多个进程副本驻留在内存中，一旦有请求出现，就立即使用这些空余的子进程进行处理，这样就不存在生成子进程造成的延迟了。这些服务器副本在处理完一次 HTTP 请求之后并不立即退出，而是停留在计算机中等待下次请求。对于客户浏览器的请求反应更快，性能较高。</p><h3 id="4-PHP-代码的执行流程"><a href="#4-PHP-代码的执行流程" class="headerlink" title="4. PHP 代码的执行流程"></a>4. PHP 代码的执行流程</h3><ul><li><a href="http://blog.csdn.net/a2534725767/article/details/55194582" target="_blank" rel="noopener">http://blog.csdn.net/a2534725767/article/details/55194582</a></li></ul><pre><code class="hljs undefined">1<span class="hljs-selector-class">.Scanning</span>(<span class="hljs-selector-tag">Lexing</span>) ,将<span class="hljs-selector-tag">PHP</span>代码转换为语言片段(<span class="hljs-selector-tag">Tokens</span>)2<span class="hljs-selector-class">.Parsing</span>, 将<span class="hljs-selector-tag">Tokens</span>转换成简单而有意义的表达式3<span class="hljs-selector-class">.Compilation</span>, 将表达式编译成<span class="hljs-selector-tag">Opocdes</span>4<span class="hljs-selector-class">.Execution</span>, 顺次执行<span class="hljs-selector-tag">Opcodes</span>，每次一条，从而实现<span class="hljs-selector-tag">PHP</span>脚本的功能。</code></pre><h3 id="5-PHP-与-Golang-的区别"><a href="#5-PHP-与-Golang-的区别" class="headerlink" title="5. PHP 与 Golang 的区别"></a>5. PHP 与 Golang 的区别</h3><h4 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h4><ul><li><a href="http://www.yinwang.org/blog-cn/2014/04/18/golang" target="_blank" rel="noopener">对 Go 语言的综合评价</a></li><li><a href="https://www.zhihu.com/question/21409296" target="_blank" rel="noopener">Go 语言的优势在哪里？</a></li><li><a href="http://blog.csdn.net/liigo/article/details/23699459" target="_blank" rel="noopener">我为什么放弃 Go 语言</a></li><li><a href="http://blog.csdn.net/a82168506/article/details/6664714" target="_blank" rel="noopener">php 的优缺点</a></li><li><a href="http://www.cnblogs.com/xiaotaoing/p/6687418.html" target="_blank" rel="noopener">php 优缺点</a></li></ul><blockquote><p>面试的时候基本上上面说到的都说到了一些但是面试的时候逻辑还是不够清晰</p></blockquote><h3 id="6-深度优先遍历与广度优先遍历"><a href="#6-深度优先遍历与广度优先遍历" class="headerlink" title="6. 深度优先遍历与广度优先遍历"></a>6. 深度优先遍历与广度优先遍历</h3><ul><li><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/18/2596983.html" target="_blank" rel="noopener">http://www.cnblogs.com/biyeymyhjob/archive/2012/07/18/2596983.html</a></li></ul><h4 id="a-DFS"><a href="#a-DFS" class="headerlink" title="a. DFS"></a>a. DFS</h4><p>（1）访问顶点 v；<br>（2）从 v 的未被访问的邻接点中选取一个顶点 w，从 w 出发进行深度优先遍历；<br>（3）重复上述两步，直至图中所有和 v 有路径相通的顶点都被访问到。</p><h4 id="b-BFS"><a href="#b-BFS" class="headerlink" title="b. BFS"></a>b. BFS</h4><p>（1）顶点 v 入队列。<br>（2）当队列非空时则继续执行，否则算法结束。<br>（3）出队列取得队头顶点 v；访问顶点 v 并标记顶点 v 已被访问。<br>（4）查找顶点 v 的第一个邻接顶点 col。<br>（5）若 v 的邻接顶点 col 未被访问过的，则 col 入队列。<br>（6）继续查找顶点 v 的另一个新的邻接顶点 col，转到步骤（5）。<br>直到顶点 v 的所有未被访问过的邻接点处理完。转到步骤（2）。<br>广度优先遍历图是以顶点 v 为起始点，由近至远，依次访问和 v 有路径相通而且路径长度为 1，2，……的顶点。为了使“先被访问顶点的邻接点”先于“后被访问顶点的邻接点”被访问，需设置队列存储访问的顶点。</p><h3 id="7-浏览器输入一个-URL-之后发生了什么事情"><a href="#7-浏览器输入一个-URL-之后发生了什么事情" class="headerlink" title="7. 浏览器输入一个 URL 之后发生了什么事情"></a>7. 浏览器输入一个 URL 之后发生了什么事情</h3><ul><li><a href="http://www.cnblogs.com/wenanry/archive/2010/02/25/1673368.html" target="_blank" rel="noopener">http://www.cnblogs.com/wenanry/archive/2010/02/25/1673368.html</a></li></ul><h3 id="8-遍历一个目录下面所有的文件以及文件夹"><a href="#8-遍历一个目录下面所有的文件以及文件夹" class="headerlink" title="8. 遍历一个目录下面所有的文件以及文件夹"></a>8. 遍历一个目录下面所有的文件以及文件夹</h3><blockquote><p>面试的时候写了一个 DFS，一下被问到 BFS 怎么写的时候短路了，没有想起了，其实实现的方法不难，参考问题 6</p></blockquote><h3 id="其实还有其他的问题，不过忘了"><a href="#其实还有其他的问题，不过忘了" class="headerlink" title="其实还有其他的问题，不过忘了"></a>其实还有其他的问题，不过忘了</h3><h2 id="三面-20min"><a href="#三面-20min" class="headerlink" title="三面[20min]"></a>三面[20min]</h2><blockquote><p>三面没有被问到技术细节</p></blockquote><h3 id="0-自我介绍-1"><a href="#0-自我介绍-1" class="headerlink" title="0. 自我介绍"></a>0. 自我介绍</h3><h3 id="1-简单的介绍了一个项目"><a href="#1-简单的介绍了一个项目" class="headerlink" title="1. 简单的介绍了一个项目"></a>1. 简单的介绍了一个项目</h3><h3 id="2-在平时做项目的时候遇到的难点"><a href="#2-在平时做项目的时候遇到的难点" class="headerlink" title="2. 在平时做项目的时候遇到的难点"></a>2. 在平时做项目的时候遇到的难点</h3><p>几个方面简单讲了一下，团队协作的难点，技术难点，心理难点</p><h3 id="3-团队合作当中如果碰到一个-BUG，但是开发人员觉得不重要，你觉得重要怎么班？"><a href="#3-团队合作当中如果碰到一个-BUG，但是开发人员觉得不重要，你觉得重要怎么班？" class="headerlink" title="3. 团队合作当中如果碰到一个 BUG，但是开发人员觉得不重要，你觉得重要怎么班？"></a>3. 团队合作当中如果碰到一个 BUG，但是开发人员觉得不重要，你觉得重要怎么班？</h3><p>坚持不放过为底线，换位思考，以产品和用户的角度劝说开发</p><h3 id="4-对加班有什么看法？"><a href="#4-对加班有什么看法？" class="headerlink" title="4. 对加班有什么看法？"></a>4. 对加班有什么看法？</h3><p>正常现象，完全可以接受</p><h3 id="5-为什么想去深圳？"><a href="#5-为什么想去深圳？" class="headerlink" title="5. 为什么想去深圳？"></a>5. 为什么想去深圳？</h3><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/1358.html">招银网络面试总结</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>秋招</tag>
      
      <tag>百度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/post/21238.html"/>
    <url>/post/21238.html</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><ol><li>比较相邻的元素（从后往前）。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>(<strong>如果这一步没有出现任何一次交换，那么说明所有的元素已经有序，不需要再进行下面的步骤了</strong>)</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h2 id="图片示例"><a href="#图片示例" class="headerlink" title="图片示例"></a>图片示例</h2><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142754.gif" srcset="/img/loading.gif" alt></p><h2 id="程序示例（go）"><a href="#程序示例（go）" class="headerlink" title="程序示例（go）"></a>程序示例（go）</h2><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SortInt</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">//交换次数，计数</span>n := <span class="hljs-number">0</span>aLen := <span class="hljs-built_in">len</span>(a)<span class="hljs-keyword">for</span> i := aLen - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<span class="hljs-comment">//标记，如果flag一次冒泡之后没有改变，那么证明排序已完成，不需要再次排序，直接退出</span>flag := <span class="hljs-number">0</span><span class="hljs-comment">//一次冒泡</span><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<span class="hljs-keyword">if</span> a[j] &gt; a[j+<span class="hljs-number">1</span>] &#123;<span class="hljs-comment">//交换两个变量的值，无需引入临时变量</span>a[j], a[j+<span class="hljs-number">1</span>] = a[j+<span class="hljs-number">1</span>], a[j]n++<span class="hljs-comment">//有交换，flag=1</span>flag = <span class="hljs-number">1</span>&#125;&#125;<span class="hljs-comment">//判断一次冒泡，是否存在交换</span><span class="hljs-keyword">if</span> flag == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">break</span>&#125;&#125;<span class="hljs-keyword">return</span> a, n&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遗传算法</title>
    <link href="/post/34642.html"/>
    <url>/post/34642.html</url>
    
    <content type="html"><![CDATA[<h2 id="实现示例-Golang"><a href="#实现示例-Golang" class="headerlink" title="实现示例-Golang"></a>实现示例-Golang</h2><p><a href="https://github.com/mohuishou/algorithm/tree/master/GA" target="_blank" rel="noopener">github</a></p><pre><code class="hljs golang"><span class="hljs-keyword">package</span> GA<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"math"</span><span class="hljs-string">"math/rand"</span><span class="hljs-string">"time"</span>)<span class="hljs-keyword">var</span> (groupSize      <span class="hljs-keyword">int</span>      <span class="hljs-comment">//种群大小</span>chromosomeSize <span class="hljs-keyword">int</span>      <span class="hljs-comment">//染色体长度</span>selectRand     <span class="hljs-keyword">float64</span>  <span class="hljs-comment">//轮盘选择概率</span>crossRand      <span class="hljs-keyword">float64</span>  <span class="hljs-comment">//交叉概率</span>mutationRand   <span class="hljs-keyword">float64</span>  <span class="hljs-comment">//变异概率</span>group          []Person <span class="hljs-comment">//种群</span>bestPerson     Person   <span class="hljs-comment">//当前最好的个体</span>r              *rand.Rand)<span class="hljs-comment">//Person 个体</span><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;chromosome []<span class="hljs-keyword">int</span>   <span class="hljs-comment">//染色体</span>value      <span class="hljs-keyword">float64</span> <span class="hljs-comment">//适应值</span>&#125;<span class="hljs-comment">//Init 初始化函数</span><span class="hljs-comment">//初始化设置种群大小、轮盘选择概率、交叉概率已经变异的概率</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Init</span><span class="hljs-params">(GroupSize, ChromosomeSize <span class="hljs-keyword">int</span>, SelectRand, CrossRand, MutationRand <span class="hljs-keyword">float64</span>)</span></span> &#123;groupSize = GroupSizecrossRand = CrossRandselectRand = SelectRandmutationRand = MutationRandchromosomeSize = ChromosomeSizer = rand.New(rand.NewSource(time.Now().UnixNano()))bestPerson.chromosome = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, chromosomeSize)&#125;<span class="hljs-comment">//InitGroup 初始化种群</span><span class="hljs-comment">//根据种群大小随机产生一些个体填充</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitGroup</span><span class="hljs-params">()</span></span> &#123;group = <span class="hljs-built_in">make</span>([]Person, groupSize)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; groupSize; i++ &#123;group[i].chromosome = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, chromosomeSize)<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; chromosomeSize; j++ &#123;<span class="hljs-keyword">if</span> r.Float64() &gt; selectRand &#123;group[i].chromosome[j] = <span class="hljs-number">1</span>&#125;&#125;&#125;&#125;<span class="hljs-comment">//Fitness 计算适应值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fitness</span><span class="hljs-params">(person Person)</span> <span class="hljs-title">float64</span></span> &#123;x := decode(person)<span class="hljs-keyword">return</span> x + <span class="hljs-number">10</span>*math.Sin(<span class="hljs-number">5</span>*x) + <span class="hljs-number">7</span>*math.Cos(<span class="hljs-number">4</span>*x)&#125;<span class="hljs-comment">//解码</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decode</span><span class="hljs-params">(person Person)</span> <span class="hljs-title">float64</span></span> &#123;<span class="hljs-keyword">var</span> sum <span class="hljs-keyword">float64</span><span class="hljs-comment">//解码</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; chromosomeSize; i++ &#123;<span class="hljs-comment">//二进制染色体转十进制值</span><span class="hljs-keyword">if</span> person.chromosome[i] == <span class="hljs-number">1</span> &#123;sum = sum + math.Pow(<span class="hljs-number">2.0</span>, <span class="hljs-keyword">float64</span>(i))&#125;&#125;<span class="hljs-keyword">return</span> sum * <span class="hljs-number">9</span> / (math.Pow(<span class="hljs-number">2.0</span>, <span class="hljs-number">14.0</span>) - <span class="hljs-number">1</span>)&#125;<span class="hljs-comment">//Select 选择</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Select</span><span class="hljs-params">()</span></span> &#123;newGroup := <span class="hljs-built_in">make</span>([]Person, groupSize)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; groupSize; i++ &#123;newGroup[i].chromosome = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, chromosomeSize)rnd := r.Float64()A:<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; groupSize; j++ &#123;<span class="hljs-keyword">if</span> group[j].value &gt; rnd*bestPerson.value &#123;<span class="hljs-built_in">copy</span>(newGroup[i].chromosome, group[j].chromosome)<span class="hljs-keyword">break</span> A&#125;<span class="hljs-keyword">if</span> j == groupSize<span class="hljs-number">-1</span> &#123;<span class="hljs-built_in">copy</span>(newGroup[i].chromosome, bestPerson.chromosome)&#125;&#125;&#125;group = newGroupnewGroup = <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">//Cross 交叉</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Cross</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; groupSize; i = i + <span class="hljs-number">2</span> &#123;<span class="hljs-keyword">if</span> r.Float64() &lt; crossRand &#123;crossPosition := r.Intn(chromosomeSize - <span class="hljs-number">1</span>)<span class="hljs-keyword">if</span> crossPosition == <span class="hljs-number">0</span> || crossPosition == <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">continue</span>&#125;<span class="hljs-comment">//交叉</span><span class="hljs-keyword">for</span> j := crossPosition; j &lt; chromosomeSize; j++ &#123;tmp := group[i].chromosome[j]group[i].chromosome[j] = group[i+<span class="hljs-number">1</span>].chromosome[j]group[i+<span class="hljs-number">1</span>].chromosome[j] = tmp&#125;&#125;&#125;&#125;<span class="hljs-comment">//Mutation 变异</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Mutation</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; groupSize; i++ &#123;<span class="hljs-keyword">if</span> r.Float64() &lt; mutationRand &#123;mutationPosition := r.Intn(chromosomeSize - <span class="hljs-number">1</span>)<span class="hljs-comment">//单点变异</span><span class="hljs-keyword">if</span> group[i].chromosome[mutationPosition] == <span class="hljs-number">0</span> &#123;group[i].chromosome[mutationPosition] = <span class="hljs-number">1</span>&#125; <span class="hljs-keyword">else</span> &#123;group[i].chromosome[mutationPosition] = <span class="hljs-number">0</span>&#125;&#125;&#125;&#125;<span class="hljs-comment">//GA 遗传算法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GA</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//初始化</span>Init(<span class="hljs-number">100</span>, <span class="hljs-number">14</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.05</span>)<span class="hljs-comment">//初始化种群</span>InitGroup()<span class="hljs-comment">//遗传循环</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++ &#123;<span class="hljs-comment">//计算适应值</span><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; groupSize; j++ &#123;group[j].value = Fitness(group[j])<span class="hljs-comment">//保存当前最好的个体</span><span class="hljs-keyword">if</span> group[j].value &gt; bestPerson.value &#123;<span class="hljs-built_in">copy</span>(bestPerson.chromosome, group[j].chromosome)bestPerson.value = group[j].valuefmt.Println(<span class="hljs-string">"第"</span>, i, <span class="hljs-string">"代最好个体："</span>, bestPerson.value, <span class="hljs-string">" "</span>, decode(bestPerson))&#125;&#125;<span class="hljs-comment">//选择</span>Select()<span class="hljs-comment">//交叉</span>Cross()<span class="hljs-comment">//变异</span>Mutation()&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/defer.html">Go数据结构与算法05-栈下: 深入理解 defer</a></li><li><a href="https://lailin.xyz/post/stack.html">Go数据结构与算法04-栈上: 如何实现一个计算器</a></li><li><a href="https://lailin.xyz/post/array_2.html">Go数据结构与算法03-数组下: 使用 GDB 调试 Golang 代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>算法</tag>
      
      <tag>遗传算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径算法SPFA</title>
    <link href="/post/21230.html"/>
    <url>/post/21230.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>前面说了单源最短路径算法 Dijkstra，以及多源最短路径算法 Floyd，但是都不能适用于有负权边存在的情况，这里实现一下是西南交通大学段凡丁于 1994 年发表的 SPFA（Shortest Path Faster Algorithm）算法。该算法在 Bellman-ford 算法的基础上加上一个队列优化，减少了冗余的松弛操作。</p></blockquote><blockquote><p>spfa 可以适用于有负权边存在的情况，但是无法求解存在负权回路的情况，但是可以判断</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>只要最短路径存在，SPFA 算法必定能求出最小值。证明：每次将点放入队尾，都是经过松弛操作达到的。换言之，每次的优化将会有某个点 v 的最短路径估计值 d[v]变小。所以算法的执行会使 d 越来越小。由于我们假定图中不存在负权回路，所以每个结点都有最短路径值。因此，算法不会无限执行下去，随着 d 值的逐渐变小，直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="github"><a href="#github" class="headerlink" title="github"></a><a href="https://github.com/mohuishou/algorithm/tree/master/ShortestPath/Floyd" target="_blank" rel="noopener">github</a></h3><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><pre><code class="hljs go">q := list.New()q.PushBack(s)<span class="hljs-comment">//循环跳出条件：队列为空</span><span class="hljs-keyword">for</span> q.Len() != <span class="hljs-number">0</span> &#123;u := q.Front().Value.(Graph.VextexType)q.Remove(q.Front())<span class="hljs-comment">//释放对点u的标记</span>visited[u] = <span class="hljs-literal">false</span>e := graph.G[u].FisrtEdge<span class="hljs-keyword">for</span> e != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//这条边下的顶点</span>v := e.V<span class="hljs-comment">//如果当前点的距离加上边的距离小于之前该点的距离，那么就更新该点的距离</span><span class="hljs-keyword">if</span> dist[v] &gt; dist[u]+e.Weight &#123;dist[v] = dist[u] + e.Weight <span class="hljs-comment">//更新该点距离</span>path[v] = u                  <span class="hljs-comment">//更新父节点</span><span class="hljs-comment">//如果顶点不在队内，则将顶点入队</span><span class="hljs-keyword">if</span> visited[v] == <span class="hljs-literal">false</span> &#123;q.PushBack(v) <span class="hljs-comment">//将该点入队</span>visited[v] = <span class="hljs-literal">true</span>count[v]++<span class="hljs-comment">//出现负环，报错</span><span class="hljs-keyword">if</span> count[v] &gt; graph.VNum &#123;<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"存在负环！"</span>)&#125;&#125;&#125;e = e.Next&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></code></pre><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><pre><code class="hljs go">visited[u] = <span class="hljs-literal">true</span>e := graph.G[u].FisrtEdge<span class="hljs-keyword">for</span> e != <span class="hljs-literal">nil</span> &#123;v := e.V<span class="hljs-keyword">if</span> dist[v] &gt; dist[u]+e.Weight &#123;dist[v] = dist[u] + e.Weight <span class="hljs-comment">//更新该点距离</span>path[v] = u                  <span class="hljs-comment">//更新父节点</span><span class="hljs-keyword">if</span> visited[v] == <span class="hljs-literal">false</span> &#123;count[v]++<span class="hljs-keyword">if</span> count[v] &gt; graph.VNum &#123;<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"存在负环！"</span>)&#125;<span class="hljs-comment">//注意DFS的结果不能直接return，直接return的时候回溯的时候就没有办法在上一级重新找值了</span>err := DFS(v)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;&#125;e = e.Next&#125;visited[u] = <span class="hljs-literal">false</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/defer.html">Go数据结构与算法05-栈下: 深入理解 defer</a></li><li><a href="https://lailin.xyz/post/stack.html">Go数据结构与算法04-栈上: 如何实现一个计算器</a></li><li><a href="https://lailin.xyz/post/array_2.html">Go数据结构与算法03-数组下: 使用 GDB 调试 Golang 代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>最短路径</tag>
      
      <tag>spfa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径算法-Floyd</title>
    <link href="/post/60101.html"/>
    <url>/post/60101.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>在上一篇当中讲了 Dijkstra 算法，Dijkstra 适用于对于单源路径的求取，但是对于任意两个点之间的最小路径呢？首先想到的当然是直接使用多次的 Dijkstra 算法来求取任意两点之间的最短路径，但是这样下来时间复杂度会比较大，所以使用一种新的算法，Floyd 算法来求取最短路径</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Floyd 算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点 i 到点 j 的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释<br>从任意节点 i 到任意节点 j 的最短路径不外乎 2 种可能:</p><ul><li>1.直接从 i 到 j，</li><li>2.从 i 经过若干个节点 k 到 j。<br>所以，我们假设 Dis(i,j)为节点 u 到节点 v 的最短路径的距离，对于每一个节点 k，我们检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到 j 的路径短，我们便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点 k，Dis(i,j)中记录的便是 i 到 j 的最短路径的距离。</li></ul><h2 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h2><p>a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 　　<br>b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。</p><h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> ShortestPath<span class="hljs-keyword">import</span> (<span class="hljs-string">"errors"</span><span class="hljs-string">"github.com/mohuishou/algorithm/GraphMatrix"</span>)<span class="hljs-comment">//Floyd 求取多源最短路径</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Floyd</span><span class="hljs-params">(graph GraphMatrix.Graph, dist [][]GraphMatrix.EdgeType, path [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; graph.VNum; i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; graph.VNum; j++ &#123;path[i][j] = <span class="hljs-number">-1</span>dist[i][j] = graph.G[i][j]&#125;&#125;    <span class="hljs-comment">//注意，k必须放在最外层，如果放在最里层会过早的确认两点的最短路径</span><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; graph.VNum; k++ &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; graph.VNum; i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; graph.VNum; j++ &#123;<span class="hljs-comment">//找到更短的路径</span><span class="hljs-keyword">if</span> dist[i][k]+dist[k][j] &lt; dist[i][j] &#123;dist[i][j] = dist[i][k] + dist[k][j]<span class="hljs-comment">//发现负值圈</span><span class="hljs-keyword">if</span> i == j &amp;&amp; dist[i][j] &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"存在负值圈"</span>)&#125;path[i][j] = k&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">//GetPathForFloyd 获取路径</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPathForFloyd</span><span class="hljs-params">(path [][]<span class="hljs-keyword">int</span>, s, t <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(tPath []<span class="hljs-keyword">int</span>)</span></span> &#123;tPath = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)tPath[<span class="hljs-number">0</span>] = s<span class="hljs-keyword">for</span> &#123;s = path[s][t]<span class="hljs-keyword">if</span> s == <span class="hljs-number">-1</span> || s == t &#123;tPath = <span class="hljs-built_in">append</span>(tPath, t)<span class="hljs-keyword">return</span> tPath&#125;tPath = <span class="hljs-built_in">append</span>(tPath, s)&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/defer.html">Go数据结构与算法05-栈下: 深入理解 defer</a></li><li><a href="https://lailin.xyz/post/stack.html">Go数据结构与算法04-栈上: 如何实现一个计算器</a></li><li><a href="https://lailin.xyz/post/array_2.html">Go数据结构与算法03-数组下: 使用 GDB 调试 Golang 代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>最短路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>邻接表-Golang</title>
    <link href="/post/18885.html"/>
    <url>/post/18885.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>最简单直接的办法一般就是使用邻接矩阵的办法来表示图，但是对于稀疏图来说边的数目想对来说比较少的情况下，使用邻接矩阵的办法会比较浪费资源，所以这里采用邻接表</p></blockquote><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p><a href="https://github.com/mohuishou/algorithm/tree/master/Graph" target="_blank" rel="noopener">https://github.com/mohuishou/algorithm/tree/master/Graph</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> Graph<span class="hljs-keyword">import</span> (<span class="hljs-string">"bufio"</span><span class="hljs-string">"io"</span><span class="hljs-string">"os"</span><span class="hljs-string">"strconv"</span><span class="hljs-string">"strings"</span>)<span class="hljs-comment">// EdgeType 边的权值类型</span><span class="hljs-keyword">type</span> EdgeType <span class="hljs-keyword">int</span><span class="hljs-comment">// VextexType 顶点类型定义</span><span class="hljs-keyword">type</span> VextexType <span class="hljs-keyword">int</span><span class="hljs-comment">// VextexDataType 顶点值类型定义</span><span class="hljs-keyword">type</span> VextexDataType <span class="hljs-keyword">int</span><span class="hljs-comment">//EdgeNode 边的节点</span><span class="hljs-keyword">type</span> EdgeNode <span class="hljs-keyword">struct</span> &#123;Weight EdgeType   <span class="hljs-comment">//权值</span>V      VextexType <span class="hljs-comment">//指向储存该顶点的下标</span>Next   *EdgeNode  <span class="hljs-comment">//指向下一条边</span>&#125;<span class="hljs-comment">//VextexNode 顶点节点定义</span><span class="hljs-keyword">type</span> VextexNode <span class="hljs-keyword">struct</span> &#123;data      VextexDataType <span class="hljs-comment">//顶点的值</span>FisrtEdge *EdgeNode      <span class="hljs-comment">//该顶点指向的第一条边</span>&#125;<span class="hljs-comment">//Graph 图</span><span class="hljs-keyword">type</span> Graph <span class="hljs-keyword">struct</span> &#123;VNum, ENum <span class="hljs-keyword">int</span>          <span class="hljs-comment">//顶点数目，边数目</span>G          []VextexNode <span class="hljs-comment">//邻接表</span>&#125;<span class="hljs-comment">//CreateGraph 创建邻接表</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateGraph</span><span class="hljs-params">(VNum <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(graph Graph)</span></span> &#123;graph.VNum = VNumgraph.G = <span class="hljs-built_in">make</span>([]VextexNode, VNum)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; VNum; i++ &#123;graph.G[i] = VextexNode&#123;&#125;&#125;<span class="hljs-keyword">return</span> graph&#125;<span class="hljs-comment">//AddEdge 添加边</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(graph Graph)</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(s, t VextexType, weight EdgeType)</span></span> &#123;edge := &amp;EdgeNode&#123;V: t, Weight: weight&#125;<span class="hljs-comment">//添加边到头部</span>edge.Next = graph.G[s].FisrtEdgegraph.G[s].FisrtEdge = edge&#125;<span class="hljs-comment">//BuildGraph 通过读取文件建图</span><span class="hljs-comment">//文件格式要求:</span><span class="hljs-comment">//顶点个数 边数</span><span class="hljs-comment">//顶点v1 顶点V2 边的权重</span><span class="hljs-comment">//...</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BuildGraph</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(graph Graph)</span></span> &#123;f, err := os.Open(path)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;buf := bufio.NewReader(f)i := <span class="hljs-number">0</span><span class="hljs-comment">//边的数目</span><span class="hljs-keyword">for</span> &#123;line, err := buf.ReadString(<span class="hljs-string">'\n'</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> err == io.EOF &#123;<span class="hljs-keyword">return</span> graph&#125;<span class="hljs-built_in">panic</span>(err)&#125;line = strings.TrimSpace(line)data := strings.Split(line, <span class="hljs-string">" "</span>)<span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;n, err := strconv.Atoi(data[<span class="hljs-number">0</span>])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;graph = CreateGraph(n)graph.ENum, err = strconv.Atoi(data[<span class="hljs-number">1</span>])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i &lt;= graph.ENum &#123;s, err := strconv.Atoi(data[<span class="hljs-number">0</span>])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;t, err := strconv.Atoi(data[<span class="hljs-number">1</span>])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;weight, err := strconv.Atoi(data[<span class="hljs-number">2</span>])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;graph.AddEdge(VextexType(s), VextexType(t), EdgeType(weight))&#125;i++&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/defer.html">Go数据结构与算法05-栈下: 深入理解 defer</a></li><li><a href="https://lailin.xyz/post/stack.html">Go数据结构与算法04-栈上: 如何实现一个计算器</a></li><li><a href="https://lailin.xyz/post/array_2.html">Go数据结构与算法03-数组下: 使用 GDB 调试 Golang 代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>邻接表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径算法-Dijkstra</title>
    <link href="/post/13459.html"/>
    <url>/post/13459.html</url>
    
    <content type="html"><![CDATA[<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><blockquote><p>这个算法是通过为每个顶点 v 保留目前为止所找到的从 s 到 v 的最短路径来工作的。初始时，原点 s 的路径权重被赋为 0 （d[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把 d[m]设为 w（s, m）,同时把所有其他（s 不能直接到达的）顶点的路径长度设为无穷大，即表示我们不知道任何通向这些顶点的路径（对于所有顶点的集合 V 中的任意顶点 v， 若 v 不为 s 和上述 m 之一， d[v] = ∞）。当算法结束时，d[v] 中存储的便是从 s 到 v 的最短路径，或者如果路径不存在的话是无穷大。<br>边的拓展是 Dijkstra 算法的基础操作：如果存在一条从 u 到 v 的边，那么从 s 到 v 的最短路径可以通过将边（u, v）添加到尾部来拓展一条从 s 到 v 的路径。这条路径的长度是 d[u] + w(u, v)。如果这个值比目前已知的 d[v] 的值要小，我们可以用新值来替代当前 d[v] 中的值。拓展边的操作一直运行到所有的 d[v] 都代表从 s 到 v 的最短路径的长度值。此算法的组织令 d[u] 达到其最终值时，每条边（u, v）都只被拓展一次。<br>算法维护两个顶点集合 S 和 Q。集合 S 保留所有已知最小 d[v] 值的顶点 v ，而集合 Q 则保留其他所有顶点。集合 S 初始状态为空，而后每一步都有一个顶点从 Q 移动到 S。这个被选择的顶点是 Q 中拥有最小的 d[u] 值的顶点。当一个顶点 u 从 Q 中转移到了 S 中，算法对 u 的每条外接边 (u, v) 进行拓展。</p></blockquote><p>如下图：<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142734.gif" srcset="/img/loading.gif" alt></p><h2 id="代码实现-Golang"><a href="#代码实现-Golang" class="headerlink" title="代码实现-Golang"></a>代码实现-Golang</h2><p><a href="https://github.com/mohuishou/algorithm/tree/master/ShortestPath" target="_blank" rel="noopener">github</a></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> ShortestPath<span class="hljs-keyword">import</span> (<span class="hljs-string">"errors"</span><span class="hljs-string">"container/list"</span><span class="hljs-string">"github.com/mohuishou/algorithm/Graph"</span>)<span class="hljs-comment">//INF 无穷大</span><span class="hljs-keyword">const</span> INF = <span class="hljs-number">0xffffff</span><span class="hljs-comment">//Dijkstra 算法</span><span class="hljs-comment">//一种求单源最短路径的算法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(graph Graph.Graph, s Graph.VextexType, dist []Graph.EdgeType, path []Graph.VextexType)</span></span> &#123;visited := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, graph.VNum)<span class="hljs-comment">//初始化</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; graph.VNum; i++ &#123;dist[i] = INF <span class="hljs-comment">//距离为无穷大</span>path[i] = <span class="hljs-number">-1</span>  <span class="hljs-comment">//没有上一个节点</span>visited[i] = <span class="hljs-literal">false</span>&#125;path[s] = sdist[s] = <span class="hljs-number">0</span><span class="hljs-comment">//使用list实现一个队列操作</span>q := list.New()<span class="hljs-comment">//将点s入队</span>q.PushBack(s)<span class="hljs-keyword">for</span> q.Len() != <span class="hljs-number">0</span> &#123;u := q.Front().Value.(Graph.VextexType)q.Remove(q.Front())<span class="hljs-comment">//如果该点周围的点已经走过，则无需再走</span><span class="hljs-keyword">if</span> visited[u] &#123;<span class="hljs-keyword">continue</span>&#125;<span class="hljs-comment">//将该点加入已观察</span>visited[u] = <span class="hljs-literal">true</span>e := graph.G[u].FisrtEdge<span class="hljs-keyword">for</span> e != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//这条边下的顶点</span>v := e.V<span class="hljs-comment">//如果该点尚未走过，并且当前点的距离加上边的距离小于之前该点的距离，那么就更新该点的距离</span><span class="hljs-keyword">if</span> visited[v] == <span class="hljs-literal">false</span> &amp;&amp; dist[v] &gt; dist[u]+e.Weight &#123;dist[v] = dist[u] + e.Weight <span class="hljs-comment">//更新该点距离</span>path[v] = u                  <span class="hljs-comment">//更新父节点</span>q.PushBack(v)                <span class="hljs-comment">//将该点入队</span>&#125;e = e.Next&#125;&#125;&#125;<span class="hljs-comment">//GetPath 通过路径获得到指定目的节点的路径</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPath</span><span class="hljs-params">(path []Graph.VextexType, t Graph.VextexType)</span> <span class="hljs-params">([]Graph.VextexType, error)</span></span> &#123;tPath := <span class="hljs-built_in">make</span>([]Graph.VextexType, <span class="hljs-number">0</span>)<span class="hljs-keyword">for</span> &#123;tPath = <span class="hljs-built_in">append</span>(tPath, t)<span class="hljs-keyword">if</span> path[t] == <span class="hljs-number">-1</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">"不存在到该节点的路径"</span>)&#125;<span class="hljs-keyword">if</span> t == path[t] &#123;<span class="hljs-keyword">return</span> tPath, <span class="hljs-literal">nil</span>&#125;t = path[t]&#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/defer.html">Go数据结构与算法05-栈下: 深入理解 defer</a></li><li><a href="https://lailin.xyz/post/stack.html">Go数据结构与算法04-栈上: 如何实现一个计算器</a></li><li><a href="https://lailin.xyz/post/array_2.html">Go数据结构与算法03-数组下: 使用 GDB 调试 Golang 代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>算法</tag>
      
      <tag>华为软挑</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为软挑2017</title>
    <link href="/post/4976.html"/>
    <url>/post/4976.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>稍稍总结一下最近差不多几天的心路历程，虽然最后没有拿到名次，但是从最开始的连最短路径是什么都不知道，到现在的已经可以利用遗传算法+最小费用最大流算法求出一些可行的解，就短短的不到一周的时间，学习到了可以说之前一个学期也未必能够学习到的知识。</p></blockquote><p>这两天会把最近学到的相关知识记录到博客当中，在这儿暂且先列一个大纲：</p><ul><li><p>最短路径问题</p><ul><li>Dijkstra</li><li>Floyd</li><li>SPFA</li></ul></li><li><p>相关问题</p><ul><li>最大流问题</li><li>最小费用最大流问题</li></ul></li><li><p>启发式算法</p><ul><li>遗传算法</li><li>模拟退火算法</li><li>粒子群算法</li></ul><p>上面都是在这个过程当中用到了的一些算法或者是一些问题的解决方案，但是在对于这个具体的问题解决的时候还要做出一些具体的调整，直接套用是不会出结果的。</p><p>但是大体的思路就是启发式算法确定服务器节点的数目以及位置，然后用最小费用最大流得到花费以及结果路径。</p></li></ul><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/defer.html">Go数据结构与算法05-栈下: 深入理解 defer</a></li><li><a href="https://lailin.xyz/post/stack.html">Go数据结构与算法04-栈上: 如何实现一个计算器</a></li><li><a href="https://lailin.xyz/post/array_2.html">Go数据结构与算法03-数组下: 使用 GDB 调试 Golang 代码</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>华为软挑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用vbox在win下搭建linux开发环境</title>
    <link href="/post/50696.html"/>
    <url>/post/50696.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前一直在用 deepin，但是最近因为要使用 win 下的一些软件就直接切到 win 了，想了想可不可以直接搭建一个 linux 环境，在 windows 下编码呢<br>第一次尝试的是 docker 的方案，但是最后放弃了，因为 docker 利用 vbox 建立的虚拟机启动的时候是不是的会出现问题然后就重建，十分的不稳定。<br>所以这次直接使用虚拟机搭建</p></blockquote><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ul><li>ubuntu-16.04-server-amd64.iso (只需要开发环境，所以使用 server 就行不需要桌面版)</li><li>vbox 5.1.10（我使用的最新版）</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.安装 VBox</p><p><em>不再赘述，直接默认就行，最好不要安装在 C 盘。如果有问题可以参见网上的其他教程</em></p><p>2.安装 UbuntuServer16.04</p><p><em>做了几个动图</em></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142743.gif" srcset="/img/loading.gif" alt></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142745.gif" srcset="/img/loading.gif" alt></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142746.gif" srcset="/img/loading.gif" alt></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142747.gif" srcset="/img/loading.gif" alt></p><p>3.设置网卡</p><p>VBox 默认使用 NAT 模式，但是这个模式下主机是 ping 不通虚拟机的，所以新建一个 host-only 网卡，使用双网卡，一个 NAT 用于上网，一个 host-only 用于和主机相连，之后直接用 xshell 连接，虚拟机后台打开就行了。</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142747.png" srcset="/img/loading.gif" alt></p><p>进入虚拟机，使用<code>ifconfig</code>命令发现只有一张网卡<code>ifconfig -a</code>发现还有一张网卡<code>enp0s8</code>未连接上</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142748.png" srcset="/img/loading.gif" alt></p><p>输入<code>sudo vi /etc/network/interfaces</code></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142750.png" srcset="/img/loading.gif" alt></p><p>新增下面几行</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142751.png" srcset="/img/loading.gif" alt></p><p>保存重启</p><p><code>ifconfig</code> 查看一共出现三个网卡<br>使用主机 ping 虚拟机可以 ping 通</p><p>4.安装 ssh 服务端</p><pre><code class="hljs bash">sudo apt-get updatesudo apt-get install openssh-server</code></pre><p>安装之后就可以使用 xshell 等工具直接连接虚拟机了</p><p>5.共享文件夹</p><p>(1).需要先安装 vbox 增强组件</p><p>a.安装增强组件前需要先装一些依赖</p><pre><code class="hljs bash">sudo apt-get install aptitudesudo  aptitude install build-essential linux-headers-$(uname -r) -y</code></pre><p>b.点击 vbox 的菜单，添加增强功能</p><p>c.挂载光盘</p><pre><code class="hljs bash">sudo mount /dev/cdrom /mnt</code></pre><p>d.安装增强功能</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /mntsudo ./VBoxLinuxAdditions.run</code></pre><p>安装成功，重启</p><p>(2).挂载磁盘</p><p>a.在 VBox 主界面-&gt;选中虚拟机-&gt;设置-&gt;共享文件夹-&gt;添加共享文件夹</p><p>b.<br>假设命名共享文件夹为 www</p><pre><code class="hljs bash">sudo mkdir /wwwsudo mount -t vboxsf www /www</code></pre><p>挂载成功</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>之前的启动都是有界面的，之后使用的时候希望不出现界面直接后台运行，我们使用 xshell 连接就好<br>复制下面的代码，新建一个 UbuntuServer.bat 粘贴进去，以后直接点击这个脚本就行了</p><pre><code class="hljs bash">%VBOX_MSI_INSTALL_PATH%VBoxManage startvm ubuntu --<span class="hljs-built_in">type</span> headless</code></pre><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>到这儿整个流程就结束了，之后可以根据需求添加软件或者是环境，例如 lnmp、node、golang、java、gcc 等等</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/50628.html">linux下天翼飞扬认证上网的一个解决方法</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在windows安装dockertool，并且配置文件夹共享</title>
    <link href="/post/7964.html"/>
    <url>/post/7964.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天折腾了好久，终于好了，但是还是有点小遗憾。</p></blockquote><p>实现下面几个点</p><ul><li>安装 dockertool(通过 boot2docker 以及 vbox 驱动)</li><li>使用 kitematic 可视化管理</li><li>和 windows 本地共享文件夹</li></ul><h2 id="安装-dockertool"><a href="#安装-dockertool" class="headerlink" title="安装 dockertool"></a>安装 dockertool</h2><h3 id="下载-dockertool"><a href="#下载-dockertool" class="headerlink" title="下载 dockertool"></a>下载 dockertool</h3><p>地址一：<a href="http://get.daocloud.io/#install-docker-for-mac-windows" target="_blank" rel="noopener">daocloud 加速</a><br>地址二：<a href="https://github.com/docker/toolbox/releases/tag/v1.12.3" target="_blank" rel="noopener">github</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>双击文件安装即可，可以更改安装位置的选项，其余默认即可<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142752.png" srcset="/img/loading.gif" alt><br>如果电脑上已经安装了 vbox 将不会再安装，如果没有 vbox 将在 C 盘安装 VBox，如果不想安装到 C 盘可以提前安装</p><h3 id="使用-kitematic-可视化管理"><a href="#使用-kitematic-可视化管理" class="headerlink" title="使用 kitematic 可视化管理"></a>使用 kitematic 可视化管理</h3><p>docker ToolBox 自带 kitematic 可以直接打开<br><strong>注意：</strong> 如果设置了环境变量 MACHINE_STORAGE_PATH，更改了虚拟机的默认保存位置，kitematic 可能会打不开，并且启动报错：<code>Error: write EPROTO</code><br>暂时没有找到可行的解决方案，但是这样只有 kitematic 不能使用，docker 没有影响</p><h3 id="使用加速器"><a href="#使用加速器" class="headerlink" title="使用加速器"></a>使用加速器</h3><p>在不使用加速器的情况下，会自动的向 docker hub 拉取镜像，但是国内的访问 docker hub 的速度实在是有些慢，这里我使用<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">daoclou</a>的加速器<br>打开 powershell</p><pre><code class="hljs undefined">docker-machine ssh<span class="hljs-built_in"> default</span>sudo sed -i <span class="hljs-string">"s|EXTRA_ARGS='|EXTRA_ARGS='--registry-mirror=加速地址 |g"</span> /var/lib/boot2docker<span class="hljs-built_in">/profile</span>exitdocker-machine restart default</code></pre><p>第一行：连接 ssh，进入虚拟机<br>第二行：添加加速器地址<br>第三行：退出虚拟机<br>第四行：重启虚拟机</p><p>也可以使用 xshell 等软件连接之后直接输入</p><pre><code class="hljs undefined">sudo sed -i <span class="hljs-string">"s|EXTRA_ARGS='|EXTRA_ARGS='--registry-mirror=加速地址 |g"</span> /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">boot2docker</span>/<span class="hljs-title">profile</span></span></code></pre><p>然后在退出连接，在本机环境下重启 docker-machine</p><pre><code class="hljs undefined"><span class="hljs-title">docker</span>-machine restart <span class="hljs-keyword">default</span></code></pre><h2 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h2><p>共享文件夹有两种方式，一种是使用 vbox 与主机共享文件夹然后在让 docker 与 boot2docker 虚拟机共享，第二种是创建一个 samba 服务。<br>我这里使用第一种。</p><p>1.首先在 vbox 当中添加共享文件夹<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-142753.png" srcset="/img/loading.gif" alt></p><p>2.然后进入 powershell 或者其他的 shell 软件</p><p>进入虚拟机(不要直接在 vbox 当中进入，直接进入可能会创建失败)</p><pre><code class="hljs undefined"><span class="hljs-title">docker</span>-machine ssh <span class="hljs-keyword">default</span></code></pre><p>挂载文件夹</p><pre><code class="hljs undefined">sudo mkdir <span class="hljs-string">/www</span>sudo mount -t vboxsf www <span class="hljs-string">/www</span></code></pre><p>www 是在 vbo 共享文件夹设置的，/www 是在虚拟机中新建的</p><p>文件夹挂载成功之后就可以创建 docker 了，但是注意不能直接在 kitematic 当中创建，kitematic 当中只能挂载<code>C\user</code>下的目录，所以只能手动创建 docker 容器<br>例如：</p><pre><code class="hljs undefined">docker run -d -P <span class="hljs-params">--name</span> web -v <span class="hljs-string">/www</span>:<span class="hljs-string">/www</span> webdevops/php-apache-dev</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/51252.html">docker镜像瘦身&优化</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在laravel/lumen之外使用Eloquent</title>
    <link href="/post/29454.html"/>
    <url>/post/29454.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>这周刚做完学校的一个智能硬件比赛的作品，我负责后端服务器，以及配套 App 的制作。整个一块都用 socket 进行数据传输，但是其中涉及到的数据库的操作，最近 lumen 用的比较多，觉得它的数据库的组件特别方便，所以就想看看能不能单独拿出来使用。</p></blockquote><p>经过一番查找资料，主要分为两步进行</p><h2 id="安装相应的数据库包"><a href="#安装相应的数据库包" class="headerlink" title="安装相应的数据库包"></a>安装相应的数据库包</h2><p><em>这里使用 5.2 的包，可以更具自己的需求进行更换</em></p><pre><code class="hljs bash">composer require illuminate/database ~5.2</code></pre><h2 id="设置启动文件-start-php"><a href="#设置启动文件-start-php" class="headerlink" title="设置启动文件(start.php)"></a>设置启动文件(start.php)</h2><p>这里将配置文件与启动文件分开，也可以合并在一起。我直接使用了一个 php 文件返回数组，也可以引入<code>vlucas/phpdotenv</code>使用.env 文件来配置变量</p><h3 id="start-php"><a href="#start-php" class="headerlink" title="start.php"></a>start.php</h3><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">/** * Created by mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;. * User: mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt; * Date: 2016/11/14 0014 * Time: 18:50 */</span>$database = <span class="hljs-keyword">require_once</span> <span class="hljs-string">"config.php"</span>;<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Container</span>\<span class="hljs-title">Container</span>;<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Database</span>\<span class="hljs-title">Capsule</span>\<span class="hljs-title">Manager</span> <span class="hljs-title">as</span> <span class="hljs-title">Capsule</span>;$capsule = <span class="hljs-keyword">new</span> Capsule;<span class="hljs-comment">// 创建链接</span>$capsule-&gt;addConnection($database);<span class="hljs-comment">// 设置全局静态可访问DB</span>$capsule-&gt;setAsGlobal();<span class="hljs-comment">// 启动Eloquent</span>$capsule-&gt;bootEloquent();</code></pre><h3 id="config-php"><a href="#config-php" class="headerlink" title="config.php"></a>config.php</h3><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">/** * Created by PhpStorm. * User: lxl * Date: 16-11-17 * Time: 下午8:38 */</span><span class="hljs-keyword">return</span> [    <span class="hljs-string">'driver'</span> =&gt; <span class="hljs-string">'mysql'</span>,    <span class="hljs-string">'host'</span> =&gt; <span class="hljs-string">"localhost"</span>,    <span class="hljs-string">'database'</span> =&gt; <span class="hljs-string">"smart_lock"</span>,    <span class="hljs-string">'username'</span> =&gt; <span class="hljs-string">"root"</span>,    <span class="hljs-string">'password'</span> =&gt; <span class="hljs-string">"mima"</span>,    <span class="hljs-string">'charset'</span> =&gt; <span class="hljs-string">'utf8'</span>,    <span class="hljs-string">'collation'</span> =&gt; <span class="hljs-string">'utf8_unicode_ci'</span>,    <span class="hljs-string">'prefix'</span> =&gt; <span class="hljs-string">""</span>,];</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>laravel</tag>
      
      <tag>lumen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java笔记1</title>
    <link href="/post/52826.html"/>
    <url>/post/52826.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>java 初学笔记，随手记录</p></blockquote><ul><li><p>单引号表示字符<code>char</code>类型(<em>不常用</em>)，双引号才是字符串</p></li><li><p>float 类型后面要添加 f<code>3.14f</code>(<em>不常用</em>)，不添加后缀默认为 double</p></li><li><p><code>final</code>表示常量，<code>static final</code>表示类常量</p></li><li><p>位运算 - 与：<code>&amp;</code> - 或：<code>|</code> - 非：<code>~</code> - 异或：<code>^</code> - 左移：<code>&lt;&lt;</code> - 右移：<code>&gt;&gt;</code></p></li><li><p>不要把布尔值强制转换为任何的其他数值，如果要转换为 int，可以使用三元运算符<code>b ? 1:0</code></p></li><li><p>数组的命名 - <code>int[] a</code>(<em>更常用</em>) - <code>int a[]</code></p></li><li><p>数组必须先初始化才能使用，没有初始化的数组不能使用 - <code>int[] a=new int[100]</code></p></li><li><p>命令行参数</p></li></ul><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;&#125;</code></pre><p><em>main 函数的参数，args 接受来自命令行的参数，每一个空格是一个参数，但是程序文件名不包含在内</em></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/62897.html">java中字符串相等的判断</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一键迁移typecho到hexo</title>
    <link href="/post/59080.html"/>
    <url>/post/59080.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>为了更好的写博客，最近打算把博客静态化，发现了 node 写的 hexo。顺便也可以直接利用 github 和 coding 的 pages 来搭建博客同时把之前闲置的未备案域名<a href="http://lailin.xyz">lailin.xyz</a>利用起来.</p></blockquote><p>写了一个 php 的 typecho 一键转换的小程序:<a href="https://github.com/mohuishou/typecho2hexo" target="_blank" rel="noopener">github</a></p><h3 id="支持："><a href="#支持：" class="headerlink" title="支持："></a>支持：</h3><ul><li>文档一键转存为 md 文件</li><li>字符编码转换（gbk=&gt;utf8）</li><li>图片/附件一键转存到本地</li><li>图片/附件一键转存到七牛云</li></ul><h3 id="使用说明："><a href="#使用说明：" class="headerlink" title="使用说明："></a>使用说明：</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><pre><code class="hljs undefined">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/mohuishou/typecho2hexo.gitcomposer install</code></pre><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>复制 config.example.php 并重命名为 config.php</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">return</span> [    <span class="hljs-string">"db"</span>=&gt;[        <span class="hljs-string">"host"</span>=&gt;<span class="hljs-string">"localhost"</span>, <span class="hljs-comment">//数据库地址</span>        <span class="hljs-string">"port"</span>=&gt;<span class="hljs-number">3306</span>, <span class="hljs-comment">//端口号</span>        <span class="hljs-string">"name"</span>=&gt;<span class="hljs-string">"typecho"</span>, <span class="hljs-comment">//数据库</span>        <span class="hljs-string">"user"</span>=&gt;<span class="hljs-string">"root"</span>, <span class="hljs-comment">//数据库用户名</span>        <span class="hljs-string">"password"</span>=&gt;<span class="hljs-string">""</span>, <span class="hljs-comment">//数据库密码</span>        <span class="hljs-string">"prefix"</span>=&gt;<span class="hljs-string">"typecho"</span>  <span class="hljs-comment">//表前缀</span>    ],    <span class="hljs-string">"is_gbk"</span>=&gt;<span class="hljs-keyword">false</span>, <span class="hljs-comment">//是否开启gbk转utf8（有些数据库里面储存的不是utf8格式需要开启这个选项）</span>    <span class="hljs-comment">//附件相关</span>    <span class="hljs-string">"attachment"</span>=&gt;[        <span class="hljs-string">"is_download"</span>=&gt;<span class="hljs-keyword">true</span>, <span class="hljs-comment">//是否下载附件</span>        <span class="hljs-string">"type"</span>=&gt;<span class="hljs-string">"file"</span> <span class="hljs-comment">//附件保存类型：file 或者 qiniu</span>    ],    <span class="hljs-comment">//七牛云储存相关</span>    <span class="hljs-string">"qiniu"</span>=&gt;[        <span class="hljs-string">"access_key"</span>=&gt;<span class="hljs-string">""</span>,        <span class="hljs-string">"secret_key"</span>=&gt;<span class="hljs-string">""</span>,        <span class="hljs-string">"bucket_name"</span>=&gt;<span class="hljs-string">"blog"</span>, <span class="hljs-comment">//七牛空间名</span>        <span class="hljs-string">"domain"</span>=&gt;<span class="hljs-string">"http://"</span> <span class="hljs-comment">//七牛外链域名，必须设置,带http://</span>    ]];</code></pre><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><pre><code class="hljs undefined">php <span class="hljs-keyword">index</span>.php <span class="hljs-comment">//命令行</span></code></pre><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>1.如果出现上传错误，附件下载使用 curl，下载时间最长为 60s，如果有比较大的文件或者是网路环境不好，请手动更改一下 Lib/Attachment.php，当中的文件最长下载时间</p><pre><code class="hljs php"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span><span class="hljs-params">($url,$filename,$dir)</span></span>&#123;    $path=$dir.<span class="hljs-string">"/"</span>.$filename;    $ch=curl_init();    $timeout=<span class="hljs-number">60</span>; <span class="hljs-comment">//文件最长下载时间</span>    curl_setopt($ch,CURLOPT_URL,$url);    curl_setopt($ch,CURLOPT_FOLLOWLOCATION,<span class="hljs-number">1</span>);    curl_setopt($ch,CURLOPT_RETURNTRANSFER,<span class="hljs-number">1</span>);    curl_setopt($ch,CURLOPT_CONNECTTIMEOUT,$timeout);    $res=curl_exec($ch);    curl_close($ch);    <span class="hljs-comment">//检查文件夹是否存在</span>    <span class="hljs-keyword">if</span>(!file_exists($dir)) mkdir($dir);    file_put_contents($path,$res);    <span class="hljs-keyword">return</span> $path;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/27142.html">hexo-next-algolia-search全文搜索</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>php</tag>
      
      <tag>typecho</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在deepin下安装shadowsocks-qt5</title>
    <link href="/post/46155.html"/>
    <url>/post/46155.html</url>
    
    <content type="html"><![CDATA[<h1 id="在-deepin-下安装-ss-qt5"><a href="#在-deepin-下安装-ss-qt5" class="headerlink" title="在 deepin 下安装 ss-qt5"></a>在 deepin 下安装 ss-qt5</h1><blockquote><p>官网的文档上 Ubuntu 可以通过添加私有源的方式安装，deepin 不行，我们这里需要直接从源码编译安装。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>检查下面两个软件是否已经安装，deepin 自带的没有安装上</p><ul><li>git</li><li>g++</li></ul><h2 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h2><pre><code class="hljs undefined">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/shadowsocks/shadowsocks-qt5.git</code></pre><p><strong>wiki 地址</strong>：<a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-qt5/wiki</a></p><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>1.按照 wiki 进行安装</p><pre><code class="hljs bash">sudo apt-get install qt5-qmake qtbase5-dev libqrencode-dev libqtshadowsocks-dev libappindicator-dev libzbar-dev libbotan1.10-dev</code></pre><p>会出现错误，没有<code>libqtshadowsocks-dev</code>这个软件包，所以这个包我们也需要自行编译</p><p>2.下载<code>libqtshadowsocks-dev</code>源代码</p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/shadowsocks/libQtShadowsocks.git</code></pre><p>3.安装编译所需的其他组件</p><pre><code class="hljs undefined">sudo apt-<span class="hljs-built_in">get</span> install qt5-qmake qtbase5-<span class="hljs-built_in">dev</span> libqrencode-<span class="hljs-built_in">dev</span>  libappindicator-<span class="hljs-built_in">dev</span> libzbar-<span class="hljs-built_in">dev</span> libbotan1<span class="hljs-number">.10</span>-<span class="hljs-built_in">dev</span></code></pre><p>4.编译<code>libqtshadowsocks-dev</code></p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> libQtShadowsocksdpkg-buildpackage -uc -us -b</code></pre><p>编译成功之后会在上一级目录发现三个 deb 包（安装后两个）：</p><pre><code class="hljs bash">shadowsocks-libqtshadowsocks_1.9.0-1_amd64.deblibqtshadowsocks-dev_1.9.0-1_amd64.deblibqtshadowsocks_1.9.0-1_amd64.deb</code></pre><p>5.安装所需的 deb 包(注意顺序)</p><pre><code class="hljs undefined"><span class="hljs-selector-tag">sudo</span> <span class="hljs-selector-tag">dpkg</span> <span class="hljs-selector-tag">-i</span> <span class="hljs-selector-tag">libqtshadowsocks_1</span><span class="hljs-selector-class">.9</span><span class="hljs-selector-class">.0-1_amd64</span><span class="hljs-selector-class">.deb</span><span class="hljs-selector-tag">sudo</span> <span class="hljs-selector-tag">dpkg</span> <span class="hljs-selector-tag">-i</span> <span class="hljs-selector-tag">libqtshadowsocks-dev_1</span><span class="hljs-selector-class">.9</span><span class="hljs-selector-class">.0-1_amd64</span><span class="hljs-selector-class">.deb</span></code></pre><p>6.编译<code>shadowsocks-qt5</code></p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> shadowsocks-qt5dpkg-buildpackage -uc -us -b</code></pre><p>编译完成之后会在上一级目录出现一个 deb 包<code>shadowsocks-qt5_2.7.0-1_amd64.deb</code>，版本不同包名可能会有一些小的区别</p><p>7.安装试试 shadowsocks-qt5</p><pre><code class="hljs undefined"><span class="hljs-selector-tag">sudo</span> <span class="hljs-selector-tag">dpkg</span> <span class="hljs-selector-tag">-i</span> <span class="hljs-selector-tag">shadowsocks-qt5_2</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.0-1_amd64</span><span class="hljs-selector-class">.deb</span></code></pre><p><strong>大功告成，最后在启动器里面就可以看到 ss-qt5 的图标了，最后给出上面提到的我编译成功的相关软件包，不保证有用^^</strong></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ss</tag>
      
      <tag>deepin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四川大学锐捷windows解除多网卡限制</title>
    <link href="/post/18280.html"/>
    <url>/post/18280.html</url>
    
    <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><blockquote><p>搬到望江校区之后校园网快了好多，但是需要锐捷认证，锐捷这个坑货需要限制多网卡，而且程序的占用实在太大，十分的不方便。使用 wifi 共享软件可以开启 wifi 热点，但是会出现连接没多久没网的情况</p></blockquote><p>我使用的锐捷版本是 v4.96</p><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>理论上说多网卡限制的问题都可以解决掉：</p><ul><li>wifi 热点共享</li><li>VPN（FQ）</li><li>虚拟机 host-only</li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>1.首先你已经安装了锐捷的客户端并且使用其可以认证上网</p><p><em>更新：可以尝试直接从第五步开始，因为我发现好像直接结束掉网其实也不会掉</em></p><p>2.然后下载 mentohust win 版本（<a href="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/MentoHUST%EF%BC%88WINDOWS%E7%89%88%EF%BC%89.rar" target="_blank" rel="noopener">点击下载</a>）<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/4058054721.png" srcset="/img/loading.gif" alt="1ecdddfa-ec9a-473b-9a13-3b2e5c3b4fdb.png"></p><p>3.mentohust 的使用方法网上有很多了这里不在赘述，<a href="http://jingyan.baidu.com/article/47a29f2416ba37c015239957.html" target="_blank" rel="noopener">百度经验</a></p><p>4.需要注意这里有不一样的地方，直接按照上面链接的方法是没有办法认证成功的，在设置好之后点击认证前，需要先使用锐捷成功认证上网，然后再使用这个软件认证 5.认证成功之后打开任务管理器，找到 8021.exe 这个进程干掉就可以了 6.然后使用 win10 自带的移动热点也可以开启热点不需要单独下载 wifi 共享软件<br>(如果没有，<del>使用 wifi 软件,测试猎豹 wifi 还是会出现没有网的情况</del> 或者直接用命令行开启也是可以的)<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/3439227638.png" srcset="/img/loading.gif" alt="1610c2cb-221c-42b6-8824-c47176e27cde.png"></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/5431.html">使用chromedp解决反爬虫问题</a></li><li><a href="https://lailin.xyz/post/51466.html">四川大学望江校区使用mentohust认证上网</a></li><li><a href="https://lailin.xyz/post/31503.html">四川大学评教开源代码</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>大学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>破解</tag>
      
      <tag>四川大学</tag>
      
      <tag>锐捷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php设计模式（一）工厂模式</title>
    <link href="/post/43893.html"/>
    <url>/post/43893.html</url>
    
    <content type="html"><![CDATA[<h1 id="PHP-设计模式（一）工厂模式"><a href="#PHP-设计模式（一）工厂模式" class="headerlink" title="PHP 设计模式（一）工厂模式"></a>PHP 设计模式（一）工厂模式</h1><blockquote><p>最近会简单的自我总结一些 php 当中的一些设计模式，当然个人才疏学浅，可能些不对的地方望各位看官见谅指正</p></blockquote><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>工厂模式是一种创建型的模式，简单的说就是用来创建对象的</p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>我们一般最普通的创建对象的方式是这样<code>new classname()</code>,但是换位想一下，这样创建对象的时候我们必须要知道类名，但是我们考虑一下下面几个情况：</p><ol><li>如果我们不知道类名呢？</li><li>如果我在很多个文件当中都用到了这个类创建对象，new 了很多次，但是在重构或者其他什么情况的时候我要修改类名怎么半？当然有人会说怎么会修改类名，这是有可能会遇到的，那说一一下常见一点的，如果我给这个类的构造方法加了，或者是少了一个参数？那岂不是得一个个的去改</li><li>我现在有一个抽象的基类，由它派生了很多子类，我不知道后面还会不会添加其他的子类</li></ol><p>上面几个都是可能会遇到的一些情况之一，使用工厂模式可以比较好的解决上面的问题</p><h2 id="怎么办？"><a href="#怎么办？" class="headerlink" title="怎么办？"></a>怎么办？</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span></span>&#123;    <span class="hljs-comment">//todo</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FoodFactory</span></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> food();    &#125;&#125;$food= FoodFactory::create();</code></pre><p>上面实现简单工厂模式,<code>FoodFactory</code>这个类很简单只有一个创建方法，返回 food 类的实例，当然也可以发现这个方法很笨拙，只能实现一个对象的创建，感觉比直接 new 一个对象<br>好不了多少，只是方便改动而已</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FoodFactory</span></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span><span class="hljs-params">($classname)</span></span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">include_once</span> <span class="hljs-string">'class/'</span> . $classname . <span class="hljs-string">'.php'</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> $classname;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">Exception</span>(<span class="hljs-string">'Driver not found'</span>);        &#125;    &#125;&#125;</code></pre><p>通过上面的方法我们发现我们已经可以不局限于，创建一个固定的类的对象了<br><strong>但是要注意的是：</strong><br><em>如果我们使用了命名空间的话，在动态实例化类的时候必须包含完整的命名空间，提前 use 或者处于统一命名空间都是没有用的</em></p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">namespace</span> <span class="hljs-title">Mohuishou</span>\<span class="hljs-title">Lib</span>;  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FoodFactory</span></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span><span class="hljs-params">($classname)</span></span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">include_once</span> <span class="hljs-string">'class/'</span> . $classname . <span class="hljs-string">'.php'</span>)&#123;        $classname=<span class="hljs-string">"Mohuishou\Lib\\"</span>.$classname;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> $classname;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">Exception</span>(<span class="hljs-string">'Driver not found'</span>);        &#125;    &#125;&#125;</code></pre><p>如果我们还想传入参数呢？</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">namespace</span> <span class="hljs-title">Mohuishou</span>\<span class="hljs-title">Lib</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FoodFactory</span></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span><span class="hljs-params">($classname,$params)</span></span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">include_once</span> <span class="hljs-string">'class/'</span> . $classname . <span class="hljs-string">'.php'</span>)&#123;    $classname=<span class="hljs-string">"Mohuishou\Lib\\"</span>.$classname;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> $classname($params);&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">Exception</span>(<span class="hljs-string">'Driver not found'</span>);&#125;    &#125;&#125;</code></pre><p>如果我们不知道类名，不知道方法，怎么办?怎么实现一个一般的工厂模式？<br>这里可能需要用到反射的概念了，这篇就不过多赘述</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-design-pattern.html">Go设计模式24-总结(更新完毕)</a></li><li><a href="https://lailin.xyz/post/mediator.html">Go设计模式23-中介模式</a></li><li><a href="https://lailin.xyz/post/interpreter.html">Go设计模式22-解释器模式</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四川大学望江校区使用mentohust认证上网</title>
    <link href="/post/51466.html"/>
    <url>/post/51466.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>刚刚解决完天翼飞扬的上网问题，结果就搬校区了，按照上一篇文章的方法在这边也是可以用的，但是校园网使用的锐捷认证已经提供了 linux 的客户端了，所以就没有必要那么麻烦了。但是在信息管理中心下载的客户端简直无语，客户端必须要禁用双网卡，而且连接的的时候会先把你的网络服务给关闭掉。。。但是有时候有开不了。如果不手动禁用掉无线网卡，认证成功之后 3 分钟之内必掉</p></blockquote><h2 id="mentohust"><a href="#mentohust" class="headerlink" title="mentohust"></a>mentohust</h2><blockquote><p>还好有 mentohust 这个神器，但是使用当中还是有一点小坑</p></blockquote><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/4178932952.png" srcset="/img/loading.gif" alt="深度截图20160719182529.png"></p><p>1.首先下载安装 mentohust</p><ul><li>官方地址:<a href="https://code.google.com/archive/p/mentohust/downloads" target="_blank" rel="noopener">https://code.google.com/archive/p/mentohust/downloads</a></li><li><p>官方的要翻墙，这儿提供一个 ubuntu/debian 的<a href="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/994570489.deb" target="_blank" rel="noopener">mentohust_0.3.4-1-2_i386.deb</a></p><p>2.然后在四川大学信息管理中心下载锐捷 4.96 版本，解压提取<code>8021x.exe</code>,<code>W32N55.dll</code>,<code>SuConfig.dat</code>移动到<code>/etc/mentohust</code></p><p>3.在经历一个一个尝试之后的可用模式</p></li></ul><pre><code class="hljs undefined"><span class="hljs-symbol">sudo</span> mentohust -u用户名 -p密码 -a0 -<span class="hljs-built_in">d2</span> -<span class="hljs-keyword">b2 </span>-<span class="hljs-built_in">v4</span>.<span class="hljs-number">96</span> -w //下次使用的时候直接使用sudo mentohust就可以了</code></pre><p><strong>注意：如果显示认证成功但是无法上网，试一试先关闭有线网络的连接然后再打开，然后马上输入上面的命令，即可。拔插网线也可以</strong></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/5431.html">使用chromedp解决反爬虫问题</a></li><li><a href="https://lailin.xyz/post/18280.html">四川大学锐捷windows解除多网卡限制</a></li><li><a href="https://lailin.xyz/post/31503.html">四川大学评教开源代码</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>大学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>四川大学</tag>
      
      <tag>mentohust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下天翼飞扬认证上网的一个解决方法</title>
    <link href="/post/50628.html"/>
    <url>/post/50628.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>博主尝试过许多的方法一直没有解决这个问题，例如：虚拟机桥接 ，crossover、wine 模拟，很早以前的 linux 版本等等，最后都没有成功，但是当要搬校区，不再使用这个客户端的前一天晚上，突发奇想结果解决了….</p></blockquote><p>理论上该方法对于所有需要认证的上网客户端有效</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.安装 virtualbox 2.下载 windows 镜像，博主使用 xp</p><h2 id="开始设置"><a href="#开始设置" class="headerlink" title="开始设置"></a>开始设置</h2><p>1.首先安装 windows 虚拟机,虚拟机设置:</p><ul><li>内存随意，可以在测试好之后，设置为能够正常运行的最小内存，我先使用的是 512M</li><li>网卡，设置两张网卡，一个使用桥接，桥接到连接宽带的有限网络上，另一个使用 host-only 用于组建局域网</li></ul><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/3069020784.png" srcset="/img/loading.gif" alt="深度截图20160718200311.png"><br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/878380818.png" srcset="/img/loading.gif" alt="深度截图20160718200300.png"></p><p>2.在虚拟机中使用宽带的客户端拨号上网</p><p>3.查看局域网地址</p><ul><li>虚拟机当中使用<code>ipconfig</code>命令</li><li>主机当中使用<code>ifconfig</code>命令</li><li>如图所示</li></ul><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/3302058632.png" srcset="/img/loading.gif" alt="深度截图20160718202926.png"></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/3537084827.png" srcset="/img/loading.gif" alt="深度截图20160718202945.png"></p><p>4.在虚拟机当中使用服务器代理软件，然后主机实现代理上网，楼主使用的 TGate</p><ul><li>TGate 设置如图所示</li></ul><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/1779186853.png" srcset="/img/loading.gif" alt="深度截图20160718203937.png"></p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/1448439344.png" srcset="/img/loading.gif" alt="深度截图20160718204111.png"></p><p>5.在主机设置代理上网</p><ul><li>可以设置全局代理，但是博主的 deepin 全局代理好像有点问题，所以就先设置 chrome 的代理了</li><li>如图所示<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/3447026534.png" srcset="/img/loading.gif" alt="深度截图20160718204345.png"></li></ul><blockquote><p>楼主到此已经可以使用了</p></blockquote><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/50696.html">利用vbox在win下搭建linux开发环境</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>大学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>天翼飞扬</tag>
      
      <tag>linux</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迁移laravel框架项目到虚拟主机</title>
    <link href="/post/13242.html"/>
    <url>/post/13242.html</url>
    
    <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>laravel 版本：<code>5.2</code><br>虚拟主机：万网</p><h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><p>1.先把所有文件复制到网站根目录 2.由于访问的时候入口文件在 public 目录下面，这时候访问 url 会变成 url/public/，重写规则跳转就行了,在根目录新建.hatcess 文件</p><pre><code class="hljs undefined"><span class="hljs-section">&lt;IfModule mod_rewrite.c&gt;</span>    <span class="hljs-attribute"><span class="hljs-nomarkup">RewriteEngine</span></span> <span class="hljs-literal">on</span>    <span class="hljs-attribute"><span class="hljs-nomarkup">RewriteCond</span></span> <span class="hljs-variable">%&#123;REQUEST_URI&#125;</span> !^public    <span class="hljs-attribute"><span class="hljs-nomarkup">RewriteRule</span></span> ^(.*)$ public/<span class="hljs-number">$1</span><span class="hljs-meta"> [L]</span><span class="hljs-section">&lt;/IfModule&gt;</span></code></pre><p>3.打开<code>config/app.php</code><br>将</p><pre><code class="hljs undefined"><span class="hljs-string">'key'</span> =&gt; env(<span class="hljs-string">'APP_KEY'</span>, <span class="hljs-string">'...'</span>), <span class="hljs-comment">//32位字符串</span><span class="hljs-string">'cipher'</span> =&gt; <span class="hljs-string">'AES-256-CBC'</span>,</code></pre><p>改为</p><pre><code class="hljs undefined"><span class="hljs-string">'key'</span> =&gt; env(<span class="hljs-string">'APP_KEY'</span>, <span class="hljs-string">'...'</span>),<span class="hljs-comment">//16位字符串</span><span class="hljs-string">'cipher'</span> =&gt; <span class="hljs-string">'AES-128-CBC'</span>,</code></pre><p><em>由于万网不支持’AES-256-CBC’所以用 128 位加密，256 位加密使用 32 位字符串，128 位使用 16 位字符串</em> 4.到这一步基本就没有什么问题了，但是在使用 ajax 的时候，post 方法有可能会被 301 跳转然后变成 get<br>解决方案：<br>打开<code>public</code>目录下的<code>.htaccess</code>文件删除下面这一段</p><pre><code class="hljs undefined"><span class="hljs-comment"># Redirect Trailing Slashes If Not A Folder...</span>  <span class="hljs-attribute"><span class="hljs-nomarkup">RewriteCond</span></span> <span class="hljs-variable">%&#123;REQUEST_FILENAME&#125;</span> !-d  <span class="hljs-attribute"><span class="hljs-nomarkup">RewriteRule</span></span> ^(.*)/$ /<span class="hljs-number">$1</span><span class="hljs-meta"> [L,R=301]</span></code></pre><p>5.好了，我的使用过程中就没什么问题了（注：把在控制台把万网的 php 版本调到最高，现在是 5.5）</p><p><strong>补充一点很多人容易忽略的，配置文件不要卸载.env 文件里面，虚拟机一般不支持，换到 config 目录下的相应配置文件下</strong></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/29454.html">在laravel/lumen之外使用Eloquent</a></li><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>laravel</tag>
      
      <tag>虚拟主机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用lnmp+owncloud+ossfs+oss搭建属于自己的私有云盘</title>
    <link href="/post/8013.html"/>
    <url>/post/8013.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>经常写一写文档之类的东西，需要一个同步网盘，但是现在市面上的还是满足不了我的要求，突然发现阿里云的 oss 可以挂载成虚拟磁盘，试着折腾了一下效果还不错，不过这中间还是有许多的坑</p></blockquote><h3 id="之前使用的云盘"><a href="#之前使用的云盘" class="headerlink" title="之前使用的云盘"></a>之前使用的云盘</h3><ol><li><p>坚果云<br>个人认为是现在市面上最好的同步盘了，支持增量同步，多平台有 linux 版本，可以使用 webdav。美中不足的免费版每个月限制上传下载流量，收费版不限制流量有空间限制。有段时间突然有大量文件需要备份导致流量不足，但是平时又用不了太多，开一个月专业版的空间又不够，用的有点憋屈所以就弃用了。</p></li><li><p>百度云等<br>在使用坚果云之前的主力网盘，同步盘功能竟然要会员才能用，而且同步盘做的很不好用，不过用来做资源分享之类的还不错</p></li></ol><h3 id="为什么使用-oss"><a href="#为什么使用-oss" class="headerlink" title="为什么使用 oss"></a>为什么使用 oss</h3><ol><li><p>数据的稳定性，我比较喜欢折腾所以服务器有时候就会重装这时候对于文件就非常的不好管理和备份，放在 oss 上面能够更好的管理</p></li><li><p>第二个就是便宜，不和其他几家的云服务对比仅仅和阿里云的云盘，就是买服务器的时候的一个选项，便宜很多。40g 的话一年也就差不多 10 多块的样子。而且和 ECS 搭配使用没有流量费用</p></li></ol><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>安装 lnmp 架构</p><blockquote><p>其实 owncloud 官方更加推荐 lamp，但是我个人更喜欢 nginx，要比 Apache 省资源一些，能够用 Apache 的也很不错，可以少踩很多配置的坑，owncloud 的 nginx 官方示例配置很多坑，之后会说到</p></blockquote><h3 id="安装-ossfs"><a href="#安装-ossfs" class="headerlink" title="安装 ossfs"></a>安装 ossfs</h3><blockquote><p>注意：在这之前你需要先开通 oss，最好是和你的 ECS 是一个地区的，当然不是用的 ECS 也可以用，只是速度会慢一些，还有就是下载会使用公网流量，上传没有</p></blockquote><p>1.<a href="https://help.aliyun.com/document_detail/32196.html" target="_blank" rel="noopener">点击打开 ossfs 的下载页面下载对应系统的安装包</a> 2.我已 Ubuntu 为例，安装 ossfs，其他系统看官方的文档就行</p><pre><code class="hljs bash">sudo apt-get updatesudo apt-get install gdebi-coresudo gdebi your_ossfs_package</code></pre><p>3.将<code>my-bucket</code>这个 bucket 挂载到<code>/data/cloud</code>目录下，AccessKeyId 是<code>faint</code>， AccessKeySecret 是<code>123</code>，oss endpoint 是<code>http://oss-cn-hangzhou.aliyuncs.com</code></p><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> my-bucket:faint:123 &gt; /etc/passwd-ossfschmod 640 /etc/passwd-ossfsmkdir /data/cloud</code></pre><p><strong>最后一步很重要，不能直接照官方文档上面的来，不然安装 owncloud 的时候可能会出现没有访问权限的问题</strong></p><ul><li>首先先看一下 nginx 的用户 id，以我的是<code>www</code>为例</li></ul><pre><code class="hljs bash">id www</code></pre><p>会返回给你用户的 uid 和 gid 等等,我假设返回的 uid 和 gid 都为 1001</p><pre><code class="hljs undefined">ossfs my-bucket /data/cloud <span class="hljs-attribute">-ourl</span>=http://oss-cn-hangzhou-internal.aliyuncs.com <span class="hljs-attribute">-ouid</span>=1001 <span class="hljs-attribute">-ogid</span>=1001 -o allow_other -o <span class="hljs-attribute">umask</span>=007</code></pre><p>这里面<code>allow_other</code>是允许其他用户访问，但是默认设置的是 777 权限这样 owncloud 会提示不安全，用<code>umask=007</code>挂载为 770 权限，不知道为啥这里 0 代表 7,7 表示 0</p><blockquote><p>到这里 ossfs 就安装完毕了下面开始安装 owncloud</p></blockquote><h3 id="安装-OWNCLOUD"><a href="#安装-OWNCLOUD" class="headerlink" title="安装 OWNCLOUD"></a>安装 OWNCLOUD</h3><blockquote><p>owncloud 的安装网上已经有很多的教程我就不多说了</p></blockquote><p>先打开<a href="https://owncloud.org/install/#instructions-server" target="_blank" rel="noopener">owncloud 的官网的服务器端的安装地址</a>，我安装的时候最新稳定版是<code>9.0.2</code>建议国内主机用迅雷之类的下载软件先下载下来上传到服务器，直接 wget 比较慢</p><p>1.下载并解压</p><pre><code class="hljs undefined">wget  https:<span class="hljs-regexp">//</span>download.owncloud.org<span class="hljs-regexp">/community/</span>owncloud-<span class="hljs-number">9.0</span>.<span class="hljs-number">2</span>.tar.bz2 <span class="hljs-regexp">//</span>手动上传这一步就不用了tar xvf owncloud-<span class="hljs-number">9.0</span>.<span class="hljs-number">2</span>.tar.bz2 <span class="hljs-regexp">//</span>以实际的文件名为准</code></pre><p>2.移动到站点目录,假设站点目录为<code>/data/wwwroot</code></p><pre><code class="hljs undefined">mv owncloud<span class="hljs-regexp">/ /</span>data<span class="hljs-regexp">/wwwroot/</span></code></pre><p><strong>3.设置目录权限，这一步很重要</strong></p><pre><code class="hljs bash">chown -R www:www /data/wwwroot/owncloud/chmod 777 /data/wwwroot/owncloud//config/</code></pre><h3 id="设置-nginx-规则（Apache-基本不用改，只需要自己去设置一下-ssl，和常规的设置就行了）"><a href="#设置-nginx-规则（Apache-基本不用改，只需要自己去设置一下-ssl，和常规的设置就行了）" class="headerlink" title="设置 nginx 规则（Apache 基本不用改，只需要自己去设置一下 ssl，和常规的设置就行了）"></a>设置 nginx 规则（Apache 基本不用改，只需要自己去设置一下 ssl，和常规的设置就行了）</h3><p><strong>注意规则设置好之后，安装的时候点高级设置，使用 mysql 或者其他数据库，<code>sqllite</code>的性能不够，然后就是数据文件目录填写之前你 ossfs 的挂载目录，我之前挂载的是<code>/data/cloud</code></strong></p><blockquote><p>后面有 9.x 官方的示例，我这儿提示一下有些坑的地方</p></blockquote><p>1.本身的设置里面没有 log 的设置，不方便 debug，access_log 可以不用，error_log 还是需要加上的 2.里面没有 index 的设置，如果打开首页一片空白，加上 index.php 之后没有问题的话，</p><pre><code class="hljs undefined"><span class="hljs-keyword">location</span> / &#123;<span class="hljs-keyword">index</span> <span class="hljs-keyword">index</span>.php <span class="hljs-meta">#加上这一句</span>      rewrite ^ /<span class="hljs-keyword">index</span>.php$uri;&#125;</code></pre><p>3.如果你进入安装页面，按照提示安装好了之后出现说<code>找不到文件目录</code>之类的话，那么很有可能是你没有开启<code>pathinfo</code>，owncloud 需要 pathinfo 的支持(示例的配置里面是有 pathinfo 的设置的)</p><h3 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h3><blockquote><p>到这里基本上 owncloud 的安装应该就结束了，使用也没有什么问题，我建议开启 ssl，不知道为什么，我开了 ssl 之后访问的速度提升了好几倍</p></blockquote><p>附送官方插件的地址<a href="https://apps.owncloud.com/" target="_blank" rel="noopener">点我点我</a>,国内主机在线安装插件可能装不上，可以 FQ 之后在这里面下载相应插件包，上传到 apps 目录下即可，下一篇说一下用 owncloud 实现离线下载功能，现在 9.0.2 版本的使用 owncloud 的离线下载插件有问题，但是看了一下这个 bug 很早就有，只是好像一直没有修复。之后我改一下能够用了再写下一篇吧</p><h3 id="9-x-官方示例"><a href="#9-x-官方示例" class="headerlink" title="9.x 官方示例"></a>9.x 官方示例</h3><pre><code class="hljs undefined"> <span class="hljs-attribute">upstream</span> php-handler &#123;    <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:9000</span>; <span class="hljs-comment">#注意一下你自己的php服务设置，这一行可能需要自己调整</span>    <span class="hljs-comment">#server unix:/var/run/php5-fpm.sock;</span>&#125;<span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span> cloud.example.com;    <span class="hljs-comment"># enforce https</span>    <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://<span class="hljs-variable">$server_name</span><span class="hljs-variable">$request_uri</span>;&#125;<span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;    <span class="hljs-attribute">server_name</span> cloud.example.com;    <span class="hljs-comment">#ssl证书的位置</span>    <span class="hljs-attribute">ssl_certificate</span> /etc/ssl/nginx/cloud.example.com.crt;    <span class="hljs-attribute">ssl_certificate_key</span> /etc/ssl/nginx/cloud.example.com.key;    <span class="hljs-comment"># Add headers to serve security related headers</span>    <span class="hljs-comment"># Before enabling Strict-Transport-Security headers please read into this</span>    <span class="hljs-comment"># topic first.</span>    <span class="hljs-comment"># 安装好之后，后台可能会提示相应错误，把这一段的注释去掉就行</span>    <span class="hljs-comment"># add_header Strict-Transport-Security "max-age=15768000;</span>    <span class="hljs-comment"># includeSubDomains; preload;";</span>    <span class="hljs-comment">#后面安装好了之后后台可能会提示header的错误，把这一短删除掉即可</span>    <span class="hljs-attribute">add_header</span> X-Content-Type-Options nosniff;    <span class="hljs-attribute">add_header</span> X-Frame-Options <span class="hljs-string">"SAMEORIGIN"</span>;    <span class="hljs-attribute">add_header</span> X-XSS-Protection <span class="hljs-string">"1; mode=block"</span>;    <span class="hljs-attribute">add_header</span> X-Robots-Tag <span class="hljs-literal">none</span>;    <span class="hljs-attribute">add_header</span> X-Download-Options noopen;    <span class="hljs-attribute">add_header</span> X-Permitted-Cross-Domain-Policies <span class="hljs-literal">none</span>;    <span class="hljs-comment"># Path to the root of your installation</span>    <span class="hljs-attribute">root</span> /var/www/owncloud/;    <span class="hljs-attribute">location</span> = /robots.txt &#123;        <span class="hljs-attribute">allow</span> all;        <span class="hljs-attribute">log_not_found</span> <span class="hljs-literal">off</span>;        <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>;    &#125;    <span class="hljs-comment"># The following 2 rules are only needed for the user_webfinger app.</span>    <span class="hljs-comment"># Uncomment it if you're planning to use this app.</span>    <span class="hljs-comment">#rewrite ^/.well-known/host-meta /public.php?service=host-meta last;</span>    <span class="hljs-comment">#rewrite ^/.well-known/host-meta.json /public.php?service=host-meta-json</span>    <span class="hljs-comment"># last;</span>    <span class="hljs-attribute">location</span> = /.well-known/carddav &#123; <span class="hljs-attribute">return</span> <span class="hljs-number">301</span>     <span class="hljs-variable">$scheme</span>://<span class="hljs-variable">$host</span>/remote.php/dav; &#125;    <span class="hljs-attribute">location</span> = /.well-known/caldav &#123; <span class="hljs-attribute">return</span> <span class="hljs-number">301</span>     <span class="hljs-variable">$scheme</span>://<span class="hljs-variable">$host</span>/remote.php/dav; &#125;    <span class="hljs-attribute">location</span> /.well-known/acme-challenge &#123; &#125;    <span class="hljs-comment"># set max upload size</span>    <span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">512M</span>;    <span class="hljs-attribute">fastcgi_buffers</span> <span class="hljs-number">64</span> <span class="hljs-number">4K</span>;    <span class="hljs-comment"># Disable gzip to avoid the removal of the ETag header</span>    <span class="hljs-attribute">gzip</span> <span class="hljs-literal">off</span>;    <span class="hljs-comment"># Uncomment if your server is build with the ngx_pagespeed module</span>    <span class="hljs-comment"># This module is currently not supported.</span>    <span class="hljs-comment">#pagespeed off;</span>    <span class="hljs-attribute">error_page</span> <span class="hljs-number">403</span> /core/templates/<span class="hljs-number">403</span>.php;    <span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> /core/templates/<span class="hljs-number">404</span>.php;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^</span> /index.php<span class="hljs-variable">$uri</span>;    &#125;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/(?:build|tests|config|lib|3rdparty|templates|data)/</span> &#123;        <span class="hljs-attribute">deny</span> all;    &#125;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/(?:\.|autotest|occ|issue|indie|db_|console)</span> &#123;        <span class="hljs-attribute">deny</span> all;    &#125;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~    ^/(?:index|remote|public|cron|core/ajax/update|status|ocs/v[12]|updater</span>    /.+|ocs-provider/.+|core/templates/<span class="hljs-number">40</span>[<span class="hljs-number">34</span>])\.php(?:$|/) &#123;        <span class="hljs-attribute">include</span> fastcgi_params;        <span class="hljs-attribute">fastcgi_split_path_info</span><span class="hljs-regexp"> ^(.+\.php)(/.+)$</span>;        <span class="hljs-attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="hljs-variable">$document_root</span><span class="hljs-variable">$fastcgi_script_name</span>;        <span class="hljs-attribute">fastcgi_param</span> PATH_INFO <span class="hljs-variable">$fastcgi_path_info</span>;        <span class="hljs-attribute">fastcgi_param</span> HTTPS <span class="hljs-literal">on</span>;        <span class="hljs-comment">#Avoid sending the security headers twice</span>        <span class="hljs-attribute">fastcgi_param</span> modHeadersAvailable <span class="hljs-literal">true</span>;        <span class="hljs-attribute">fastcgi_param</span> front_controller_active <span class="hljs-literal">true</span>;        <span class="hljs-attribute">fastcgi_pass</span> php-handler;        <span class="hljs-attribute">fastcgi_intercept_errors</span> <span class="hljs-literal">on</span>;        <span class="hljs-attribute">fastcgi_request_buffering</span> <span class="hljs-literal">off</span>;    &#125;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/(?:updater|ocs-provider)(?:$|/)</span> &#123;        <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span>/ =<span class="hljs-number">404</span>;        <span class="hljs-attribute">index</span> index.php;    &#125;    <span class="hljs-comment"># Adding the cache control header for js and css files</span>    <span class="hljs-comment"># Make sure it is BELOW the PHP block</span>    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~* \.(?:css|js)$</span> &#123;        <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> /index.php<span class="hljs-variable">$uri</span><span class="hljs-variable">$is_args</span><span class="hljs-variable">$args</span>;        <span class="hljs-attribute">add_header</span> Cache-Control <span class="hljs-string">"public, max-age=7200"</span>;        <span class="hljs-comment"># Add headers to serve security related headers (It is intended to</span>        <span class="hljs-comment"># have those duplicated to the ones above)</span>        <span class="hljs-comment"># Before enabling Strict-Transport-Security headers please read into</span>        <span class="hljs-comment"># this topic first.</span>        <span class="hljs-comment"># add_header Strict-Transport-Security "max-age=15768000;</span>        <span class="hljs-comment">#  includeSubDomains; preload;";</span>        <span class="hljs-attribute">add_header</span> X-Content-Type-Options nosniff;        <span class="hljs-attribute">add_header</span> X-Frame-Options <span class="hljs-string">"SAMEORIGIN"</span>;        <span class="hljs-attribute">add_header</span> X-XSS-Protection <span class="hljs-string">"1; mode=block"</span>;        <span class="hljs-attribute">add_header</span> X-Robots-Tag <span class="hljs-literal">none</span>;        <span class="hljs-attribute">add_header</span> X-Download-Options noopen;        <span class="hljs-attribute">add_header</span> X-Permitted-Cross-Domain-Policies <span class="hljs-literal">none</span>;        <span class="hljs-comment"># Optional: Don't log access to assets</span>        <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>;    &#125;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~* \.(?:svg|gif|png|html|ttf|woff|ico|jpg|jpeg)$</span> &#123;        <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> /index.php<span class="hljs-variable">$uri</span><span class="hljs-variable">$is_args</span><span class="hljs-variable">$args</span>;        <span class="hljs-comment"># Optional: Don't log access to other assets</span>        <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>;    &#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>lnmp</tag>
      
      <tag>云盘</tag>
      
      <tag>owncloud</tag>
      
      <tag>oss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四川大学评教开源代码</title>
    <link href="/post/31503.html"/>
    <url>/post/31503.html</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">require</span> <span class="hljs-string">"login.php"</span>;<span class="hljs-keyword">require</span> <span class="hljs-string">"QueryList.class.php"</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">evaluate</span></span>&#123;    <span class="hljs-keyword">private</span> $_listUrl=<span class="hljs-string">"http://202.115.47.141/jxpgXsAction.do?oper=listWj&amp;page="</span>;<span class="hljs-comment">//评教列表页面</span>    <span class="hljs-keyword">private</span> $_formUrl=<span class="hljs-string">"http://202.115.47.141/jxpgXsAction.do?oper=wjShow&amp;"</span>;<span class="hljs-comment">//评教表单页面</span>    <span class="hljs-keyword">private</span> $_postUrl=<span class="hljs-string">"http://202.115.47.141/jxpgXsAction.do?oper=wjpg&amp;"</span>;<span class="hljs-comment">//评教提交地址</span>    <span class="hljs-keyword">private</span> $_yjpj;    <span class="hljs-keyword">private</span> $_successNo=<span class="hljs-number">0</span>;<span class="hljs-comment">//成功次数</span>    <span class="hljs-keyword">private</span> $_failNo=<span class="hljs-number">0</span>;<span class="hljs-comment">//失败次数</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span><span class="hljs-params">($name,$pass)</span>    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;_yjpj=<span class="hljs-keyword">new</span> login($name,$pass);    &#125;    <span class="hljs-comment">/**     * 获取评教列表并且返回列表信息以及页码     * <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;     * <span class="hljs-doctag">@return</span> mixed     *       $list=[     *           'info'=&gt;[     *               [     *                   'param'=&gt;[     *                       0 =&gt; '0000000038',     *                       1 =&gt; '19873162',     *                       2 =&gt; '高苹',     *                       3 =&gt; '学评教',     *                       4 =&gt; '马克思主义基本原理概论',     *                       5 =&gt; '107021030',     *                   ],     *                   'status'=&gt;0     *               ],     *              ......     *           ],     *           'page'=&gt;[     *               [     *                   'page'=&gt;'2'     *               ]     *           ]     *       ];     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">getList</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-comment">/*--------------获取第一页的评教列表页面---------------*/</span>        $listContent=<span class="hljs-keyword">$this</span>-&gt;_yjpj-&gt;show(<span class="hljs-keyword">$this</span>-&gt;_listUrl.<span class="hljs-string">"1"</span>);        <span class="hljs-comment">/*------------获取评教分页信息--------------*/</span>        $pageReg=[            <span class="hljs-string">'page'</span>=&gt;[<span class="hljs-string">'script:eq(3)'</span>,<span class="hljs-string">'html'</span>,<span class="hljs-string">''</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($page)</span></span>&#123;                $pattern=<span class="hljs-string">"/document\.all\.pageNo\.value&gt;(.)/"</span>;                preg_match($pattern,$page,$no);                <span class="hljs-keyword">if</span>($no[<span class="hljs-number">1</span>])&#123;                    <span class="hljs-keyword">return</span> $no[<span class="hljs-number">1</span>];                &#125;            &#125;]        ];        $page=QueryList::Query($listContent,$pageReg);        $page=$page-&gt;jsonArr[<span class="hljs-number">0</span>][<span class="hljs-string">'page'</span>];        <span class="hljs-comment">/*---------获取评教老师信息--------------*/</span>        $listReg=[            <span class="hljs-string">'param'</span>=&gt;[<span class="hljs-string">'img'</span>,<span class="hljs-string">'name'</span>,<span class="hljs-string">''</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($a)</span></span>&#123;                <span class="hljs-keyword">if</span>($a)&#123;                    <span class="hljs-keyword">return</span> explode(<span class="hljs-string">'#@'</span>,$a);                &#125;            &#125;],            <span class="hljs-string">'status'</span>=&gt;[<span class="hljs-string">'img'</span>,<span class="hljs-string">'onclick'</span>,<span class="hljs-string">''</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($a)</span></span>&#123;                <span class="hljs-keyword">if</span>(trim($a)==<span class="hljs-string">"evaluation(this)"</span>)&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                &#125;            &#125;],        ];        <span class="hljs-comment">/*[优化]：减少重复抓取列表页，大大提高效率*/</span>        $c=QueryList::Query($listContent,$listReg);        $list[]=$c-&gt;jsonArr;        <span class="hljs-keyword">if</span>($page&gt;<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">for</span>($i=<span class="hljs-number">2</span>;$i&lt;=$page;$i++)&#123;                $listContent=<span class="hljs-keyword">$this</span>-&gt;_yjpj-&gt;show(<span class="hljs-keyword">$this</span>-&gt;_listUrl.$i);                $c=QueryList::Query($listContent,$listReg);                $list[]=$c-&gt;jsonArr;            &#125;        &#125;        <span class="hljs-keyword">return</span> $list;<span class="hljs-comment">//获取到的评教信息</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPostInfo</span><span class="hljs-params">($list)</span>    </span>&#123;<span class="hljs-comment">//        print_r($list);</span>        <span class="hljs-keyword">foreach</span>($list <span class="hljs-keyword">as</span>  $listVal)&#123;<span class="hljs-comment">//            print_r($listVal);</span>            <span class="hljs-keyword">foreach</span>($listVal <span class="hljs-keyword">as</span> $listkey =&gt; $listValue)&#123;                <span class="hljs-keyword">if</span>($listValue[<span class="hljs-string">'status'</span>]==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//                    print_r($listValue);</span>                    $param=[                        <span class="hljs-string">'wjbm'</span>=&gt;$listValue[<span class="hljs-string">'param'</span>][<span class="hljs-number">0</span>],                        <span class="hljs-string">'bpr'</span>=&gt;$listValue[<span class="hljs-string">'param'</span>][<span class="hljs-number">1</span>],                        <span class="hljs-string">'pgnr'</span>=&gt;$listValue[<span class="hljs-string">'param'</span>][<span class="hljs-number">5</span>],                    ];                    $param=http_build_query($param);                    $url=<span class="hljs-keyword">$this</span>-&gt;_formUrl.$param;<span class="hljs-comment">//                    echo $url;</span>                    $formContent=<span class="hljs-keyword">$this</span>-&gt;_yjpj-&gt;show($url);<span class="hljs-comment">//                    print_r($formContent);</span>                    $res=QueryList::Query($formContent,[<span class="hljs-string">'name'</span>=&gt;[<span class="hljs-string">'[value=10_1]'</span>,<span class="hljs-string">'name'</span>]]);                    <span class="hljs-comment">/*--------------将获取的表单信息整理成为即将post的参数-------------*/</span>                    <span class="hljs-keyword">foreach</span>($res-&gt;jsonArr <span class="hljs-keyword">as</span> $postKey =&gt; $postValue)&#123;                        $postParam[$postValue[<span class="hljs-string">'name'</span>]]=<span class="hljs-string">"10_1"</span>;                    &#125;                    $postParam[<span class="hljs-string">'wjbm'</span>]=$listValue[<span class="hljs-string">'param'</span>][<span class="hljs-number">0</span>];                    $postParam[<span class="hljs-string">'bpr'</span>]=$listValue[<span class="hljs-string">'param'</span>][<span class="hljs-number">1</span>];                    $postParam[<span class="hljs-string">'pgnr'</span>]=$listValue[<span class="hljs-string">'param'</span>][<span class="hljs-number">5</span>];                    $postParam[<span class="hljs-string">'zgpj'</span>]=<span class="hljs-string">"very good teacher!!"</span>;                    <span class="hljs-keyword">$this</span>-&gt;post($postParam);<span class="hljs-comment">//                    return 0;</span>                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span><span class="hljs-params">($param)</span></span>&#123;        $param=http_build_query($param);        $url=<span class="hljs-keyword">$this</span>-&gt;_postUrl.$param;<span class="hljs-comment">//        echo $url;</span>        $evalContent=<span class="hljs-keyword">$this</span>-&gt;_yjpj-&gt;show($url);        <span class="hljs-comment">/*--------------------抓取提交之后的数据查看是否成功提交--------------------*/</span>        $res=QueryList::Query($evalContent,[<span class="hljs-string">'info'</span>=&gt;[<span class="hljs-string">'script'</span>,<span class="hljs-string">'html'</span>,<span class="hljs-string">''</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($a)</span></span>&#123;            $pattern=<span class="hljs-string">'/alert\("(.+)"\)/'</span>;            preg_match_all($pattern,$a,$res);            $success=<span class="hljs-string">'评估成功！'</span>;            <span class="hljs-keyword">if</span>($res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]==$success)&#123;                $a=[                    <span class="hljs-string">'message'</span>=&gt;$res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],                    <span class="hljs-string">'status'</span>=&gt;<span class="hljs-number">1</span>                ];            &#125;<span class="hljs-keyword">else</span>&#123;                $a=[                    <span class="hljs-string">'message'</span>=&gt;$res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],                    <span class="hljs-string">'status'</span>=&gt;<span class="hljs-number">0</span>                ];            &#125;            <span class="hljs-keyword">return</span> $a;        &#125;]]);        $status=$res-&gt;jsonArr[<span class="hljs-number">0</span>][<span class="hljs-string">'info'</span>][<span class="hljs-string">'status'</span>];        <span class="hljs-keyword">if</span>($status==<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">$this</span>-&gt;_successNo+=<span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">$this</span>-&gt;_failNo+=<span class="hljs-number">1</span>;        &#125;<span class="hljs-comment">//        print_r($res-&gt;jsonArr);</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;getPostInfo(<span class="hljs-keyword">$this</span>-&gt;getList());        <span class="hljs-keyword">$this</span>-&gt;count();      <span class="hljs-keyword">return</span> [<span class="hljs-string">'success'</span>=&gt;<span class="hljs-keyword">$this</span>-&gt;_successNo,<span class="hljs-string">'fail'</span>=&gt;<span class="hljs-keyword">$this</span>-&gt;_failNo];        <span class="hljs-comment">//return '评教成功，成功：'.$this-&gt;_successNo.'位，'.'失败：'.$this-&gt;_failNo."位";</span>    &#125;&#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/5431.html">使用chromedp解决反爬虫问题</a></li><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/18280.html">四川大学锐捷windows解除多网卡限制</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>大学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>四川大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Composer上线前的优化</title>
    <link href="/post/36128.html"/>
    <url>/post/36128.html</url>
    
    <content type="html"><![CDATA[<p>更新之后或者上线前别忘了执行下面的命令<br>否则少则损失 20%-50%的性能，多则程序直接报错</p><pre><code class="hljs bash">composer dump-autoload --optimize</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>composer</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php识别验证码（二）</title>
    <link href="/post/10661.html"/>
    <url>/post/10661.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>在 php 识别验证码（一）当中说了基本的识别验证码的方法，及其关键的代码，但是最后我们留下了一个问题，就是对于有旋转的验证码的识别率及其低下的问题，下面来解决这个问题。</p></blockquote><h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><blockquote><p>解决类似于下面图片这种有旋转字符的验证码，我们首先要给出一种标准，让所有的分割后的图片都按照一个标准来摆放，最后对比的时候才能够统一</p></blockquote><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/1900195239.png" srcset="/img/loading.gif" alt="inImgTemp.png"></p><p><strong>如何标准化？</strong></p><ul><li><p>我们对一个字符进行旋转，然后计算这个字符的宽度，当宽度最小时，我们认为它是一个标准字符，这样我们就能够得到比较好的结果了（通过观察这种验证码，发现一般只要左右旋转三十度即可）</p></li><li><p>然后仅仅进行旋转还不够，为了能够和模板也就是特征值库进行对比，我们还需要，统一字符长度。也就是二值化之后的字符串长度，这时就需要画一张长宽固定的图片，把我们原来的图片按照比例拉伸压缩复制过去</p></li></ul><pre><code class="hljs php">    <span class="hljs-comment">/**     * 图像标准化，将旋转的图像标准化     * <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;     * <span class="hljs-doctag">@param</span> $img     * <span class="hljs-doctag">@return</span> resource 标准的图像资源句柄     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">imageStandard</span><span class="hljs-params">($img)</span></span>&#123;        $min_w=<span class="hljs-number">999</span>;        $oimg=$img;        $c=imagecolorallocate($img, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);        <span class="hljs-keyword">for</span>($i=<span class="hljs-number">-30</span>;$i&lt;<span class="hljs-number">30</span>;$i++)&#123;            $simg=imagerotate($img,$i,$c);<span class="hljs-comment">//            //计算字符宽度</span>            $simg_hash_data=<span class="hljs-keyword">$this</span>-&gt;getWidth($simg);            $w=count($simg_hash_data);            <span class="hljs-keyword">if</span>($w&lt;$min_w)&#123;                $oimg_hash_data=$simg_hash_data;                $min_w=$w;            &#125;        &#125;        $out_img_w=count($oimg_hash_data);        $out_img_h=count($oimg_hash_data[<span class="hljs-number">0</span>]);        $out_img = imagecreatetruecolor($out_img_w,$out_img_h);<span class="hljs-comment">//创建一幅真彩色图像</span>        $bg=imagecolorallocate($out_img, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);<span class="hljs-comment">//背景色画为白色</span>        imagefill($out_img, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>, $bg);        <span class="hljs-comment">//一列一列的进行画图</span>        <span class="hljs-keyword">foreach</span> ($oimg_hash_data <span class="hljs-keyword">as</span> $k=&gt;$v)&#123;            <span class="hljs-keyword">foreach</span> ($v <span class="hljs-keyword">as</span> $key=&gt; $val)&#123;                $color=<span class="hljs-number">255</span>;                <span class="hljs-keyword">if</span>($val) $color=<span class="hljs-number">0</span>;                $c = imagecolorallocate($out_img, $color, $color, $color);                imagesetpixel($out_img, $k,$key, $c);            &#125;        &#125;<span class="hljs-comment">//        imagepng($out_img,'./0.png');</span>        $hash_img = imagecreatetruecolor(<span class="hljs-keyword">self</span>::HASH_W, <span class="hljs-keyword">self</span>::HASH_H);        imagecopyresized($hash_img, $out_img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">self</span>::HASH_W,<span class="hljs-keyword">self</span>::HASH_H,$out_img_w,$out_img_h);        <span class="hljs-keyword">return</span> $hash_img;    &#125;    <span class="hljs-comment">/**     * 获取图像的宽度     * <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;     * <span class="hljs-doctag">@param</span> $img 图像资源句柄     * <span class="hljs-doctag">@return</span> int     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWidth</span><span class="hljs-params">($img)</span></span>&#123;        <span class="hljs-comment">//根据资源句柄获取整个图像的高与宽</span>        $img_w=imagesx($img);        $img_h=imagesy($img);        <span class="hljs-comment">//图像二值化</span>        <span class="hljs-keyword">for</span>($i = <span class="hljs-number">0</span>; $i &lt;$img_h; $i++) &#123;            <span class="hljs-keyword">for</span> ($j = <span class="hljs-number">0</span>; $j &lt;$img_w; $j++) &#123;                $rgb = imagecolorat($img,$j,$i);                <span class="hljs-keyword">if</span>($rgb==<span class="hljs-number">0</span>)&#123;                    $data[$i][$j]=<span class="hljs-number">1</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    $data[$i][$j]=<span class="hljs-number">0</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">//去掉零行</span>        $data=<span class="hljs-keyword">$this</span>-&gt;removeZero($data);        <span class="hljs-comment">//按列取图像获取宽度</span>        <span class="hljs-keyword">for</span>($i=<span class="hljs-number">0</span>;$i&lt;$img_w;$i++)&#123;            $column=array_column($data,$i);            <span class="hljs-keyword">if</span>(implode(<span class="hljs-string">""</span>,$column)!=<span class="hljs-number">0</span>)&#123;                $data1[]=$column;            &#125;        &#125;        <span class="hljs-comment">//返回</span>        <span class="hljs-keyword">return</span> $data1;    &#125;</code></pre><blockquote><p>看上方的代码发现会有一个去除零行的操作，也就是去除空白行，这一步操作的目的主要是为了出掉上下左右无用的空白部分，在我们进行模板对比的时候更加的精确</p></blockquote><h2 id="建立特征值库"><a href="#建立特征值库" class="headerlink" title="建立特征值库"></a>建立特征值库</h2><blockquote><p>之前提到了很多和模板或者是特征值库进行比较，那我们如何来建立这个库呢？下面说一下最简单的两种方法</p></blockquote><ul><li>第一种，就是把你需要的数字可能还有 26 个字母，都先识别一遍然后存到一个文件当中，使用的时候包含这个文件进行对比就行了</li><li>第二种，也差不多，可以写一个 study 文件，让上面的步骤稍微智能一点，直接输入之后，自动储存到数据库中</li></ul><p>下面是我写的一个针对联通优选在沃的一个小的脚本，需要注意的是对于这种通过链接来识别的，一定要先将链接的图片保存下来，因为链接没获取一次图片就会改变一次</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">/** * Created by mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;. * User: mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt; * Date: 2016/5/1 0001 * Time: 20:44 */</span><span class="hljs-keyword">require_once</span> <span class="hljs-string">'Image.class.php'</span>;<span class="hljs-keyword">require_once</span>  <span class="hljs-string">'DB.class.php'</span>;$db=<span class="hljs-keyword">new</span> \ImageOCR\DB();<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">'send'</span>])&amp;&amp;$_POST[<span class="hljs-string">'send'</span>]==<span class="hljs-string">"send"</span>)&#123;    $image=<span class="hljs-keyword">new</span> \ImageOCR\Image(<span class="hljs-string">"./img/inImgTemp.png"</span>);    $code=$_POST[<span class="hljs-string">'code'</span>];    $code_arr=str_split($code);    <span class="hljs-keyword">for</span>($i=<span class="hljs-number">0</span>;$i&lt;$image::CHAR_NUM;$i++)&#123;        $hash_img_data=implode(<span class="hljs-string">""</span>,$image-&gt;splitImage($i));        $db-&gt;add($code_arr[$i],$hash_img_data);    &#125;    <span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;script&gt;location.href='./study.php';&lt;/script&gt;"</span>;&#125;<span class="hljs-keyword">else</span>&#123;    $image=<span class="hljs-keyword">new</span> \ImageOCR\Image(<span class="hljs-string">"http://www.169ol.com/Mall/Code/getCode&amp;1462104790492"</span>);    imagepng($image-&gt;_in_img,<span class="hljs-string">"./img/inImgTemp.png"</span>);&#125;<span class="hljs-meta">?&gt;</span>&lt;!DOCTYPE html&gt;&lt;html lang=<span class="hljs-string">"en"</span>&gt;&lt;head&gt;    &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;    &lt;title&gt;Study&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=<span class="hljs-string">""</span> method=<span class="hljs-string">"post"</span>&gt;        &lt;img src=<span class="hljs-string">"img/inImgTemp.png"</span>&gt;        &lt;input type=<span class="hljs-string">"text"</span> name=<span class="hljs-string">"code"</span>&gt;        &lt;input name=<span class="hljs-string">"send"</span> type=<span class="hljs-string">"submit"</span> value=<span class="hljs-string">"send"</span> /&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="开源代码"><a href="#开源代码" class="headerlink" title="开源代码"></a>开源代码</h2><p><strong>觉得不错，给个 star 呗</strong></p><script src="http://git.oschina.net/lxl520/ImageOCR/widget_preview"></script><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="http://drops.wooyun.org/tips/141" target="_blank" rel="noopener">常见验证码的弱点与验证码识别</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>目前的识别效率可以达到 50%以上，基本可以投入正常使用，但是还有很大的进步空间，正在做下一步的优化，针对识别结果对特征库进行自动优化，自动去除使用率较低的特征值，自动保存，识别成功的特征值等等</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>图片</tag>
      
      <tag>验证码识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php利用curl保存图片</title>
    <link href="/post/58471.html"/>
    <url>/post/58471.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>做验证码识别的时候需要先把图片保存起来，写了一个保存图片的函数</p></blockquote><pre><code class="hljs php"><span class="hljs-comment">/*** <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;* <span class="hljs-doctag">@param</span> string $url 获取图片的网址* <span class="hljs-doctag">@param</span> string $fileName 保存的地址以及文件名*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getImg</span><span class="hljs-params">($url, $fileName)</span>    </span>&#123;        $ch = curl_init();        $fp = fopen($fileName, <span class="hljs-string">'w+'</span>);        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_HEADER, <span class="hljs-number">0</span>);        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, <span class="hljs-number">0</span>);        curl_setopt($ch, CURLOPT_TIMEOUT, <span class="hljs-number">60</span>);        curl_setopt($ch, CURLOPT_FILE,$fp);        curl_exec($ch);        curl_close($ch);        fclose($fp);    &#125;</code></pre><blockquote><p>使用的时候发现，需要保存验证码的 cookies，留作验证，必要的时候还需要加上 header</p></blockquote><pre><code class="hljs php"><span class="hljs-comment">/*** <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt;* <span class="hljs-doctag">@param</span> string $url* <span class="hljs-doctag">@param</span> string $fileName*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCode</span><span class="hljs-params">($url = <span class="hljs-string">'http://www.169ol.com/Mall/Code/getCode'</span>, $fileName = <span class="hljs-string">'./img/code.png'</span>)</span>    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;_code_cookie = dirname(<span class="hljs-keyword">__FILE__</span>).<span class="hljs-string">"/pic.cookie"</span>;        $ch = curl_init();        $fp = fopen($fileName, <span class="hljs-string">'w+'</span>);        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_HEADER, <span class="hljs-number">0</span>);        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, <span class="hljs-number">0</span>);        curl_setopt($ch, CURLOPT_TIMEOUT, <span class="hljs-number">60</span>);        curl_setopt($ch, CURLOPT_FILE,$fp);        curl_setopt($ch, CURLOPT_COOKIEJAR, <span class="hljs-keyword">$this</span>-&gt;_code_cookie);        curl_exec($ch);        curl_close($ch);        fclose($fp);    &#125;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>图片</tag>
      
      <tag>curl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php识别验证码（一）</title>
    <link href="/post/47583.html"/>
    <url>/post/47583.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>想做一个针对联通优选在沃自动签到的小程序，但是登陆需要验证码，找了一下现有的一些博客或者是开源的验证码识别的代码，没有一个比较满意的，so，自己写了一个。</p></blockquote><h2 id="需要识别的验证码"><a href="#需要识别的验证码" class="headerlink" title="需要识别的验证码"></a>需要识别的验证码</h2><blockquote><p>第一种：</p></blockquote><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2190097228.png" srcset="/img/loading.gif" alt="code.png"></p><blockquote><p>第二种</p></blockquote><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/1819792828.gif" srcset="/img/loading.gif" alt="1211862590-56a5bd94d822e.gif"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>像上图的验证码一般来说的话，我们需要识别的是 4 个数字，但是验证码为了防止自动识别程序添加了许多的干扰项，例如<code>背景色</code>、<code>雪花</code>、<code>干扰线</code>等等</p><h2 id="去除背景"><a href="#去除背景" class="headerlink" title="去除背景"></a>去除背景</h2><p>我们通过分析该验证码图片可以知道，数字的 rgb 值一般处在 180~190 以下，而背景色和雪花的 rgb 值一般处在 200 以上，so，我们只要在处理图片的时候只取 190 以下的 rgb 值保存就 ok 了，这样就可以去除掉绝大部分的干扰项</p><h2 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h2><p>把干扰信息去除之后，只留下二进制（也就是 0 和 1 表示）的点阵</p><pre><code class="hljs php"><span class="hljs-comment">/** * 二值化，排除背景色，雪花等干扰项 * <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt; */</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">imageHash</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>($i = <span class="hljs-number">0</span>; $i &lt; <span class="hljs-keyword">$this</span>-&gt;_image_h; $i++) &#123;        <span class="hljs-keyword">for</span> ($j = <span class="hljs-number">0</span>; $j &lt; <span class="hljs-keyword">$this</span>-&gt;_image_w; $j++) &#123;            $rgb = imagecolorat(<span class="hljs-keyword">$this</span>-&gt;_in_img,$j,$i);            $rgb_array = imagecolorsforindex(<span class="hljs-keyword">$this</span>-&gt;_in_img, $rgb);            <span class="hljs-keyword">if</span>($rgb_array[<span class="hljs-string">'red'</span>]&lt;<span class="hljs-number">190</span>&amp;&amp;$rgb_array[<span class="hljs-string">'green'</span>]&lt;<span class="hljs-number">190</span>&amp;&amp;$rgb_array[<span class="hljs-string">'blue'</span>]&lt;<span class="hljs-number">190</span>)&#123;                $data[$i][$j]=<span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                $data[$i][$j]=<span class="hljs-number">0</span>;            &#125;        &#125;    &#125;&#125;</code></pre><blockquote><p>点阵化之后的截图</p></blockquote><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2878339217.png" srcset="/img/loading.gif" alt="QQ截图20160503213904.png"></p><h2 id="去噪点"><a href="#去噪点" class="headerlink" title="去噪点"></a>去噪点</h2><p>图像二值化之后可能还存在很多噪点，噪点的特点一般是孤立无援的，这时候我们只需要判断以这个 1 点为中心的点，周围的 1 点个数小于一个阈值（我把它设为 3），就确认它为噪点并将之去除</p><pre><code class="hljs php"><span class="hljs-comment">/** * 去除噪点 * <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt; * <span class="hljs-doctag">@param</span> $hash_data * <span class="hljs-doctag">@return</span> mixed */</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeHotSpots</span><span class="hljs-params">($hash_data)</span></span>&#123;    <span class="hljs-keyword">for</span>($i = <span class="hljs-number">0</span>; $i &lt; <span class="hljs-keyword">$this</span>-&gt;_image_h; $i++) &#123;        <span class="hljs-keyword">for</span> ($j = <span class="hljs-number">0</span>; $j &lt; <span class="hljs-keyword">$this</span>-&gt;_image_w; $j++) &#123;            <span class="hljs-keyword">if</span>($hash_data[$i][$j])&#123;                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">$this</span>-&gt;isHotSpots($i,$j,$hash_data)) $hash_data[$i][$j]=<span class="hljs-number">0</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> $hash_data;&#125;<span class="hljs-comment">/** * 判断是否是噪点 * <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt; * <span class="hljs-doctag">@param</span> $i * <span class="hljs-doctag">@param</span> $j * <span class="hljs-doctag">@param</span> $hash_data * <span class="hljs-doctag">@return</span> bool ture:是噪点,false:不是 */</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isHotSpots</span><span class="hljs-params">($i,$j,$hash_data)</span></span>&#123;    <span class="hljs-keyword">if</span>($i == <span class="hljs-number">0</span> || $j == <span class="hljs-number">0</span> || $i == (<span class="hljs-keyword">$this</span>-&gt;_image_h - <span class="hljs-number">1</span>) || $j == (<span class="hljs-keyword">$this</span>-&gt;_image_w - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    <span class="hljs-comment">//待检查点为中心的九个点</span>    $points[<span class="hljs-number">0</span>]=$hash_data[$i<span class="hljs-number">-1</span>][$j<span class="hljs-number">-1</span>];    $points[<span class="hljs-number">1</span>]=$hash_data[$i<span class="hljs-number">-1</span>][$j];    $points[<span class="hljs-number">2</span>]=$hash_data[$i<span class="hljs-number">-1</span>][$j+<span class="hljs-number">1</span>];    $points[<span class="hljs-number">3</span>]=$hash_data[$i][$j<span class="hljs-number">-1</span>];    $points[<span class="hljs-number">4</span>]=$hash_data[$i][$j];<span class="hljs-comment">//待检查点</span>    $points[<span class="hljs-number">5</span>]=$hash_data[$i][$j+<span class="hljs-number">1</span>];    $points[<span class="hljs-number">6</span>]=$hash_data[$i+<span class="hljs-number">1</span>][$j<span class="hljs-number">-1</span>];    $points[<span class="hljs-number">7</span>]=$hash_data[$i+<span class="hljs-number">1</span>][$j];    $points[<span class="hljs-number">8</span>]=$hash_data[$i+<span class="hljs-number">1</span>][$j+<span class="hljs-number">1</span>];    $count=<span class="hljs-number">0</span>;    <span class="hljs-keyword">foreach</span> ($points <span class="hljs-keyword">as</span> $v)&#123;        <span class="hljs-keyword">if</span>($v)&#123;            $count++;        &#125;    &#125;    <span class="hljs-keyword">return</span> $count&lt;<span class="hljs-number">4</span>;&#125;</code></pre><blockquote><p>去除噪点之后</p></blockquote><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/1678387744.png" srcset="/img/loading.gif" alt="QQ截图20160503214315.png"></p><h2 id="去除干扰线"><a href="#去除干扰线" class="headerlink" title="去除干扰线"></a>去除干扰线</h2><p>通过去除噪点之后的图像，我们可以发现，大部分的干扰线，其实已经被去除掉了，所以我们可以将，去除噪点的方法当做一个滤镜，多过滤几次，干扰线基本上可以去除完毕（这里测试去除三次的效果是最好的）</p><h2 id="分割验证码"><a href="#分割验证码" class="headerlink" title="分割验证码"></a>分割验证码</h2><p>这个验证码的每个数字其实都是等分的，所以我们可以采用等分的方法去分割它</p><pre><code class="hljs php"><span class="hljs-comment">/** * <span class="hljs-doctag">@author</span> mohuishou&lt;1<span class="hljs-doctag">@lailin</span>.xyz&gt; * <span class="hljs-doctag">@param</span> $n * <span class="hljs-doctag">@return</span> array */</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">splitImage</span><span class="hljs-params">($n)</span></span>&#123;    $data=[];    $a=<span class="hljs-keyword">$this</span>-&gt;_image_w/<span class="hljs-keyword">self</span>::CHAR_NUM;    <span class="hljs-keyword">for</span>($i=$n*$a;$i&lt;($n+<span class="hljs-number">1</span>)*$a;$i++)&#123;        $column=array_column(<span class="hljs-keyword">$this</span>-&gt;_hash_data,$i);        <span class="hljs-keyword">if</span>(implode(<span class="hljs-string">""</span>,$column)!=<span class="hljs-number">0</span>)&#123;            $data[]=$column;        &#125;    &#125;    $out_img_w=count($data)+<span class="hljs-number">4</span>;    $out_img_h=count($data[<span class="hljs-number">0</span>])+<span class="hljs-number">4</span>;    $out_img = imagecreatetruecolor($out_img_w,$out_img_h);<span class="hljs-comment">//创建一幅真彩色图像</span>    $bg=imagecolorallocate($out_img, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);<span class="hljs-comment">//背景色画为白色</span>    imagefill($out_img, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>, $bg);    <span class="hljs-comment">//一列一列的进行画图</span>    <span class="hljs-keyword">foreach</span> ($data <span class="hljs-keyword">as</span> $k=&gt;$v)&#123;        <span class="hljs-keyword">foreach</span> ($v <span class="hljs-keyword">as</span> $key=&gt; $val)&#123;            $color=<span class="hljs-number">255</span>;            <span class="hljs-keyword">if</span>($val) $color=<span class="hljs-number">0</span>;            $c = imagecolorallocate($out_img, $color, $color, $color);            imagesetpixel($out_img, $k+<span class="hljs-number">2</span>,$key+<span class="hljs-number">2</span>, $c);        &#125;    &#125;    <span class="hljs-keyword">return</span> $out_img;&#125;</code></pre><h2 id="保存-amp-对比识别"><a href="#保存-amp-对比识别" class="headerlink" title="保存&amp;对比识别"></a>保存&amp;对比识别</h2><blockquote><p>最后将分割好的图片二值化，通过一个数组保存下来，作为一个标准，然后后之后需要验证的验证码，通过和之前的数组求交集，比较最相近的数字得出结果即可</p></blockquote><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><strong>其实到这一步之后已经能够识别一些验证码了，对于第二种验证码已经可以达到很好的识别效果，但是对于第一种验证码的识别率很低很低，大概只有<code>5%-15%</code>，基本不能投入使用，下一篇文章针对这种验证码，怎么更好的识别，主要是<code>标准化</code>和<code>特征库的建立</code></strong></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>图片</tag>
      
      <tag>识别</tag>
      
      <tag>验证码识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php-webhook利用php脚本自动化部署git项目</title>
    <link href="/post/61468.html"/>
    <url>/post/61468.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>遇到权限的问题弄了好久，整理一下步骤简单的写一下<br>在阅读这篇文章的时候默认你的服务器上安装了 web 服务器和 git</p></blockquote><h2 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h2><blockquote><p>写一个简单的脚本查看你的服务器运行的账户，和是否能够运行相关函数</p></blockquote><pre><code class="hljs php">$test=shell_exec(<span class="hljs-string">"whoami"</span>);var_dump($test);<span class="hljs-comment">//我的返回的是 www-data</span></code></pre><p><strong>如果这里返回 null 的话，不妨检查一下 shell_exec 函数是否被禁用了</strong></p><h2 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h2><blockquote><p>建立 ssh 公钥，以我的 www-data 账户为例子</p></blockquote><p>1.先建立一个.ssh 目录并给予 www-data 用户权限</p><pre><code class="hljs undefined">sudo mkdir <span class="hljs-regexp">/var/</span>www/.sshsudo chown -R www-<span class="hljs-string">data:</span>www-data <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/.ssh/</span></code></pre><p>2.生成 webhook 部署公钥</p><pre><code class="hljs undefined"><span class="hljs-title">sudo</span> -<span class="hljs-type">Hu</span> www-<span class="hljs-class"><span class="hljs-keyword">data</span> ssh-keygen -t rsa //一直回车即可</span></code></pre><p><em>如果你和我一样，遇到了<code>-su: sudo: command not found</code>，可以先安装<code>sudo</code>命令,<code>apt-get install sudo</code>，如果你和我还一样遇到了一些问题，不妨先试试<code>apt-get update</code></em></p><p>3.将 webhook 部署公钥上传到托管网站</p><blockquote><p>测试用的 Coding，其他还在测试当中</p></blockquote><p>先查看公钥</p><pre><code class="hljs undefined">sudo cat <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub</code></pre><p>然后复制上面的内容到托管网站，项目的 webhook 上面</p><h2 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h2><blockquote><p>webhook 文件</p></blockquote><script src="http://git.oschina.net/lxl520/php-webhook/widget_preview"></script><h2 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h2><blockquote><p>先在服务器上<code>git clone</code></p></blockquote><pre><code class="hljs undefined"><span class="hljs-title">sudo</span> chown -<span class="hljs-type">R</span> www-<span class="hljs-class"><span class="hljs-keyword">data</span>:www-<span class="hljs-keyword">data</span> &#123;代码地址&#125;</span><span class="hljs-title">sudo</span> -<span class="hljs-type">Hu</span> www-<span class="hljs-class"><span class="hljs-keyword">data</span> git clone &#123;你的项目<span class="hljs-title">ssh</span>地址&#125; &#123;代码地址&#125;  <span class="hljs-comment">--depth=1</span></span></code></pre><p><strong>注意，这里初始化 clone 必须要用 www-data 用户</strong></p><h2 id="step5"><a href="#step5" class="headerlink" title="step5"></a>step5</h2><blockquote><p>在托管网站上添加 webhook 地址，然后提交一次测试</p></blockquote><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><blockquote><p>参考了以下代码<br><a href="https://gist.github.com/overtrue/0bf1cd704bf804de2e2c" target="_blank" rel="noopener">https://gist.github.com/overtrue/0bf1cd704bf804de2e2c</a></p></blockquote><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>git</tag>
      
      <tag>webhook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx无法启动</title>
    <link href="/post/33991.html"/>
    <url>/post/33991.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天装了一个服务器但是 nginx 一直无法启动，google 了各种答案，还是没有效果</p></blockquote><h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><pre><code class="hljs undefined">nginx启动，重启，关闭命令停止操作停止操作是通过向nginx进程发送信号（什么是信号请参阅linux文 章）来进行的步骤<span class="hljs-number">1</span>：查询nginx主进程号ps -ef | grep nginx在进程列表里 面找master进程，它的编号就是主进程号了。步骤<span class="hljs-number">2</span>：发送信号从容停止Nginx：<span class="hljs-keyword">kill</span> -<span class="hljs-keyword">QUIT</span> 主进程号快速停止Nginx：<span class="hljs-keyword">kill</span> -TERM 主进程号强制停止Nginx：pkill -<span class="hljs-number">9</span> nginx另外， 若在nginx.conf配置了pid文件存放路径则该文件存放的就是Nginx主进程号，如果没指定则放在nginx的logs目录下。有了pid文 件，我们就不用先查询Nginx的主进程号，而直接向Nginx发送信号了，命令如下：<span class="hljs-keyword">kill</span> -信号类型 '/usr/nginx/logs/nginx.pid'平滑重启如果更改了配置就要重启Nginx，要先关闭Nginx再打开？不是的，可以向Nginx 发送信号，平滑重启。平滑重启命令：<span class="hljs-keyword">kill</span> -HUP 住进称号或进程号文件路径或者使用/usr/nginx/sbin/nginx -<span class="hljs-keyword">s</span> reload注意，修改了配置文件后最好先检查一下修改过的配置文件是否正 确，以免重启后Nginx出现错误影响服务器稳定运行。判断Nginx配置是否正确命令如下：nginx -t -c /usr/nginx/conf/nginx.conf或者/usr/nginx/sbin/nginx -t平滑升级如果服务器正在运行的Nginx要进行升级、添加或删除模块时，我们需 要停掉服务器并做相应修改，这样服务器就要在一段时间内停止服务，Nginx可以在不停机的情况下进行各种升级动作而不影响服务器运行。步骤<span class="hljs-number">1</span>：如 果升级Nginx程序，先用新程序替换旧程序文件，编译安装的话新程序直接编译到Nginx安装目录中。步 骤<span class="hljs-number">2</span>：执行命令<span class="hljs-keyword">kill</span> -USR2 旧版程序的主进程号或进程文件名此时旧的Nginx主进程将会把自己的进程文件改名为.oldbin，然后执行新版 Nginx。新旧Nginx会同市运行，共同处理请求。这时要逐步停止旧版 Nginx，输入命令：<span class="hljs-keyword">kill</span> -WINCH 旧版主进程号慢慢旧的工作进程就都会随着任务执行完毕而退出，新版的Nginx的工作进程会逐渐取代旧版 工作进程。此 时，我们可以决定使用新版还是恢复到旧版。不重载配置启动新/旧工作进程<span class="hljs-keyword">kill</span> -HUP 旧/新版主进程号从容关闭旧/新进程<span class="hljs-keyword">kill</span> -<span class="hljs-keyword">QUIT</span> 旧/新主进程号如果此时报错，提示还有进程没有结束就用下面命令先关闭旧/新工作进程，再关闭主进程号：<span class="hljs-keyword">kill</span> -TERM 旧/新工作进程号这样下来，如果要恢复到旧版本，只需要上面的几个步 骤都是操作新版主进程号，如果要用新版本就上面的几个步骤都操作旧版主进程号就行了。上面就是Nginx的一些基本的操作，希望以后Nginx能有更好的方法来处理这些操作， 最好是Nginx的命令而不是向Nginx进程发送系统信号。</code></pre><h3 id="后面发现"><a href="#后面发现" class="headerlink" title="后面发现"></a>后面发现</h3><p>突然想起来会不会是配置文件有错误导致的无法启动，so</p><pre><code class="hljs undefined">nginx -t -c <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/nginx.conf</span></code></pre><p><strong>结果发现</strong>是配置项里面的日志文件目录不存在</p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>以后遇到这种问题一定要先看看日志或者先测试一下语句</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59269.html">nginx-php报502错误</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx-php报502错误</title>
    <link href="/post/59269.html"/>
    <url>/post/59269.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>正是悲催犯了一个超低级的错误</p></blockquote><p>在腾讯云新买了一个服务器，直接用了以前 nginx 的配置文件，但是装上之后先是 404 然后 502，一直不知道为什么</p><pre><code class="hljs undefined"><span class="hljs-number">404</span>是因为本来要报<span class="hljs-number">502</span>的错误，但是<span class="hljs-number">502</span>的页面没有放进去....</code></pre><h4 id="502-的错误在网上搜索了很多答案都没有解决，然后后面发现我自己竟然没有看错误日志，翻日志的时候发现是："><a href="#502-的错误在网上搜索了很多答案都没有解决，然后后面发现我自己竟然没有看错误日志，翻日志的时候发现是：" class="headerlink" title="502 的错误在网上搜索了很多答案都没有解决，然后后面发现我自己竟然没有看错误日志，翻日志的时候发现是："></a>502 的错误在网上搜索了很多答案都没有解决，然后后面发现我自己竟然没有看错误日志，翻日志的时候发现是：</h4><pre><code class="hljs undefined"><span class="hljs-number">2016</span>/<span class="hljs-number">04</span>/<span class="hljs-number">25</span> <span class="hljs-number">04</span>:<span class="hljs-number">32</span>:<span class="hljs-number">42</span> <span class="hljs-string">[crit]</span> <span class="hljs-number">251</span>#<span class="hljs-number">251</span>: *<span class="hljs-number">166</span> connect() to unix:/var/run/php5-fpm.sock failed (<span class="hljs-number">2</span>: No such file or directory) while connecting to upstream, client: <span class="hljs-number">220</span>.<span class="hljs-number">167</span>.<span class="hljs-number">47</span>.<span class="hljs-number">185</span>, server: <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>, request: <span class="hljs-string">"<span class="hljs-keyword">GET</span> / HTTP/1.1"</span>, upstream: <span class="hljs-string">"fastcgi://unix:/var/run/php5-fpm.sock:"</span>, host: <span class="hljs-string">"115.159.94.101"</span></code></pre><h4 id="突然间恍然大悟，我新买的服务器装的是-php7，以前用的-php5，sock-文件的地址不一样-改成下面这个重启，就没有问题了"><a href="#突然间恍然大悟，我新买的服务器装的是-php7，以前用的-php5，sock-文件的地址不一样-改成下面这个重启，就没有问题了" class="headerlink" title="突然间恍然大悟，我新买的服务器装的是 php7，以前用的 php5，sock 文件的地址不一样,改成下面这个重启，就没有问题了"></a>突然间恍然大悟，我新买的服务器装的是 php7，以前用的 php5，sock 文件的地址不一样,改成下面这个重启，就没有问题了</h4><pre><code class="hljs undefined">fastcgi_pass <span class="hljs-string">unix:</span><span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/php/</span>php7<span class="hljs-number">.0</span>-fpm.sock;</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>服务器</tag>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言验证浮点数的二进制表示</title>
    <link href="/post/48100.html"/>
    <url>/post/48100.html</url>
    
    <content type="html"><![CDATA[<h3 id="验证浮点数"><a href="#验证浮点数" class="headerlink" title="验证浮点数"></a>验证浮点数</h3><blockquote><p>虽然以前也学过浮点数的表示原理，大致的原理还是清楚的，但是使用 C 语言的来进性验证还没有尝试过，下面是验证的过程</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>知道浮点数，是按照 32 位在内存中保存，其中第一位表示符号，后 8 位表示指数，最后 23 位表示小数</li><li>C 语言当中存在指针，可以直接通过指针来获取，变量的地址。</li><li>所以就先定义一个变量来储存浮点数，在定义一个指针来获取，浮点数的储存地址，在把 16 进制或者 10 进制的地址转化为 2 进制即可<a id="more"></a></li></ol><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<span class="hljs-keyword">float</span> a=<span class="hljs-number">209.125</span>;<span class="hljs-keyword">int</span> *p=(<span class="hljs-keyword">int</span> *)&amp;a;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入一串数:"</span>);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%f"</span>,&amp;a);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, *p);<span class="hljs-comment">//输出数值在内存中10进制表示</span>decimal2Binary(*p);<span class="hljs-comment">//将十进制转化为二进制</span>decimal2Binary_2(*p);&#125;getchar();<span class="hljs-comment">//防止程序退出</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ol start="4"><li>在十进制转化为二进制的过程中，我使用了两种办法，首先想到的就是通过循环求余的办法来转化</li></ol><pre><code class="hljs C"><span class="hljs-comment">/** * [decimal2Binary 十进制转换成二进制，使用循环求余法] * @author mohuishou&lt;1@lailin.xyz&gt; * @param  x [要转换的十进制数] * @return   [0] */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decimal2Binary</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">int</span> a[<span class="hljs-number">32</span>];<span class="hljs-keyword">int</span> rem;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">31</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123; rem=x%<span class="hljs-number">2</span>; x=x/<span class="hljs-number">2</span>; a[j]=rem;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">31</span>;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a[i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ol start="5"><li>第二种是后面查资料的时候看到的一种办法，我转换了一下，用于这个小程序。主要是充分应用了 C 语言当中的位运算</li></ol><pre><code class="hljs C"><span class="hljs-comment">/** * [decimal2Binary_2 十进制转换成二进制，使用按位对比法] * @author mohuishou&lt;1@lailin.xyz&gt; * @param  x [要进行转化的10进制数] * @return   [0] */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decimal2Binary_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &gt;=<span class="hljs-number">0</span>;i--)&#123;<span class="hljs-keyword">if</span>(x&amp;(<span class="hljs-number">1</span>&lt;&lt;i))&#123;<span class="hljs-comment">//将1左移i位并和x进行按位对比</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,<span class="hljs-number">1</span> );&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,<span class="hljs-number">0</span> );&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="0-在浮点数中怎么表示"><a href="#0-在浮点数中怎么表示" class="headerlink" title="0 在浮点数中怎么表示"></a>0 在浮点数中怎么表示</h3><blockquote><p>我先通过上面写好的程序，输入 0 之后，得到的值为 32 个 0，然后进行一个简单的分析认为：</p></blockquote><h4 id="浮点数的表示方法"><a href="#浮点数的表示方法" class="headerlink" title="浮点数的表示方法"></a>浮点数的表示方法</h4><ol><li>浮点数的表示方法是：先转化为 1.xxx（小数部分） * 2^m（指数部分）</li><li>首先判断符号，正的话第一位为 0，负数的话为第一位 1</li><li>指数部分 m+127=&gt;转化为 2 进制</li><li>小数部分 xxx=&gt;转化为 2 进制，</li></ol><h4 id="对于-0-的推断"><a href="#对于-0-的推断" class="headerlink" title="对于 0 的推断"></a>对于 0 的推断</h4><p>由于 0 的话，他第一步就不能转化为 1.xxx（小数部分） * 2^m（指数部分)的形式，所以比较好的一个办法就是以 32 个 0 表示</p><h4 id="推断的验证"><a href="#推断的验证" class="headerlink" title="推断的验证"></a>推断的验证</h4><blockquote><p>对于 C 语言来说我在之前就已经验证了，然后我查询了维基百科 IEEE 二进制浮点数算术标准（IEEE 754）<a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">点击打开</a>，对比得出，0 的二进制浮点数表示的确是 32 个 0</p></blockquote><h3 id="程序运行结果截图"><a href="#程序运行结果截图" class="headerlink" title="程序运行结果截图"></a>程序运行结果截图</h3><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2541890988.png" srcset="/img/loading.gif" alt="1.png"></p><h3 id="程序源代码截图"><a href="#程序源代码截图" class="headerlink" title="程序源代码截图"></a>程序源代码截图</h3><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2014147934.png" srcset="/img/loading.gif" alt="2.png"><br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2014147934.png" srcset="/img/loading.gif" alt="3.png"></p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js编码解码URL</title>
    <link href="/post/62847.html"/>
    <url>/post/62847.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>在 js 的 URL 编码解码当中有这两个函数，分别是</p></blockquote><h3 id="编码解码函数"><a href="#编码解码函数" class="headerlink" title="编码解码函数"></a>编码解码函数</h3><p>1.</p><p>编码<code>encodeURI(str)</code><br>解码<code>decodeURI(str)</code></p><p>2.</p><p>编码<code>encodeURIComponent</code><br>解码<code>decodeURIComponent</code></p><a id="more"></a><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>encodeURI 对于字母和属于 URL 的字符不进行编码<br>但是 encodeURIComponent 会对属于 URL 的字符也进行编码<br><strong>例如这些字符</strong><code>-_.!~*&#39;()</code></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code class="hljs undefined">var <span class="hljs-built_in">str</span>=<span class="hljs-string">"http://lxl520.com/程序"</span>;console.<span class="hljs-built_in">log</span>(<span class="hljs-string">"我是初始字符串"</span>+<span class="hljs-built_in">str</span>);</code></pre><p><em>我是初始字符串<a href="http://lxl520.com/程序" target="_blank" rel="noopener">http://lxl520.com/程序</a></em></p><pre><code class="hljs undefined"><span class="hljs-keyword">var</span> str2=<span class="hljs-built_in">encodeURI</span>(str);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"我是经过encodeURI编码的："</span>+str2);</code></pre><p><em>我是经过 encodeURI 编码的：<a href="http://lxl520.com/%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">http://lxl520.com/%E7%A8%8B%E5%BA%8F</a></em></p><pre><code class="hljs undefined"><span class="hljs-keyword">var</span> str3=<span class="hljs-built_in">encodeURIComponent</span>(str);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"我是经过encodeURIComponent编码的："</span>+str3);</code></pre><p><em>我是经过 encodeURIComponent 编码的：http%3A%2F%2Flxl520.com%2F%E7%A8%8B%E5%BA%8F</em></p><pre><code class="hljs undefined"><span class="hljs-keyword">var</span> str2Decode=<span class="hljs-built_in">decodeURI</span>(str2);<span class="hljs-keyword">var</span> str3Decode=<span class="hljs-built_in">decodeURIComponent</span>(str3);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"我们是经过解码的字符串："</span>+str2Decode+<span class="hljs-string">"\n"</span>+str3Decode);</code></pre><p><em>我们是经过解码的字符串：<a href="http://lxl520.com/程序" target="_blank" rel="noopener">http://lxl520.com/程序</a><br><a href="http://lxl520.com/程序" target="_blank" rel="noopener">http://lxl520.com/程序</a></em></p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>URL编码<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"get"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入您要编码的字符串"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"urlEncode();"</span>&gt;</span>点击进行编码<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"urlDecode();"</span>&gt;</span>点击进行解码<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"output"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"输出框"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">      <span class="hljs-comment">/**       * <span class="hljs-doctag">@author <span class="hljs-variable">mohuishou</span></span>       * [test URL编码测试]       * <span class="hljs-doctag">@return <span class="hljs-type">&#123;[type]&#125;</span> </span>[description]       */</span>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> str = <span class="hljs-string">"http://lxl520.com/程序"</span>;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"我是初始字符串"</span> + str);        <span class="hljs-keyword">var</span> str2 = <span class="hljs-built_in">encodeURI</span>(str);        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"我是经过encodeURI编码的："</span> + str2);        <span class="hljs-keyword">var</span> str3 = <span class="hljs-built_in">encodeURIComponent</span>(str);        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"我是经过encodeURIComponent编码的："</span> + str3);        <span class="hljs-keyword">var</span> str2Decode = <span class="hljs-built_in">decodeURI</span>(str2);        <span class="hljs-keyword">var</span> str3Decode = <span class="hljs-built_in">decodeURIComponent</span>(str3);        <span class="hljs-built_in">console</span>.log(          <span class="hljs-string">"我们是经过解码的字符串："</span> + str2Decode + <span class="hljs-string">"\n"</span> + str3Decode        );      &#125;      <span class="hljs-comment">/**       * <span class="hljs-doctag">@author <span class="hljs-variable">mohuishou</span></span>       * 更改输入的值，并将其输出       */</span>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">urlEncode</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> getVal = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"get"</span>).value; <span class="hljs-comment">//获取输入框的值</span>        <span class="hljs-keyword">var</span> strEncode = <span class="hljs-built_in">encodeURI</span>(getVal);        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"output"</span>).value = strEncode; <span class="hljs-comment">//将编码过后的值输出到输出框</span>      &#125;      <span class="hljs-comment">/**       * [urlDecode 解码函数，对进行解码]       * <span class="hljs-doctag">@return <span class="hljs-type">&#123;[type]&#125;</span> </span>[description]       */</span>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">urlDecode</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> getVal = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"get"</span>).value; <span class="hljs-comment">//获取输入框的值</span>        <span class="hljs-keyword">var</span> strDecode = <span class="hljs-built_in">decodeURI</span>(getVal);        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"output"</span>).value = strDecode;      &#125;    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59875.html">【福利】至善网媒体素材一键评价</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css中权重与优先级</title>
    <link href="/post/39494.html"/>
    <url>/post/39494.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天在写一个前端文件的时候发现有一个样式突然没有了作用，但是按照优先级来说应该后面的前面的才对。<br>然后研究了一下 css 当中的优先级到底是怎么回事，才发现原来都是权重的锅</p></blockquote><a id="more"></a><h3 id="选择器的权重"><a href="#选择器的权重" class="headerlink" title="选择器的权重"></a>选择器的权重</h3><blockquote><p>分为四个等级,权重值越大表示优先级别越高</p></blockquote><h4 id="权重表"><a href="#权重表" class="headerlink" title="权重表"></a>权重表</h4><table><thead><tr><th>选择器</th><th>例子</th><th>权重值</th></tr></thead><tbody><tr><td>内联样式</td><td><code>style=&#39;&#39;</code></td><td>1000</td></tr><tr><td>id 选择器</td><td><code>#title</code></td><td>100</td></tr><tr><td>类，伪类，属性选择器</td><td><code>.title，:hover ,a[href]</code></td><td>10</td></tr><tr><td>类型选择器，伪元素选择器</td><td><code>p, :before</code></td><td>1</td></tr><tr><td>通用选择器，子选择器和相邻同胞选择器</td><td><code>*,&gt;,+</code></td><td>0</td></tr></tbody></table><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p><strong>sytle</strong></p><pre><code class="hljs css"><span class="hljs-comment">/*权重=100+1=101*/</span><span class="hljs-selector-id">#title</span> <span class="hljs-selector-tag">h2</span> &#123;  <span class="hljs-attribute">color</span>: red;&#125;<span class="hljs-comment">/*权重=10+1=11*/</span><span class="hljs-selector-class">.content</span> <span class="hljs-selector-tag">h2</span> &#123;  <span class="hljs-attribute">color</span>: blue;&#125;<span class="hljs-comment">/*权重=100+1=101*/</span><span class="hljs-selector-id">#title</span> <span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">color</span>: orange;&#125;<span class="hljs-comment">/*权重=100+10=110*/</span><span class="hljs-selector-id">#title</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href]</span> &#123;  <span class="hljs-attribute">color</span>: green;&#125;</code></pre><p><strong>html</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"title"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:#333;"</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-comment">&lt;!--权重=1000--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://lxl520.com"</span>&gt;</span>lxl520<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>0...0<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141636.png" srcset="/img/loading.gif" alt></p><h3 id="层叠原理（或者说是就近原则）"><a href="#层叠原理（或者说是就近原则）" class="headerlink" title="层叠原理（或者说是就近原则）"></a>层叠原理（<em>或者说是就近原则</em>）</h3><p><strong>当两个样式的优先级一样时,会自动选择最近的一条样式</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">  <span class="hljs-selector-id">#title</span> &#123;    <span class="hljs-attribute">color</span>: red;  &#125;  <span class="hljs-selector-id">#title</span> &#123;    <span class="hljs-attribute">color</span>: blue;  &#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"title"</span>&gt;</span>我到底啥颜色<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141637.png" srcset="/img/loading.gif" alt></p><h3 id="例外（-important）"><a href="#例外（-important）" class="headerlink" title="例外（!important）"></a>例外（!important）</h3><p><strong>在属性的后面加上!important 可以用来提权，就好比直接获得管理员权限一样，这这个属性会变成最高优先级</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">  <span class="hljs-selector-tag">h2</span> &#123;    <span class="hljs-attribute">color</span>: red <span class="hljs-meta">!important</span>;  &#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:blue;"</span>&gt;</span>我想必应该是蓝色<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141638.png" srcset="/img/loading.gif" alt></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li><p><strong>一些不成文规则</strong></p><ul><li><strong>不要</strong>在全站范围的 css 中使用<code>!important</code>.</li><li><strong>只在</strong>需要覆盖全站范围的 css 或是外部 css（例如引用的 ExtJs 或是 YUI）的时候才在指定的页面上使用<code>!important</code>。</li><li><strong>不要</strong>在你的插件中使用<code>!important</code>。</li><li><strong>永远</strong>都要优先考虑使用样式规则的优先级来解决问题而不是<code>!important</code>。</li></ul></li><li><p>如果你和我一样遇到了似乎没有起作用的 CSS 规则，请试试在你的选择器中添加他的一个父元素的 ID，从而提高它的特殊性。看看能不能解决问题</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EmotionCamera</title>
    <link href="/post/16707.html"/>
    <url>/post/16707.html</url>
    
    <content type="html"><![CDATA[<h4 id="wiz_toc_0">简单实现逻辑</h4><ol><br><li>首先识别脸部</li><br><li>标识出关键点</li><br><li>通过一定的算法捕抓表情</li><br></ol><h4 id="wiz_toc_1">表情相机模块需要实现的任务</h4><ol><br><li>什么时候拍照？<br><br><em>需要确定一个阈值</em></li><br><li>导出一个静态库<br><br><em>ios和andriod</em><br><br><blockquote><br><p>补充，ios需要涉及到mac系统还有OC；andriod需要涉及到Linux，安卓方面导出的静态库是.a格式；动态库为.so格式</p><br></blockquote></li><br></ol><h4 id="wiz_toc_2">最近两周需要完成的任务</h4><blockquote><br><p>现在的时间：2015年11月1日 23:34:33<br><br>两周后需要达到的效果：使用安卓调用C++生成的.a文件</p><br></blockquote><h5 id="wiz_toc_3">需要搜索的一些东西：</h5><p></p><ol><p></p><li>C++静态库导出（ios/andriod）</li><br><li>静态vs动态库</li><br><li>object―C （ios）</li><br><li>makefile&amp;modify Macro</li><br><li>能不能直接在一个环境下同时导出ios和安卓需要的库</li></ol>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>phpstrom10激活方法（JetBrains系列软件激活）</title>
    <link href="/post/28397.html"/>
    <url>/post/28397.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>找到一个 JetBrains 系列软件的注册服务器</p></blockquote><p><strong>注册时选择“License server”输入“<a href="http://idea.lanyus.com/”点击“OK”快速激活JetBrains系列产品" target="_blank" rel="noopener">http://idea.lanyus.com/”点击“OK”快速激活JetBrains系列产品</a></strong></p><p>也可以<br><a href="http://idea.lanyus.com/" target="_blank" rel="noopener">点击进入计算注册码</a></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/18280.html">四川大学锐捷windows解除多网卡限制</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>破解</tag>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NDK开发中无法访问android.support.v7.app.AppCompatActivity解决办法</title>
    <link href="/post/64902.html"/>
    <url>/post/64902.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>错误详情：<br>错误: 无法访问 android.support.v7.app.AppCompatActivity<br>找不到 android.support.v7.app.AppCompatActivity 的类文件</p></blockquote><p>为了这个问题纠结 2 天了，在网上找了很多的解决办法都不行，几乎所有的办法都试过了</p><p>无意中查看 sdk Manager 的时候发现我的<strong>“android support library”</strong>没有安装，然后当即安装上去</p><p>随后执行：</p><pre><code class="hljs undefined">javah -d jni -classpath   F:<span class="hljs-symbol">\S</span>oftInstall<span class="hljs-symbol">\A</span>ndroid<span class="hljs-symbol">\s</span>dk<span class="hljs-symbol">\p</span>latforms<span class="hljs-symbol">\a</span>ndroid-23<span class="hljs-symbol">\a</span>ndroid.jar;F:<span class="hljs-symbol">\S</span>oftInstall<span class="hljs-symbol">\a</span>ndroid<span class="hljs-symbol">\s</span>dk<span class="hljs-symbol">\e</span>xtras<span class="hljs-symbol">\a</span>ndroid<span class="hljs-symbol">\s</span>upport<span class="hljs-symbol">\v</span>4<span class="hljs-symbol">\a</span>ndroid-support-v4.jar;F:<span class="hljs-symbol">\S</span>oftInstall<span class="hljs-symbol">\a</span>ndroid<span class="hljs-symbol">\s</span>dk<span class="hljs-symbol">\e</span>xtras<span class="hljs-symbol">\a</span>ndroid<span class="hljs-symbol">\s</span>upport<span class="hljs-symbol">\v</span>7<span class="hljs-symbol">\a</span>ppcompat<span class="hljs-symbol">\l</span>ibs<span class="hljs-symbol">\a</span>ndroid-support-v7-appcompat.jar;..<span class="hljs-symbol">\.</span>.<span class="hljs-symbol">\b</span>uild<span class="hljs-symbol">\i</span>ntermediates<span class="hljs-symbol">\c</span>lasses<span class="hljs-symbol">\d</span>ebug com.lxl520.demo3.MainActivity</code></pre><p>即可</p><p><strong>注意：</strong><br>如果发现你的 sdk 文件夹下面没有<strong>sdk\extras\android\support**<br>这个文件夹的时候一定要检查一下你的</strong>“android support library”**是否安装，<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141647.png" srcset="/img/loading.gif" alt></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/34934.html">appcan利用天翼rtc实现视频通话功能</a></li><li><a href="https://lailin.xyz/post/35791.html">使用MITAPPInventor2web客户端组件保存数据至云端</a></li><li><a href="https://lailin.xyz/post/23045.html">如何使用MITAPPInventor2快速创建一个蓝牙串口app</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>app</tag>
      
      <tag>ndk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>phpsocket连接，UDP</title>
    <link href="/post/19867.html"/>
    <url>/post/19867.html</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs php">&lt;meta charset=<span class="hljs-string">"utf-8"</span>&gt;<span class="hljs-meta">&lt;?php</span><span class="hljs-comment">//服务器信息</span>$server = <span class="hljs-string">'udp://192.168.253.1:9998'</span>;<span class="hljs-comment">//消息结束符号</span>$msg_eof = <span class="hljs-string">"\n"</span>;$socket = stream_socket_server($server, $errno, $errstr, STREAM_SERVER_BIND);<span class="hljs-keyword">if</span> (!$socket) &#123;<span class="hljs-keyword">die</span>(<span class="hljs-string">"$errstr ($errno)"</span>);&#125;<span class="hljs-keyword">do</span> &#123;<span class="hljs-comment">//接收客户端发来的信息</span>$inMsg = stream_socket_recvfrom($socket, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, $peer);<span class="hljs-comment">//服务端打印出相关信息</span><span class="hljs-keyword">echo</span> <span class="hljs-string">"Client : $peer\n"</span>;<span class="hljs-keyword">echo</span> <span class="hljs-string">"Receive : &#123;$inMsg&#125;"</span>;<span class="hljs-comment">//给客户端发送信息</span>$outMsg = substr($inMsg, <span class="hljs-number">0</span>, (strrpos($inMsg, $msg_eof))).<span class="hljs-string">' -- '</span>.date(<span class="hljs-string">"D M j H:i:s Y\r\n"</span>);stream_socket_sendto($socket, $outMsg, <span class="hljs-number">0</span>, $peer);&#125; <span class="hljs-keyword">while</span> ($inMsg !== <span class="hljs-keyword">false</span>);<span class="hljs-meta">?&gt;</span></code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>socket</tag>
      
      <tag>udp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>appcan利用天翼rtc实现视频通话功能</title>
    <link href="/post/34934.html"/>
    <url>/post/34934.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本代码是在示例代码的基础上进行了一些简化，并将其单独做了一个 vedio.js 文件，只需要两个按钮，即可完成接听和拨打的需求</p></blockquote><p><strong>attention：</strong></p><ol><li>默认将用户名设置成 1234，拨打的帐号设置成 4321，如果需要使用一个 app 实现的话，具体逻辑自行修改</li></ol><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs javascript"><span class="hljs-comment">/** * 视频功能实现 * 使用天翼rtc插件实现 */</span><span class="hljs-comment">/** * 初始化，在页面初始化方法中调用这个函数 * 定义天翼rtc回调函数 * 同一个页面中  appcan.ready可以存在多个，不会冲突;而uexOnload不行... */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rtcInit</span>(<span class="hljs-params"></span>) </span>&#123;  uexESurfingRtc.onGlobalStatus = upgateGlobalStatus; <span class="hljs-comment">//全局监控</span>  uexESurfingRtc.cbLogStatus = upgateLogStatus; <span class="hljs-comment">//登陆回调</span>  uexESurfingRtc.cbCallStatus = updateCallStatus; <span class="hljs-comment">//呼叫回调</span>  <span class="hljs-comment">//uexESurfingRtc.cbRemotePicPath = showRemotePicPath;//截屏回调</span>  <span class="hljs-comment">/*----------配置天翼rtc插件的appkey &amp; appid---------*/</span>  appId = <span class="hljs-string">"70392"</span>;  appKey = uexESurfingRtc.setAppKeyAndAppId(appKey, appId); <span class="hljs-comment">//输入你自己的appKey;</span>&#125;<span class="hljs-comment">/** * 登陆回调，返回是否登陆成功 */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upgateLogStatus</span>(<span class="hljs-params">opCode, dataType, data</span>) </span>&#123;  <span class="hljs-comment">//alert(data);</span>  <span class="hljs-keyword">if</span> (<span class="hljs-string">"OK"</span> == data.substring(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) &#123;    <span class="hljs-keyword">var</span> status = data.split(<span class="hljs-string">"OK:"</span>)[<span class="hljs-number">1</span>];    <span class="hljs-keyword">var</span> showStr = <span class="hljs-string">""</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-string">"LOGIN"</span> == status) &#123;      showStr = <span class="hljs-string">"登陆成功，点击退出"</span>;      $(<span class="hljs-string">"#login"</span>).attr(<span class="hljs-string">"name"</span>, <span class="hljs-string">"logout"</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"LOGOUT"</span> == status) &#123;      showStr = <span class="hljs-string">"登陆"</span>;      $(<span class="hljs-string">"#login"</span>).attr(<span class="hljs-string">"name"</span>, <span class="hljs-string">"login"</span>);    &#125;    $(<span class="hljs-string">"#login"</span>).text(showStr);  &#125; <span class="hljs-keyword">else</span> &#123;    alert(data);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCallStatus</span>(<span class="hljs-params">opCode, dataType, data</span>) </span>&#123;  alert(data);  <span class="hljs-keyword">if</span> (<span class="hljs-string">"OK"</span> == data.substring(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) &#123;    <span class="hljs-keyword">var</span> status = data.split(<span class="hljs-string">"OK:"</span>)[<span class="hljs-number">1</span>];    <span class="hljs-keyword">var</span> showStr = <span class="hljs-string">""</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-string">"NORMAL"</span> == status) &#123;      showStr = <span class="hljs-string">"call"</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"INCOMING"</span> == status) &#123;      showStr = <span class="hljs-string">"accept"</span>;    &#125;    <span class="hljs-comment">// else if("CALLING" == status)</span>    <span class="hljs-comment">// &#123;</span>    <span class="hljs-comment">//     showStr = "Calling";</span>    <span class="hljs-comment">// &#125;</span>    $(<span class="hljs-string">"#call"</span>).attr(<span class="hljs-string">"name"</span>, showStr);    $(<span class="hljs-string">"#call"</span>).text(showStr);  &#125; <span class="hljs-keyword">else</span> &#123;    alert(data);  &#125;&#125;<span class="hljs-comment">/** *监控中心回调 */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upgateGlobalStatus</span>(<span class="hljs-params">opCode, dataType, data</span>) </span>&#123;  $(<span class="hljs-string">"#content"</span>).append(data);&#125;<span class="hljs-comment">/** * 登陆方法的实现 * */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">login</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// alert(123);</span>  <span class="hljs-comment">/*--设置登陆的配置，分别是本地窗口和对方视频窗口的大小----*/</span>  jsonViewConfig = &#123;    <span class="hljs-attr">localView</span>: &#123;      <span class="hljs-attr">x</span>: <span class="hljs-string">"10"</span>,      <span class="hljs-attr">y</span>: <span class="hljs-string">"800"</span>,      <span class="hljs-attr">w</span>: <span class="hljs-string">"432"</span>,      <span class="hljs-attr">h</span>: <span class="hljs-string">"528"</span>,    &#125;,    <span class="hljs-attr">remoteView</span>: &#123;      <span class="hljs-attr">x</span>: <span class="hljs-string">"440"</span>,      <span class="hljs-attr">y</span>: <span class="hljs-string">"800"</span>,      <span class="hljs-attr">w</span>: <span class="hljs-string">"432"</span>,      <span class="hljs-attr">h</span>: <span class="hljs-string">"528"</span>,    &#125;,  &#125;;  <span class="hljs-comment">/*---这里默认设置一个用户名用于调试，后期用户登录之后直接自动生成---*/</span>  userName = <span class="hljs-string">"1234"</span>;  <span class="hljs-comment">/*--uexESurfingRtc.login函数需要传入的参数是一个json字符串，所以需要调用JSON.stringify方法将json对象转换为字符串--*/</span>  jsonDtr = <span class="hljs-built_in">JSON</span>.stringify(jsonViewConfig);  uexESurfingRtc.login(jsonDtr, userName);&#125;<span class="hljs-comment">/** * 退出登录 * <span class="hljs-doctag">@return <span class="hljs-type">&#123;[type]&#125;</span> </span>[description] */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logout</span>(<span class="hljs-params"></span>) </span>&#123;  uexESurfingRtc.logout();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">call</span>(<span class="hljs-params"></span>) </span>&#123;  uexESurfingRtc.call(<span class="hljs-string">"3"</span>, <span class="hljs-string">"4321"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accept</span>(<span class="hljs-params"></span>) </span>&#123;  uexESurfingRtc.acceptCall(<span class="hljs-string">"3"</span>);&#125;<span class="hljs-comment">/** *登陆按钮 *点击之后直接视频登陆 */</span>appcan.button(<span class="hljs-string">"#login"</span>, <span class="hljs-string">"ani-act"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> btnName = $(<span class="hljs-string">"#login"</span>).attr(<span class="hljs-string">"name"</span>);  <span class="hljs-keyword">if</span> (btnName == <span class="hljs-string">"login"</span>) &#123;    $(<span class="hljs-string">"#login"</span>).text(<span class="hljs-string">"登陆中，请稍候..."</span>);    login();  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((btnName = <span class="hljs-string">"logout"</span>)) &#123;    $(<span class="hljs-string">"#login"</span>).text(<span class="hljs-string">"退出中，请稍候..."</span>);    logout();  &#125;&#125;);<span class="hljs-comment">/** * 呼叫按钮 */</span>appcan.button(<span class="hljs-string">"#call"</span>, <span class="hljs-string">"ani-act"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> btnName = $(<span class="hljs-string">"#call"</span>).attr(<span class="hljs-string">"name"</span>);  <span class="hljs-keyword">if</span> (btnName == <span class="hljs-string">"call"</span>) &#123;    $(<span class="hljs-string">"#call"</span>).text(<span class="hljs-string">"呼叫中，请稍候..."</span>);    call();  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((btnName = <span class="hljs-string">"accept"</span>)) &#123;    $(<span class="hljs-string">"#call"</span>).text(<span class="hljs-string">"接听中，请稍候..."</span>);    accept();  &#125;&#125;);</code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/64902.html">NDK开发中无法访问android.support.v7.app.AppCompatActivity解决办法</a></li><li><a href="https://lailin.xyz/post/35791.html">使用MITAPPInventor2web客户端组件保存数据至云端</a></li><li><a href="https://lailin.xyz/post/23045.html">如何使用MITAPPInventor2快速创建一个蓝牙串口app</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>app</tag>
      
      <tag>appcan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java中字符串相等的判断</title>
    <link href="/post/62897.html"/>
    <url>/post/62897.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天需要写一个 Java 的小程序需要判断一下从控制台输入的字符串是否相等，在使用的过程中发现直接使用“==”来判断是没有办法判断出来的，Google&amp;百度了一下，找到一个解决办法</p></blockquote><h4 id="1-用“-”运算符，该运算符表示指向字符串的引用是否相同"><a href="#1-用“-”运算符，该运算符表示指向字符串的引用是否相同" class="headerlink" title="1. 用“==”运算符，该运算符表示指向字符串的引用是否相同"></a>1. 用“==”运算符，该运算符表示指向字符串的引用是否相同</h4><p>比如说：</p><pre><code class="hljs java">String a=<span class="hljs-string">"abc"</span>;String b=<span class="hljs-string">"abc"</span>;a==b;<span class="hljs-comment">//将返回true。</span><span class="hljs-comment">/*这是因为在java中字符串的值是不可改变的，相同的字符串在内存中只会存一份，所以a和b指向的是同一个对象*/</span></code></pre><p>再比如：</p><pre><code class="hljs java">String a=<span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);String b=<span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);<span class="hljs-comment">//那么a==b将返回false，因为a和b指向不同的对象。</span></code></pre><p>用 scanner 类获取字符串来比较的时候：</p><pre><code class="hljs java">Scanner input=<span class="hljs-keyword">new</span> Scanner(System.in);<span class="hljs-comment">//新建input对象，用于实现输入功能</span>String a=<span class="hljs-string">"exit"</span>;<span class="hljs-comment">//定义一个字符串</span>System.out.println(<span class="hljs-string">"请输入您想输入的字符串："</span>);String get=input.nextLine();<span class="hljs-comment">//获取输入得的字符串的值</span><span class="hljs-keyword">if</span>(get==a)&#123;    System.out.println(a);&#125;<span class="hljs-comment">//这个时候没有输出值</span></code></pre><h4 id="2-用-equals-方法，该方法比较的是字符串的内容是否相同"><a href="#2-用-equals-方法，该方法比较的是字符串的内容是否相同" class="headerlink" title="2. 用 equals 方法，该方法比较的是字符串的内容是否相同"></a>2. 用 equals 方法，该方法比较的是字符串的内容是否相同</h4><p>比如：</p><pre><code class="hljs java">String a=<span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);String b=<span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);a.equals(b);<span class="hljs-comment">//将返回true。</span></code></pre><p><strong>所以通常情况下，为了避免出现上述问题，判断字符串是否相等使用 equals 方法。</strong></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/52826.html">java笔记1</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>office2016激活工具</title>
    <link href="/post/37989.html"/>
    <url>/post/37989.html</url>
    
    <content type="html"><![CDATA[<h4 id="可以用于激活-windows-office2010-2013-2016-全系列版本"><a href="#可以用于激活-windows-office2010-2013-2016-全系列版本" class="headerlink" title="可以用于激活 windows office2010/2013/2016 全系列版本"></a>可以用于激活 windows office2010/2013/2016 全系列版本</h4><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720151022110350.png" srcset="/img/loading.gif" alt="请输入图片描述"></p><p><strong>以管理员身份运行该软件即可</strong><br>30S 不到，你会发现你的 office 或者 windows 已经激活了，没有安装界面</p><p><a href="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/1198607745.rar" target="_blank" rel="noopener">软件下载</a></p><h3 id="ps-本软件收集于网络，这里仅作分享，请下载之后-24-小时之内删除，并且不得用于商业用途"><a href="#ps-本软件收集于网络，这里仅作分享，请下载之后-24-小时之内删除，并且不得用于商业用途" class="headerlink" title="ps:本软件收集于网络，这里仅作分享，请下载之后 24 小时之内删除，并且不得用于商业用途"></a><em>ps:本软件收集于网络，这里仅作分享，请下载之后 24 小时之内删除，并且不得用于商业用途</em></h3><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/18280.html">四川大学锐捷windows解除多网卡限制</a></li><li><a href="https://lailin.xyz/post/28397.html">phpstrom10激活方法（JetBrains系列软件激活）</a></li><li><a href="https://lailin.xyz/post/19314.html">phpstrom9可用注册码一枚</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>破解</tag>
      
      <tag>软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用MITAPPInventor2web客户端组件保存数据至云端</title>
    <link href="/post/35791.html"/>
    <url>/post/35791.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>接着前面的说，蓝牙接收到数据之后需要将数据处理分析然后保存下来，但是 AI2 并没有直接写代码来的方便快捷，并且我们的现在处于云计算的时代，数据无价，所以我们需要想办法将数据保存到云端。</p></blockquote><h4 id="数据保存到云端的方法："><a href="#数据保存到云端的方法：" class="headerlink" title="数据保存到云端的方法："></a>数据保存到云端的方法：</h4><ol><li>使用自带的网络微数据库</li><li>使用 web 客户端调用写好的后端接口上传数据</li></ol><blockquote><p>由于自带的网络微数据库是 Python 写的，而且对于数据库的接口有着严格限制，所以这里我才用我自己用 php+mysql 写的一个 api 来进行上传</p></blockquote><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>先看看用到的组件：主要是 web 客户端<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141639.jpg" srcset="/img/loading.gif" alt></li><li>组件的代码块:<ul><li>用于设置 web 客户端的网址<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141640.jpg" srcset="/img/loading.gif" alt></li><li>执行 get 请求<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141641.jpg" srcset="/img/loading.gif" alt></li><li>请求成功后返回操作<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141642.jpg" srcset="/img/loading.gif" alt><br>注意：这一个的话如果你设置了保存响应信息为 ture 就选择获得文件这个控制块，否则的话选择获得文字的控制块，我们使用获得文字的控制块</li></ul></li></ol><h4 id="逻辑控制图"><a href="#逻辑控制图" class="headerlink" title="逻辑控制图"></a>逻辑控制图</h4><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141643.jpg" srcset="/img/loading.gif" alt><br><em>我做的接口的返回值为 json 格式所以采用了 json 的解析，我暂时不需要判断返回值得内容【里面包含了上传是否成功之类的】，如果需要的话请参考有关 json 解析的相关内容</em></p><h4 id="推荐参考手册"><a href="#推荐参考手册" class="headerlink" title="推荐参考手册"></a>推荐参考手册</h4><ol><li>感谢@老巫婆翻译的参考手册，这里分享给大家：<a href="http://www.17coding.net/reference/" target="_blank" rel="noopener">AI2 中文参考手册</a></li><li><a href="http://blog.sina.com.cn/s/blog_62218b990102vhmo.html" target="_blank" rel="noopener">@老巫婆的 json 解析教程</a></li><li><a href="http://i.youku.com/u/UNTc5MzY3NTYw/playlists" target="_blank" rel="noopener">AI2 视频教程</a>不得不吐槽这个教程的清晰度</li></ol><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/64902.html">NDK开发中无法访问android.support.v7.app.AppCompatActivity解决办法</a></li><li><a href="https://lailin.xyz/post/34934.html">appcan利用天翼rtc实现视频通话功能</a></li><li><a href="https://lailin.xyz/post/23045.html">如何使用MITAPPInventor2快速创建一个蓝牙串口app</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>app</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php如何实现整除</title>
    <link href="/post/28942.html"/>
    <url>/post/28942.html</url>
    
    <content type="html"><![CDATA[<h3 id="php-如何实现整除"><a href="#php-如何实现整除" class="headerlink" title="php 如何实现整除"></a>php 如何实现整除</h3><blockquote><p>以前在用 C/C++的时候，整除就是’/‘，还要特别注意这个问题，今天用到 php 调试的时候出错了，最后发现：在 php 中’/‘除法是默认带有小数部分的，php 自带有几个函数可以对小数进行处理</p></blockquote><h4 id="1-round-函数，四舍五入"><a href="#1-round-函数，四舍五入" class="headerlink" title="1. round()函数，四舍五入"></a>1. round()函数，四舍五入</h4><pre><code>&lt;?php echo round(7/3); //2 ?&gt;</code></pre><h4 id="2-ceil-函数，进一法"><a href="#2-ceil-函数，进一法" class="headerlink" title="2. ceil()函数，进一法"></a>2. ceil()函数，进一法</h4><p><em>也就是取比该数大的最小整数</em></p><pre><code>&lt;?php echo ceil(7/3); //3 ?&gt;</code></pre><h4 id="3-floor-函数，舍一法"><a href="#3-floor-函数，舍一法" class="headerlink" title="3. floor()函数，舍一法"></a>3. floor()函数，舍一法</h4><p><em>也就是取比该数小的最大整数</em></p><p>&lt;?php echo floor(7/3); //2?&gt;</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/go-training-week3-data-race.html">Week03: Go并发编程(三) data race</a></li><li><a href="https://lailin.xyz/post/go-training-week3-go-memory-model.html">Week03: Go并发编程(二) Go 内存模型</a></li><li><a href="https://lailin.xyz/post/go-training-week3-goroutine.html">Week03: Go并发编程(一) goroutine</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>phpstrom9可用注册码一枚</title>
    <link href="/post/19314.html"/>
    <url>/post/19314.html</url>
    
    <content type="html"><![CDATA[<h4 id="phpstrom9-可用注册码一枚"><a href="#phpstrom9-可用注册码一枚" class="headerlink" title="phpstrom9 可用注册码一枚"></a>phpstrom9 可用注册码一枚</h4><p><strong>username</strong></p><pre><code>EMBRACE</code></pre><p><strong>key</strong></p><pre><code class="hljs undefined"><span class="hljs-section">===== LICENSE BEGIN =====</span>43136-1204201000002UsvSON704l"dILe1PVx3y4"B349AU6oSDJrsjE8nMOQh"8HTDJHIUUhgd1BebYc5U"6OxDbVsALB4Eb10PW8"<span class="hljs-section">===== LICENSE END =====</span></code></pre><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/18280.html">四川大学锐捷windows解除多网卡限制</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>破解</tag>
      
      <tag>php</tag>
      
      <tag>注册码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【福利】至善网媒体素材一键评价</title>
    <link href="/post/59875.html"/>
    <url>/post/59875.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近做至善网上面的题时候，发现媒体素材需要一个一个的评价实在是有点烦；所以开挂写了一个 JS 的小插件，直接一次性搞定</p></blockquote><p><strong>方法一：直接将下面这个链接拖入书签栏，然后在你需要一件评价媒体素材的地方点击就好</strong><br><em>ps:毛概测试成功，其他的请自测</em></p><p><a href="javascript:(function(){function sleep(d){for(var t=Date.now();Date.now()-t<=d;){}}function getNum(text){var value=text.replace(/[^0-9]/ig,"");return value}var obj=$("p[href="+"\"javascript:;\""+"]").each(function(){var name=$(this).attr("name");name=getNum(name);parent.showMediaRight(name);wkMediaPj(name,3);var btn1=$(".aui_state_highlight");btn1.click();sleep(1000)})})();" target="_blank" rel="noopener">至善网媒体素材一键评价</a></p><p><em>有什么问题直接在评论问就好</em></p><p><strong>更新，附赠一个毛概的答案</strong><br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141644.jpg" srcset="/img/loading.gif" alt></p><p><strong>毛概答案补充：中间有一个问号，那道题的答案是：一个中心，两个基本的</strong><br><strong>注：这是毛概上的答案</strong></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/62847.html">js编码解码URL</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用MITAPPInventor2快速创建一个蓝牙串口app</title>
    <link href="/post/23045.html"/>
    <url>/post/23045.html</url>
    
    <content type="html"><![CDATA[<h3 id="如何使用-MIT-APP-Inventor2-快速创建一个蓝牙串口-app"><a href="#如何使用-MIT-APP-Inventor2-快速创建一个蓝牙串口-app" class="headerlink" title="如何使用 MIT APP Inventor2 快速创建一个蓝牙串口 app"></a>如何使用 MIT APP Inventor2 快速创建一个蓝牙串口 app</h3><hr><blockquote><p>最近做学校的一个比赛，我是平时是学习做 web 后端的，有时候捎带一些前端的东西，但是最近这个比赛需要做一个 app，问题来了，没有学过 Java 没有学过 OC 所以 ios 和安卓都是无从下手，然后最后找了很多混合开发的工具，比如说 APPCAN，apicloud，hbuilder，wex5 等等，最后不是没有蓝牙串口的插件，就是没有办法使用.最终在一次搜索中无意的发现了这个 AI2.</p></blockquote><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><hr><p><strong>1. 使用 AI2 的前提条件：</strong></p><ul><li>不要求界面的美观性，需要实用性</li><li>不会原生代码的编程</li></ul><p><strong>2. 使用 AI2 好处：</strong></p><ul><li>不要求你会写代码，图形化编程，简单易用</li><li>提供了很多模块一般做一个常用的 app 完全没有问题</li><li>有中文版，所以说语言障碍也不存在了</li></ul><p><strong>3. 使用 AI2 的几种方式：</strong></p><ul><li>离线安装，离线调试</li><li>在线使用，AI 伴侣调试（模拟器调试）<br><em>个人推荐第二种，在线使用，AI 伴侣调试</em></li></ul><p><strong>4. AI2 的中文网址：</strong></p><ul><li>最新的中文服务器：<a href="http://app.gzjkw.net/" target="_blank" rel="noopener">http://app.gzjkw.net/</a></li><li>中文教程网站：<a href="http://www.17coding.net/" target="_blank" rel="noopener">http://www.17coding.net/</a></li></ul><h4 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h4><blockquote><p>PS:仅仅是自己的一些经验观点，有什么错误大家交流啊</p></blockquote><hr><h5 id="1-点击进入-http-app-gzjkw-net-，-注册帐号之后，进入以下页面"><a href="#1-点击进入-http-app-gzjkw-net-，-注册帐号之后，进入以下页面" class="headerlink" title="1. 点击进入 http://app.gzjkw.net/， 注册帐号之后，进入以下页面"></a>1. 点击进入 <a href="http://app.gzjkw.net/" target="_blank" rel="noopener">http://app.gzjkw.net/</a>， 注册帐号之后，进入以下页面</h5><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/blogQQ图片20151015130813.png" srcset="/img/loading.gif" alt="点击查看大图"></p><h5 id="2-选择上面的帮助下载AI-伴侣apk，之后用于在线调试"><a href="#2-选择上面的帮助下载AI-伴侣apk，之后用于在线调试" class="headerlink" title="2. 选择上面的帮助下载AI 伴侣apk，之后用于在线调试"></a>2. 选择上面的帮助下载<strong>AI 伴侣</strong>apk，之后用于在线调试</h5><ul><li>或者直接点击 <a href="http://app.gzjkw.net/companions/MITAI2Companion.apk" title="AI伴侣" target="_blank" rel="noopener">AI 伴侣</a> 下载</li></ul><h5 id="3-简单的功能介绍"><a href="#3-简单的功能介绍" class="headerlink" title="3. 简单的功能介绍"></a>3. 简单的功能介绍</h5><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/blogQQ图片20151015131926.png" srcset="/img/loading.gif" alt="点击查看大图"></p><ul><li><strong>其中我们需要用到的几个组件：</strong></li></ul><table><thead><tr><th>名称</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>蓝牙客户端 1</td><td style="text-align:center">用于接收蓝牙串口设备的消息</td></tr><tr><td>按钮</td><td style="text-align:center">一般的 button</td></tr><tr><td>水平布局</td><td style="text-align:center">用于布局整个界面</td></tr><tr><td>对话框</td><td style="text-align:center">用于发出提示消息</td></tr><tr><td>activity 控制器</td><td style="text-align:center">用于打开蓝牙</td></tr><tr><td>web 客户端</td><td style="text-align:center">用于链接网络相关的东西（这个下一次用到）</td></tr><tr><td>计时器</td><td style="text-align:center">用于定时接收蓝牙串口发送出来的消息</td></tr></tbody></table><ul><li><strong>具体的常用组件的介绍，请大家点击网站查看<a href="http://www.17coding.net/" target="_blank" rel="noopener">http://www.17coding.net/</a></strong></li></ul><h5 id="4-逻辑设置"><a href="#4-逻辑设置" class="headerlink" title="4. 逻辑设置"></a>4. 逻辑设置</h5><ul><li>首先完成界面的一个界面的布局工作<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/blogQQ图片20151015170129.png" srcset="/img/loading.gif" alt="点击查看大图"></li><li><p>组件的逻辑设置【点击右上角的逻辑设计即可】<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/blogQQ图片20151015170447.png" srcset="/img/loading.gif" alt="点击查看大图"></p></li><li><p>其中将 activity 启动器 1 的 action 值设置为<strong>android.bluetooth.adapter.action.REQUEST_ENABLE</strong> ，这样可以达到开启蓝牙的效果</p></li></ul><h3 id="下一篇讲如何将数据保存到服务器（不使用自带的网络数据库的情况下）"><a href="#下一篇讲如何将数据保存到服务器（不使用自带的网络数据库的情况下）" class="headerlink" title="下一篇讲如何将数据保存到服务器（不使用自带的网络数据库的情况下）"></a><em>下一篇讲如何将数据保存到服务器（不使用自带的网络数据库的情况下）</em></h3><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/64902.html">NDK开发中无法访问android.support.v7.app.AppCompatActivity解决办法</a></li><li><a href="https://lailin.xyz/post/34934.html">appcan利用天翼rtc实现视频通话功能</a></li><li><a href="https://lailin.xyz/post/35791.html">使用MITAPPInventor2web客户端组件保存数据至云端</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>app</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreThink图片轮播插件【ImageSlider】</title>
    <link href="/post/15278.html"/>
    <url>/post/15278.html</url>
    
    <content type="html"><![CDATA[<p>移植于 OT 插件，原文地址<a href="http://www.topthink.com/topic/6244.html" target="_blank" rel="noopener">http://www.topthink.com/topic/6244.html</a></p><p>1、支持 unslider\flexslider 切换选择</p><p>2、支持推荐位选择</p><p>3、支持多图</p><p>4、切换时间&amp;方向选择</p><p>5、自定义容器宽度&amp;高度</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141646.png" srcset="/img/loading.gif" alt></p><p><strong><em>**</em></strong>*<strong><em>**</em></strong>使用说明<strong><em>**</em></strong>***<strong><em>**</em></strong><br>1、请先将下面这段代码复制到 Application\common\controller\addon.class.php</p><pre><code>/* 获取件所需的钩子是否存在，没有则新增   * @param string $str  钩子名称   * @param string $addons  插件名称   * @param string $addons  件简介   */ public function existHook($str, $addons, $msg=&apos;&apos;){       $hook_mod = M(&apos;addon_hook&apos;); $where[&apos;name&apos;] = $str;       $gethook = $hook_mod-&gt;where($where)-&gt;find();       if(!$gethook || empty($gethook) || !is_array($gethook)){           $data[&apos;name&apos;] = $str; $data[&apos;description&apos;] = $msg; $data[&apos;type&apos;] = 1;           $data[&apos;update_time&apos;] = NOW_TIME; $data[&apos;addons&apos;] = $addons;           if( false !== $hook_mod-&gt;create($data) ){               $hook_mod-&gt;add();           }       }   }   /**    * delete钩子    * @param string $hook  钩子名称    */   public function deleteHook($hook){       $model = M(&apos;addon_hook&apos;);       $condition = array( &apos;name&apos; =&gt; $hook, );       $model-&gt;where($condition)-&gt;delete();   }</code></pre><p>2、调用方法</p><pre><code class="hljs undefined">&#123;<span class="hljs-symbol">:hook</span>(<span class="hljs-name">'ImageSlider'</span>)&#125;</code></pre><p>3、如果出现显示不出图片，路径错误的情况</p><p>请改一下那个 unslider\flexslider.html 的图片路径，因为安装的路径不同可能出现意外</p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>corethink</tag>
      
      <tag>插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Corethink瀑布流插件</title>
    <link href="/post/54589.html"/>
    <url>/post/54589.html</url>
    
    <content type="html"><![CDATA[<h2 id="【原创插件】瀑布流"><a href="#【原创插件】瀑布流" class="headerlink" title="【原创插件】瀑布流"></a>【原创插件】瀑布流</h2><h3 id="1、前台界面"><a href="#1、前台界面" class="headerlink" title="1、前台界面"></a>1、前台界面</h3><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141648.png" srcset="/img/loading.gif" alt></p><h3 id="2、前台大图预览"><a href="#2、前台大图预览" class="headerlink" title="2、前台大图预览"></a>2、前台大图预览</h3><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141649.png" srcset="/img/loading.gif" alt></p><h3 id="3、后台设置"><a href="#3、后台设置" class="headerlink" title="3、后台设置"></a>3、后台设置</h3><p>支持容器宽度自定义，高度随宽度按比例改变</p><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141650.png" srcset="/img/loading.gif" alt></p><h3 id="4、后台管理界面"><a href="#4、后台管理界面" class="headerlink" title="4、后台管理界面"></a>4、后台管理界面</h3><p>作者，内容为选填项，其余为必填项<br><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141651.png" srcset="/img/loading.gif" alt></p><h3 id="5、新增界面"><a href="#5、新增界面" class="headerlink" title="5、新增界面"></a>5、新增界面</h3><p><img src="https://me-blog.oss-cn-shenzhen.aliyuncs.com/img/2018-12-03-141653.png" srcset="/img/loading.gif" alt></p><p><strong>**</strong>***<strong>**</strong>使用说明<strong><strong><em>**</em></strong></strong>****<strong><strong><em>**</em></strong></strong><br>1、前台调用</p><pre><code>钩子{:hook(&apos;WaterFall&apos;)}</code></pre><p>2、安装说明</p><p>如果默认表前缀不是 ct<em>，请在插件目录下 WaterFallAddon.class.php 中的 ct</em>改为你的表前缀</p><pre><code>-&gt;where(&apos;ct_addon_waterfall.status=1&apos;)</code></pre><p>3、安装说明 2<br>如果不能安装是不存在钩子原因，解决办法请看我上一个 OT 移植插件 ImageSlider 中的使用方法</p><p><a href="http://lxl520.com/me/blog/index.php/archives/6/" target="_blank" rel="noopener">ImageSlider</a></p><p>ps：</p><p><a href="http://www.cnblogs.com/sanshi/p/3237429.html" target="_blank" rel="noopener">感谢三生石上的前端瀑布流教程</a></p><div><h2 id="相关推荐">相关推荐</h2><ul><li><a href="https://lailin.xyz/post/59080.html">一键迁移typecho到hexo</a></li><li><a href="https://lailin.xyz/post/43893.html">php设计模式（一）工厂模式</a></li><li><a href="https://lailin.xyz/post/13242.html">迁移laravel框架项目到虚拟主机</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>corethink</tag>
      
      <tag>插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
