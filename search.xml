<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker镜像瘦身&优化]]></title>
    <url>%2Fpost%2Fnotes%2Fdocker%E9%95%9C%E5%83%8F%E7%98%A6%E8%BA%AB%2F</url>
    <content type="text"><![CDATA[为什么在存储如此便宜的今天我们仍然需要对 Docker 镜像进行瘦身? PS: 本文篇幅较长，请酌情观看 小镜像的优点 加速构建/部署 虽然存储资源较为廉价，但是网络 IO 是有限的，在带宽有限的情况下，部署一个 1G 的镜像和 10M 的镜像带来的时间差距可能就是分钟级和秒级的差距。特别是在出现故障，服务被调度到其他节点时，这个时间尤为宝贵。 提高安全性，减少攻击面积 越小的镜像表示无用的程序越少，可以大大的减少被攻击的目标 减少存储开销 小镜像的制作原则 选用最小的基础镜像 减少层，去除非必要的文件 在实际制作镜像的过程中，一味的合并层不可取，需要学会充分的利用 Docker 的缓存机制，提取公共层，加速构建。 依赖文件和实际的代码文件单独分层 团队/公司采用公共的基础镜像等 使用多阶段构建 往往我们在构建阶段和实际运行阶段需要的依赖环境是不同的，例如golang编写的程序实际运行的时候仅仅需要一个二进制文件即可，对于Node来说，可能最后运行的只是一些打包之后的js文件而不需要包含node_modules里成千上万的依赖 基础镜像 distroless “Distroless” images contain only your application and its runtime dependencies. They do not contain package managers, shells or any other programs you would expect to find in a standard Linux distribution. distroless是 Google 推出的一个仅仅包含运行时环境，不包含包管理器，shell等其他程序。如果你的程序没有其他依赖的话，这是一个不错的选择 alpine Alpine Linux is a security-oriented, lightweight Linux distribution based on musl libc and busybox. alpine 是一个基于musl, busybox的安全的linux发行版。麻雀虽小五脏俱全，虽然不到 10M, 但是包含了一个包管理器和shell环境，这在我们实际的使用调试当中将非常有用。 但是请注意，由于alpine使用了更小的muslc替代glibc，会导致某些应用无法使用，需要重新编译 scratch scratch 是空白镜像，一般用于基础镜像构建，例如alpine镜像的dockerfile便是从scratch开始的 123FROM scratchADD alpine-minirootfs-20190228-x86_64.tar.gz /CMD ["/bin/sh"] busybox 一般而言，distroless相对会更加的安全，但是在实际使用的过程中可能会遇到添加依赖以及调试方面的问题，alpine更小，自带包管理器，更加贴合使用习惯，但是muslc可能会带来兼容性的问题，一般而言我会选择alpine作为基础镜像使用。 除此之外，在Docker Hub当中我们可以发现常用的Debian的镜像也会提供的只包含基础功能的小镜像 基础镜像对比此处直接拉取基础镜像，查看镜像大小， 通过观察我们可以发现，alpine只有 5M 左右为debian的 20 分之一 12345alpine latest 5cb3aa00f899 3 weeks ago 5.53MBdebian latest 0af60a5c6dd0 3 weeks ago 101MBubuntu 18.04 47b19964fb50 7 weeks ago 88.1MBubuntu latest 47b19964fb50 7 weeks ago 88.1MBalpine 3.8 3f53bb00af94 3 months ago 4.41MB 似乎从上面看，感觉差距不大，实践中，不同语言的基础镜像都会提供一些采用不同基础镜像制作的 tag，下面我们以ruby的镜像为例，查看不同基础镜像的差异。可以看到默认的 latest 镜像881MB而alpine仅仅只有不到50MB这个差距就十分的可观了 123ruby latest a5d26127d8d0 4 weeks ago 881MBruby alpine 8d8f7d19d1fa 4 weeks ago 47.8MBruby slim 58dd4d3c99da 4 weeks ago 125MB 减少层，去除非必要的文件 删除文件不要跨行 123456789101112131415# dockerfile 1FROM alpineRUN wget https://github.com/mohuishou/scuplus-wechat/archive/1.0.0.zip &amp;&amp; rm 1.0.0.zip# dockerfile 2FROM alpineRUN wget https://github.com/mohuishou/scuplus-wechat/archive/1.0.0.zipRUN rm 1.0.0.zip# dockerfile 3FROM alpineRUN wget https://github.com/mohuishou/scuplus-wechat/archive/1.0.0.zip &amp;&amp; rm 1.0.0.zip 123test 3 351a80e99c22 5 seconds ago 5.53MBtest 2 ad27e625b8e5 49 seconds ago 6.1MBtest 1 165e2e0df1d3 About a minute ago 6.1MB 可以发现 1，2 两个大小一样，但是 3 小了 0.5MB，这是因为 docker 几乎每一行命令都会生成一个层，删除文件的时候：因为底下各层都是只读的，当需要删除这些层中的文件时，AUFS 使用 whiteout 机制，它的实现是通过在上层的可写的目录下建立对应的 whiteout 隐藏文件来实现的，所以在当前层去删除上一层的文件，只是会把这个文件隐藏掉罢了 使用单行命令 除了删除语句需要放在一行以外，由于层的机制，我们安装依赖的一些公共的语句最好也使用条RUN命令生成，减少最终的层数 分离依赖包，以及源代码程序，充分利用层的缓存 这是一个最佳实践，在实际的开发过程中，我们的依赖包往往是变动不大的，但是我们正在开发的源码的变动是较为频繁，如果我们实际的代码只有10M，但是依赖项有1G, 如果在COPY的时候直接COPY . .会导致每次修改代码都会时这一层的缓存失效，导致浪费复制以及推送到镜像仓库的时间，将 COPY 语句分开，每次 push 就可以只变更我们频繁修改的代码层，而不是连着依赖一起 使用.dockerignore 在使用Git时，我们可以通过.gitignore忽略文件，在 docker build 的时候也可以使用.dockerignore在 Docker 上下文中忽略文件，这样不仅可以减少一些非必要文件的导入，也可以提高安全性，避免将一些配置文件打包到镜像中 多阶段构建多阶段构建其实也是减少层的一种，通过多阶段构建，最终镜像可以仅包含最后生成的可执行文件，和必须的运行时依赖，大大减少镜像体积。 以GO语言为例，实际运行的过程中只需要最后编译生成的二进制文件即可，而GO语言本省以及扩展包，代码文件都是不必要的，但是我们在编译的时候这些依赖又是必须的，这时候就可以使用多阶段构建的方式，减少最终生成的镜像体积 1234567891011121314151617181920# 使用golang镜像作为builder镜像FROM golang:1.12 as builderWORKDIR /go/src/github.com/go/helloworld/COPY app.go .RUN go build -o app .# 编译完成之后使用alpine镜像作为最终的基础镜像FROM alpine:latest as prodRUN apk --no-cache add ca-certificatesWORKDIR /root/# 从builder中复制编译好的二进制文件COPY --from=builder /go/src/github.com/go/helloworld/app .CMD ["./app"] 由于本文篇幅较长，这里不对多阶段构建展开讲解，详情可以参考多阶段构建 奇淫技巧 使用dive查看 docker 镜像的层，可以帮助你分析减少镜像体积 使用docker-slim 可以自动帮助你减少镜像体积，对于 Web 应用较为有用 安装软件时去除依赖 12345678# ubuntuapt-get install -y — no-install-recommends#alpineapk add --no-cache &amp;&amp; apk del build-dependencies# centosyum install -y ... &amp;&amp; yum clean all 使用--flatten参数，减少层(不推荐) 使用docker-squash压缩层 不同语言的示例 添加中…… Ruby(Rails) 只安装生产所需的依赖 删除不需要的依赖文件 12345bundle install --without development:test:assets -j4 --retry 3 --path=vendor/bundle \ # Remove unneeded files (cached *.gem, *.o, *.c) &amp;&amp; rm -rf vendor/bundle/ruby/2.5.0/cache/*.gem \ &amp;&amp; find vendor/bundle/ruby/2.5.0/gems/ -name "*.c" -delete \ &amp;&amp; find vendor/bundle/ruby/2.5.0/gems/ -name "*.o" -delete 删除前端的node_modules以及缓存文件 1rm -rf node_modules tmp/cache app/assets vendor/assets spec 上述内容可以结合多阶段构建实现 GolangGolang 在使用多阶段构建之后，只剩下了一个二进制文件，这时候再要优化，就只有使用npx之类的工具压缩二进制文件的体积了 参考资料 Docker 容器镜像瘦身的三个小窍门 基础镜像 | 再谈 Docker 瘦身 Docker —— 从入门到实践这是一本很不错的 Docker 开源书 Docker 基本原理简析 Ruby on Rails — Smaller docker images 推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新pprof go性能分析工具Github Actions介绍&自动构建Github Pages博客在blog中内嵌在线PPT在windows安装dockertool，并且配置文件夹共享如何搭建基于Hexo的独立博客]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>docker</tag>
        <tag>cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GORM避坑指南之含关联关系的更新]]></title>
    <url>%2Fpost%2Fgo%2Fgorm%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%E4%B9%8B%E5%90%AB%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E7%9A%84%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[在GORM的文档当中有说明，使用Update, Updates时只会更新改变的字段，但是出现关联关系的时候情况似乎有了一些微妙的变化 If you only want to update changed Fields, you could use Update, Updates 先说结论db.Model(&amp;user).Update(&quot;name&quot;, &quot;hello&quot;)如果user包含关联关系，user的关联关系将被自动更新 避坑1.如果确认不会使用到关联相关的回调，可以直接使用UpdateColumn,UpdateColumns方法 下面是来自官方文档的例子: 1234567// Update single attribute, similar with `Update`db.Model(&amp;user).UpdateColumn("name", "hello")//// UPDATE users SET name='hello' WHERE id = 111;// Update multiple attributes, similar with `Updates`db.Model(&amp;user).UpdateColumns(User&#123;Name: "hello", Age: 18&#125;)//// UPDATE users SET name='hello', age=18 WHERE id = 111; 2.如果需要用到相关的回调，可以手动指定Model里面的结构体 1db.Model(&amp;User&#123;Model: Model&#123;ID: 1&#125;&#125;).UpdateColumn("name", "hello") 复现下面这一段是官方文档中的例子，只会更新更新users表的name字段 123// Update single attribute if it is changeddb.Model(&amp;user).Update("name", "hello")//// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111; 但是如果Model(&amp;struct),struct包含关联关系时，struct关联关系将被更新，如以下所示: 123456789101112131415161718192021222324252627282930313233type Product struct &#123; gorm.Model Code string Price uint Applications []Application&#125;type Application struct &#123; gorm.Model Name string ProductID uint&#125;func main() &#123; // Migrate the schema db.AutoMigrate(&amp;Product&#123;&#125;, &amp;Application&#123;&#125;) // Create db.Create(&amp;Product&#123;Code: "L1212", Price: 1000&#125;) // Read var product Product db.First(&amp;product, 1) // find product with id 1 product.Applications = []Application&#123; &#123; Name: "test", &#125;, &#125; // Update - update product's price to 2000 db.Model(&amp;product).Update("Price", 1000) // UPDATE products SET price = '1000', updated_at = '2019-01-29 21:58:52' WHERE products.deleted_at IS NULL // INSERT INTO applications (created_at,updated_at,deleted_at,name,product_id) VALUES ('2019-01-29 21:58:52','2019-01-29 21:58:52',NULL,'test','0') &#125; 溯源 该部分默认对GORM的源码有一定的了解 查看Model相关的源码，我们可以发现Model其实就是clone了一个DB对象然后将传入的指针赋值给Value 12345678910// Model specify the model you would like to run db operations// // update all users's name to `hello`// db.Model(&amp;User&#123;&#125;).Update("name", "hello")// // if user's primary key is non-blank, will use it as condition, then will only update the user's name to `hello`// db.Model(&amp;user).Update("name", "hello")func (s *DB) Model(value interface&#123;&#125;) *DB &#123; c := s.clone() c.Value = value return c&#125; 查看Update/Updates相关的源码我们可以发现，这里讲需要更新的字段通过InstanceSet(&quot;gorm:update_interface&quot;, values)保存了下来 123456789101112// Update update attributes with callbacks, refer: https://jinzhu.github.io/gorm/crud.html#updatefunc (s *DB) Update(attrs ...interface&#123;&#125;) *DB &#123; return s.Updates(toSearchableMap(attrs...), true)&#125;// Updates update attributes with callbacks, refer: https://jinzhu.github.io/gorm/crud.html#updatefunc (s *DB) Updates(values interface&#123;&#125;, ignoreProtectedAttrs ...bool) *DB &#123; return s.NewScope(s.Value). Set("gorm:ignore_protected_attrs", len(ignoreProtectedAttrs) &gt; 0). InstanceSet("gorm:update_interface", values). callCallbacks(s.parent.callbacks.updates).db&#125; 再看看关联关系更新的代码， 只有一个参数scope,scope哪儿来的呢，上面的s.NewScope(s.Value),这个地方其实也是将最开始Model中的 value拷贝了一份 12345678func saveAfterAssociationsCallback(scope *Scope) &#123; // 判断是否存在关系关系然后更新bala bala... for _, field := range scope.Fields() &#123; autoUpdate, autoCreate, saveReference, relationship := saveAssociationCheck(scope, field) //... &#125; //...&#125; 看到这个了差不多就可明白了，主要原因是因为Model的value一直跟随到了最后，导致最后执行关联关系更新回调的时候，检测到有关联数据数据表中不存在，就会自然的根据关联关系插入进去 相关资源 目前还不清楚这是一个bug还是一个feature，先提交了一个issue: https://github.com/jinzhu/gorm/issues/2278 一个十分边缘的gorm的bug 推荐文章（由hexo文章推荐插件驱动）pprof go性能分析工具Github Actions介绍&自动构建Github Pages博客在blog中内嵌在线PPTdocker镜像瘦身&优化记一次net http内存泄漏如何搭建基于Hexo的独立博客]]></content>
      <tags>
        <tag>blog</tag>
        <tag>go</tag>
        <tag>note</tag>
        <tag>gorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Actions介绍&自动构建Github Pages博客]]></title>
    <url>%2Fpost%2Fnotes%2FGithub-Actions%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAGithub-Pages%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本文将主要讲述如何创建一个自定义的Github Actions， 并且使用Github Actions 完成 CI/CD的操作 故事的起因就是，github的私有仓库免费了, 打算将blog仓库切换为私有仓库，这样可以同时将笔记和博客放在一块，利用hugo的draft功能，将不想发布的文章设置true即可。 修改之后由于之前使用Travis CI自动构建博客的静态页面，而Travis CI对于私有仓库只能试用100次，正好之前获得了Github Actions的测试资格，但是一直都还没有使用过，本次记录一下Github Actions的使用过程 Actionsactions可以用来作为CI/CD使用，但是它不只是CI/CD，因为它其实是一组docker容器所组成的Workflow，Workflow的触发条件，公共仓库目前仅支持push，私有仓库则支持check_run、create、delete、issue comment， commit comment, pull request等许多事件, 通过这些事件，可以完成除了CI/CD之外的许多自动化操作，例如接收到issue comment之后使用telegram bot发送通知等等 创建一个Workflow如果你有权限的话，在你的仓库下应该可以看到一个Actions的菜单 Workflow GUI如下图所示 切换视图，从左到右分别是，GUI的方式编辑，直接编辑文件，查看变动 workflow区域，一个main.workflow文件下可以包含多个workflow，每一个workflow 每个workflow具体的编辑区域，每个workflow可以关联多个action，每个action都有头尾两个点，点击下拉即可连接起来 保存提交按钮 Workflow edit如下图所示，workflow只有两个可选的修改项，分别是Name以及触发条件，触发条件公共仓库目前仅支持push，私有仓库则支持check_run、create、delete、issue comment， commit comment, pull request等许多事件。完整的触发条件可以查看 Events supported in workflow files action edit如下图所示 uses 使用的docker镜像, 在 https://github.com/actions 提供了一些常用的actions可以直接使用 {user}/{repo}/{path}@{ref} 直接使用公开的仓库，仓库里必须包含dockerfile, path为可选项，没有path默认为根路径，e.g actions/heroku@master, `actions/aws/ec2@v2.0.1` ./path/to/dir当前仓库的相对路径 docker://{host}/{image}:{tag} docker镜像地址，host为可选项，不填host默认从dockerhub拉取，e.g docker://mohuishou/hugo:0.53, docker://gcr.io/cloud-builders/gradle label 就是标签 runs 覆盖dockerfile中的 entrypoint args 覆盖dockerfile中的 cmd secret 读取该仓库保存的秘密变量，将以环境变量的形式注入到运行的容器中 env 注入到运行的容器中的环境变量，是可见的 创建ActionAction其实就是Docker镜像，按照Docker镜像的写法即可，需要关注以下几点 1. Dockerfile Lablesgithub actions 会读取dockerfile的label在Workflow GUI上做一些展示 12345678LABEL "com.github.actions.name"="" #Github action 的名字LABEL "com.github.actions.description"="desc" #说明LABEL "com.github.actions.icon"="mic" #GUI上展示的图标LABEL "com.github.actions.color"="purple" # GUI上展示的颜色LABEL "repository"="http://github.com/mohuishou/hugo-action" # 仓库地址LABEL "homepage"="http://github.com/mohuishou" # 主页LABEL "maintainer"="mohuishou &lt;1@lailin.xyz&gt;" # 作者 2. Env默认的环境变量，以及如何读取 默认环境变量所有的默认值可以参考这里 Environment variables 常用的主要有 Environment variable Description GITHUB_ACTOR 用户的名字 GITHUB_REPOSITORY 用户和仓库的地址 例如 mohuishou/hugo-action GITHUB_WORKSPACE github的工作区， 默认值为 /github/workspace GITHUB_TOKEN workflow的github token可以用来clone拉取数据，但是没有push的权限 读取环境变量读取环境变量时需要注意，环境变量是在容器运行时注入的，所以在dockerfile里面没有办法直接使用 使用hugo-action自动build&amp;push博客https://github.com/mohuishou/hugo-action 遵循以下约定 你的博客源代码地址和github pages地址不同 github pages仓库地址为 youname.github.io 使用创建文件 .github/main.workflow 1234567891011121314workflow "blog ci/cd" &#123; on = "push" resolves = ["hugo"]&#125;action "hugo" &#123; uses = "docker://mohuishou/hugo-action:0.53" secrets = [ "TOKEN", ] env = &#123; EMAIL = "1@lailin.xyz" &#125;&#125; 环境变量 Key Value Must TOKEN 你的github token，需要有push权限，保存在密码变量中 yes EMAIL 你的邮箱 参考链接 官方文档 GitHub Actions 介绍，了解一下？ Github Actions Repo 推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新pprof go性能分析工具在blog中内嵌在线PPTdocker镜像瘦身&优化记一次net http内存泄漏如何搭建基于Hexo的独立博客]]></content>
      <tags>
        <tag>blog</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在blog中内嵌在线PPT]]></title>
    <url>%2Fpost%2Fnotes%2F%E5%9C%A8blog%E4%B8%AD%E5%86%85%E5%B5%8C%E5%9C%A8%E7%BA%BFPPT%2F</url>
    <content type="text"><![CDATA[有时我们会做一些分享，分享之后可以把 PPT 脱敏之后放在博客上面，可以使用 office online 直接内嵌 PPT, 巨硬大法好 需求 在线播放 支持动画 支持播放内嵌视频 自适应 上面的需求, WPS 云文档支持 1, 以及一些简单的动画，Office online 支持 1,2,3 第四点我们可以通过一个简单 js 脚本解决 获取分享链接1.登录 https://onedrive.live.com 上传需要分享的 PPT 2.如下图所示 打开刚刚上传的 PPT 文件 3.点击右上角的文件 -&gt; 共享 -&gt; 嵌入 4.获取分享链接，将代码中的分享链接复制 123456&lt;iframe src="这里是你的分享链接" width="350px" height="221px" frameborder="0" &gt;这是嵌入 &lt;a target="_blank" href="https://office.com"&gt;Microsoft Office&lt;/a&gt; 演示文稿，由 &lt;a target="_blank" href="https://office.com/webapps"&gt;Office Online&lt;/a&gt; 支持。&lt;/iframe&gt; 5.修改代码自适应，将上一步获取到的链接替换到下方代码中，复制粘贴到博客中即可 123456789101112131415&lt;iframe id="ppt" width="100%" onload="autoChange()" src="在此处替换为你的PPT链接" frameborder="0"&gt;&lt;/iframe&gt;&lt;script&gt; function autoChange() &#123; let ifm = document.getElementById('ppt') ifm.height = (ifm.clientWidth / 16) * 9 + 24 &#125; window.onresize = autoChange&lt;/script&gt; 示例https://lailin.xyz/post/notes/pprof-go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/ 总结Office Online 对于 PPT 支持相当的好，唯一的缺点可能就是在国内有些的确被墙，可能需要 FQ 才能访问 推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新pprof go性能分析工具Github Actions介绍&自动构建Github Pages博客docker镜像瘦身&优化如何搭建基于Hexo的独立博客]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次net http内存泄漏]]></title>
    <url>%2Fpost%2Fgo%2F%E8%AE%B0%E4%B8%80%E6%AC%A1net-http%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[使用 gin 作为文件下载服务器，内存占用突然从几十 M 到了 10G 以上，导致服务被 kill 重启 复现server.go 123456789101112131415161718192021222324func main() &#123; r := gin.Default() r.GET("/download", func(context *gin.Context) &#123; f, err := os.Open("./win7.iso") log.Println(err) defer f.Close() info, _ := f.Stat() b := make([]byte, info.Size()) f.Read(b) context.Data(200, "application/octet-stream", b) &#125;) go func() &#123; log.Println(http.ListenAndServe("localhost:6060", nil)) &#125;() go func() &#123; for &#123; time.Sleep(time.Second * 30) runtime.GC() log.Println("gc") &#125; &#125;() runtime.MemProfileRate = 16 * 1024 r.Run(":8080")&#125; client.go 123456func main() &#123; resp, _ := http.Get("http://localhost:8080/download") resp.Body.Close() log.Println("ok") select &#123;&#125;&#125; 使用pprof我们可以发现内存占用高达3GB, 即使我主动调用了 GC 这个内存仍未释放 追溯通过查看代码我们可以发现请求已经结束，代码并没有其他地方对[]byte引用，一直追溯到最低层也不见其他引用。 但是结束client进程之后会有一个神奇的发现，结束 client 之后这一块内存就可以被 GC 掉 通过这个现象自然而然的就想到可能是 TCP 链接没有断开，导致这一块内存的引用并没有被释放掉 http 是一个本身是短连接，但是为了复用 TCP 连接所以有了keep-alive，但是对于下载服务来说我们其实不用复用 TCP 连接，只需要在文件下载完毕之后主动关闭这个连接即可，所以我分别在 client 加上了一个 header 1Connection: close 再次通过pprof查看内存占用发现内存仍未得到释放 原因通过 rfc 文档，我们可以发现规范并没有规定由谁来关闭链接，Go net/http 希望客户端关闭链接 https://tools.ietf.org/html/rfc2616#page-117 HTTP/1.1 defines the “close” connection option for the sender to signal that the connection will be closed after completion of the response. 解决 使用流而不是直接读内存，在gin中不要直接使用c.Data而是使用c.DataFromReader 使用 AWS S3 等存储服务下发文件，减轻服务压力 尽量不使用官方的net/http处理文件 @jiajun 老师 已经给 Go 官方提了一个 PR，等待 PR Merge 参考资料 https://jiajunhuang.com/articles/2018_11_24-memory_leak_in_net_http.md.html https://tools.ietf.org/html/rfc2616 https://lailin.xyz/post/notes/pprof-go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/ 推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新使用chromedp解决反爬虫问题使用Goland调试Go程序Httprouter介绍及源码阅读最短路径算法-DijkstraGo 语言的环境配置，然后试试种子爬虫黑科技]]></content>
      <tags>
        <tag>go</tag>
        <tag>notes</tag>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pprof go性能分析工具]]></title>
    <url>%2Fpost%2Fgo%2Fpprof-go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[PPT 分享(可能需要 FQ 方能访问，需要可以访问, onedrive.live.com) 这是嵌入 Microsoft Office 演示文稿，由 Office Online 支持。 function changeFrameHeight(){ var ifm= document.getElementById("ppt"); console.log(ifm.width) ifm.height=ifm.clientWidth / 16 * 9 + 24; } window.onresize = changeFrameHeight 推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新Github Actions介绍&自动构建Github Pages博客在blog中内嵌在线PPTdocker镜像瘦身&优化如何搭建基于Hexo的独立博客]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用TravisCI自动部署Blog]]></title>
    <url>%2Fpost%2Fnotes%2F%E4%BD%BF%E7%94%A8TravisCI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Blog%2F</url>
    <content type="text"><![CDATA[之前博客的更新一直都是在本地运行hugo然后手动push到github仓库，虽然写了一个小脚本，但是本地还是多了一个public文件夹，最近看了travis ci可以和github完美的结合。关于travis ci 不过多介绍，感兴趣的可以直接看官方文档，写的非常详细 123456789101112131415161718192021222324252627282930# 指定运行语言为golanguage: go# 指定go语言版本go: - "1.10.x"# 安装依赖，安装hugoinstall: - wget https://github.com/gohugoio/hugo/releases/download/v0.49/hugo_0.49_Linux-64bit.tar.gz - tar -xzvf hugo_0.49_Linux-64bit.tar.gz# 在script执行前执行，设置git用户名，邮箱，从github把blog文件拉下来before_script: - git config --global user.email "1@lailin.xyz" - git config --global user.name "mohuishou" - git clone https://$GITHUB_TOKEN@github.com/mohuishou/mohuishou.github.io.git public # clone 主题 - git clone https://github.com/laozhu/hugo-nuo themes/hugo-nuo# 生成静态网页script: - ./hugo# 运行成功之后将页面推送到github上after_success: - cd public - git add . - git commit -m 'travis auto update' - git push -u origin master 推荐文章（由hexo文章推荐插件驱动）记一次net http内存泄漏Github Actions介绍&自动构建Github Pages博客纯技术人员和投资者的一些区别一个十分边缘的gorm的bug從 Surge 搬家到 GitLab]]></content>
      <tags>
        <tag>notes</tag>
        <tag>ci</tag>
        <tag>hugo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Goland调试Go程序]]></title>
    <url>%2Fpost%2F%E5%B7%A5%E5%85%B7%2F%E4%BD%BF%E7%94%A8Goland%E8%B0%83%E8%AF%95Go%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在上一篇Blog当中发现了一个十分边缘的GORM的bug，由于不熟悉工具，bug的调试过程还是比较麻烦，这一篇讲一讲如何使用Goland强大的debug功能调试Go程序 GolandGoland 是jb公司的Go语言IDE，和jb家族的其他IDE一样的强大并且吃内存 下载地址: https://www.jetbrains.com/go Debugwhere如下图所示，在main函数或者是单元测试函数的旁边会出现一个执行的按钮在屏幕的右上角也可以看见一个小虫子的按钮，点击就可以开始debug 配置如下图所示，点击Edit打开配置窗口如下图所示，可以对当前的运行命令进行配置，或者点击下方templates，对模板配置，修改模板配置，在当前项目之后再点击go run时，会自动采用模板的配置配置可以对文件，环境变量，运行命令等进行配置，一般用的比较多的就是环境变量 断点如图所示点击行号和代码之间的空白即可添加断点如图所示，右键点击红点，可以对断点进行一些高级的设定点击more会出现如下弹窗 窗口点击Debug开始运行之后，会出现一个debug窗口，当前的窗口是console窗口点击debugger可以看到整个程序的调用栈，点击相应的调用栈可以调转的相应的代码，并且显示当前的变量信息如图所示可以在当前栈，执行相应的命令，但是暂时还不支持执行方法，只能查看变量或者是调用变量的属性 推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新记一次net http内存泄漏使用chromedp解决反爬虫问题Httprouter介绍及源码阅读最短路径算法-DijkstraGo 语言的环境配置，然后试试种子爬虫黑科技]]></content>
      <tags>
        <tag>go</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个十分边缘的gorm的bug]]></title>
    <url>%2Fpost%2Fnotes%2F%E4%B8%80%E4%B8%AA%E5%8D%81%E5%88%86%E8%BE%B9%E7%BC%98%E7%9A%84gorm%E7%9A%84bug%2F</url>
    <content type="text"><![CDATA[[toc] 复现代码这个代码的触发条件比较严苛，首先必须要保证gorm执行的一行必须为updates语句，并且在updates(struct),并且传入的这个struct必须要包含一个直接或者间接关联的一个多态表，这些条件缺一不可 12345678910111213141516type A struct &#123; gorm.Model Name string B B `gorm:"polymorphic:Owner"`&#125;type B struct &#123; gorm.Model OwnerID uint OwnerType string&#125;a := A&#123;Name: "test"&#125;db = db.Model(&amp;a)db.Where(a)db.Updates(A&#123;Name: "test2"&#125;) // panic 现象先说现象，在一次代码联调的过程当中，发现调用一个更新接口的时候会报500错误（panic），但是在什么都不修改的情况下，再次调用接口，更新成功 错误日志如下，是由于一个空指针的调用:1234567891011121314151617181920212223242526panic: runtime error: invalid memory address or nil pointer dereferencegithub.com/jinzhu/gorm.(*DB).clone(0x0, 0x0) E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/main.go:715 +0x4egithub.com/jinzhu/gorm.(*DB).Model(0x0, 0x6cb460, 0xc00017c160, 0x0) E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/main.go:445 +0x32github.com/jinzhu/gorm.(*Scope).TableName(0xc000172100, 0xc00016c3c0, 0x6f894a) E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.go:325 +0x133github.com/jinzhu/gorm.(*Scope).GetModelStruct.func2(0xc000170010, 0xc000172100, 0xc00017a050, 0xc0001749c0) E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/model_struct.go:420 +0x24c7github.com/jinzhu/gorm.(*Scope).GetModelStruct(0xc000172100, 0xc00017a050) E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/model_struct.go:574 +0x140cgithub.com/jinzhu/gorm.(*Scope).Fields(0xc000172100, 0xc000172100, 0x2030000, 0x2030000) E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.go:115 +0xafgithub.com/jinzhu/gorm.convertInterfaceToMap(0x6cb460, 0xc00017c160, 0xc00017c001, 0x199) E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.go:860 +0x4f8github.com/jinzhu/gorm.(*Scope).updatedAttrsWithValues(0xc000172080, 0x6cb460, 0xc00017c160, 0x6cb460, 0xc00017c160) E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.go:877 +0x8bgithub.com/jinzhu/gorm.assignUpdatingAttributesCallback(0xc000172080) E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/callback_update.go:25 +0x81github.com/jinzhu/gorm.(*Scope).callCallbacks(0xc000172080, 0xc00012ff00, 0x9, 0x10, 0xc00017c160) E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/scope.go:831 +0x5cgithub.com/jinzhu/gorm.(*DB).Updates(0xc00017e090, 0x6cb460, 0xc00017c160, 0x0, 0x0, 0x0, 0xc00017e090) E:/SoftFile/GOPATH/src/github.com/jinzhu/gorm/main.go:383 +0x13bmain.main() E:/SoftFile/GOPATH/src/github.com/mohuishou/test/main.go:34 +0x269 调试首先从panic的堆栈顶端往下看, 是调用s.db的时候报的错，推断应该是s的值为nil导致的错误12345func (s *DB) clone() *DB &#123; db := &amp;DB&#123; db: s.db, // 从这一行开始panic &#125;&#125; 接着往下看，这里的s应该也是一个nil12345678910// Model specify the model you would like to run db operations// // update all users's name to `hello`// db.Model(&amp;User&#123;&#125;).Update("name", "hello")// // if user's primary key is non-blank, will use it as condition, then will only update the user's name to `hello`// db.Model(&amp;user).Update("name", "hello")func (s *DB) Model(value interface&#123;&#125;) *DB &#123; c := s.clone() // 从这里调用 c.Value = value return c&#125; 接着走, 在获取表名的时候，需要调用scope.db.Model， 这里的db应该是一个nil导致调用失败12345// TableName return table namefunc (scope *Scope) TableName() string &#123; // ... return scope.GetModelStruct().TableName(scope.db.Model(scope.Value))&#125; 从下面的调用，可以看到，实在获取Struct的结构的时候，由于有多态关联(polymorphic)的tag，所以需要获取多态表的TableName1234567891011func (scope *Scope) GetModelStruct() *ModelStruct &#123; // ... if polymorphic := field.TagSettings["POLYMORPHIC"]; polymorphic != "" &#123; if value, ok := field.TagSettings["POLYMORPHIC_VALUE"]; ok &#123; relationship.PolymorphicValue = value &#125; else &#123; // 这里调用 relationship.PolymorphicValue = scope.TableName() &#125; &#125;&#125; 调用GetModelStruct的原因是因为需要获取value的所有字段，字段等于nil的时候，就会调用GetModelStruct去获取123456789// Fields get value's fieldsfunc (scope *Scope) Fields() []*Field &#123; if scope.fields == nil &#123; // ... for _, structField := range scope.GetModelStruct().StructFields &#123; // ... &#125; &#125;&#125; 看这个函数可以发现，会把interface转为map, 由于我们最开始传入的是db.Updates(A{Name: &quot;test2&quot;})条件是一个struct所以会执行下面case interface{} -&gt; default分支。此时会调用(&amp;Scope{Value: values}).Fields()，这时候可以发现Scope这个对象在初始话的时候是没有db这个字段的，所以在获取table name的时候需要调用到scope.db这时候就会panic12345678910111213141516171819202122232425262728293031func convertInterfaceToMap(values interface&#123;&#125;, withIgnoredField bool) map[string]interface&#123;&#125; &#123; var attrs = map[string]interface&#123;&#125;&#123;&#125; switch value := values.(type) &#123; case map[string]interface&#123;&#125;: return value case []interface&#123;&#125;: for _, v := range value &#123; for key, value := range convertInterfaceToMap(v, withIgnoredField) &#123; attrs[key] = value &#125; &#125; case interface&#123;&#125;: reflectValue := reflect.ValueOf(values) switch reflectValue.Kind() &#123; case reflect.Map: for _, key := range reflectValue.MapKeys() &#123; attrs[ToDBName(key.Interface().(string))] = reflectValue.MapIndex(key).Interface() &#125; default: // 在这里调用 for _, field := range (&amp;Scope&#123;Value: values&#125;).Fields() &#123; if !field.IsBlank &amp;&amp; (withIgnoredField || !field.IsIgnored) &#123; attrs[field.DBName] = field.Field.Interface() &#125; &#125; &#125; &#125; return attrs&#125; 到这里这个bug就算结案了，但是接着看看，为什么会调用这个函数. 这个函数会获取需要更新的字段map,如果传入的是一个struct，会转换为map123456789func (scope *Scope) updatedAttrsWithValues(value interface&#123;&#125;) (results map[string]interface&#123;&#125;, hasUpdate bool) &#123; if scope.IndirectValue().Kind() != reflect.Struct &#123; return convertInterfaceToMap(value, false), true &#125; results = map[string]interface&#123;&#125;&#123;&#125; for key, value := range convertInterfaceToMap(value, true) &#123;&#125;&#125; 这个方法会把获取到需要更新的map保存下来12345678910// assignUpdatingAttributesCallback assign updating attributes to modelfunc assignUpdatingAttributesCallback(scope *Scope) &#123; if attrs, ok := scope.InstanceGet("gorm:update_interface"); ok &#123; if updateMaps, hasUpdate := scope.updatedAttrsWithValues(attrs); hasUpdate &#123; scope.InstanceSet("gorm:update_attrs", updateMaps) &#125; else &#123; scope.SkipLeft() &#125; &#125;&#125; 解决方案https://github.com/jinzhu/gorm/pull/2105 总结GORM，使用map而不是struct在使用的GORM的时候，需要更新一些字段的时候最好使用map而不是struct，因为如果使用struct，gorm最终会把这个struct转换为map，并且如果这个struct包含一些关联关系，gorm会一直递归的查找转换下去，如果整个表的关联关系比较复杂，会导致效率比较低下 为什么不需要修改代码，第二次运行就不会panic这是由于GORM会对struct的结构有一个全局的缓存modelStructsMap，由于这个是因为查找关联关系的时候报错，其本身已经新建了一个modelstruct并且缓存了下来，所以再次调用的时候就不会执行后面的代码了123456789// GetModelStruct get value's model struct, relationships based on struct and tag definitionfunc (scope *Scope) GetModelStruct() *ModelStruct &#123; //... // Get Cached model struct if value := modelStructsMap.Get(reflectType); value != nil &#123; return value &#125; // ...&#125; 调试总结调试的过程比写来的要艰辛很多，由于调试的时候是从自身的代码开始，通过Goland的debug不断的打断点，一遍一遍的执行，查找整个执行的过程，导致忽略了最直接找到错误代码的方式。 不过这也是一个宝贵的经历，这个Bug调试结束之后，Goland强大的调试功能已经可以玩的比较6了 推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新记一次net http内存泄漏使用chromedp解决反爬虫问题使用Goland调试Go程序Httprouter介绍及源码阅读Go 语言的环境配置，然后试试种子爬虫黑科技]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>gorm</tag>
        <tag>notes</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Httprouter介绍及源码阅读]]></title>
    <url>%2Fpost%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2Fhttprouter%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[在上一篇文章当中阅读了Go语言的一个高性能的Web框架Gin，Web框架当中最重要的功能之一是路由，Gin的路由就是由httprouter这个包实现的 地址 https://github.com/julienschmidt/httprouter https://godoc.org/github.com/julienschmidt/httprouter 特性 基于基数树实现的高性能路由框架 仅支持精确匹配 不必关心URL结尾的斜线 路径自动校正，例如在url路径当中有../,//的时候 可以在URL当中设置参数，例如/user/:id 零内存分配 不存在服务器崩溃，可以通过设置panic handler使服务器从panic当中恢复 适合API构建 源码两个问题解决两个问题，就基本明白了这个路由框架 路由是是如何注册？如何保存的？ 当请求到来之后，路由是如何匹配，如何查找的？ 一个Demo还是从一个Hello World讲起1234567func main() &#123; r := httprouter.New() r.GET("/:name", func(writer http.ResponseWriter, request *http.Request, params httprouter.Params) &#123; fmt.Fprintf(writer, "hello, %s!\n", params.ByName("name")) &#125;) http.ListenAndServe(":8080",r)&#125; httprouter.New()初始化了一个Router，下面直接看一下Router的结构 Router在Router的源码当中有十分详尽的注释，这里按照我个人的理解注释一下 123456789101112131415161718192021222324252627282930313233// Router实现了Http.Handler接口，用于注册分发路由type Router struct &#123; // trees 是一个基数树集合，每一个HTTP方法对应一棵单独的路由树 // node是基数树的根节点 trees map[string]*node // 用于开启上文提到的自动处理URL尾部斜杆的特性 // 这个值为true时，如果/foo/没有被匹配到，会尝试匹配/foo RedirectTrailingSlash bool // 用于开启上文提到的路由校正的特性 // 这个值为true时，会对../和//这种路径进行校正 RedirectFixedPath bool // 这个值为true时，如果当前方法的路由没有被匹配到，会尝试匹配其他方法的路由， // 如果匹配到了则返回405，如果没有，就交给NotFound Handler处理 HandleMethodNotAllowed bool // 这个值为true时，将开启OPTIONS自动匹配，注意: 手动匹配优先级更高 HandleOPTIONS bool // 没有匹配到相应路由的时候会调用这个方法 // 如果没有注册这个方法会返回 NotFound NotFound http.Handler // 没有匹配到相应路由并且HandleMethodNotAllowed为true时会调用这个方法 MethodNotAllowed http.Handler // 用于从panic当中恢复 // 需要返回500错误，并且渲染相应的错误页面 PanicHandler func(http.ResponseWriter, *http.Request, interface&#123;&#125;)&#125; 初始化Router之后看看路由是如何保存并且注册的 路由是如何保存的?这里以官方Readme当中的例子说明：如果注册了以下路由12345678r.GET("/", f1)r.GET("/search/", f2)r.GET("/support/", f3)r.GET("/blog/", f4)r.GET("/blog/:post/", f5)r.GET("/about_us/", f6)r.GET("/about_us/team/", f7)r.GET("/contact/", f8) 那么这些路由会如下方所示，以一颗树的形式保存，并且这些路由的公共前缀会被抽离并且变为上一层节点Priority 表示加上自身一共有多少个节点Path 表示路径Handle 表示路由注册的方法1234567891011Priority Path Handle9 \ *&lt;1&gt;3 ├s nil2 |├earch\ *&lt;2&gt;1 |└upport\ *&lt;3&gt;2 ├blog\ *&lt;4&gt;1 | └:post nil1 | └\ *&lt;5&gt;2 ├about-us\ *&lt;6&gt;1 | └team\ *&lt;7&gt;1 └contact\ *&lt;8&gt; r.Handler.Get, r.Post等方法实质都是通过调用r.Handle实现的 123456789101112131415161718192021func (r *Router) Handle(method, path string, handle Handle) &#123; // 路径注册必须从/开始，否则直接报错 if path[0] != '/' &#123; panic("path must begin with '/' in path '" + path + "'") &#125; // 路由树map不存在需要新建 if r.trees == nil &#123; r.trees = make(map[string]*node) &#125; // 获取当前方法所对应树的根节点，不存在则新建一个 root := r.trees[method] if root == nil &#123; root = new(node) r.trees[method] = root &#125; // 向路由树当中添加一条一条路由 root.addRoute(path, handle)&#125; node路由是注册到一颗路由树当中的，先看看节点的源码，再来分析，是如何添加路由的 12345678910111213141516171819202122232425262728293031323334type node struct &#123; // 当前节点的路径 path string // 是否为参数节点，参数节点用:name表示 wildChild bool // 当前节点类型， 一共有4种 // static: 静态节点，默认类型 // root: 根节点 // param: 其他节点 // catchAll: 带有*的节点，这里*的作用和正则当中的*一样 nType nodeType // 当前路径上最大参数的个数，不能超过255 maxParams uint8 // 代表分支的首字母 // 上面的例子，当前节点为s // 那么indices = eu // ├s nil // |├earch\ *&lt;2&gt; // |└upport\ *&lt;3&gt; indices string // 孩子节点 children []*node // 注册的路由 handle Handle // 权重，表示当前节点加上所有子节点的数目 priority uint32&#125; 路由树是如何生成的？未完待续 推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新记一次net http内存泄漏使用chromedp解决反爬虫问题使用Goland调试Go程序最短路径算法-DijkstraGo 语言的环境配置，然后试试种子爬虫黑科技]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gin源码阅读 从0.1开始]]></title>
    <url>%2Fpost%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2Fgin%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%BB%8E0-0-1%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[最近打算开始学习一下Gin的源代码，现在Gin已经是一个十分成熟的框架了，代码量也不少，阅读起来还是有一定的难度，所以我打算从0.1版本开始阅读学习，一直到最新的一个版本。跟随着Gin的源码一步一步的学习成长。 目录结构Gin 0.1的代码量十分的少, 主要代码一共也只有五个文件，代码中的注释也比较详细 123456│ auth.go│ gin.go│ logger.go│ README.md│ recovery.go│ validation.go 跑起来Gin 0.1的代码量十分的少，但是还是先从readme的示例开始说起 首先下面这一段代码是直接跑不起来的，不知道是代码本身的bug还是因为Go语言的版本变化导致的，首先我们需要修改几个地方123456789101112import "github.com/gin-gonic/gin"func main() &#123; r := gin.Default() r.GET("ping", func(c *gin.Context)&#123; c.String("pong") &#125;) // Listen and server on 0.0.0.0:8080 r.Run(":80")&#125; 第一次修改main.go123456789101112131415161718package mainimport ( "github.com/gin-gonic/gin" "net/http")func main() &#123; r := gin.Default() // 在这儿必须在ping，前加上/，不然会导致panic r.GET("/ping", func(c *gin.Context)&#123; // String 方法接受两个参数，但是实例只写了一个 c.String(http.StatusOK,"pong") &#125;) // Listen and server on 0.0.0.0:8080 r.Run(":80")&#125; gin.go1234567891011// Returns a new blank Engine instance without any middleware attached.// The most basic configurationfunc New() *Engine &#123; engine := &amp;Engine&#123;&#125; engine.RouterGroup = &amp;RouterGroup&#123;nil, "", nil, engine&#125; engine.router = httprouter.New() // NotFound 是一个http.Handler的接口，但是源码当中赋值了一个方法给他 engine.router.NotFound = engine // engine.router.NotFound = engine.handle404 return engine&#125; 好了修改完成之后就可以运行, go run main.go成功运行了，但是还有一个bug，只能访问一次，就会因为stack overflow退出 查看一下gin.go, ServeHTTP可以发现，gin是直接调用了httprouter的ServeHTTP方法1234// ServeHTTP makes the router implement the http.Handler interface.func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123; engine.router.ServeHTTP(w, req)&#125; 继续追踪，可以发现在httprouter的ServeHTTP方法最后有一段判定404的代码，这时候就可以发现这是之前修改gin.go` engine.router.NotFound = engine这段代码造成的，由于Chrome浏览器访问的时候会尝试访问/favicon.ico这个文件，然而我们在路由当中并没有定义，此时就是404，这时候由于之前我们在初始化的时候，给router传递的NotFound为engine，而engine.ServeHTTP调用了router.ServeHTTP`这时候就造成了无限递归，导致最后退出123456// Handle 404if r.NotFound != nil &#123; r.NotFound.ServeHTTP(w, req)&#125; else &#123; http.NotFound(w, req)&#125; 第二次修改gin.go1234567891011// Returns a new blank Engine instance without any middleware attached.// The most basic configurationfunc New() *Engine &#123; engine := &amp;Engine&#123;&#125; engine.RouterGroup = &amp;RouterGroup&#123;nil, "", nil, engine&#125; engine.router = httprouter.New() // NotFound 是一个http.Handler的接口，但是源码当中赋值了一个方法给他 // 注释掉即可 // engine.router.NotFound = engine.handle404 return engine&#125; go run main.go成功运行，就没有问题了 Gin源码分析跑起来之后就具体看看源码,初始版本的Gin当中拥有三个比较重要的struct，也是核心的组成部分 Context123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Context是gin当中最为重要的一部分// 它用于在中间件当中传递变量，管理流程。例如接受json请求，并返回json// Context is the most important part of gin. It allows us to pass variables between middleware,// manage the flow, validate the JSON of a request and render a JSON response for example.Context struct &#123; // ServeHTTP 第二个参数，请求体 Req *http.Request // ServeHTTP 第一次参数，响应 Writer http.ResponseWriter // 可以设置的值 Keys map[string]interface&#123;&#125; // 错误信息 Errors []ErrorMsg // 请求参数 Params httprouter.Params // = 中间件 + 请求处理函数(最后一个) handlers []HandlerFunc // Engine 实例 engine *Engine // 当前处理到的Handler下标 index int8&#125;// 下一个中间件Next()// 终止处理，直接返回Abort(code int)// 添加错误信息，并且终止处理Fail(code int, err error)// 添加错误信息Error(err error, meta interface&#123;&#125;)// 给Context.Keys添加值Set(key string, item interface&#123;&#125;)// 获取Context.Keys的值，如果不存在会导致panicGet(key string) interface&#123;&#125;// 将请求体的参数作为json解析ParseBody(item interface&#123;&#125;) error// 同ParseBody，但是如果不是一个可解析的json会调用Fail(400)终止请求EnsureBody(item interface&#123;&#125;) bool// 下面是和返回相关的函数，code 参数均表示http status// 返回json JSON(code int, obj interface&#123;&#125;)// 返回xmlXML(code int, obj interface&#123;&#125;)// HTML模板渲染，使用golang标准库的模板库HTML(code int, name string, data interface&#123;&#125;)// 返回字符串String(code int, msg string)// 返回流数据Data(code int, data []byte) RouterGroup123456789101112131415161718192021222324252627282930313233// RouterGroup用于管理路由，一个RouterGroup和一个前缀以及一组中间件关联// Used internally to configure router, a RouterGroup is associated with a prefix// and an array of handlers (middlewares)RouterGroup struct &#123; // 中间件 Handlers []HandlerFunc // 路径前缀 prefix string parent *RouterGroup // Engine 实例 engine *Engine&#125;// 新建一个Context，用于传递这个路由组的数据createContext(w http.ResponseWriter, req *http.Request, params httprouter.Params, handlers []HandlerFunc) *Context// 添加一个中间件到这个路由组Use(middlewares ...HandlerFunc)// 新建一个路由组Group(component string, handlers ...HandlerFunc) *RouterGroup// 注册一个路由Handle(method, p string, handlers []HandlerFunc)// 调用Handle方法注册一个POST路由POST(path string, handlers ...HandlerFunc)// 调用Handle方法注册一个GET路由GET(path string, handlers ...HandlerFunc)// 调用Handle方法注册一个DELETE路由DELETE(path string, handlers ...HandlerFunc)// 调用Handle方法注册一个PATCH路由PATCH(path string, handlers ...HandlerFunc)// 调用Handle方法注册一个PUT路由PUT(path string, handlers ...HandlerFunc)// 组合中间件，将传入的Handlers放在已有的Handlers后面combineHandlers(handlers []HandlerFunc) []HandlerFunc Engine123456789101112131415161718192021222324// 用于表示Web框架，包含了fast HTTProuter和一个全局的中间件列表// Represents the web framework, it wrappers the blazing fast httprouter multiplexer and a list of global middlewares.Engine struct &#123; // 路由组 *RouterGroup // 404 处理 handlers404 []HandlerFunc // http router 实例 router *httprouter.Router // 模板 HTMLTemplates *template.Template&#125;// 加载HTML模板LoadHTMLTemplates(pattern string)// 设置404方法NotFound404(handlers ...HandlerFunc)// 默认的404方法，但是这个版本并没有使用上handle404(w http.ResponseWriter, req *http.Request)// 保存文件ServeFiles(path string, root http.FileSystem)// 实现http.Handler接口ServeHTTP(w http.ResponseWriter, req *http.Request)// 调用http.ListenAndServe启动服务器Run(addr string) 0.1版本的gin只是一个极小，极为简单的工具箱，主要提供了一个简单的路由和简单的中间件实现，搞清楚下面这两个问题这个框架的也就明白了。 一个使用了Gin的Web应用，从初始化到启动的流程？ 一个请求从接收到返回经历了什么？ 应用流程1.首先创建了一个engine实例，注册了两个两个基本的中间件 1gin.Default() -&gt; gin.New() -&gt; engine.Use(Recovery(), Logger()) 2.然后使用group.Handle方法注册路由, 关键代码如下，将路由添加到http router的树中，当执行handler方法的时候，会创建一个Context并且从头开始执行 1234group.engine.router.Handle(method, p, func(w http.ResponseWriter, req *http.Request, params httprouter.Params) &#123; group.createContext(w, req, params, handlers).Next()&#125;) 3.调用http.ListenAndServe监听指定端口，启动服务器 请求流程 当服务器收到请求时，会调用之前注册的engine.ServeHTTP方法，查找路由 engine.ServeHTTP方法使用了httprouter的ServeHTTP方法，这是会通过请求的path从已注册的路由树上获取对应的路由，并且执行其handler方法，如上所示，handler方法内部通过创建一个router group对应的Context从头开始执行所有的中间件以及注册路由时注册的请求处理函数 从请求处理函数中返回信息 推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新记一次net http内存泄漏使用chromedp解决反爬虫问题使用Goland调试Go程序Httprouter介绍及源码阅读Go 语言的环境配置，然后试试种子爬虫黑科技]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>gin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯技术人员和投资者的一些区别]]></title>
    <url>%2Fpost%2Fnotes%2F%E7%BA%AF%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E5%92%8C%E6%8A%95%E8%B5%84%E8%80%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[以下都是流水账，感慨一下… 今天有幸参加了一位师兄的校友聚会，也很巧合，和很多大佬一起吃了一个饭，听大佬们聊天受益颇多。 今天有一位做技术很厉害的，专家级的师兄想创业，聊起了他的项目，另外几个做企业的师兄在旁边听并且给出建议。让我产生一种很强烈的对比，做技术的师兄考虑的最多的是技术十分的牛，技术拥有不可复制，或者说很高的复制成本。但是没有说到具体的牛在什么地方，而其他几个师兄在帮忙理清项目的思路，有没有做过市场调查，有没有成型的产品，产品具体的技术指标等等。 不同位置的人看问题的角度不一样，或许只有那个技术很牛的师兄一样才能把一门技术做到极致。 但是反过来思考一下做技术需不需要有一定的产品思维，需不需要了解市场动态，需不需要良好的一个语言表述和组织能力，虽然这些肯定不是最重要的，但是应该也是不可或缺的吧。 自勉 推荐文章（由hexo文章推荐插件驱动）记一次net http内存泄漏Github Actions介绍&自动构建Github Pages博客使用TravisCI自动部署Blog一个十分边缘的gorm的bug]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年的一些小目标]]></title>
    <url>%2Fpost%2F%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92%2F2018%2F</url>
    <content type="text"><![CDATA[时间过得很快，从一个学生到一个社会人只需要那么一瞬间，一个来不及反应的瞬间。虽然之前经历过大量的实习工作，也不是第一次只身一人千里迢迢来到这个陌生的城市，但是还是有那么一些的不适应。 开始工作了，时间变得少了，但是学习的紧迫性却是变得更高了 列一列剩下不到半年时间想要学习的东西吧，权当是一个备忘录 阅读学习至少两个Go Web框架 七八月 Echo Gin Iris Beego … 学习Golang调度源码 七八月 or 九月 从零开始编写自己的第一个Go Web框架 八九月 未完待续… 希望能够养成记录学习过程的习惯，好记性不如烂笔头 推荐文章（由hexo文章推荐插件驱动）2018年度复盘，2019年度规划]]></content>
      <categories>
        <category>规划总结</category>
      </categories>
      <tags>
        <tag>规划</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go标准库——ioutil.ReadAll的实现]]></title>
    <url>%2Fpost%2Fgo%2Fgo%E6%A0%87%E5%87%86%E5%BA%93%2Fioutil-ReadAll%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[序 最近准备学习一下 golang 的标准库，详细的阅读部分源码，这个目录记录一下学习的过程和心得 go 语言的ioutil包提供了很多方便的 io 操作的工具集，本文主要详细分析ReadAll方法的源码实现。 ReadAll是很常用的一个方法，用来一次性的读取io.Reader当中的数据。 源码实现1. ReadAll阅读下方的源码我们可以发现，ReadAll其实调用了一个非导出的方法，我们一步一步的追踪 12345678910// ReadAll reads from r until an error or EOF and returns the data it read.// A successful call returns err == nil, not err == EOF. Because ReadAll is// defined to read from src until EOF, it does not treat an EOF from Read// as an error to be reported.// ReadAll从r读取数据直到EOF或遇到error，返回读取的数据和遇到的错误。// 成功的调用返回的err为nil而非EOF。// 因为本函数定义为读取r直到EOF，它不会将读取返回的EOF视为应报告的错误。func ReadAll(r io.Reader) ([]byte, error) &#123; return readAll(r, bytes.MinRead)&#125; 2. readAll阅读这个函数代码，可以发现，ioutil.ReadAll实质上是使用bytes.buffer实现的，在这里面调用了两个bytes.buffer的方法，一个用来初始化buffer的容量，一个用于读取所有的io.Reader数据 除此之外我们还可以学习到 go 当中 panic recover 的使用方法，在buffer当中，如果无法分配足够的内存的时候，会直接panic bytes.ErrTooLarge的错误，但是，这个方法我们期望把这个错误给返回回来，这个时候就可以使用defer recover从panic当中恢复回来 123456789101112131415161718192021222324252627282930// readAll reads from r until an error or EOF and returns the data it read// from the internal buffer allocated with a specified capacity.// readAll从r读取到一个错误或EOF，并返回从指定容量分配的内部缓冲区中读取的数据。func readAll(r io.Reader, capacity int64) (b []byte, err error) &#123; // 新建了一个buffer var buf bytes.Buffer // If the buffer overflows, we will get bytes.ErrTooLarge. // Return that as an error. Any other panic remains. // 如果buffer溢出了，会得到一个bytes.ErrTooLarge的错误 // 如果得到的是bytes.ErrTooLarge错误，将其返回，其他panic错误，仍然panic defer func() &#123; e := recover() if e == nil &#123; return &#125; if panicErr, ok := e.(error); ok &amp;&amp; panicErr == bytes.ErrTooLarge &#123; err = panicErr &#125; else &#123; panic(e) &#125; &#125;() // 判断capacity的值是否超过了int类型的上限 if int64(int(capacity)) == capacity &#123; // 向buffer当中增加capacity的容量 buf.Grow(int(capacity)) &#125; // 使用buffer ReadFrom 方法读取所有的io.Reader数据 _, err = buf.ReadFrom(r) return buf.Bytes(), err&#125; 3. buffer要看buffer相关函数的实现，先看看buffer的定义，不然到时候可能会懵 B 主要会用到两个字段，一个是buf,buf的内容是用off到len(buf)的，off之前的表示已经读取了数据，off表示当前位置，buffer的write和read方法都会从这个位置开始 123456789101112131415// A Buffer is a variable-sized buffer of bytes with Read and Write methods.// The zero value for Buffer is an empty buffer ready to use.// Buffer是一个实现了读写方法的可变大小的字节缓冲。// 本类型的零值是一个空的可用于读写的缓冲。type Buffer struct &#123; buf []byte // contents are the bytes buf[off : len(buf)] off int // read at &amp;buf[off], write at &amp;buf[len(buf)] lastRead readOp // last read operation, so that Unread* can work correctly. // FIXME: lastRead can fit in a single byte // memory to hold first slice; helps small buffers avoid allocation. // FIXME: it would be advisable to align Buffer to cachelines to avoid false // sharing. bootstrap [64]byte&#125; 4. buffer.Grow这个方法主要用来增加缓冲区的内存，实际还是调用了非导出的grow方法 123456789101112131415// Grow grows the buffer's capacity, if necessary, to guarantee space for// another n bytes. After Grow(n), at least n bytes can be written to the// buffer without another allocation.// If n is negative, Grow will panic.// If the buffer can't grow it will panic with ErrTooLarge.// 必要时会增加缓冲的容量，以保证n字节的剩余空间。// 调用Grow(n)后至少可以向缓冲中写入n字节数据而无需申请内存。// 如果n小于零或者不能增加容量都会panic ErrTooLarge 错误。func (b *Buffer) Grow(n int) &#123; if n &lt; 0 &#123; panic("bytes.Buffer.Grow: negative count") &#125; m := b.grow(n) b.buf = b.buf[0:m]&#125; 5. buffer.ReadFrom主要看看这个方法的实现，实现了从io.Reader读取所有数据。 示意图: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// ReadFrom reads data from r until EOF and appends it to the buffer, growing// the buffer as needed. The return value n is the number of bytes read. Any// error except io.EOF encountered during the read is also returned. If the// buffer becomes too large, ReadFrom will panic with ErrTooLarge.// ReadFrom从r中读取数据直到结束并将读取的数据写入缓冲中，如必要会增加缓冲容量。// 返回值n为从r读取并写入b的字节数；会返回读取时遇到的除了io.EOF之外的错误。// 如果缓冲太大，ReadFrom会采用错误值ErrTooLarge引发panic。func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) &#123; // const opInvalid = 0 // Non-read operation. 表示之前没有读操作 b.lastRead = opInvalid // If buffer is empty, reset to recover space. // 如果缓冲区为空，重置为恢复空间。 if b.off &gt;= len(b.buf) &#123; b.Reset() &#125; // 循环读取io.Reader 的数据 for &#123; // 判断当前剩余空间是否小于MinRead，MinRead = 512 if free := cap(b.buf) - len(b.buf); free &lt; MinRead &#123; // not enough space at end // 空间不足 // 新建一个buf newBuf := b.buf // 判断实际剩余容量是否小于MinRead = 512 if b.off+free &lt; MinRead &#123; // not enough space using beginning of buffer; // double buffer capacity // 实际剩余空间不足，分配双倍的缓冲空间，缓冲的最小值为MinRead所以加上一个MinRead，避免双倍之后仍然比MinRead小 // makeSlice函数用于分配缓冲空间，如果分配失败会panic ErrTooLarge 错误 newBuf = makeSlice(2*cap(b.buf) + MinRead) &#125; // 将原有buf数据复制到新的buf copy(newBuf, b.buf[b.off:]) // len(b.buf)-b.off 就等于buf当前内容的长度 // 例子: a:=make([]byte,20) // b:=a[:10] // len(b) // 10 // cap(b) //20 b.buf = newBuf[:len(b.buf)-b.off] // 将off置0 b.off = 0 &#125; // 从io.Reader当中读取数据，传入buf的剩余空间 // 第一种情况，数据读取完毕，返回读取长度m以及,io.EOF错误 // 第二种情况, 数据未读完，遇到错误 // 第三种情况，数据未读完，缓冲区容量不够，返回读取数据长度m以及nil m, e := r.Read(b.buf[len(b.buf):cap(b.buf)]) // 只获取有数据的buf，无数据的空间转化为cap b.buf = b.buf[0 : len(b.buf)+m] n += int64(m) // 数据读取完毕跳出循环 if e == io.EOF &#123; break &#125; // 遇到错误返回 if e != nil &#123; return n, e &#125; &#125; return n, nil // err is EOF, so return nil explicitly&#125; 推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新记一次net http内存泄漏使用chromedp解决反爬虫问题使用Goland调试Go程序Httprouter介绍及源码阅读Go 语言的环境配置，然后试试种子爬虫黑科技]]></content>
      <tags>
        <tag>go</tag>
        <tag>go标准库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用chromedp解决反爬虫问题]]></title>
    <url>%2Fpost%2Fnotes%2F%E4%BD%BF%E7%94%A8chromedp%E8%A7%A3%E5%86%B3%E5%8F%8D%E7%88%AC%E8%99%AB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言最近We川大上的教务处公告新闻已经很久没有更新了，想到可能是ip被封了，查了一下log，发现并不是，而是获取到的页面全变成了混淆过的js，下面放两个格式化的函数 1234567891011121314151617181920212223242526272829function _$Es(_$Cu) &#123; _$Cu[14] = _$v9(); _$Cu[_$yf(_$ox(), 16)] = _$Dn(); var _$cR = _$CR(); _$cR = _$iT(); return _$DA();&#125;function _$Dk(_$Cu) &#123; var _$x5 = _$Dv(); var _$x5 = _$EB(); if (_$Ex()) &#123; _$w9 = _$Dw(); &#125; _$Cu[_$yf(_$EJ(), 16)] = _$ED(); _$Cu[_$yf(_$Ep(), 16)] = _$EP(); _$w9 = _$EB(); return _$Cu[_$yf(_$v9(), 16)];&#125;function _$rK() &#123; var _$aJ = _$c0(_$DN()); _$aJ = _$BC(_$aJ, 2); var _$Ce = _$yr(_$qt()); for (var _$Cu = 0; _$Cu &lt; _$aJ[_$gX()]; _$Cu++) &#123; _$aJ[_$Cu] = _$Ce + _$aJ[_$Cu]; &#125; return _$aJ;&#125; 看着这一堆就头大，但是本着只要是浏览器能够渲染出来的页面爬虫就可以爬到的原则，一步一步的解决 分析 先使用postman发送了一下请求，发现返回了上面一堆乱码 复制了正常渲染页面request header重新发送请求，可以得到正常的页面。考虑两个可能一个是header有什么特殊的处理，一个是cookie上的问题。 header其他内容不变，去掉cookie重新发送请求，再一次得到一堆乱码。问题定位成功，应该就是cookie的问题了 清空chrome的缓存，重新加载页面，查看请求记录，可以看到这个页面一共加载了两次第一次加载没有返回cookie第二次加载返回了一个JSESSIONID，这个应该就是最终需要的cookie了 观察两次请求的中间，我们可以发现还有两个请求，这两个请求应该就是第二次返回cookie的原因了，第一个请求是页面内的外链js文件，第二个请求应该就是混淆过的js发出的请求了。 因为实力有限，分析了几个小时都没有分析出来这个逻辑是怎么加载的。但是想到了直接从浏览器把cookie复制下来给爬虫使用不就可以了？但是这样也还有一个问题，就是不可能每一次都手动的去获取cookie这样达不到想要的效果。然后看到Python有使用Selenium来完全模拟浏览器渲染然后解析页面的爬虫案例，找了一下golang有没有类似的浏览器渲染方案，在万能的gayhub上找到了chromedp。下面使用chromedp来解决这个问题。 chromedp Package chromedp is a faster, simpler way to drive browsers (Chrome, Edge, Safari, Android, etc) without external dependencies (ie, Selenium, PhantomJS, etc) using the Chrome Debugging Protocol. 1.install（建议使用梯子）1go get -u github.com/chromedp/chromedp 2.code运行下面这一段代码可以看到chrome会弹出一个窗口并且运行网页，最后在console输出期望的html，但是我们其实只需要得到正确的cookie，用来之后爬取网页使用。如果所有的页面都需要等待chrome渲染结束之后爬取，那么效率实在是太低了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( "context" "fmt" "io/ioutil" "log" "time" "github.com/chromedp/cdproto/cdp" "github.com/chromedp/chromedp")func main() &#123; var err error // create context ctxt, cancel := context.WithCancel(context.Background()) defer cancel() // create chrome instance c, err := chromedp.New(ctxt, chromedp.WithLog(log.Printf)) if err != nil &#123; log.Fatal(err) &#125; // run task list var res string err = c.Run(ctxt, chromedp.Tasks&#123; // 访问教务处页面 chromedp.Navigate(`http://jwc.scu.edu.cn/jwc/moreNotice.action`), // 等待table渲染成功，成功则说明已经获取到了正确的页面 chromedp.WaitVisible(`table`, chromedp.ByQuery), // 获取body标签的html字符 chromedp.OuterHTML("body", &amp;res), &#125;) if err != nil &#123; log.Fatal(err) &#125; // 关闭chrome实例 err = c.Shutdown(ctxt) if err != nil &#123; log.Fatal(err) &#125; // 等待chrome实例关闭 err = c.Wait() if err != nil &#123; log.Fatal(err) &#125; // 输出html字符串 log.Printf(res)&#125; 3.获取cookie修改第2步当中task list 的代码获取cookie，修改之后可以看到console当中输出了一段cookie字符串，使用这个cookie在postman当中测试可以发现，可以获取到正确的页面。到了这一步其实就应该算基本完成了，但是还是有一个缺点：每次运行的时候都会弹出一个chrome窗口，爬虫在服务器上运行是没有gui页面的，并且每次打开一个chrome实例的时间开销也比较大。 1234567891011121314151617// 将chromedp.OuterHTML("body", &amp;res) 替换为下面的代码chromedp.ActionFunc(func(ctx context.Context, h cdp.Executor) error &#123; // 获取cookie cookies, err := network.GetAllCookies().Do(ctx, h) // 将cookie拼接成header请求中cookie字段的模式 var c string for _, v := range cookies &#123; c = c + v.Name + "=" + v.Value + ";" &#125; log.Println(c) if err != nil &#123; return err &#125; return nil&#125;), 5.使用chrome的headless模式a.使用docker运行一个headless模式的chrome 1docker run -d -p 9222:9222 --rm --name chrome-headless knqz/chrome-headless b.修改代码 可以看到主要的区别就在创建chrome实例的时候没有去启动一个chrome，当然最后也不需要去关闭它 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( "context" "log" "github.com/chromedp/chromedp/client" "github.com/chromedp/cdproto/network" "github.com/chromedp/cdproto/cdp" "github.com/chromedp/chromedp")func main() &#123; var err error // create context ctxt, cancel := context.WithCancel(context.Background()) defer cancel() // create chrome instance c, err := chromedp.New(ctxt, chromedp.WithTargets(client.New().WatchPageTargets(ctxt)), chromedp.WithLog(log.Printf)) if err != nil &#123; log.Fatal(err) &#125; // run task list err = c.Run(ctxt, chromedp.Tasks&#123; // 访问教务处页面 chromedp.Navigate(`http://jwc.scu.edu.cn/jwc/moreNotice.action`), // 等待table渲染成功，成功则说明已经获取到了正确的页面 chromedp.WaitVisible(`table`, chromedp.ByQuery), // 获取body标签的html字符 chromedp.ActionFunc(func(ctx context.Context, h cdp.Executor) error &#123; // 获取cookie cookies, err := network.GetAllCookies().Do(ctx, h) // 将cookie拼接成header请求中cookie字段的模式 var c string for _, v := range cookies &#123; c = c + v.Name + "=" + v.Value + ";" &#125; log.Println(c) if err != nil &#123; return err &#125; return nil &#125;), &#125;) if err != nil &#123; log.Fatal(err) &#125;&#125; 到这里基本就可以使用了，获取到cookie之后可以使用喜欢的方式去获取页面 推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新记一次net http内存泄漏使用Goland调试Go程序Httprouter介绍及源码阅读最短路径算法-DijkstraGo 语言的环境配置，然后试试种子爬虫黑科技]]></content>
      <tags>
        <tag>go</tag>
        <tag>爬虫</tag>
        <tag>chromedp</tag>
        <tag>四川大学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[We川大开发笔记@0.2.0]]></title>
    <url>%2Fpost%2Fwescu%2Fwe%E5%B7%9D%E5%A4%A7%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%400.2.0%2F</url>
    <content type="text"><![CDATA[序可以搜索小程序we川大直接体验 这不是刚刚发完0.1.0的笔记么？怎么0.2.0都出来了？ 没有看错，效率就是那么高，上一篇也提到了0.1.0审核通过的时候0.2.0就基本已经完成了，而且现在已经上线了(准确的说是0.2.1版本)，这一次的审核快了许多，只用了不到两天就已经审核通过了 功能预览这一版主要新增三个功能，然后就是一些优化： 1.反馈 参考we重邮，直接和github的issue关联，所有提交的反馈信息，都会新建一条issue，为了防止滥用，每天的反馈次数做了一定的限制 这个后端上直接采用了Google的go-github包，开发起来十分的方便，只是文档资料不是特别的丰富，之后会专门总结一下 2.空闲教室查询 学校的空闲教室查询页面：http://cir.scu.edu.cn/cir/index.html 这是学校难得做的比较友好的站点，对于这个需要后端做一次接口中转即可 3.新闻Tag列表 这一版可以直接通过点击列表的tag，查看前20条包含该tag的新闻， 至于为什么是20条，因为一个很奇怪的bug现在还没有解决。 两个页面，A，B包含了同一个模块C，在模块C当中可以点击跳转到B，现在的问题就是在A页面的C模块当中点击跳转到B页面之后，B页面的C模块的scroll-view绑定的所有事件都会消失 图片预览 博客原文&amp;&amp;开源地址https://github.com/mohuishou/scuplus-wechathttp://lailin.xyz/post/We川大开发笔记@0.2.0/ 可以关注开发进度或者提交反馈或者是PR，star多多益善 推荐文章（由hexo文章推荐插件驱动）We川大开发笔记@0.1.0]]></content>
      <tags>
        <tag>we川大</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[We川大开发笔记@0.1.0]]></title>
    <url>%2Fpost%2Fwescu%2Fwe%E5%B7%9D%E5%A4%A7%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%400.1.0%2F</url>
    <content type="text"><![CDATA[序微信小程序已经出来一年左右了，然后之前也写过一个scuplus的web项目，但是还没有正式上线就无疾而终了，当然也不是一点用处都没有，拆分出来了两个小的功能模块，一个是绩点计算器，一个快捷评教，绩点计算器的日PV快要破3W了，UV已经破1W了，大家期末看成绩的心情依旧是那么的急迫。 按理来说，我即将毕业做这些其实不太好，毕业之后代码的维护以及运营都是一个大问题，但是川大一直缺少一个综合型的APP或者网站，学校官方的网站做的都及其的不友好，而且十分的分散，所以一直有这个想法，想做一个集新闻资讯、比赛资讯/找队友/拉票，教务查询，课程推荐/排名/评价/选课，书籍查询/借阅于一体的一个综合型网站。当然这个想法涉及到的东西有点多，吸取之前的教训，这次打算一步一步的来，前期做功能，后期做优化，分模块上线 使用微信小程序开发好处是不用考虑浏览器的兼容性也不用考虑去做两个APP，以及各种型号的手机，但是不好的地方就是所有的界面都只能靠自己去实现，基本没有现成的ui框架，有时候写的有点蛋疼(PS我是一个后端)。然后就是审核，微信的审核0.1.0版本用了5天才完成，这个时间我的0.2.0版本已经基本开发完成了 项目已经开源，可以关注开发进度或者提交反馈或者是PR，star多多益善https://github.com/mohuishou/scuplus-wechat 扫码体验 功能预览0.1.0 版本只是完成了基本的框架，以及相对来说比较常用的功能： 最新资讯（青春川大/scuinfo/教务处/学工部等） 成绩/GPA查询 课表查询 图片预览 推荐文章（由hexo文章推荐插件驱动）We川大开发笔记@0.2.0]]></content>
      <tags>
        <tag>we川大</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[招银网络面试总结]]></title>
    <url>%2Fpost%2F%E6%A0%A1%E6%8B%9B%2F%E6%8B%9B%E9%93%B6%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[三面同时进行，每一面间隔不超过五分钟，前面两面技术面最后一面HR，完全不会JAVA，结果一直问JAVA心态爆炸 一面(20min)1. 自我介绍2. JAVA用过么？准备去什么地方？用过一天写了一个小APP 3. JAVA的HashMap怎么实现？PUT一次做了什么操作不会 4. JAVA的GC怎么实现不会，强行说了一波PHP的GC 5. Mysql的锁Innodb支持到行级锁，MyISAM只支持到表 6. 求一个二叉树任意两节点的距离，时间复杂度是多少？7. 设计模式了解不？装饰器模式解释一下，写一个解释了一下，没有写，后面让写了一个工厂 还有一些忘了 二面(15min)1. 自我介绍2. JAVA的GC怎么实现。。。又来了3. Mysql去除重复项4. Mysql触发器机制5. 设计一个无限极分类的数据库表6. 怎么把去处来的数据树型结构化三面(35min)1. 拿了一波简历，成绩单，自我介绍2. 为什么不想留在成都3. 成绩单上很多60分，飘过还是重修飘过 4. 现在面试了哪些公司，有没有收到offer意向5. 简单的介绍了一个项目6. 介绍了社团研发部部长和学院团副经历 还有一些记不住了 推荐文章（由hexo文章推荐插件驱动）百度面试总结百度面试总结Google面试经历-一]]></content>
      <tags>
        <tag>面试</tag>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2Fpost%2F%E7%AE%97%E6%B3%95%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序定义冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 步骤： 比较相邻的元素（从后往前）。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。(如果这一步没有出现任何一次交换，那么说明所有的元素已经有序，不需要再进行下面的步骤了) 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 图片示例 程序示例（go）1234567891011121314151617181920212223242526272829303132func SortInt(a []int) ([]int, int) &#123; //交换次数，计数 n := 0 aLen := len(a) for i := aLen - 1; i &gt;= 0; i-- &#123; //标记，如果flag一次冒泡之后没有改变，那么证明排序已完成，不需要再次排序，直接退出 flag := 0 //一次冒泡 for j := 0; j &lt; i; j++ &#123; if a[j] &gt; a[j+1] &#123; //交换两个变量的值，无需引入临时变量 a[j], a[j+1] = a[j+1], a[j] n++ //有交换，flag=1 flag = 1 &#125; &#125; //判断一次冒泡，是否存在交换 if flag == 0 &#123; break &#125; &#125; return a, n&#125; 推荐文章（由hexo文章推荐插件驱动）shell排序堆排序归并排序快速排序插入排序排序算法]]></content>
      <tags>
        <tag>排序</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2Fpost%2F%E7%AE%97%E6%B3%95%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[说明归并排序:是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用 步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针达到序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 效果 示例1234567891011121314151617181920212223242526272829303132333435363738package merge//INFINITY 一个比较大的值用作哨兵const INFINITY = 0xfffffunc merge(arr []int, start, end int) &#123; if start &lt; end &#123; //从中间划分，分别左右两边排序 mid := (end + start) / 2 merge(arr, start, mid) merge(arr, mid+1, end) //下面进行归并操作，将两个长度较小但是已经排序完成的数组合并成一个较长长度的排序数组 //新建一个数组用于存放左边的值 arr1 := make([]int, mid-start+2) copy(arr1, arr[start:mid+1]) arr1[mid-start+1] = INFINITY //新建一个数组用于存放右边的值 arr2 := make([]int, end-mid+1) copy(arr2, arr[mid+1:end+1]) arr2[end-mid] = INFINITY //比较大小 j, k := 0, 0 for i := start; i &lt;= end; i++ &#123; if arr1[j] &lt;= arr2[k] &#123; arr[i] = arr1[j] j++ &#125; else &#123; arr[i] = arr2[k] k++ &#125; &#125; &#125;&#125;推荐文章（由hexo文章推荐插件驱动）shell排序冒泡排序堆排序快速排序插入排序排序算法]]></content>
      <tags>
        <tag>排序</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度面试总结]]></title>
    <url>%2Fpost%2F%E6%A0%A1%E6%8B%9B%2F%E7%99%BE%E5%BA%A6%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一面(40min)0. 自我介绍1. 介绍ImageOCR的项目2. 知道有哪些排序算法？冒泡、插入、shell、归并、快排、堆排序、选择排序等等 有没有不会写的，排雷排掉了堆排序 3. 手写插入排序并解释4. 上面的排序算法哪些是稳定的，哪些是不稳定的还有一些忘了二面(1.2h)0. 介绍简历上的另外一个项目1. PHP的基本数据类型以及基本数据类型内核如何实现?基本数据类型12345678boolean(布尔型) 布尔型是最简单的数据类型，只有两个值 false(假) 和true(真)string(字符串型) 字符串就是连续的字符序列，如 ehco &quot;string&quot;;integer(整型) 整型数据类型只能包含整数，这些数据类型可以是负数或者正数folat(浮点型) 浮点型类型用于存储数字，和整型不同的是浮点型可以有小数点array（数组） 一组相同类型的集合object（对象） 对象是一个实力，使用new命令创建一个对象resource（资源） 资源是一种特殊的变量，保存在外部资源的一个应用，资源是通过函数来进行建立的null（ 空白） 特殊的值，表示变量没有值，任何变量的初始值都是null 变量的在内核当中的保存方式： php5.3: http://blog.csdn.net/qq_28602957/article/details/52959132 12345678910111213141516171819typedef union _zvalue_value &#123; long lval; /* long value */ double dval; /* double value */ struct &#123; char *val; int len; &#125; str; HashTable *ht; /* hash table value */ zend_object_value obj; zend_ast *ast;&#125; zvalue_value;struct _zval_struct &#123; /* Variable information */ zvalue_value value; /* value */ zend_uint refcount__gc; zend_uchar type; /* active type */ zend_uchar is_ref__gc;&#125;; PHP语言层类型 存在zvalue_value的成员变量 long,bool,resoure lval double dval string str(len保存字符串的长度，val保存字符串的值) array ht（哈希表） object obj php7: https://yq.aliyun.com/articles/27359 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//存储变量的结构struct _zval_struct &#123; zend_value value; /* value */ union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar type, /* active type */ zend_uchar type_flags, zend_uchar const_flags, zend_uchar reserved) /* call info for EX(This) */ &#125; v; uint32_t type_info; &#125; u1; union &#123; uint32_t var_flags; uint32_t next; /* hash collision chain */ uint32_t cache_slot; /* literal cache slot */ uint32_t lineno; /* line number (for ast nodes) */ uint32_t num_args; /* arguments number for EX(This) */ uint32_t fe_pos; /* foreach position */ uint32_t fe_iter_idx; /* foreach iterator index */ &#125; u2;&#125;;//变量的值//通过上面的代码我们可以看到。变量是通过一个_zval_struct结构体方式存储的。其中结构体中的value存储的是变量的值。这个成员是zend_value类型的。zend_value类型的定义如下：typedef union _zend_value &#123; zend_long lval; /* long value */ double dval; /* double value */ zend_refcounted *counted; zend_string *str; zend_array *arr; zend_object *obj; zend_resource *res; zend_reference *ref; zend_ast_ref *ast; zval *zv; void *ptr; zend_class_entry *ce; zend_function *func; struct &#123; uint32_t w1; uint32_t w2; &#125; ww;&#125; zend_value; 2. PHP如何与nginx通信，通信方式有什么异同 https://vsxen.github.io/2017/05/30/phpcgi-socks-vs-tcp/ CGI模式CGI CGI（common gateway interface）通常翻译为共同网关接口，是HTTP服务器与机器上的其他程序进行通信的一个接口，让Web服务器必要时启动额外的程序处理动态内容。CGI是一种协议，它定义了Webserver与CGI程序的通信方式。Webserver接受客户端的HTTP请求，然后建立进程执行CGI程序，客户端的请求被传递给CGI程序，CGI执行后结果再返回Webserver。 CGI的出现让WEB从静态变为为动态，随着Web的越来越普及，很多的网站的都需要有动态的页面，以便与浏览者互交。随着网络技术的发展，CGI方式的缺点也越来越突出。每次客户端请求都需要建立和销毁进程。因为HTTP要生成一个动态页面，系统就必须启动一个新的进程以运行CGI程序，不断地fork是一项很消耗时间和资源的工作。 FastCGI众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中 并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail-Over特性等等。 FastCGI是一个常驻型的CGI，可以一直执行，只要激活后，不会每次都花时间去fork一次，而且还支持分布式运算（使得php程序解释执行可以单独交给php服务器），即可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。 1、Web Server 启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module）;2、FastCGI进程管理器自身初始化，启动多个CGI解释器进程 (在任务管理器中可见多个php-cgi.exe)并等待来自Web Server的连接。3、当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi.exe。4、FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器（运行在 WebServer中）的下一个连接。 在正常的CGI模式中，php-cgi.exe在此便退出了 Apache 模块MPM Multi Path Modules （多道处理模块）用于定义apache在响应多个用户请求时所工作的模型。有三种MPM模式： prefork（一个请求一个进程响应） worker（一个请求用一个线程响应，启动多个进程每个进程生成多个线程） event（一个进程处理多个请求） 以模块安装的php没有独立的进程，是作为apache的模块和apache一起启动的。 以上三种MPM模式，worker模式会比prefork模式占据更少的内存，高并发下的表现更好。而且使用多进程和多线程混合模式，即使有一个线程挂了，也只影响和该线程同进程的其他线程，不会影响到其他的进程。但是如果有特别多的线程都使用keep-alive的长连接方式，则线程会一直被占据直到超时才释放，导致在高并发场景下无可用线程。而event模式使用了一个专门的线程来处理这些keep-alive类线程，较好的解决了这个问题。 NginxNginx处理PHP文件 只有FastCGI 一种不过Nginx连接fastcgi的方式有2种：TCP和unix domain socketUnix domain socket 或者 IPC socket是一种终端，可以使同一台操作系统上的两个或多个进程进行数据通信。与管道相比，Unix domain sockets 既可以使用字节流和数据队列，而管道通信则只能通过字节流。Unix domain sockets的接口和Internet socket很像，但它不使用网络底层协议来通信。Unix domain socket 的功能是POSIX操作系统里的一种组件。Unix domain sockets 使用系统文件的地址来作为自己的身份。它可以被系统进程引用。所以两个进程可以同时打开一个Unix domain sockets来进行通信。不过这种通信方式是发生在系统内核里而不会在网络里传播。TCP和unix domain socket方式对比TCP是使用TCP端口连接127.0.0.1:9000Socket是使用unix domain socket连接套接字/dev/shm/php-cgi.sock（很多教程使用路径/tmp，而路径/dev/shm是个tmpfs，速度比磁盘快得多）测试机是个1核的centos5.4，2用户并发时系统资源消耗50%左右，10用户资源就跑得很满了 结论是在服务器压力不大的情况下，tcp和socket差别不大，但在压力比较满的时候，用套接字方式，效果确实比较好。下面是php 5.3以上版本将TCP改成socket方式的配置方法：修改php-fpm.conf（/usr/local/php/etc/php-fpm.conf）;listen = 127.0.0.1:9000listen = /dev/shm/php-cgi.sock修改nginx配置文件server段的配置，将http的方式改为socket方式 从原理上来说，unix socket方式肯定要比tcp的方式快而且消耗资源少，因为socket之间在nginx和php-fpm的进程之间通信，而tcp需要经过本地回环驱动，还要申请临时端口和tcp相关资源。当然还是从原理上来说，unix socket会显得不是那么稳定，当并发连接数爆发时，会产生大量的长时缓存，在没有面向连接协议支撑的情况下，大数据包很有可能就直接出错并不会返回异常。而TCP这样的面向连接的协议，多少可以保证通信的正确性和完整性。 3. PHP的执行模式有哪些 http://blog.csdn.net/xujingzhong0077/article/details/53316767 运行模式关于PHP目前比较常见的五大运行模式：1）CGI（通用网关接口/ Common Gateway Interface）2）FastCGI（常驻型CGI / Long-Live CGI）3）CLI（命令行运行 / Command Line Interface）4）Web模块模式（Apache等Web服务器运行的模式）5）ISAPI（Internet Server Application Program Interface） 备注：在PHP5.3以后，PHP不再有ISAPI模式，安装后也不再有php5isapi.dll这个文件。要在IIS6上使用高版本PHP，必须安装FastCGI 扩展，然后使IIS6支持FastCGI。 1.1、CGI模式CGI即通用网关接口（Common Gateway Interface），它是一段程序，通俗的讲CGI就象是一座桥，把网页和Web服务器中的执行程序连接起来，它把HTML接收的指令传递给服务器的执行程序，再把服务器执行程序的结果返还给HTML页。CGI 的跨平台性能极佳，几乎可以在任何操作系统上实现。CGI已经是比较老的模式了，这几年都很少用了。 每有一个用户请求，都会先要创建CGI的子进程，然后处理请求，处理完后结束这个子进程，这就是Fork-And-Execute模式。 当用户请求数量非常多时，会大量挤占系统的资源如内存，CPU时间等，造成效能低下。所以用CGI方式的服务器有多少连接请求就会有多少CGI子进程，子进程反复加载是CGI性能低下的主要原因。 如果不想把 PHP 嵌入到服务器端软件（如 Apache）作为一个模块安装的话，可以选择以 CGI 的模式安装。或者把 PHP 用于不同的 CGI 封装以便为代码创建安全的 chroot 和 setuid 环境。这样每个客户机请求一个PHP文件，Web服务器就调用php.exe（win下是php.exe,linux是php）去解释这个文件，然后再把解释的结果以网页的形式返回给客户机。 这种安装方式通常会把 PHP 的可执行文件安装到 web 服务器的 cgi-bin 目录。CERT 建议书 CA-96.11 建议不要把任何的解释器放到 cgi-bin 目录。 这种方式的好处是把Web Server和具体的程序处理独立开来，结构清晰，可控性强，同时缺点就是如果在高访问需求的情况下，CGI的进程Fork就会成为很大的服务器负担，想 象一下数百个并发请求导致服务器Fork出数百个进程就明白了。这也是为什么CGI一直背负性能低下，高资源消耗的恶名的原因。 1.2、FastCGI模式FastCGI是CGI的升级版本，FastCGI像是一个常驻 (long-live)型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去 Fork 一次 （这是 CGI 最为人诟病的 fork-and-execute 模式）。FastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等，同时，FastCGI也被许多脚本语言所支持，其中就有PHP。FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。 【原理】1）Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module)；2）FastCGI进程管理器自身初始化，启动多个CGI解释器进程 (可见多个php-cgi.exe或php-cig)并等待来自Web Server的连接；3）当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi；4）FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器（运行在 WebServer中）的下一个连接。在正常的CGI模式中，php-cgi.exe在此便退出了。 在CGI模式中，你可以想象 CGI通常有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部dll扩展并重初始化全部数据结构。使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接（Persistent database connection）可以工作。 备注：PHP的FastCGI进程管理器是PHP-FPM（PHP-FastCGI Process Manager）【优点】1）从稳定性上看，FastCGI是以独立的进程池来运行CGI，单独一个进程死掉，系统可以很轻易的丢弃，然后重新分配新的进程来运行逻辑；2）从安全性上看，FastCGI支持分布式运算。FastCGI和宿主的Server完全独立，FastCGI怎么down也不会把Server搞垮；3）从性能上看，FastCGI把动态逻辑的处理从Server中分离出来，大负荷的IO处理还是留给宿主Server，这样宿主Server可以一心一意作IO，对于一个普通的动态网页来说, 逻辑处理可能只有一小部分，大量的是图片等静态。 【缺点】 说完了好处，也来说说缺点。从我的实际使用来看，用FastCGI模式更适合生产环境的服务器。但对于开发用机器来说就不太合适。因为当使用 Zend Studio调试程序时，由于 FastCGI会认为 PHP进程超时，从而在页面返回 500错误。这一点让人非常恼火，所以我在开发机器上还是换回了 ISAPI模式。对某些服务器的新版本支持不好，对分布式负载均衡没要求的模块化安装是否是更好的选择。目前的FastCGI和Server沟通还不够智能，一个FastCGI进程如果执行时间过长会被当成是死进程杀掉重起，这样在处理长时间任务的时候很麻烦，这样做也使得FastCGI无法允许联机调试。因为是多进程，所以比CGI多线程消耗更多的服务器内存，PHP-CGI解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。 1.3 CLI模式 PHP-CLI是PHP Command Line Interface的简称，如同它名字的意思，就是PHP在命令行运行的接口，区别于在Web服务器上运行的PHP环境（PHP-CGI，ISAPI等）。 也就是说，PHP不单可以写前台网页，它还可以用来写后台的程序。 PHP的CLI Shell脚本适用于所有的PHP优势，使创建要么支持脚本或系统甚至与GUI应用程序的服务端，在Windows和Linux下都是支持PHP-CLI模式的。【优点】1）使用多进程，子进程结束以后，内核会负责回收资源；2）使用多进程，子进程异常退出不会导致整个进程Thread退出，父进程还有机会重建流程；3）一个常驻主进程，只负责任务分发，逻辑更清楚。 我们在Linux下经常使用”php –m”查找PHP安装了那些扩展就是PHP命令行运行模式；有兴趣的同学可以输入”php –h”去深入研究该运行模式。 1.4 模块模式 模块模式是以mod_php5模块的形式集成，此时mod_php5模块的作用是接收Apache传递过来的PHP文件请求，并处理这些请求，然后将处理后的结果返回给Apache。如果我们在Apache启动前在其配置文件中配置好了PHP模块（mod_php5）， PHP模块通过注册apache2的ap_hook_post_config挂钩，在Apache启动的时候启动此模块以接受PHP文件的请求。 除了这种启动时的加载方式，Apache的模块可以在运行的时候动态装载，这意味着对服务器可以进行功能扩展而不需要重新对源代码进行编译，甚至根本不需要停止服务器。我们所需要做的仅仅是给服务器发送信号HUP或者AP_SIG_GRACEFUL通知服务器重新载入模块。但是在动态加载之前，我们需要将模块编译成为动态链接库。此时的动态加载就是加载动态链接库。 Apache中对动态链接库的处理是通过模块mod_so来完成的，因此mod_so模块不能被动态加载，它只能被静态编译进Apache的核心。这意味着它是随着Apache一起启动的。 Apache是如何加载模块的呢？我们以前面提到的mod_php5模块为例。首先我们需要在Apache的配置文件httpd.conf中添加一行：LoadModule php5_module modules/mod_php5.so 这里我们使用了LoadModule命令，该命令的第一个参数是模块的名称，名称可以在模块实现的源码中找到。第二个选项是该模块所处的路径。如果需要在服务器运行时加载模块，可以通过发送信号HUP或者AP_SIG_GRACEFUL给服务器，一旦接受到该信号，Apache将重新装载模块，而不需要重新启动服务器。 该运行模式是我们以前在windows环境下使用apache服务器经常使用的，而在模块化（DLL）中，PHP是与Web服务器一起启动并运行的。（它是apache在CGI的基础上进行的一种扩展，加快PHP的运行效率）。 1.5 ISAPI模式 ISAPI（Internet Server Application Program Interface）是微软提供的一套面向Internet服务的API接口，一个ISAPI的DLL，可以在被用户请求激活后长驻内存，等待用户的另一个请求，还可以在一个DLL里设置多个用户请求处理函数，此外，ISAPI的DLL应用程序和WWW服务器处于同一个进程中，效率要显著高于CGI。（由于微软的排他性，只能运行于windows环境） PHP作为Apache模块，Apache服务器在系统启动后，预先生成多个进程副本驻留在内存中，一旦有请求出现，就立即使用这些空余的子进程进行处理，这样就不存在生成子进程造成的延迟了。这些服务器副本在处理完一次HTTP请求之后并不立即退出，而是停留在计算机中等待下次请求。对于客户浏览器的请求反应更快，性能较高。 4. PHP代码的执行流程 http://blog.csdn.net/a2534725767/article/details/55194582 12341.Scanning(Lexing) ,将PHP代码转换为语言片段(Tokens) 2.Parsing, 将Tokens转换成简单而有意义的表达式 3.Compilation, 将表达式编译成Opocdes 4.Execution, 顺次执行Opcodes，每次一条，从而实现PHP脚本的功能。 5. PHP与Golang的区别参考博文 对 Go 语言的综合评价 Go 语言的优势在哪里？ 我为什么放弃Go语言 php的优缺点 php优缺点 面试的时候基本上上面说到的都说到了一些但是面试的时候逻辑还是不够清晰 6. 深度优先遍历与广度优先遍历 http://www.cnblogs.com/biyeymyhjob/archive/2012/07/18/2596983.html a. DFS（1）访问顶点v；（2）从v的未被访问的邻接点中选取一个顶点w，从w出发进行深度优先遍历；（3）重复上述两步，直至图中所有和v有路径相通的顶点都被访问到。 b. BFS（1）顶点v入队列。（2）当队列非空时则继续执行，否则算法结束。（3）出队列取得队头顶点v；访问顶点v并标记顶点v已被访问。（4）查找顶点v的第一个邻接顶点col。（5）若v的邻接顶点col未被访问过的，则col入队列。（6）继续查找顶点v的另一个新的邻接顶点col，转到步骤（5）。 直到顶点v的所有未被访问过的邻接点处理完。转到步骤（2）。广度优先遍历图是以顶点v为起始点，由近至远，依次访问和v有路径相通而且路径长度为1，2，……的顶点。为了使“先被访问顶点的邻接点”先于“后被访问顶点的邻接点”被访问，需设置队列存储访问的顶点。 7. 浏览器输入一个URL之后发生了什么事情 http://www.cnblogs.com/wenanry/archive/2010/02/25/1673368.html 8. 遍历一个目录下面所有的文件以及文件夹 面试的时候写了一个DFS，一下被问到BFS怎么写的时候短路了，没有想起了，其实实现的方法不难，参考问题6 其实还有其他的问题，不过忘了三面[20min] 三面没有被问到技术细节 0. 自我介绍1. 简单的介绍了一个项目2. 在平时做项目的时候遇到的难点几个方面简单讲了一下，团队协作的难点，技术难点，心理难点 3. 团队合作当中如果碰到一个BUG，但是开发人员觉得不重要，你觉得重要怎么班？坚持不放过为底线，换位思考，以产品和用户的角度劝说开发 4. 对加班有什么看法？正常现象，完全可以接受 5. 为什么想去深圳？推荐文章（由hexo文章推荐插件驱动）招银网络面试总结招银网络面试总结Google面试经历-一]]></content>
      <tags>
        <tag>面试</tag>
        <tag>秋招</tag>
        <tag>百度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell排序]]></title>
    <url>%2Fpost%2F%E7%AE%97%E6%B3%95%2Fshell%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Shell 排序说明希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 步骤 设置间隔（传统间隔为 N/2） 插入排序 图片示例 程序示例传统实现12345678910111213141516171819202122//SortInt 传统shell排序,间隔为N/2//相邻间隔可能不互质，可能会出现前置排序无用的情况func SortInt(a []int) ([]int, int) &#123; n := 0 aLen := len(a) //定义间隔 for i := aLen / 2; i &gt; 0; i = i / 2 &#123; //插入排序 for j := i; j &lt; aLen; j++ &#123; tmp := a[j] k := j for ; k &gt;= i &amp;&amp; tmp &lt; a[k-i]; k = k - i &#123; a[k] = a[k-i] n++ &#125; a[k] = tmp &#125; &#125; return a, n&#125; Hibbard 算法1234567891011121314151617181920212223//SortHibbardInt Hibbard算法，间隔为2^k-1func SortHibbardInt(a []int) ([]int, int) &#123; n, i := 0, 0 aLen := len(a) for i = 1; i &lt;= aLen-1; i = i*2 + 1 &#123; &#125; //定义间隔 for ; i &gt; 0; i = (i - 1) / 2 &#123; // println(i) //插入排序 for j := i; j &lt; aLen; j++ &#123; tmp := a[j] k := j for ; k &gt;= i &amp;&amp; tmp &lt; a[k-i]; k = k - i &#123; a[k] = a[k-i] n++ &#125; a[k] = tmp &#125; &#125; return a, n&#125; 推荐文章（由hexo文章推荐插件驱动）冒泡排序堆排序归并排序快速排序插入排序排序算法]]></content>
      <tags>
        <tag>排序</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2Fpost%2F%E7%AE%97%E6%B3%95%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[说明堆积排序： 是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 步骤 建堆，建堆是不断调整堆的过程，从len/2处开始调整，一直到第一个节点，此处len是堆中元素的个数。建堆的过程是线性的过程，从len/2到0处一直调用调整堆的过程，相当于o(h1)+o(h2)…+o(hlen/2) 其中h表示节点的深度，len/2表示节点的个数，这是一个求和的过程，结果是线性的O(n)。 调整堆：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点i和它的孩子节点left(i),right(i)，选出三者最大(或者最小)者，如果最大（小）值不是节点i而是它的一个孩子节点，那边交互节点i和该节点，然后再调用调整堆过程，这是一个递归的过程。调整堆的过程时间复杂度与堆的深度有关系，是lgn的操作，因为是沿着深度方向进行调整的。 堆排序：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面len-1个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。堆排序过程的时间复杂度是O(nlgn)。因为建堆的时间复杂度是O(n)（调用一次）；调整堆的时间复杂度是lgn，调用了n-1次，所以堆排序的时间复杂度是O(nlgn)[2] 注意: 根节点在数组当中存放的位置是0，所以第i个节点的左孩子是2i+1,右孩子是2i+2 示例 实现12345678910111213141516171819202122232425262728293031323334package HeapSortimport ( "fmt")//HeapSort 堆排序func HeapSort(arr []int) &#123; LEN := len(arr) for i := LEN/2 - 1; i &gt;= 0; i-- &#123; HeapAjust(arr, i, LEN) &#125; for i := LEN - 1; i &gt; 0; i-- &#123; arr[i], arr[0] = arr[0], arr[i] HeapAjust(arr, 0, i) &#125;&#125;//HeapAjust 堆调整func HeapAjust(arr []int, start int, length int) &#123; tmp := arr[start] for i := 2*start + 1; i &lt; length; i = i * 2 &#123; if i+1 &lt; length &amp;&amp; arr[i] &lt; arr[i+1] &#123; i++ &#125; if tmp &gt; arr[i] &#123; break &#125; arr[start] = arr[i] start = i &#125; arr[start] = tmp&#125;推荐文章（由hexo文章推荐插件驱动）shell排序冒泡排序归并排序快速排序插入排序排序算法]]></content>
      <tags>
        <tag>排序</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2Fpost%2F%E7%AE%97%E6%B3%95%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[https://github.com/mohuishou/go-sort 说明快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来，且在大部分真实世界的数据，可以决定设计的选择，减少所需时间的二次方项之可能性。 步骤 从数列中挑出一个元素，称为 “基准”（pivot）， 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 注意: 基准点采用三元素原则法，三元素选择之后一头一尾就已经有序了 示例 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package quik//Sort 快速排序func Sort(arr []int) &#123; Quik(arr, 0, len(arr)-1)&#125;//Quik 快速排序递归实现func Quik(arr []int, left int, right int) &#123; if right-left &lt; 2 &#123; return &#125; p := middle3(arr, left, right) i := left + 1 j := right - 2 for &#123; for arr[i] &lt; p &#123; i++ &#125; for arr[j] &gt; p &#123; j-- &#125; if i &lt; j &#123; arr[i], arr[j] = arr[j], arr[i] &#125; else &#123; break &#125; &#125; arr[i], arr[right-1] = arr[right-1], arr[i] Quik(arr, left, i-1) Quik(arr, i+1, right)&#125;func middle3(arr []int, left int, right int) int &#123; center := (right + left) / 2 if arr[left] &gt; arr[center] &#123; arr[left], arr[center] = arr[center], arr[left] &#125; if arr[left] &gt; arr[right] &#123; arr[left], arr[right] = arr[right], arr[left] &#125; if arr[center] &gt; arr[right] &#123; arr[center], arr[right] = arr[right], arr[center] &#125; arr[center], arr[right-1] = arr[right-1], arr[center] return arr[right-1]&#125;推荐文章（由hexo文章推荐插件驱动）shell排序冒泡排序堆排序归并排序插入排序排序算法]]></content>
      <tags>
        <tag>排序</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2Fpost%2F%E7%AE%97%E6%B3%95%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序说明插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 步骤 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 图片示例 程序示例（go）12345678910111213141516171819202122//SortInt 插入排序func SortInt(a []int) ([]int, int) &#123; n := 0 aLen := len(a) //从i=1开始，第一个数不用排序，一个数相当于已经有序了 for i := 1; i &lt; aLen; i++ &#123; //取出新数（类似摸牌） tmp := a[i] //将新数和之前的数从后往前（从大到小）一次比较，如果新数更小,就将以前的数往后移一位 j := i for ; (j &gt; 0) &amp;&amp; (tmp &lt; a[j-1]); j-- &#123; n++ a[j] = a[j-1] //后移一位 &#125; //新数插入 a[j] = tmp &#125; return a, n&#125; 推荐文章（由hexo文章推荐插件驱动）shell排序冒泡排序堆排序归并排序快速排序排序算法]]></content>
      <tags>
        <tag>排序</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2Fpost%2F%E7%AE%97%E6%B3%95%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[https://github.com/mohuishou/go-sort 说明选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。 示例 实现123456789101112131415161718package selection//Sort 选择排序func Sort(arr []int) &#123; var LEN = len(arr) minIndex := 0 for i := 0; i &lt; LEN; i++ &#123; minIndex = i for j := i; j &lt; LEN; j++ &#123; if arr[minIndex] &gt; arr[j] &#123; minIndex = j &#125; &#125; if minIndex != i &#123; arr[minIndex], arr[i] = arr[i], arr[minIndex] &#125; &#125;&#125; 推荐文章（由hexo文章推荐插件驱动）shell排序冒泡排序堆排序归并排序快速排序排序算法]]></content>
      <tags>
        <tag>排序</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遗传算法]]></title>
    <url>%2Fpost%2F%E7%AE%97%E6%B3%95%2F%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[实现示例-Golanggithub 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159package GAimport ( "fmt" "math" "math/rand" "time")var ( groupSize int //种群大小 chromosomeSize int //染色体长度 selectRand float64 //轮盘选择概率 crossRand float64 //交叉概率 mutationRand float64 //变异概率 group []Person //种群 bestPerson Person //当前最好的个体 r *rand.Rand)//Person 个体type Person struct &#123; chromosome []int //染色体 value float64 //适应值&#125;//Init 初始化函数//初始化设置种群大小、轮盘选择概率、交叉概率已经变异的概率func Init(GroupSize, ChromosomeSize int, SelectRand, CrossRand, MutationRand float64) &#123; groupSize = GroupSize crossRand = CrossRand selectRand = SelectRand mutationRand = MutationRand chromosomeSize = ChromosomeSize r = rand.New(rand.NewSource(time.Now().UnixNano())) bestPerson.chromosome = make([]int, chromosomeSize)&#125;//InitGroup 初始化种群//根据种群大小随机产生一些个体填充func InitGroup() &#123; group = make([]Person, groupSize) for i := 0; i &lt; groupSize; i++ &#123; group[i].chromosome = make([]int, chromosomeSize) for j := 0; j &lt; chromosomeSize; j++ &#123; if r.Float64() &gt; selectRand &#123; group[i].chromosome[j] = 1 &#125; &#125; &#125;&#125;//Fitness 计算适应值func Fitness(person Person) float64 &#123; x := decode(person) return x + 10*math.Sin(5*x) + 7*math.Cos(4*x)&#125;//解码func decode(person Person) float64 &#123; var sum float64 //解码 for i := 0; i &lt; chromosomeSize; i++ &#123; //二进制染色体转十进制值 if person.chromosome[i] == 1 &#123; sum = sum + math.Pow(2.0, float64(i)) &#125; &#125; return sum * 9 / (math.Pow(2.0, 14.0) - 1)&#125;//Select 选择func Select() &#123; newGroup := make([]Person, groupSize) for i := 0; i &lt; groupSize; i++ &#123; newGroup[i].chromosome = make([]int, chromosomeSize) rnd := r.Float64() A: for j := 0; j &lt; groupSize; j++ &#123; if group[j].value &gt; rnd*bestPerson.value &#123; copy(newGroup[i].chromosome, group[j].chromosome) break A &#125; if j == groupSize-1 &#123; copy(newGroup[i].chromosome, bestPerson.chromosome) &#125; &#125; &#125; group = newGroup newGroup = nil&#125;//Cross 交叉func Cross() &#123; for i := 0; i &lt; groupSize; i = i + 2 &#123; if r.Float64() &lt; crossRand &#123; crossPosition := r.Intn(chromosomeSize - 1) if crossPosition == 0 || crossPosition == 1 &#123; continue &#125; //交叉 for j := crossPosition; j &lt; chromosomeSize; j++ &#123; tmp := group[i].chromosome[j] group[i].chromosome[j] = group[i+1].chromosome[j] group[i+1].chromosome[j] = tmp &#125; &#125; &#125;&#125;//Mutation 变异func Mutation() &#123; for i := 0; i &lt; groupSize; i++ &#123; if r.Float64() &lt; mutationRand &#123; mutationPosition := r.Intn(chromosomeSize - 1) //单点变异 if group[i].chromosome[mutationPosition] == 0 &#123; group[i].chromosome[mutationPosition] = 1 &#125; else &#123; group[i].chromosome[mutationPosition] = 0 &#125; &#125; &#125;&#125;//GA 遗传算法func GA() &#123; //初始化 Init(100, 14, 0.5, 0.6, 0.05) //初始化种群 InitGroup() //遗传循环 for i := 0; i &lt; 200; i++ &#123; //计算适应值 for j := 0; j &lt; groupSize; j++ &#123; group[j].value = Fitness(group[j]) //保存当前最好的个体 if group[j].value &gt; bestPerson.value &#123; copy(bestPerson.chromosome, group[j].chromosome) bestPerson.value = group[j].value fmt.Println("第", i, "代最好个体：", bestPerson.value, " ", decode(bestPerson)) &#125; &#125; //选择 Select() //交叉 Cross() //变异 Mutation() &#125;&#125;推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新记一次net http内存泄漏使用chromedp解决反爬虫问题使用Goland调试Go程序Httprouter介绍及源码阅读Go 语言的环境配置，然后试试种子爬虫黑科技]]></content>
      <tags>
        <tag>go</tag>
        <tag>算法</tag>
        <tag>遗传算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径算法SPFA]]></title>
    <url>%2Fpost%2F%E7%AE%97%E6%B3%95%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-SPFA%2F</url>
    <content type="text"><![CDATA[前面说了单源最短路径算法Dijkstra，以及多源最短路径算法Floyd，但是都不能适用于有负权边存在的情况，这里实现一下是西南交通大学段凡丁于1994年发表的SPFA（Shortest Path Faster Algorithm）算法。该算法在Bellman-ford算法的基础上加上一个队列优化，减少了冗余的松弛操作。 spfa可以适用于有负权边存在的情况，但是无法求解存在负权回路的情况，但是可以判断 原理只要最短路径存在，SPFA算法必定能求出最小值。证明：每次将点放入队尾，都是经过松弛操作达到的。换言之，每次的优化将会有某个点v的最短路径估计值d[v]变小。所以算法的执行会使d越来越小。由于我们假定图中不存在负权回路，所以每个结点都有最短路径值。因此，算法不会无限执行下去，随着d值的逐渐变小，直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。 实现githubBFS123456789101112131415161718192021222324252627282930313233343536373839q := list.New() q.PushBack(s) //循环跳出条件：队列为空 for q.Len() != 0 &#123; u := q.Front().Value.(Graph.VextexType) q.Remove(q.Front()) //释放对点u的标记 visited[u] = false e := graph.G[u].FisrtEdge for e != nil &#123; //这条边下的顶点 v := e.V //如果当前点的距离加上边的距离小于之前该点的距离，那么就更新该点的距离 if dist[v] &gt; dist[u]+e.Weight &#123; dist[v] = dist[u] + e.Weight //更新该点距离 path[v] = u //更新父节点 //如果顶点不在队内，则将顶点入队 if visited[v] == false &#123; q.PushBack(v) //将该点入队 visited[v] = true count[v]++ //出现负环，报错 if count[v] &gt; graph.VNum &#123; return errors.New("存在负环！") &#125; &#125; &#125; e = e.Next &#125; &#125; return nil DFS1234567891011121314151617181920212223242526visited[u] = true e := graph.G[u].FisrtEdge for e != nil &#123; v := e.V if dist[v] &gt; dist[u]+e.Weight &#123; dist[v] = dist[u] + e.Weight //更新该点距离 path[v] = u //更新父节点 if visited[v] == false &#123; count[v]++ if count[v] &gt; graph.VNum &#123; return errors.New("存在负环！") &#125; //注意DFS的结果不能直接return，直接return的时候回溯的时候就没有办法在上一级重新找值了 err := DFS(v) if err != nil &#123; return err &#125; &#125; else &#123; return nil &#125; &#125; e = e.Next &#125; visited[u] = false return nil推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新记一次net http内存泄漏使用chromedp解决反爬虫问题使用Goland调试Go程序Httprouter介绍及源码阅读Go 语言的环境配置，然后试试种子爬虫黑科技]]></content>
      <tags>
        <tag>go</tag>
        <tag>算法</tag>
        <tag>图</tag>
        <tag>最短路径</tag>
        <tag>spfa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径算法-Floyd]]></title>
    <url>%2Fpost%2F%E7%AE%97%E6%B3%95%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-Floyd%2F</url>
    <content type="text"><![CDATA[在上一篇当中讲了Dijkstra算法，Dijkstra适用于对于单源路径的求取，但是对于任意两个点之间的最小路径呢？首先想到的当然是直接使用多次的Dijkstra算法来求取任意两点之间的最短路径，但是这样下来时间复杂度会比较大，所以使用一种新的算法，Floyd算法来求取最短路径 原理Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释从任意节点i到任意节点j的最短路径不外乎2种可能: 1.直接从i到j， 2.从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。 算法描述：a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。 Golang实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package ShortestPathimport ( "errors" "github.com/mohuishou/algorithm/GraphMatrix")//Floyd 求取多源最短路径func Floyd(graph GraphMatrix.Graph, dist [][]GraphMatrix.EdgeType, path [][]int) error &#123; for i := 0; i &lt; graph.VNum; i++ &#123; for j := 0; j &lt; graph.VNum; j++ &#123; path[i][j] = -1 dist[i][j] = graph.G[i][j] &#125; &#125; //注意，k必须放在最外层，如果放在最里层会过早的确认两点的最短路径 for k := 0; k &lt; graph.VNum; k++ &#123; for i := 0; i &lt; graph.VNum; i++ &#123; for j := 0; j &lt; graph.VNum; j++ &#123; //找到更短的路径 if dist[i][k]+dist[k][j] &lt; dist[i][j] &#123; dist[i][j] = dist[i][k] + dist[k][j] //发现负值圈 if i == j &amp;&amp; dist[i][j] &lt; 0 &#123; return errors.New("存在负值圈") &#125; path[i][j] = k &#125; &#125; &#125; &#125; return nil&#125;//GetPathForFloyd 获取路径func GetPathForFloyd(path [][]int, s, t int) (tPath []int) &#123; tPath = make([]int, 1) tPath[0] = s for &#123; s = path[s][t] if s == -1 || s == t &#123; tPath = append(tPath, t) return tPath &#125; tPath = append(tPath, s) &#125;&#125;推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新记一次net http内存泄漏使用chromedp解决反爬虫问题使用Goland调试Go程序Httprouter介绍及源码阅读Go 语言的环境配置，然后试试种子爬虫黑科技]]></content>
      <tags>
        <tag>go</tag>
        <tag>算法</tag>
        <tag>图</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[邻接表-Golang]]></title>
    <url>%2Fpost%2F%E7%AE%97%E6%B3%95%2F%E9%82%BB%E6%8E%A5%E8%A1%A8-Golang%2F</url>
    <content type="text"><![CDATA[最简单直接的办法一般就是使用邻接矩阵的办法来表示图，但是对于稀疏图来说边的数目想对来说比较少的情况下，使用邻接矩阵的办法会比较浪费资源，所以这里采用邻接表 Githubhttps://github.com/mohuishou/algorithm/tree/master/Graph 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package Graphimport ( "bufio" "io" "os" "strconv" "strings")// EdgeType 边的权值类型type EdgeType int// VextexType 顶点类型定义type VextexType int// VextexDataType 顶点值类型定义type VextexDataType int//EdgeNode 边的节点type EdgeNode struct &#123; Weight EdgeType //权值 V VextexType //指向储存该顶点的下标 Next *EdgeNode //指向下一条边&#125;//VextexNode 顶点节点定义type VextexNode struct &#123; data VextexDataType //顶点的值 FisrtEdge *EdgeNode //该顶点指向的第一条边&#125;//Graph 图type Graph struct &#123; VNum, ENum int //顶点数目，边数目 G []VextexNode //邻接表&#125;//CreateGraph 创建邻接表func CreateGraph(VNum int) (graph Graph) &#123; graph.VNum = VNum graph.G = make([]VextexNode, VNum) for i := 0; i &lt; VNum; i++ &#123; graph.G[i] = VextexNode&#123;&#125; &#125; return graph&#125;//AddEdge 添加边func (graph Graph) AddEdge(s, t VextexType, weight EdgeType) &#123; edge := &amp;EdgeNode&#123;V: t, Weight: weight&#125; //添加边到头部 edge.Next = graph.G[s].FisrtEdge graph.G[s].FisrtEdge = edge&#125;//BuildGraph 通过读取文件建图//文件格式要求://顶点个数 边数//顶点v1 顶点V2 边的权重//...func BuildGraph(path string) (graph Graph) &#123; f, err := os.Open(path) if err != nil &#123; panic(err) &#125; buf := bufio.NewReader(f) i := 0 //边的数目 for &#123; line, err := buf.ReadString('\n') if err != nil &#123; if err == io.EOF &#123; return graph &#125; panic(err) &#125; line = strings.TrimSpace(line) data := strings.Split(line, " ") if i == 0 &#123; n, err := strconv.Atoi(data[0]) if err != nil &#123; panic(err) &#125; graph = CreateGraph(n) graph.ENum, err = strconv.Atoi(data[1]) if err != nil &#123; panic(err) &#125; &#125; else if i &lt;= graph.ENum &#123; s, err := strconv.Atoi(data[0]) if err != nil &#123; panic(err) &#125; t, err := strconv.Atoi(data[1]) if err != nil &#123; panic(err) &#125; weight, err := strconv.Atoi(data[2]) if err != nil &#123; panic(err) &#125; graph.AddEdge(VextexType(s), VextexType(t), EdgeType(weight)) &#125; i++ &#125;&#125;推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新记一次net http内存泄漏使用chromedp解决反爬虫问题使用Goland调试Go程序Httprouter介绍及源码阅读Go 语言的环境配置，然后试试种子爬虫黑科技]]></content>
      <tags>
        <tag>go</tag>
        <tag>算法</tag>
        <tag>图</tag>
        <tag>邻接表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径算法-Dijkstra]]></title>
    <url>%2Fpost%2F%E7%AE%97%E6%B3%95%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-Dijkstra%2F</url>
    <content type="text"><![CDATA[算法描述 这个算法是通过为每个顶点 v 保留目前为止所找到的从 s 到 v 的最短路径来工作的。初始时，原点 s 的路径权重被赋为 0 （d[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把 d[m]设为 w（s, m）,同时把所有其他（s 不能直接到达的）顶点的路径长度设为无穷大，即表示我们不知道任何通向这些顶点的路径（对于所有顶点的集合 V 中的任意顶点 v， 若 v 不为 s 和上述 m 之一， d[v] = ∞）。当算法结束时，d[v] 中存储的便是从 s 到 v 的最短路径，或者如果路径不存在的话是无穷大。边的拓展是 Dijkstra 算法的基础操作：如果存在一条从 u 到 v 的边，那么从 s 到 v 的最短路径可以通过将边（u, v）添加到尾部来拓展一条从 s 到 v 的路径。这条路径的长度是 d[u] + w(u, v)。如果这个值比目前已知的 d[v] 的值要小，我们可以用新值来替代当前 d[v] 中的值。拓展边的操作一直运行到所有的 d[v] 都代表从 s 到 v 的最短路径的长度值。此算法的组织令 d[u] 达到其最终值时，每条边（u, v）都只被拓展一次。算法维护两个顶点集合 S 和 Q。集合 S 保留所有已知最小 d[v] 值的顶点 v ，而集合 Q 则保留其他所有顶点。集合 S 初始状态为空，而后每一步都有一个顶点从 Q 移动到 S。这个被选择的顶点是 Q 中拥有最小的 d[u] 值的顶点。当一个顶点 u 从 Q 中转移到了 S 中，算法对 u 的每条外接边 (u, v) 进行拓展。 如下图： 代码实现-Golanggithub 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package ShortestPathimport ( "errors" "container/list" "github.com/mohuishou/algorithm/Graph")//INF 无穷大const INF = 0xffffff//Dijkstra 算法//一种求单源最短路径的算法func Dijkstra(graph Graph.Graph, s Graph.VextexType, dist []Graph.EdgeType, path []Graph.VextexType) &#123; visited := make([]bool, graph.VNum) //初始化 for i := 0; i &lt; graph.VNum; i++ &#123; dist[i] = INF //距离为无穷大 path[i] = -1 //没有上一个节点 visited[i] = false &#125; path[s] = s dist[s] = 0 //使用list实现一个队列操作 q := list.New() //将点s入队 q.PushBack(s) for q.Len() != 0 &#123; u := q.Front().Value.(Graph.VextexType) q.Remove(q.Front()) //如果该点周围的点已经走过，则无需再走 if visited[u] &#123; continue &#125; //将该点加入已观察 visited[u] = true e := graph.G[u].FisrtEdge for e != nil &#123; //这条边下的顶点 v := e.V //如果该点尚未走过，并且当前点的距离加上边的距离小于之前该点的距离，那么就更新该点的距离 if visited[v] == false &amp;&amp; dist[v] &gt; dist[u]+e.Weight &#123; dist[v] = dist[u] + e.Weight //更新该点距离 path[v] = u //更新父节点 q.PushBack(v) //将该点入队 &#125; e = e.Next &#125; &#125;&#125;//GetPath 通过路径获得到指定目的节点的路径func GetPath(path []Graph.VextexType, t Graph.VextexType) ([]Graph.VextexType, error) &#123; tPath := make([]Graph.VextexType, 0) for &#123; tPath = append(tPath, t) if path[t] == -1 &#123; return nil, errors.New("不存在到该节点的路径") &#125; if t == path[t] &#123; return tPath, nil &#125; t = path[t] &#125;&#125; 推荐文章（由hexo文章推荐插件驱动）GORM避坑指南之含关联关系的更新记一次net http内存泄漏使用chromedp解决反爬虫问题使用Goland调试Go程序Httprouter介绍及源码阅读Go 语言的环境配置，然后试试种子爬虫黑科技]]></content>
      <tags>
        <tag>go</tag>
        <tag>算法</tag>
        <tag>华为软挑</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为软挑2017]]></title>
    <url>%2Fpost%2Fnotes%2F%E5%8D%8E%E4%B8%BA%E8%BD%AF%E6%8C%912017%2F</url>
    <content type="text"><![CDATA[稍稍总结一下最近差不多几天的心路历程，虽然最后没有拿到名次，但是从最开始的连最短路径是什么都不知道，到现在的已经可以利用遗传算法+最小费用最大流算法求出一些可行的解，就短短的不到一周的时间，学习到了可以说之前一个学期也未必能够学习到的知识。 这两天会把最近学到的相关知识记录到博客当中，在这儿暂且先列一个大纲： 最短路径问题 Dijkstra Floyd SPFA 相关问题 最大流问题 最小费用最大流问题 启发式算法 遗传算法 模拟退火算法 粒子群算法 上面都是在这个过程当中用到了的一些算法或者是一些问题的解决方案，但是在对于这个具体的问题解决的时候还要做出一些具体的调整，直接套用是不会出结果的。 但是大体的思路就是启发式算法确定服务器节点的数目以及位置，然后用最小费用最大流得到花费以及结果路径。 推荐文章（由hexo文章推荐插件驱动）最短路径算法-Dijkstra最短路径算法-Floyd最短路径算法SPFA遗传算法邻接表-Golanghorner算法及其实现代码]]></content>
      <tags>
        <tag>算法</tag>
        <tag>华为软挑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用vbox在win下搭建linux开发环境]]></title>
    <url>%2Fpost%2Fnotes%2F%E5%88%A9%E7%94%A8vbox%E5%9C%A8win%E4%B8%8B%E6%90%AD%E5%BB%BAlinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[之前一直在用 deepin，但是最近因为要使用 win 下的一些软件就直接切到 win 了，想了想可不可以直接搭建一个 linux 环境，在 windows 下编码呢第一次尝试的是 docker 的方案，但是最后放弃了，因为 docker 利用 vbox 建立的虚拟机启动的时候是不是的会出现问题然后就重建，十分的不稳定。所以这次直接使用虚拟机搭建 准备工具 ubuntu-16.04-server-amd64.iso (只需要开发环境，所以使用 server 就行不需要桌面版) vbox 5.1.10（我使用的最新版） 安装1.安装 VBox 不再赘述，直接默认就行，最好不要安装在 C 盘。如果有问题可以参见网上的其他教程 2.安装 UbuntuServer16.04 做了几个动图 3.设置网卡 VBox 默认使用 NAT 模式，但是这个模式下主机是 ping 不通虚拟机的，所以新建一个 host-only 网卡，使用双网卡，一个 NAT 用于上网，一个 host-only 用于和主机相连，之后直接用 xshell 连接，虚拟机后台打开就行了。 进入虚拟机，使用ifconfig命令发现只有一张网卡ifconfig -a发现还有一张网卡enp0s8未连接上 输入sudo vi /etc/network/interfaces 新增下面几行 保存重启 ifconfig 查看一共出现三个网卡使用主机 ping 虚拟机可以 ping 通 4.安装 ssh 服务端 12sudo apt-get updatesudo apt-get install openssh-server 安装之后就可以使用 xshell 等工具直接连接虚拟机了 5.共享文件夹 (1).需要先安装 vbox 增强组件 a.安装增强组件前需要先装一些依赖 12sudo apt-get install aptitudesudo aptitude install build-essential linux-headers-$(uname -r) -y b.点击 vbox 的菜单，添加增强功能 c.挂载光盘 1sudo mount /dev/cdrom /mnt d.安装增强功能 12cd /mntsudo ./VBoxLinuxAdditions.run 安装成功，重启 (2).挂载磁盘 a.在 VBox 主界面-&gt;选中虚拟机-&gt;设置-&gt;共享文件夹-&gt;添加共享文件夹 b.假设命名共享文件夹为 www 12sudo mkdir /wwwsudo mount -t vboxsf www /www 挂载成功 启动之前的启动都是有界面的，之后使用的时候希望不出现界面直接后台运行，我们使用 xshell 连接就好复制下面的代码，新建一个 UbuntuServer.bat 粘贴进去，以后直接点击这个脚本就行了 1%VBOX_MSI_INSTALL_PATH%VBoxManage startvm ubuntu --type headless END到这儿整个流程就结束了，之后可以根据需求添加软件或者是环境，例如 lnmp、node、golang、java、gcc 等等 推荐文章（由hexo文章推荐插件驱动）linux下天翼飞扬认证上网的一个解决方法《Linux就该这么学》读书笔记·〇]]></content>
      <tags>
        <tag>linux</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在windows安装dockertool，并且配置文件夹共享]]></title>
    <url>%2Fpost%2Fnotes%2F%E5%9C%A8windows%E5%AE%89%E8%A3%85dockertool%EF%BC%8C%E5%B9%B6%E4%B8%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%B9%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[今天折腾了好久，终于好了，但是还是有点小遗憾。 实现下面几个点 安装 dockertool(通过 boot2docker 以及 vbox 驱动) 使用 kitematic 可视化管理 和 windows 本地共享文件夹 安装 dockertool下载 dockertool地址一：daocloud 加速地址二：github 安装双击文件安装即可，可以更改安装位置的选项，其余默认即可如果电脑上已经安装了 vbox 将不会再安装，如果没有 vbox 将在 C 盘安装 VBox，如果不想安装到 C 盘可以提前安装 使用 kitematic 可视化管理docker ToolBox 自带 kitematic 可以直接打开注意： 如果设置了环境变量 MACHINE_STORAGE_PATH，更改了虚拟机的默认保存位置，kitematic 可能会打不开，并且启动报错：Error: write EPROTO暂时没有找到可行的解决方案，但是这样只有 kitematic 不能使用，docker 没有影响 使用加速器在不使用加速器的情况下，会自动的向 docker hub 拉取镜像，但是国内的访问 docker hub 的速度实在是有些慢，这里我使用daoclou的加速器打开 powershell 1234docker-machine ssh defaultsudo sed -i &quot;s|EXTRA_ARGS=&apos;|EXTRA_ARGS=&apos;--registry-mirror=加速地址 |g&quot; /var/lib/boot2docker/profileexitdocker-machine restart default 第一行：连接 ssh，进入虚拟机第二行：添加加速器地址第三行：退出虚拟机第四行：重启虚拟机 也可以使用 xshell 等软件连接之后直接输入 1sudo sed -i &quot;s|EXTRA_ARGS=&apos;|EXTRA_ARGS=&apos;--registry-mirror=加速地址 |g&quot; /var/lib/boot2docker/profile 然后在退出连接，在本机环境下重启 docker-machine 1docker-machine restart default 共享文件夹共享文件夹有两种方式，一种是使用 vbox 与主机共享文件夹然后在让 docker 与 boot2docker 虚拟机共享，第二种是创建一个 samba 服务。我这里使用第一种。 1.首先在 vbox 当中添加共享文件夹 2.然后进入 powershell 或者其他的 shell 软件 进入虚拟机(不要直接在 vbox 当中进入，直接进入可能会创建失败) 1docker-machine ssh default 挂载文件夹 12sudo mkdir /wwwsudo mount -t vboxsf www /www www 是在 vbo 共享文件夹设置的，/www 是在虚拟机中新建的 文件夹挂载成功之后就可以创建 docker 了，但是注意不能直接在 kitematic 当中创建，kitematic 当中只能挂载C\user下的目录，所以只能手动创建 docker 容器例如： 1docker run -d -P --name web -v /www:/www webdevops/php-apache-dev 推荐文章（由hexo文章推荐插件驱动）docker镜像瘦身&优化docker build 相关疑问解惑]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在laravel/lumen之外使用Eloquent]]></title>
    <url>%2Fpost%2Fphp%2F%E5%9C%A8laravel-lumen%E4%B9%8B%E5%A4%96%E4%BD%BF%E7%94%A8Eloquent%2F</url>
    <content type="text"><![CDATA[这周刚做完学校的一个智能硬件比赛的作品，我负责后端服务器，以及配套App的制作。整个一块都用socket进行数据传输，但是其中涉及到的数据库的操作，最近lumen用的比较多，觉得它的数据库的组件特别方便，所以就想看看能不能单独拿出来使用。 经过一番查找资料，主要分为两步进行 安装相应的数据库包这里使用5.2的包，可以更具自己的需求进行更换1composer require illuminate/database ~5.2 设置启动文件(start.php)这里将配置文件与启动文件分开，也可以合并在一起。我直接使用了一个php文件返回数组，也可以引入vlucas/phpdotenv使用.env文件来配置变量 start.php12345678910111213141516171819202122&lt;?php/** * Created by mohuishou&lt;1@lailin.xyz&gt;. * User: mohuishou&lt;1@lailin.xyz&gt; * Date: 2016/11/14 0014 * Time: 18:50 */$database = require_once "config.php";use Illuminate\Container\Container;use Illuminate\Database\Capsule\Manager as Capsule;$capsule = new Capsule;// 创建链接$capsule-&gt;addConnection($database);// 设置全局静态可访问DB$capsule-&gt;setAsGlobal();// 启动Eloquent$capsule-&gt;bootEloquent(); config.php1234567891011121314151617&lt;?php/** * Created by PhpStorm. * User: lxl * Date: 16-11-17 * Time: 下午8:38 */return [ 'driver' =&gt; 'mysql', 'host' =&gt; "localhost", 'database' =&gt; "smart_lock", 'username' =&gt; "root", 'password' =&gt; "mima", 'charset' =&gt; 'utf8', 'collation' =&gt; 'utf8_unicode_ci', 'prefix' =&gt; "",]; 推荐文章（由hexo文章推荐插件驱动）迁移laravel框架项目到虚拟主机Laravel思维导图之Laravel入门指南]]></content>
      <tags>
        <tag>laravel</tag>
        <tag>lumen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java笔记1]]></title>
    <url>%2Fpost%2Fnotes%2Fjava%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[java初学笔记，随手记录 单引号表示字符char类型(不常用)，双引号才是字符串 float类型后面要添加f3.14f(不常用)，不添加后缀默认为double final表示常量，static final表示类常量 位运算 与：&amp; 或：| 非：~ 异或：^ 左移：&lt;&lt; 右移：&gt;&gt; 不要把布尔值强制转换为任何的其他数值，如果要转换为int，可以使用三元运算符b ? 1:0 数组的命名 int[] a(更常用) int a[] 数组必须先初始化才能使用，没有初始化的数组不能使用 int[] a=new int[100] 命令行参数 1public static void main(String[] args) &#123;&#125; main函数的参数，args接受来自命令行的参数，每一个空格是一个参数，但是程序文件名不包含在内 推荐文章（由hexo文章推荐插件驱动）java中字符串相等的判断Spring-Boot启动类SpringApplication解析]]></content>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一键迁移typecho到hexo]]></title>
    <url>%2Fpost%2Fnotes%2F%E4%B8%80%E9%94%AE%E8%BF%81%E7%A7%BBtypecho%E5%88%B0hexo%2F</url>
    <content type="text"><![CDATA[为了更好的写博客，最近打算把博客静态化，发现了node写的hexo。顺便也可以直接利用github和coding的pages来搭建博客同时把之前闲置的未备案域名lailin.xyz利用起来. 写了一个php的typecho一键转换的小程序:github 支持： 文档一键转存为md文件 字符编码转换（gbk=&gt;utf8） 图片/附件一键转存到本地 图片/附件一键转存到七牛云 使用说明：下载12git clone https://github.com/mohuishou/typecho2hexo.gitcomposer install 修改配置文件复制config.example.php并重命名为config.php123456789101112131415161718192021222324&lt;?phpreturn [ "db"=&gt;[ "host"=&gt;"localhost", //数据库地址 "port"=&gt;3306, //端口号 "name"=&gt;"typecho", //数据库 "user"=&gt;"root", //数据库用户名 "password"=&gt;"", //数据库密码 "prefix"=&gt;"typecho" //表前缀 ], "is_gbk"=&gt;false, //是否开启gbk转utf8（有些数据库里面储存的不是utf8格式需要开启这个选项） //附件相关 "attachment"=&gt;[ "is_download"=&gt;true, //是否下载附件 "type"=&gt;"file" //附件保存类型：file 或者 qiniu ], //七牛云储存相关 "qiniu"=&gt;[ "access_key"=&gt;"", "secret_key"=&gt;"", "bucket_name"=&gt;"blog", //七牛空间名 "domain"=&gt;"http://" //七牛外链域名，必须设置,带http:// ]]; 运行1php index.php //命令行 说明1.如果出现上传错误，附件下载使用curl，下载时间最长为60s，如果有比较大的文件或者是网路环境不好，请手动更改一下Lib/Attachment.php，当中的文件最长下载时间123456789101112131415protected function download($url,$filename,$dir)&#123; $path=$dir."/".$filename; $ch=curl_init(); $timeout=60; //文件最长下载时间 curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_FOLLOWLOCATION,1); curl_setopt($ch,CURLOPT_RETURNTRANSFER,1); curl_setopt($ch,CURLOPT_CONNECTTIMEOUT,$timeout); $res=curl_exec($ch); curl_close($ch); //检查文件夹是否存在 if(!file_exists($dir)) mkdir($dir); file_put_contents($path,$res); return $path;&#125; 推荐文章（由hexo文章推荐插件驱动）四川大学评教开源代码Composer上线前的优化CoreThink图片轮播插件【ImageSlider】Corethink瀑布流插件nginx-php报502错误PHP函数setcookie写入重名cookie]]></content>
      <tags>
        <tag>php</tag>
        <tag>hexo</tag>
        <tag>typecho</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在deepin下安装shadowsocks-qt5]]></title>
    <url>%2Fpost%2Fnotes%2F%E5%9C%A8deepin%E4%B8%8B%E5%AE%89%E8%A3%85shadowsocks-qt5%2F</url>
    <content type="text"><![CDATA[在deepin下安装ss-qt5 官网的文档上Ubuntu可以通过添加私有源的方式安装，deepin不行，我们这里需要直接从源码编译安装。 准备工作检查下面两个软件是否已经安装，deepin自带的没有安装上 git g++ 下载源代码1git clone https://github.com/shadowsocks/shadowsocks-qt5.git wiki地址：https://github.com/shadowsocks/shadowsocks-qt5/wiki 编译安装1.按照wiki进行安装 1sudo apt-get install qt5-qmake qtbase5-dev libqrencode-dev libqtshadowsocks-dev libappindicator-dev libzbar-dev libbotan1.10-dev 会出现错误，没有libqtshadowsocks-dev这个软件包，所以这个包我们也需要自行编译 2.下载libqtshadowsocks-dev源代码 1git clone https://github.com/shadowsocks/libQtShadowsocks.git 3.安装编译所需的其他组件 1sudo apt-get install qt5-qmake qtbase5-dev libqrencode-dev libappindicator-dev libzbar-dev libbotan1.10-dev 4.编译libqtshadowsocks-dev 12cd libQtShadowsocksdpkg-buildpackage -uc -us -b 编译成功之后会在上一级目录发现三个deb包（安装后两个）： 123shadowsocks-libqtshadowsocks_1.9.0-1_amd64.deblibqtshadowsocks-dev_1.9.0-1_amd64.deblibqtshadowsocks_1.9.0-1_amd64.deb 5.安装所需的deb包(注意顺序) 12sudo dpkg -i libqtshadowsocks_1.9.0-1_amd64.debsudo dpkg -i libqtshadowsocks-dev_1.9.0-1_amd64.deb 6.编译shadowsocks-qt5 12cd shadowsocks-qt5dpkg-buildpackage -uc -us -b 编译完成之后会在上一级目录出现一个deb包shadowsocks-qt5_2.7.0-1_amd64.deb，版本不同包名可能会有一些小的区别 7.安装试试shadowsocks-qt5 1sudo dpkg -i shadowsocks-qt5_2.7.0-1_amd64.deb 大功告成，最后在启动器里面就可以看到ss-qt5的图标了，最后给出上面提到的我编译成功的相关软件包，不保证有用^^]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ss</tag>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四川大学锐捷windows解除多网卡限制]]></title>
    <url>%2Fpost%2Fnotes%2F%E5%9B%9B%E5%B7%9D%E5%A4%A7%E5%AD%A6%E9%94%90%E6%8D%B7windows%E8%A7%A3%E9%99%A4%E5%A4%9A%E7%BD%91%E5%8D%A1%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[序 搬到望江校区之后校园网快了好多，但是需要锐捷认证，锐捷这个坑货需要限制多网卡，而且程序的占用实在太大，十分的不方便。使用 wifi 共享软件可以开启 wifi 热点，但是会出现连接没多久没网的情况 我使用的锐捷版本是 v4.96 解决的问题理论上说多网卡限制的问题都可以解决掉： wifi 热点共享 VPN（FQ） 虚拟机 host-only 使用方法1.首先你已经安装了锐捷的客户端并且使用其可以认证上网 更新：可以尝试直接从第五步开始，因为我发现好像直接结束掉网其实也不会掉 2.然后下载 mentohust win 版本（点击下载） 3.mentohust 的使用方法网上有很多了这里不在赘述，百度经验 4.需要注意这里有不一样的地方，直接按照上面链接的方法是没有办法认证成功的，在设置好之后点击认证前，需要先使用锐捷成功认证上网，然后再使用这个软件认证 5.认证成功之后打开任务管理器，找到 8021.exe 这个进程干掉就可以了 6.然后使用 win10 自带的移动热点也可以开启热点不需要单独下载 wifi 共享软件(如果没有，使用 wifi 软件,测试猎豹 wifi 还是会出现没有网的情况 或者直接用命令行开启也是可以的) 推荐文章（由hexo文章推荐插件驱动）office2016激活工具phpstrom10激活方法（JetBrains系列软件激活）phpstrom9可用注册码一枚使用chromedp解决反爬虫问题四川大学评教开源代码使用 Mentohust 代替锐捷进行校园网认证]]></content>
      <categories>
        <category>大学</category>
      </categories>
      <tags>
        <tag>破解</tag>
        <tag>四川大学</tag>
        <tag>锐捷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php设计模式（一）工厂模式]]></title>
    <url>%2Fpost%2Fphp%2Fphp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[PHP设计模式（一）工厂模式 最近会简单的自我总结一些php当中的一些设计模式，当然个人才疏学浅，可能些不对的地方望各位看官见谅指正 是什么？工厂模式是一种创建型的模式，简单的说就是用来创建对象的 为什么？我们一般最普通的创建对象的方式是这样new classname(),但是换位想一下，这样创建对象的时候我们必须要知道类名，但是我们考虑一下下面几个情况： 如果我们不知道类名呢？ 如果我在很多个文件当中都用到了这个类创建对象，new了很多次，但是在重构或者其他什么情况的时候我要修改类名怎么半？当然有人会说怎么会修改类名，这是有可能会遇到的，那说一一下常见一点的，如果我给这个类的构造方法加了，或者是少了一个参数？那岂不是得一个个的去改 我现在有一个抽象的基类，由它派生了很多子类，我不知道后面还会不会添加其他的子类 上面几个都是可能会遇到的一些情况之一，使用工厂模式可以比较好的解决上面的问题 怎么办？简单工厂模式12345678910111213&lt;?php class Food&#123; //todo &#125; class FoodFactory&#123; static public function create()&#123; return new food(); &#125; &#125; $food= FoodFactory::create(); 上面实现简单工厂模式,FoodFactory这个类很简单只有一个创建方法，返回food类的实例，当然也可以发现这个方法很笨拙，只能实现一个对象的创建，感觉比直接new一个对象好不了多少，只是方便改动而已 工厂方法模式123456789101112class FoodFactory&#123; static public function create($classname)&#123; if(include_once 'class/' . $classname . '.php')&#123; return new $classname; &#125; else &#123; throw new Exception('Driver not found'); &#125; &#125; &#125; 通过上面的方法我们发现我们已经可以不局限于，创建一个固定的类的对象了但是要注意的是：如果我们使用了命名空间的话，在动态实例化类的时候必须包含完整的命名空间，提前use或者处于统一命名空间都是没有用的 1234567891011121314&lt;?phpnamespace Mohuishou\Lib; class FoodFactory&#123; static public function create($classname)&#123; if(include_once 'class/' . $classname . '.php')&#123; $classname="Mohuishou\Lib\\".$classname; return new $classname; &#125; else &#123; throw new Exception('Driver not found'); &#125; &#125; &#125; 如果我们还想传入参数呢？123456789101112&lt;?phpnamespace Mohuishou\Lib;class FoodFactory&#123; static public function create($classname,$params)&#123; if(include_once 'class/' . $classname . '.php')&#123; $classname="Mohuishou\Lib\\".$classname; return new $classname($params); &#125; else &#123; throw new Exception('Driver not found'); &#125; &#125;&#125; 如果我们不知道类名，不知道方法，怎么办?怎么实现一个一般的工厂模式？ 这里可能需要用到反射的概念了，这篇就不过多赘述 推荐文章（由hexo文章推荐插件驱动）一键迁移typecho到hexo四川大学评教开源代码Composer上线前的优化CoreThink图片轮播插件【ImageSlider】Corethink瀑布流插件PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四川大学望江校区使用mentohust认证上网]]></title>
    <url>%2Fpost%2Fnotes%2F%E5%9B%9B%E5%B7%9D%E5%A4%A7%E5%AD%A6%E6%9C%9B%E6%B1%9F%E6%A0%A1%E5%8C%BA%E4%BD%BF%E7%94%A8mentohust%E8%AE%A4%E8%AF%81%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[序 刚刚解决完天翼飞扬的上网问题，结果就搬校区了，按照上一篇文章的方法在这边也是可以用的，但是校园网使用的锐捷认证已经提供了 linux 的客户端了，所以就没有必要那么麻烦了。但是在信息管理中心下载的客户端简直无语，客户端必须要禁用双网卡，而且连接的的时候会先把你的网络服务给关闭掉。。。但是有时候有开不了。如果不手动禁用掉无线网卡，认证成功之后 3 分钟之内必掉 mentohust 还好有 mentohust 这个神器，但是使用当中还是有一点小坑 1.首先下载安装 mentohust 官方地址:https://code.google.com/archive/p/mentohust/downloads 官方的要翻墙，这儿提供一个 ubuntu/debian 的mentohust_0.3.4-1-2_i386.deb 2.然后在四川大学信息管理中心下载锐捷 4.96 版本，解压提取8021x.exe,W32N55.dll,SuConfig.dat移动到/etc/mentohust 3.在经历一个一个尝试之后的可用模式 1sudo mentohust -u用户名 -p密码 -a0 -d2 -b2 -v4.96 -w //下次使用的时候直接使用sudo mentohust就可以了 注意：如果显示认证成功但是无法上网，试一试先关闭有线网络的连接然后再打开，然后马上输入上面的命令，即可。拔插网线也可以 推荐文章（由hexo文章推荐插件驱动）使用chromedp解决反爬虫问题四川大学评教开源代码四川大学锐捷windows解除多网卡限制]]></content>
      <categories>
        <category>大学</category>
      </categories>
      <tags>
        <tag>四川大学</tag>
        <tag>mentohust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下天翼飞扬认证上网的一个解决方法]]></title>
    <url>%2Fpost%2Fnotes%2Flinux%E4%B8%8B%E5%A4%A9%E7%BF%BC%E9%A3%9E%E6%89%AC%E8%AE%A4%E8%AF%81%E4%B8%8A%E7%BD%91%E7%9A%84%E4%B8%80%E4%B8%AA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 博主尝试过许多的方法一直没有解决这个问题，例如：虚拟机桥接 ，crossover、wine 模拟，很早以前的 linux 版本等等，最后都没有成功，但是当要搬校区，不再使用这个客户端的前一天晚上，突发奇想结果解决了…. 理论上该方法对于所有需要认证的上网客户端有效 准备工作1.安装 virtualbox 2.下载 windows 镜像，博主使用 xp 开始设置1.首先安装 windows 虚拟机,虚拟机设置: 内存随意，可以在测试好之后，设置为能够正常运行的最小内存，我先使用的是 512M 网卡，设置两张网卡，一个使用桥接，桥接到连接宽带的有限网络上，另一个使用 host-only 用于组建局域网 2.在虚拟机中使用宽带的客户端拨号上网 3.查看局域网地址 虚拟机当中使用ipconfig命令 主机当中使用ifconfig命令 如图所示 4.在虚拟机当中使用服务器代理软件，然后主机实现代理上网，楼主使用的 TGate TGate 设置如图所示 5.在主机设置代理上网 可以设置全局代理，但是博主的 deepin 全局代理好像有点问题，所以就先设置 chrome 的代理了 如图所示 楼主到此已经可以使用了 推荐文章（由hexo文章推荐插件驱动）利用vbox在win下搭建linux开发环境《Linux就该这么学》读书笔记·〇]]></content>
      <categories>
        <category>大学</category>
      </categories>
      <tags>
        <tag>天翼飞扬</tag>
        <tag>linux</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迁移laravel框架项目到虚拟主机]]></title>
    <url>%2Fpost%2Fphp%2F%E8%BF%81%E7%A7%BBlaravel%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[序laravel版本：5.2虚拟主机：万网 迁移1.先把所有文件复制到网站根目录2.由于访问的时候入口文件在public目录下面，这时候访问url会变成url/public/，重写规则跳转就行了,在根目录新建.hatcess文件12345&lt;IfModule mod_rewrite.c&gt; RewriteEngine on RewriteCond %&#123;REQUEST_URI&#125; !^public RewriteRule ^(.*)$ public/$1 [L]&lt;/IfModule&gt; 3.打开config/app.php将12&apos;key&apos; =&gt; env(&apos;APP_KEY&apos;, &apos;...&apos;), //32位字符串&apos;cipher&apos; =&gt; &apos;AES-256-CBC&apos;, 改为12&apos;key&apos; =&gt; env(&apos;APP_KEY&apos;, &apos;...&apos;),//16位字符串&apos;cipher&apos; =&gt; &apos;AES-128-CBC&apos;, 由于万网不支持’AES-256-CBC’所以用128位加密，256位加密使用32位字符串，128位使用16位字符串4.到这一步基本就没有什么问题了，但是在使用ajax的时候，post方法有可能会被301跳转然后变成get解决方案：打开public目录下的.htaccess文件删除下面这一段123# Redirect Trailing Slashes If Not A Folder... RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteRule ^(.*)/$ /$1 [L,R=301] 5.好了，我的使用过程中就没什么问题了（注：把在控制台把万网的php版本调到最高，现在是5.5） 补充一点很多人容易忽略的，配置文件不要卸载.env文件里面，虚拟机一般不支持，换到config目录下的相应配置文件下 推荐文章（由hexo文章推荐插件驱动）一键迁移typecho到hexo四川大学评教开源代码Composer上线前的优化CoreThink图片轮播插件【ImageSlider】Corethink瀑布流插件PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
        <tag>虚拟主机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用lnmp+owncloud+ossfs+oss搭建属于自己的私有云盘]]></title>
    <url>%2Fpost%2Fnotes%2F%E4%BD%BF%E7%94%A8lnmp%2Bowncloud%2Bossfs%2Boss%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A7%81%E6%9C%89%E4%BA%91%E7%9B%98%2F</url>
    <content type="text"><![CDATA[经常写一写文档之类的东西，需要一个同步网盘，但是现在市面上的还是满足不了我的要求，突然发现阿里云的oss可以挂载成虚拟磁盘，试着折腾了一下效果还不错，不过这中间还是有许多的坑 之前使用的云盘 坚果云个人认为是现在市面上最好的同步盘了，支持增量同步，多平台有linux版本，可以使用webdav。美中不足的免费版每个月限制上传下载流量，收费版不限制流量有空间限制。有段时间突然有大量文件需要备份导致流量不足，但是平时又用不了太多，开一个月专业版的空间又不够，用的有点憋屈所以就弃用了。 百度云等在使用坚果云之前的主力网盘，同步盘功能竟然要会员才能用，而且同步盘做的很不好用，不过用来做资源分享之类的还不错 为什么使用oss 数据的稳定性，我比较喜欢折腾所以服务器有时候就会重装这时候对于文件就非常的不好管理和备份，放在oss上面能够更好的管理 第二个就是便宜，不和其他几家的云服务对比仅仅和阿里云的云盘，就是买服务器的时候的一个选项，便宜很多。40g的话一年也就差不多10多块的样子。而且和ECS搭配使用没有流量费用 准备工作安装lnmp架构 其实owncloud官方更加推荐lamp，但是我个人更喜欢nginx，要比Apache省资源一些，能够用Apache的也很不错，可以少踩很多配置的坑，owncloud的nginx官方示例配置很多坑，之后会说到 安装ossfs 注意：在这之前你需要先开通oss，最好是和你的ECS是一个地区的，当然不是用的ECS也可以用，只是速度会慢一些，还有就是下载会使用公网流量，上传没有 1.点击打开ossfs的下载页面下载对应系统的安装包2.我已Ubuntu为例，安装ossfs，其他系统看官方的文档就行 123sudo apt-get updatesudo apt-get install gdebi-coresudo gdebi your_ossfs_package 3.将my-bucket这个bucket挂载到/data/cloud目录下，AccessKeyId是faint， AccessKeySecret是123，oss endpoint是http://oss-cn-hangzhou.aliyuncs.com123echo my-bucket:faint:123 &gt; /etc/passwd-ossfschmod 640 /etc/passwd-ossfsmkdir /data/cloud 最后一步很重要，不能直接照官方文档上面的来，不然安装owncloud的时候可能会出现没有访问权限的问题 首先先看一下nginx的用户id，以我的是www为例 1id www 会返回给你用户的uid和gid等等,我假设返回的uid和gid都为1001 1ossfs my-bucket /data/cloud -ourl=http://oss-cn-hangzhou-internal.aliyuncs.com -ouid=1001 -ogid=1001 -o allow_other -o umask=007 这里面allow_other是允许其他用户访问，但是默认设置的是777权限这样owncloud会提示不安全，用umask=007挂载为770权限，不知道为啥这里0代表7,7表示0 到这里ossfs就安装完毕了下面开始安装owncloud 安装OWNCLOUD owncloud的安装网上已经有很多的教程我就不多说了 先打开owncloud的官网的服务器端的安装地址，我安装的时候最新稳定版是9.0.2建议国内主机用迅雷之类的下载软件先下载下来上传到服务器，直接wget比较慢 1.下载并解压 12wget https://download.owncloud.org/community/owncloud-9.0.2.tar.bz2 //手动上传这一步就不用了tar xvf owncloud-9.0.2.tar.bz2 //以实际的文件名为准 2.移动到站点目录,假设站点目录为/data/wwwroot 1mv owncloud/ /data/wwwroot/ 3.设置目录权限，这一步很重要 12chown -R www:www /data/wwwroot/owncloud/chmod 777 /data/wwwroot/owncloud//config/ 设置nginx规则（Apache基本不用改，只需要自己去设置一下ssl，和常规的设置就行了）注意规则设置好之后，安装的时候点高级设置，使用mysql或者其他数据库，sqllite的性能不够，然后就是数据文件目录填写之前你ossfs的挂载目录，我之前挂载的是/data/cloud 后面有9.x官方的示例，我这儿提示一下有些坑的地方 1.本身的设置里面没有log的设置，不方便debug，access_log可以不用，error_log还是需要加上的 2.里面没有index的设置，如果打开首页一片空白，加上index.php之后没有问题的话，1234location / &#123; index index.php #加上这一句 rewrite ^ /index.php$uri;&#125; 3.如果你进入安装页面，按照提示安装好了之后出现说找不到文件目录之类的话，那么很有可能是你没有开启pathinfo，owncloud需要pathinfo的支持(示例的配置里面是有pathinfo的设置的) NEXT 到这里基本上owncloud的安装应该就结束了，使用也没有什么问题，我建议开启ssl，不知道为什么，我开了ssl之后访问的速度提升了好几倍 附送官方插件的地址点我点我,国内主机在线安装插件可能装不上，可以FQ之后在这里面下载相应插件包，上传到apps目录下即可，下一篇说一下用owncloud实现离线下载功能，现在9.0.2版本的使用owncloud的离线下载插件有问题，但是看了一下这个bug很早就有，只是好像一直没有修复。之后我改一下能够用了再写下一篇吧 9.x官方示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129 upstream php-handler &#123; server 127.0.0.1:9000; #注意一下你自己的php服务设置，这一行可能需要自己调整 #server unix:/var/run/php5-fpm.sock;&#125;server &#123; listen 80; server_name cloud.example.com; # enforce https return 301 https://$server_name$request_uri;&#125;server &#123; listen 443 ssl; server_name cloud.example.com; #ssl证书的位置 ssl_certificate /etc/ssl/nginx/cloud.example.com.crt; ssl_certificate_key /etc/ssl/nginx/cloud.example.com.key; # Add headers to serve security related headers # Before enabling Strict-Transport-Security headers please read into this # topic first. # 安装好之后，后台可能会提示相应错误，把这一段的注释去掉就行 # add_header Strict-Transport-Security &quot;max-age=15768000; # includeSubDomains; preload;&quot;; #后面安装好了之后后台可能会提示header的错误，把这一短删除掉即可 add_header X-Content-Type-Options nosniff; add_header X-Frame-Options &quot;SAMEORIGIN&quot;; add_header X-XSS-Protection &quot;1; mode=block&quot;; add_header X-Robots-Tag none; add_header X-Download-Options noopen; add_header X-Permitted-Cross-Domain-Policies none; # Path to the root of your installation root /var/www/owncloud/; location = /robots.txt &#123; allow all; log_not_found off; access_log off; &#125; # The following 2 rules are only needed for the user_webfinger app. # Uncomment it if you&apos;re planning to use this app. #rewrite ^/.well-known/host-meta /public.php?service=host-meta last; #rewrite ^/.well-known/host-meta.json /public.php?service=host-meta-json # last; location = /.well-known/carddav &#123; return 301 $scheme://$host/remote.php/dav; &#125; location = /.well-known/caldav &#123; return 301 $scheme://$host/remote.php/dav; &#125; location /.well-known/acme-challenge &#123; &#125; # set max upload size client_max_body_size 512M; fastcgi_buffers 64 4K; # Disable gzip to avoid the removal of the ETag header gzip off; # Uncomment if your server is build with the ngx_pagespeed module # This module is currently not supported. #pagespeed off; error_page 403 /core/templates/403.php; error_page 404 /core/templates/404.php; location / &#123; rewrite ^ /index.php$uri; &#125; location ~ ^/(?:build|tests|config|lib|3rdparty|templates|data)/ &#123; deny all; &#125; location ~ ^/(?:\.|autotest|occ|issue|indie|db_|console) &#123; deny all; &#125; location ~ ^/(?:index|remote|public|cron|core/ajax/update|status|ocs/v[12]|updater /.+|ocs-provider/.+|core/templates/40[34])\.php(?:$|/) &#123; include fastcgi_params; fastcgi_split_path_info ^(.+\.php)(/.+)$; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param HTTPS on; #Avoid sending the security headers twice fastcgi_param modHeadersAvailable true; fastcgi_param front_controller_active true; fastcgi_pass php-handler; fastcgi_intercept_errors on; fastcgi_request_buffering off; &#125; location ~ ^/(?:updater|ocs-provider)(?:$|/) &#123; try_files $uri/ =404; index index.php; &#125; # Adding the cache control header for js and css files # Make sure it is BELOW the PHP block location ~* \.(?:css|js)$ &#123; try_files $uri /index.php$uri$is_args$args; add_header Cache-Control &quot;public, max-age=7200&quot;; # Add headers to serve security related headers (It is intended to # have those duplicated to the ones above) # Before enabling Strict-Transport-Security headers please read into # this topic first. # add_header Strict-Transport-Security &quot;max-age=15768000; # includeSubDomains; preload;&quot;; add_header X-Content-Type-Options nosniff; add_header X-Frame-Options &quot;SAMEORIGIN&quot;; add_header X-XSS-Protection &quot;1; mode=block&quot;; add_header X-Robots-Tag none; add_header X-Download-Options noopen; add_header X-Permitted-Cross-Domain-Policies none; # Optional: Don&apos;t log access to assets access_log off; &#125; location ~* \.(?:svg|gif|png|html|ttf|woff|ico|jpg|jpeg)$ &#123; try_files $uri /index.php$uri$is_args$args; # Optional: Don&apos;t log access to other assets access_log off; &#125;&#125; 推荐文章（由hexo文章推荐插件驱动）一键迁移typecho到hexo四川大学评教开源代码Composer上线前的优化CoreThink图片轮播插件【ImageSlider】Corethink瀑布流插件PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>lnmp</tag>
        <tag>云盘</tag>
        <tag>owncloud</tag>
        <tag>oss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四川大学评教开源代码]]></title>
    <url>%2Fpost%2Fnotes%2F%E5%9B%9B%E5%B7%9D%E5%A4%A7%E5%AD%A6%E8%AF%84%E6%95%99%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173&lt;?phprequire "login.php";require "QueryList.class.php";class evaluate&#123; private $_listUrl="http://202.115.47.141/jxpgXsAction.do?oper=listWj&amp;page=";//评教列表页面 private $_formUrl="http://202.115.47.141/jxpgXsAction.do?oper=wjShow&amp;";//评教表单页面 private $_postUrl="http://202.115.47.141/jxpgXsAction.do?oper=wjpg&amp;";//评教提交地址 private $_yjpj; private $_successNo=0;//成功次数 private $_failNo=0;//失败次数 public function __construct($name,$pass) &#123; $this-&gt;_yjpj=new login($name,$pass); &#125; /** * 获取评教列表并且返回列表信息以及页码 * @author mohuishou&lt;1@lailin.xyz&gt; * @return mixed * $list=[ * 'info'=&gt;[ * [ * 'param'=&gt;[ * 0 =&gt; '0000000038', * 1 =&gt; '19873162', * 2 =&gt; '高苹', * 3 =&gt; '学评教', * 4 =&gt; '马克思主义基本原理概论', * 5 =&gt; '107021030', * ], * 'status'=&gt;0 * ], * ...... * ], * 'page'=&gt;[ * [ * 'page'=&gt;'2' * ] * ] * ]; */ public function getList() &#123; /*--------------获取第一页的评教列表页面---------------*/ $listContent=$this-&gt;_yjpj-&gt;show($this-&gt;_listUrl."1"); /*------------获取评教分页信息--------------*/ $pageReg=[ 'page'=&gt;['script:eq(3)','html','',function($page)&#123; $pattern="/document\.all\.pageNo\.value&gt;(.)/"; preg_match($pattern,$page,$no); if($no[1])&#123; return $no[1]; &#125; &#125;] ]; $page=QueryList::Query($listContent,$pageReg); $page=$page-&gt;jsonArr[0]['page']; /*---------获取评教老师信息--------------*/ $listReg=[ 'param'=&gt;['img','name','',function($a)&#123; if($a)&#123; return explode('#@',$a); &#125; &#125;], 'status'=&gt;['img','onclick','',function($a)&#123; if(trim($a)=="evaluation(this)")&#123; return 1; &#125;else&#123; return 0; &#125; &#125;], ]; /*[优化]：减少重复抓取列表页，大大提高效率*/ $c=QueryList::Query($listContent,$listReg); $list[]=$c-&gt;jsonArr; if($page&gt;1)&#123; for($i=2;$i&lt;=$page;$i++)&#123; $listContent=$this-&gt;_yjpj-&gt;show($this-&gt;_listUrl.$i); $c=QueryList::Query($listContent,$listReg); $list[]=$c-&gt;jsonArr; &#125; &#125; return $list;//获取到的评教信息 &#125; public function getPostInfo($list) &#123;// print_r($list); foreach($list as $listVal)&#123;// print_r($listVal); foreach($listVal as $listkey =&gt; $listValue)&#123; if($listValue['status']==1)&#123;// print_r($listValue); $param=[ 'wjbm'=&gt;$listValue['param'][0], 'bpr'=&gt;$listValue['param'][1], 'pgnr'=&gt;$listValue['param'][5], ]; $param=http_build_query($param); $url=$this-&gt;_formUrl.$param;// echo $url; $formContent=$this-&gt;_yjpj-&gt;show($url);// print_r($formContent); $res=QueryList::Query($formContent,['name'=&gt;['[value=10_1]','name']]); /*--------------将获取的表单信息整理成为即将post的参数-------------*/ foreach($res-&gt;jsonArr as $postKey =&gt; $postValue)&#123; $postParam[$postValue['name']]="10_1"; &#125; $postParam['wjbm']=$listValue['param'][0]; $postParam['bpr']=$listValue['param'][1]; $postParam['pgnr']=$listValue['param'][5]; $postParam['zgpj']="very good teacher!!"; $this-&gt;post($postParam);// return 0; &#125; &#125; &#125; &#125; public function post($param)&#123; $param=http_build_query($param); $url=$this-&gt;_postUrl.$param;// echo $url; $evalContent=$this-&gt;_yjpj-&gt;show($url); /*--------------------抓取提交之后的数据查看是否成功提交--------------------*/ $res=QueryList::Query($evalContent,['info'=&gt;['script','html','',function($a)&#123; $pattern='/alert\("(.+)"\)/'; preg_match_all($pattern,$a,$res); $success='评估成功！'; if($res[1][0]==$success)&#123; $a=[ 'message'=&gt;$res[1][0], 'status'=&gt;1 ]; &#125;else&#123; $a=[ 'message'=&gt;$res[1][0], 'status'=&gt;0 ]; &#125; return $a; &#125;]]); $status=$res-&gt;jsonArr[0]['info']['status']; if($status==1)&#123; $this-&gt;_successNo+=1; &#125;else&#123; $this-&gt;_failNo+=1; &#125;// print_r($res-&gt;jsonArr); &#125; public function action() &#123; $this-&gt;getPostInfo($this-&gt;getList()); $this-&gt;count(); return ['success'=&gt;$this-&gt;_successNo,'fail'=&gt;$this-&gt;_failNo]; //return '评教成功，成功：'.$this-&gt;_successNo.'位，'.'失败：'.$this-&gt;_failNo."位"; &#125;&#125;推荐文章（由hexo文章推荐插件驱动）一键迁移typecho到hexoComposer上线前的优化CoreThink图片轮播插件【ImageSlider】Corethink瀑布流插件nginx-php报502错误PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>大学</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>四川大学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Composer上线前的优化]]></title>
    <url>%2Fpost%2Fphp%2FComposer%E4%B8%8A%E7%BA%BF%E5%89%8D%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[更新之后或者上线前别忘了执行下面的命令否则少则损失20%-50%的性能，多则程序直接报错 1composer dump-autoload --optimize 推荐文章（由hexo文章推荐插件驱动）一键迁移typecho到hexo四川大学评教开源代码CoreThink图片轮播插件【ImageSlider】Corethink瀑布流插件nginx-php报502错误PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>composer</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php识别验证码（二）]]></title>
    <url>%2Fpost%2Fphp%2Fphp%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在 php 识别验证码（一）当中说了基本的识别验证码的方法，及其关键的代码，但是最后我们留下了一个问题，就是对于有旋转的验证码的识别率及其低下的问题，下面来解决这个问题。 标准化 解决类似于下面图片这种有旋转字符的验证码，我们首先要给出一种标准，让所有的分割后的图片都按照一个标准来摆放，最后对比的时候才能够统一 如何标准化？ 我们对一个字符进行旋转，然后计算这个字符的宽度，当宽度最小时，我们认为它是一个标准字符，这样我们就能够得到比较好的结果了（通过观察这种验证码，发现一般只要左右旋转三十度即可） 然后仅仅进行旋转还不够，为了能够和模板也就是特征值库进行对比，我们还需要，统一字符长度。也就是二值化之后的字符串长度，这时就需要画一张长宽固定的图片，把我们原来的图片按照比例拉伸压缩复制过去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 /** * 图像标准化，将旋转的图像标准化 * @author mohuishou&lt;1@lailin.xyz&gt; * @param $img * @return resource 标准的图像资源句柄 */ public function imageStandard($img)&#123; $min_w=999; $oimg=$img; $c=imagecolorallocate($img, 255, 255, 255); for($i=-30;$i&lt;30;$i++)&#123; $simg=imagerotate($img,$i,$c);// //计算字符宽度 $simg_hash_data=$this-&gt;getWidth($simg); $w=count($simg_hash_data); if($w&lt;$min_w)&#123; $oimg_hash_data=$simg_hash_data; $min_w=$w; &#125; &#125; $out_img_w=count($oimg_hash_data); $out_img_h=count($oimg_hash_data[0]); $out_img = imagecreatetruecolor($out_img_w,$out_img_h);//创建一幅真彩色图像 $bg=imagecolorallocate($out_img, 255, 255, 255);//背景色画为白色 imagefill($out_img, 0,0, $bg); //一列一列的进行画图 foreach ($oimg_hash_data as $k=&gt;$v)&#123; foreach ($v as $key=&gt; $val)&#123; $color=255; if($val) $color=0; $c = imagecolorallocate($out_img, $color, $color, $color); imagesetpixel($out_img, $k,$key, $c); &#125; &#125;// imagepng($out_img,'./0.png'); $hash_img = imagecreatetruecolor(self::HASH_W, self::HASH_H); imagecopyresized($hash_img, $out_img, 0, 0, 0, 0, self::HASH_W,self::HASH_H,$out_img_w,$out_img_h); return $hash_img; &#125; /** * 获取图像的宽度 * @author mohuishou&lt;1@lailin.xyz&gt; * @param $img 图像资源句柄 * @return int */ public function getWidth($img)&#123; //根据资源句柄获取整个图像的高与宽 $img_w=imagesx($img); $img_h=imagesy($img); //图像二值化 for($i = 0; $i &lt;$img_h; $i++) &#123; for ($j = 0; $j &lt;$img_w; $j++) &#123; $rgb = imagecolorat($img,$j,$i); if($rgb==0)&#123; $data[$i][$j]=1; &#125;else&#123; $data[$i][$j]=0; &#125; &#125; &#125; //去掉零行 $data=$this-&gt;removeZero($data); //按列取图像获取宽度 for($i=0;$i&lt;$img_w;$i++)&#123; $column=array_column($data,$i); if(implode("",$column)!=0)&#123; $data1[]=$column; &#125; &#125; //返回 return $data1; &#125; 看上方的代码发现会有一个去除零行的操作，也就是去除空白行，这一步操作的目的主要是为了出掉上下左右无用的空白部分，在我们进行模板对比的时候更加的精确 建立特征值库 之前提到了很多和模板或者是特征值库进行比较，那我们如何来建立这个库呢？下面说一下最简单的两种方法 第一种，就是把你需要的数字可能还有 26 个字母，都先识别一遍然后存到一个文件当中，使用的时候包含这个文件进行对比就行了 第二种，也差不多，可以写一个 study 文件，让上面的步骤稍微智能一点，直接输入之后，自动储存到数据库中 下面是我写的一个针对联通优选在沃的一个小的脚本，需要注意的是对于这种通过链接来识别的，一定要先将链接的图片保存下来，因为链接没获取一次图片就会改变一次 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php/** * Created by mohuishou&lt;1@lailin.xyz&gt;. * User: mohuishou&lt;1@lailin.xyz&gt; * Date: 2016/5/1 0001 * Time: 20:44 */require_once 'Image.class.php';require_once 'DB.class.php';$db=new \ImageOCR\DB();if(isset($_POST['send'])&amp;&amp;$_POST['send']=="send")&#123; $image=new \ImageOCR\Image("./img/inImgTemp.png"); $code=$_POST['code']; $code_arr=str_split($code); for($i=0;$i&lt;$image::CHAR_NUM;$i++)&#123; $hash_img_data=implode("",$image-&gt;splitImage($i)); $db-&gt;add($code_arr[$i],$hash_img_data); &#125; echo "&lt;script&gt;location.href='./study.php';&lt;/script&gt;";&#125;else&#123; $image=new \ImageOCR\Image("http://www.169ol.com/Mall/Code/getCode&amp;1462104790492"); imagepng($image-&gt;_in_img,"./img/inImgTemp.png");&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Study&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="" method="post"&gt; &lt;img src="img/inImgTemp.png"&gt; &lt;input type="text" name="code"&gt; &lt;input name="send" type="submit" value="send" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 开源代码觉得不错，给个 star 呗 感谢常见验证码的弱点与验证码识别 结束语目前的识别效率可以达到 50%以上，基本可以投入正常使用，但是还有很大的进步空间，正在做下一步的优化，针对识别结果对特征库进行自动优化，自动去除使用率较低的特征值，自动保存，识别成功的特征值等等 推荐文章（由hexo文章推荐插件驱动）一键迁移typecho到hexo四川大学评教开源代码Composer上线前的优化CoreThink图片轮播插件【ImageSlider】Corethink瀑布流插件PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>图片</tag>
        <tag>验证码识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php利用curl保存图片]]></title>
    <url>%2Fpost%2Fphp%2Fphp%E5%88%A9%E7%94%A8curl%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[做验证码识别的时候需要先把图片保存起来，写了一个保存图片的函数 123456789101112131415161718/*** @author mohuishou&lt;1@lailin.xyz&gt;* @param string $url 获取图片的网址* @param string $fileName 保存的地址以及文件名*/function getImg($url, $fileName) &#123; $ch = curl_init(); $fp = fopen($fileName, 'w+'); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 0); curl_setopt($ch, CURLOPT_TIMEOUT, 60); curl_setopt($ch, CURLOPT_FILE,$fp); curl_exec($ch); curl_close($ch); fclose($fp); &#125; 使用的时候发现，需要保存验证码的cookies，留作验证，必要的时候还需要加上header 12345678910111213141516171819202122/*** @author mohuishou&lt;1@lailin.xyz&gt;* @param string $url* @param string $fileName*/function getCode($url = 'http://www.169ol.com/Mall/Code/getCode', $fileName = './img/code.png') &#123; $this-&gt;_code_cookie = dirname(__FILE__)."/pic.cookie"; $ch = curl_init(); $fp = fopen($fileName, 'w+'); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 0); curl_setopt($ch, CURLOPT_TIMEOUT, 60); curl_setopt($ch, CURLOPT_FILE,$fp); curl_setopt($ch, CURLOPT_COOKIEJAR, $this-&gt;_code_cookie); curl_exec($ch); curl_close($ch); fclose($fp); &#125;推荐文章（由hexo文章推荐插件驱动）一键迁移typecho到hexo四川大学评教开源代码Composer上线前的优化CoreThink图片轮播插件【ImageSlider】Corethink瀑布流插件PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>图片</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php识别验证码（一）]]></title>
    <url>%2Fpost%2Fphp%2Fphp%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[想做一个针对联通优选在沃自动签到的小程序，但是登陆需要验证码，找了一下现有的一些博客或者是开源的验证码识别的代码，没有一个比较满意的，so，自己写了一个。 需要识别的验证码 第一种： 第二种 分析像上图的验证码一般来说的话，我们需要识别的是 4 个数字，但是验证码为了防止自动识别程序添加了许多的干扰项，例如背景色、雪花、干扰线等等 去除背景我们通过分析该验证码图片可以知道，数字的 rgb 值一般处在 180~190 以下，而背景色和雪花的 rgb 值一般处在 200 以上，so，我们只要在处理图片的时候只取 190 以下的 rgb 值保存就 ok 了，这样就可以去除掉绝大部分的干扰项 二值化把干扰信息去除之后，只留下二进制（也就是 0 和 1 表示）的点阵 123456789101112131415161718192021/** * 二值化，排除背景色，雪花等干扰项 * @author mohuishou&lt;1@lailin.xyz&gt; */public function imageHash()&#123; for($i = 0; $i &lt; $this-&gt;_image_h; $i++) &#123; for ($j = 0; $j &lt; $this-&gt;_image_w; $j++) &#123; $rgb = imagecolorat($this-&gt;_in_img,$j,$i); $rgb_array = imagecolorsforindex($this-&gt;_in_img, $rgb); if($rgb_array['red']&lt;190&amp;&amp;$rgb_array['green']&lt;190&amp;&amp;$rgb_array['blue']&lt;190)&#123; $data[$i][$j]=1; &#125;else&#123; $data[$i][$j]=0; &#125; &#125; &#125;&#125; 点阵化之后的截图 去噪点图像二值化之后可能还存在很多噪点，噪点的特点一般是孤立无援的，这时候我们只需要判断以这个 1 点为中心的点，周围的 1 点个数小于一个阈值（我把它设为 3），就确认它为噪点并将之去除 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 去除噪点 * @author mohuishou&lt;1@lailin.xyz&gt; * @param $hash_data * @return mixed */public function removeHotSpots($hash_data)&#123; for($i = 0; $i &lt; $this-&gt;_image_h; $i++) &#123; for ($j = 0; $j &lt; $this-&gt;_image_w; $j++) &#123; if($hash_data[$i][$j])&#123; if($this-&gt;isHotSpots($i,$j,$hash_data)) $hash_data[$i][$j]=0; &#125; &#125; &#125; return $hash_data;&#125;/** * 判断是否是噪点 * @author mohuishou&lt;1@lailin.xyz&gt; * @param $i * @param $j * @param $hash_data * @return bool ture:是噪点,false:不是 */public function isHotSpots($i,$j,$hash_data)&#123; if($i == 0 || $j == 0 || $i == ($this-&gt;_image_h - 1) || $j == ($this-&gt;_image_w - 1)) return true; //待检查点为中心的九个点 $points[0]=$hash_data[$i-1][$j-1]; $points[1]=$hash_data[$i-1][$j]; $points[2]=$hash_data[$i-1][$j+1]; $points[3]=$hash_data[$i][$j-1]; $points[4]=$hash_data[$i][$j];//待检查点 $points[5]=$hash_data[$i][$j+1]; $points[6]=$hash_data[$i+1][$j-1]; $points[7]=$hash_data[$i+1][$j]; $points[8]=$hash_data[$i+1][$j+1]; $count=0; foreach ($points as $v)&#123; if($v)&#123; $count++; &#125; &#125; return $count&lt;4;&#125; 去除噪点之后 去除干扰线通过去除噪点之后的图像，我们可以发现，大部分的干扰线，其实已经被去除掉了，所以我们可以将，去除噪点的方法当做一个滤镜，多过滤几次，干扰线基本上可以去除完毕（这里测试去除三次的效果是最好的） 分割验证码这个验证码的每个数字其实都是等分的，所以我们可以采用等分的方法去分割它 12345678910111213141516171819202122232425262728293031323334/** * @author mohuishou&lt;1@lailin.xyz&gt; * @param $n * @return array */public function splitImage($n)&#123; $data=[]; $a=$this-&gt;_image_w/self::CHAR_NUM; for($i=$n*$a;$i&lt;($n+1)*$a;$i++)&#123; $column=array_column($this-&gt;_hash_data,$i); if(implode("",$column)!=0)&#123; $data[]=$column; &#125; &#125; $out_img_w=count($data)+4; $out_img_h=count($data[0])+4; $out_img = imagecreatetruecolor($out_img_w,$out_img_h);//创建一幅真彩色图像 $bg=imagecolorallocate($out_img, 255, 255, 255);//背景色画为白色 imagefill($out_img, 0,0, $bg); //一列一列的进行画图 foreach ($data as $k=&gt;$v)&#123; foreach ($v as $key=&gt; $val)&#123; $color=255; if($val) $color=0; $c = imagecolorallocate($out_img, $color, $color, $color); imagesetpixel($out_img, $k+2,$key+2, $c); &#125; &#125; return $out_img;&#125; 保存&amp;对比识别 最后将分割好的图片二值化，通过一个数组保存下来，作为一个标准，然后后之后需要验证的验证码，通过和之前的数组求交集，比较最相近的数字得出结果即可 更多其实到这一步之后已经能够识别一些验证码了，对于第二种验证码已经可以达到很好的识别效果，但是对于第一种验证码的识别率很低很低，大概只有5%-15%，基本不能投入使用，下一篇文章针对这种验证码，怎么更好的识别，主要是标准化和特征库的建立 推荐文章（由hexo文章推荐插件驱动）一键迁移typecho到hexo四川大学评教开源代码Composer上线前的优化CoreThink图片轮播插件【ImageSlider】Corethink瀑布流插件PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>图片</tag>
        <tag>识别</tag>
        <tag>验证码识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php-webhook利用php脚本自动化部署git项目]]></title>
    <url>%2Fpost%2Fphp%2Fphp-webhook-%E5%88%A9%E7%94%A8php%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2git%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[遇到权限的问题弄了好久，整理一下步骤简单的写一下在阅读这篇文章的时候默认你的服务器上安装了web服务器和git step1 写一个简单的脚本查看你的服务器运行的账户，和是否能够运行相关函数12$test=shell_exec("whoami");var_dump($test);//我的返回的是 www-data 如果这里返回null的话，不妨检查一下shell_exec函数是否被禁用了 step2 建立ssh公钥，以我的www-data账户为例子 1.先建立一个.ssh目录并给予www-data用户权限12sudo mkdir /var/www/.sshsudo chown -R www-data:www-data /var/www/.ssh/ 2.生成webhook部署公钥1sudo -Hu www-data ssh-keygen -t rsa //一直回车即可 如果你和我一样，遇到了-su: sudo: command not found，可以先安装sudo命令,apt-get install sudo，如果你和我还一样遇到了一些问题，不妨先试试apt-get update 3.将webhook部署公钥上传到托管网站 测试用的Coding，其他还在测试当中 先查看公钥1sudo cat /var/www/.ssh/id_rsa.pub 然后复制上面的内容到托管网站，项目的webhook上面 step3 webhook文件 step4 先在服务器上git clone 12sudo chown -R www-data:www-data &#123;代码地址&#125;sudo -Hu www-data git clone &#123;你的项目ssh地址&#125; &#123;代码地址&#125; --depth=1 注意，这里初始化clone必须要用www-data用户 step5 在托管网站上添加webhook地址，然后提交一次测试 感谢 参考了以下代码https://gist.github.com/overtrue/0bf1cd704bf804de2e2c 推荐文章（由hexo文章推荐插件驱动）一键迁移typecho到hexo四川大学评教开源代码Composer上线前的优化CoreThink图片轮播插件【ImageSlider】Corethink瀑布流插件PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>git</tag>
        <tag>webhook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx无法启动]]></title>
    <url>%2Fpost%2Fnotes%2Fnginx%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[今天装了一个服务器但是nginx一直无法启动，google了各种答案，还是没有效果 例如：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253nginx启动，重启，关闭命令停止操作停止操作是通过向nginx进程发送信号（什么是信号请参阅linux文 章）来进行的步骤1：查询nginx主进程号ps -ef | grep nginx在进程列表里 面找master进程，它的编号就是主进程号了。步骤2：发送信号从容停止Nginx：kill -QUIT 主进程号快速停止Nginx：kill -TERM 主进程号强制停止Nginx：pkill -9 nginx另外， 若在nginx.conf配置了pid文件存放路径则该文件存放的就是Nginx主进程号，如果没指定则放在nginx的logs目录下。有了pid文 件，我们就不用先查询Nginx的主进程号，而直接向Nginx发送信号了，命令如下：kill -信号类型 &apos;/usr/nginx/logs/nginx.pid&apos;平滑重启如果更改了配置就要重启Nginx，要先关闭Nginx再打开？不是的，可以向Nginx 发送信号，平滑重启。平滑重启命令：kill -HUP 住进称号或进程号文件路径或者使用/usr/nginx/sbin/nginx -s reload注意，修改了配置文件后最好先检查一下修改过的配置文件是否正 确，以免重启后Nginx出现错误影响服务器稳定运行。判断Nginx配置是否正确命令如下：nginx -t -c /usr/nginx/conf/nginx.conf或者/usr/nginx/sbin/nginx -t平滑升级如果服务器正在运行的Nginx要进行升级、添加或删除模块时，我们需 要停掉服务器并做相应修改，这样服务器就要在一段时间内停止服务，Nginx可以在不停机的情况下进行各种升级动作而不影响服务器运行。步骤1：如 果升级Nginx程序，先用新程序替换旧程序文件，编译安装的话新程序直接编译到Nginx安装目录中。步 骤2：执行命令kill -USR2 旧版程序的主进程号或进程文件名此时旧的Nginx主进程将会把自己的进程文件改名为.oldbin，然后执行新版 Nginx。新旧Nginx会同市运行，共同处理请求。这时要逐步停止旧版 Nginx，输入命令：kill -WINCH 旧版主进程号慢慢旧的工作进程就都会随着任务执行完毕而退出，新版的Nginx的工作进程会逐渐取代旧版 工作进程。此 时，我们可以决定使用新版还是恢复到旧版。不重载配置启动新/旧工作进程kill -HUP 旧/新版主进程号从容关闭旧/新进程kill -QUIT 旧/新主进程号如果此时报错，提示还有进程没有结束就用下面命令先关闭旧/新工作进程，再关闭主进程号：kill -TERM 旧/新工作进程号这样下来，如果要恢复到旧版本，只需要上面的几个步 骤都是操作新版主进程号，如果要用新版本就上面的几个步骤都操作旧版主进程号就行了。上面就是Nginx的一些基本的操作，希望以后Nginx能有更好的方法来处理这些操作， 最好是Nginx的命令而不是向Nginx进程发送系统信号。 后面发现突然想起来会不会是配置文件有错误导致的无法启动，so1nginx -t -c /etc/nginx/nginx.conf 结果发现是配置项里面的日志文件目录不存在 总结一下以后遇到这种问题一定要先看看日志或者先测试一下语句 推荐文章（由hexo文章推荐插件驱动）nginx-php报502错误nginx-php报502错误nginx-rewrite指令中的flag参数]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx-php报502错误]]></title>
    <url>%2Fpost%2Fphp%2Fnginx-php-%E6%8A%A5502%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[正是悲催犯了一个超低级的错误 在腾讯云新买了一个服务器，直接用了以前nginx的配置文件，但是装上之后先是404然后502，一直不知道为什么 1404是因为本来要报502的错误，但是502的页面没有放进去.... 502的错误在网上搜索了很多答案都没有解决，然后后面发现我自己竟然没有看错误日志，翻日志的时候发现是：12016/04/25 04:32:42 [crit] 251#251: *166 connect() to unix:/var/run/php5-fpm.sock failed (2: No such file or directory) while connecting to upstream, client: 220.167.47.185, server: 127.0.0.1, request: &quot;GET / HTTP/1.1&quot;, upstream: &quot;fastcgi://unix:/var/run/php5-fpm.sock:&quot;, host: &quot;115.159.94.101&quot; 突然间恍然大悟，我新买的服务器装的是php7，以前用的php5，sock文件的地址不一样,改成下面这个重启，就没有问题了1fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;推荐文章（由hexo文章推荐插件驱动）nginx无法启动nginx无法启动一键迁移typecho到hexo四川大学评教开源代码Composer上线前的优化nginx-rewrite指令中的flag参数]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>服务器</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言验证浮点数的二进制表示]]></title>
    <url>%2Fpost%2Fnotes%2FC%E8%AF%AD%E8%A8%80%E9%AA%8C%E8%AF%81%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[验证浮点数 虽然以前也学过浮点数的表示原理，大致的原理还是清楚的，但是使用 C 语言的来进性验证还没有尝试过，下面是验证的过程 思路 知道浮点数，是按照 32 位在内存中保存，其中第一位表示符号，后 8 位表示指数，最后 23 位表示小数 C 语言当中存在指针，可以直接通过指针来获取，变量的地址。 所以就先定义一个变量来储存浮点数，在定义一个指针来获取，浮点数的储存地址，在把 16 进制或者 10 进制的地址转化为 2 进制即可 1234567891011121314int main(void)&#123; float a=209.125; int *p=(int *)&amp;a; while(1)&#123; printf("请输入一串数:"); scanf("%f",&amp;a); printf("%d\n", *p);//输出数值在内存中10进制表示 decimal2Binary(*p);//将十进制转化为二进制 decimal2Binary_2(*p); &#125; getchar();//防止程序退出 return 0;&#125; 在十进制转化为二进制的过程中，我使用了两种办法，首先想到的就是通过循环求余的办法来转化 12345678910111213141516171819/** * [decimal2Binary 十进制转换成二进制，使用循环求余法] * @author mohuishou&lt;1@lailin.xyz&gt; * @param x [要转换的十进制数] * @return [0] */int decimal2Binary(int x)&#123; int a[32]; int rem; for(int j=31;j&gt;=0;j--)&#123; rem=x%2; x=x/2; a[j]=rem; &#125; for(int i=0;i&lt;=31;i++) printf("%d",a[i]); printf("\n"); return 0;&#125; 第二种是后面查资料的时候看到的一种办法，我转换了一下，用于这个小程序。主要是充分应用了 C 语言当中的位运算 123456789101112131415161718/** * [decimal2Binary_2 十进制转换成二进制，使用按位对比法] * @author mohuishou&lt;1@lailin.xyz&gt; * @param x [要进行转化的10进制数] * @return [0] */int decimal2Binary_2(int x)&#123; for (int i = 31; i &gt;=0;i--) &#123; if(x&amp;(1&lt;&lt;i))&#123;//将1左移i位并和x进行按位对比 printf("%d",1 ); &#125;else&#123; printf("%d",0 ); &#125; &#125; printf("\n"); return 0;&#125; 0 在浮点数中怎么表示 我先通过上面写好的程序，输入 0 之后，得到的值为 32 个 0，然后进行一个简单的分析认为： 浮点数的表示方法 浮点数的表示方法是：先转化为 1.xxx（小数部分） * 2^m（指数部分） 首先判断符号，正的话第一位为 0，负数的话为第一位 1 指数部分 m+127=&gt;转化为 2 进制 小数部分 xxx=&gt;转化为 2 进制， 对于 0 的推断由于 0 的话，他第一步就不能转化为 1.xxx（小数部分） * 2^m（指数部分)的形式，所以比较好的一个办法就是以 32 个 0 表示 推断的验证 对于 C 语言来说我在之前就已经验证了，然后我查询了维基百科 IEEE 二进制浮点数算术标准（IEEE 754）点击打开，对比得出，0 的二进制浮点数表示的确是 32 个 0 程序运行结果截图 程序源代码截图 推荐文章（由hexo文章推荐插件驱动）CSAPP课程学习笔记-0]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js编码解码URL]]></title>
    <url>%2Fpost%2Fnotes%2Fjs%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81URL%2F</url>
    <content type="text"><![CDATA[在js的URL编码解码当中有这两个函数，分别是 编码解码函数 编码encodeURI(str)解码decodeURI(str) 编码encodeURIComponent解码decodeURIComponent 区别encodeURI对于字母和属于URL的字符不进行编码但是encodeURIComponent会对属于URL的字符也进行编码例如这些字符-_.!~*&#39;() 示例12var str=&quot;http://lxl520.com/程序&quot;;console.log(&quot;我是初始字符串&quot;+str); 我是初始字符串http://lxl520.com/程序12var str2=encodeURI(str);console.log(&quot;我是经过encodeURI编码的：&quot;+str2); 我是经过encodeURI编码的：http://lxl520.com/%E7%A8%8B%E5%BA%8F12var str3=encodeURIComponent(str);console.log(&quot;我是经过encodeURIComponent编码的：&quot;+str3); 我是经过encodeURIComponent编码的：http%3A%2F%2Flxl520.com%2F%E7%A8%8B%E5%BA%8F123var str2Decode=decodeURI(str2);var str3Decode=decodeURIComponent(str3);console.log(&quot;我们是经过解码的字符串：&quot;+str2Decode+&quot;\n&quot;+str3Decode); 我们是经过解码的字符串：http://lxl520.com/程序http://lxl520.com/程序 示例212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;URL编码&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea id="get" placeholder="请输入您要编码的字符串"&gt;&lt;/textarea&gt; &lt;br&gt; &lt;button onclick="urlEncode();"&gt;点击进行编码&lt;/button&gt; &lt;button onclick="urlDecode();"&gt;点击进行解码&lt;/button&gt; &lt;br&gt; &lt;textarea id="output" placeholder="输出框"&gt;&lt;/textarea&gt; &lt;script type="text/javascript"&gt; /** * @author mohuishou * [test URL编码测试] * @return &#123;[type]&#125; [description] */ function test()&#123; var str="http://lxl520.com/程序"; console.log("我是初始字符串"+str); var str2=encodeURI(str); console.log("我是经过encodeURI编码的："+str2); var str3=encodeURIComponent(str); console.log("我是经过encodeURIComponent编码的："+str3); var str2Decode=decodeURI(str2); var str3Decode=decodeURIComponent(str3); console.log("我们是经过解码的字符串："+str2Decode+"\n"+str3Decode); &#125; /** * @author mohuishou * 更改输入的值，并将其输出 */ function urlEncode()&#123; var getVal=document.getElementById('get').value;//获取输入框的值 var strEncode=encodeURI(getVal); document.getElementById('output').value=strEncode;//将编码过后的值输出到输出框 &#125; /** * [urlDecode 解码函数，对进行解码] * @return &#123;[type]&#125; [description] */ function urlDecode()&#123; var getVal=document.getElementById('get').value;//获取输入框的值 var strDecode=decodeURI(getVal); document.getElementById('output').value=strDecode; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 推荐文章（由hexo文章推荐插件驱动）【福利】至善网媒体素材一键评价]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css中权重与优先级]]></title>
    <url>%2Fpost%2Fnotes%2Fcss%E4%B8%AD%E6%9D%83%E9%87%8D%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[今天在写一个前端文件的时候发现有一个样式突然没有了作用，但是按照优先级来说应该后面的前面的才对。然后研究了一下css当中的优先级到底是怎么回事，才发现原来都是权重的锅 选择器的权重 分为四个等级,权重值越大表示优先级别越高 权重表 选择器 例子 权重值 内联样式 style=&#39;&#39; 1000 id选择器 #title 100 类，伪类，属性选择器 .title，:hover ,a[href] 10 类型选择器，伪元素选择器 p, :before 1 通用选择器，子选择器和相邻同胞选择器 *,&gt;,+ 0 一个例子sytle12345678910111213141516171819/*权重=100+1=101*/#title h2&#123; color:red;&#125;/*权重=10+1=11*/.content h2&#123; color:blue;&#125;/*权重=100+1=101*/#title a&#123; color:orange;&#125;/*权重=100+10=110*/#title a[href]&#123; color:green;&#125; html12345678&lt;div id="title"&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;div class="content"&gt; &lt;h2 style="color:#333;"&gt;我是内容&lt;/h2&gt;&lt;!--权重=1000--&gt; &lt;a href="http://lxl520.com"&gt;lxl520&lt;/a&gt; &lt;a&gt;0...0&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 层叠原理（或者说是就近原则）当两个样式的优先级一样时,会自动选择最近的一条样式 123456789&lt;style&gt; #title&#123; color:red; &#125; #title&#123; color:blue; &#125;&lt;/style&gt;&lt;h2 id="title"&gt;我到底啥颜色&lt;/h2&gt; 例外（!important）在属性的后面加上!important可以用来提权，就好比直接获得管理员权限一样，这这个属性会变成最高优先级123456&lt;style&gt; h2&#123; color:red !important; &#125;&lt;/style&gt;&lt;h2 style="color:blue;"&gt;我想必应该是蓝色&lt;/h2&gt; 注意 一些不成文规则 不要在全站范围的css中使用!important. 只在需要覆盖全站范围的css或是外部css（例如引用的ExtJs或是YUI）的时候才在指定的页面上使用!important。 不要在你的插件中使用!important。 永远都要优先考虑使用样式规则的优先级来解决问题而不是!important。 如果你和我一样遇到了似乎没有起作用的CSS规则，请试试在你的选择器中添加他的一个父元素的ID，从而提高它的特殊性。看看能不能解决问题 推荐文章（由hexo文章推荐插件驱动）Next修改配色]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EmotionCamera]]></title>
    <url>%2Fpost%2Fnotes%2FEmotionCamera%2F</url>
    <content type="text"><![CDATA[简单实现逻辑 首先识别脸部标识出关键点通过一定的算法捕抓表情 表情相机模块需要实现的任务 什么时候拍照？ 需要确定一个阈值导出一个静态库 ios和andriod 补充，ios需要涉及到mac系统还有OC；andriod需要涉及到Linux，安卓方面导出的静态库是.a格式；动态库为.so格式 最近两周需要完成的任务 现在的时间：2015年11月1日 23:34:33 两周后需要达到的效果：使用安卓调用C++生成的.a文件 需要搜索的一些东西： C++静态库导出（ios/andriod）静态vs动态库object―C （ios）makefile&amp;modify Macro能不能直接在一个环境下同时导出ios和安卓需要的库 推荐文章（由hexo文章推荐插件驱动）愚人节专题项目前端开发小结]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NDK开发中无法访问android.support.v7.app.AppCompatActivity解决办法]]></title>
    <url>%2Fpost%2Fnotes%2FNDK%E5%BC%80%E5%8F%91%E4%B8%AD%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEandroid.support.v7.app.AppCompatActivity-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[错误详情：错误: 无法访问android.support.v7.app.AppCompatActivity找不到android.support.v7.app.AppCompatActivity的类文件 为了这个问题纠结2天了，在网上找了很多的解决办法都不行，几乎所有的办法都试过了 无意中查看sdk Manager的时候发现我的“android support library”没有安装，然后当即安装上去 随后执行：1javah -d jni -classpath F:\SoftInstall\Android\sdk\platforms\android-23\android.jar;F:\SoftInstall\android\sdk\extras\android\support\v4\android-support-v4.jar;F:\SoftInstall\android\sdk\extras\android\support\v7\appcompat\libs\android-support-v7-appcompat.jar;..\..\build\intermediates\classes\debug com.lxl520.demo3.MainActivity 即可 注意：如果发现你的sdk文件夹下面没有sdk\extras\android\support\这个文件夹的时候一定要检查一下你的“android support library”是否安装， 推荐文章（由hexo文章推荐插件驱动）appcan利用天翼rtc实现视频通话功能使用MITAPPInventor2web客户端组件保存数据至云端如何使用MITAPPInventor2快速创建一个蓝牙串口app利用Fusion App实现Web2App功能]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>app</tag>
        <tag>ndk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstrom10激活方法（JetBrains系列软件激活）]]></title>
    <url>%2Fpost%2Fphp%2Fphpstrom10%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95%EF%BC%88JetBrains%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E6%BF%80%E6%B4%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[找到一个JetBrains系列软件的注册服务器 注册时选择“License server”输入“http://idea.lanyus.com/”点击“OK”快速激活JetBrains系列产品 也可以点击进入计算注册码 推荐文章（由hexo文章推荐插件驱动）office2016激活工具四川大学锐捷windows解除多网卡限制phpstrom9可用注册码一枚一键迁移typecho到hexo四川大学评教开源代码PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>破解</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpsocket连接，UDP]]></title>
    <url>%2Fpost%2Fphp%2Fphp-socket%E8%BF%9E%E6%8E%A5%EF%BC%8CUDP%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526&lt;meta charset="utf-8"&gt;&lt;?php//服务器信息$server = 'udp://192.168.253.1:9998';//消息结束符号$msg_eof = "\n";$socket = stream_socket_server($server, $errno, $errstr, STREAM_SERVER_BIND);if (!$socket) &#123; die("$errstr ($errno)");&#125;do &#123; //接收客户端发来的信息 $inMsg = stream_socket_recvfrom($socket, 1024, 0, $peer); //服务端打印出相关信息 echo "Client : $peer\n"; echo "Receive : &#123;$inMsg&#125;"; //给客户端发送信息 $outMsg = substr($inMsg, 0, (strrpos($inMsg, $msg_eof))).' -- '.date("D M j H:i:s Y\r\n"); stream_socket_sendto($socket, $outMsg, 0, $peer); &#125; while ($inMsg !== false);?&gt;推荐文章（由hexo文章推荐插件驱动）一键迁移typecho到hexo四川大学评教开源代码Composer上线前的优化CoreThink图片轮播插件【ImageSlider】Corethink瀑布流插件PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>socket</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appcan利用天翼rtc实现视频通话功能]]></title>
    <url>%2Fpost%2Fnotes%2Fappcan%E5%88%A9%E7%94%A8%E5%A4%A9%E7%BF%BCrtc%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[本代码是在示例代码的基础上进行了一些简化，并将其单独做了一个vedio.js文件，只需要两个按钮，即可完成接听和拨打的需求 attention： 默认将用户名设置成1234，拨打的帐号设置成4321，如果需要使用一个app实现的话，具体逻辑自行修改 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/** * 视频功能实现 * 使用天翼rtc插件实现 *//** * 初始化，在页面初始化方法中调用这个函数 * 定义天翼rtc回调函数 * 同一个页面中 appcan.ready可以存在多个，不会冲突;而uexOnload不行... */function rtcInit()&#123; uexESurfingRtc.onGlobalStatus = upgateGlobalStatus; //全局监控 uexESurfingRtc.cbLogStatus = upgateLogStatus; //登陆回调 uexESurfingRtc.cbCallStatus = updateCallStatus; //呼叫回调 //uexESurfingRtc.cbRemotePicPath = showRemotePicPath;//截屏回调 /*----------配置天翼rtc插件的appkey &amp; appid---------*/ appId = '70392'; appKey = //输入你自己的appKey; uexESurfingRtc.setAppKeyAndAppId(appKey, appId);&#125;;/** * 登陆回调，返回是否登陆成功 */function upgateLogStatus(opCode, dataType, data) &#123; //alert(data); if ("OK" == data.substring(0, 2)) &#123; var status = data.split("OK:")[1]; var showStr = ""; if ("LOGIN" == status) &#123; showStr = "登陆成功，点击退出"; $("#login").attr('name', 'logout'); &#125; else if ("LOGOUT" == status) &#123; showStr = "登陆"; $("#login").attr('name', 'login'); &#125; $("#login").text(showStr); &#125; else &#123; alert(data); &#125;&#125;function updateCallStatus(opCode, dataType, data)&#123; alert(data); if("OK" == data.substring(0,2)) &#123; var status = data.split("OK:")[1]; var showStr = ""; if("NORMAL" == status) &#123; showStr ="call"; &#125; else if("INCOMING" == status) &#123; showStr = "accept"; &#125; // else if("CALLING" == status) // &#123; // showStr = "Calling"; // &#125; $('#call').attr('name',showStr); $('#call').text(showStr); &#125; else &#123; alert(data); &#125;&#125;/** *监控中心回调 */function upgateGlobalStatus(opCode, dataType, data) &#123; $("#content").append(data);&#125;/** * 登陆方法的实现 * */function login() &#123; // alert(123); /*--设置登陆的配置，分别是本地窗口和对方视频窗口的大小----*/ jsonViewConfig = &#123; "localView": &#123; "x": "10", "y": "800", "w": "432", "h": "528" &#125;, "remoteView": &#123; "x": "440", "y": "800", "w": "432", "h": "528" &#125; &#125; /*---这里默认设置一个用户名用于调试，后期用户登录之后直接自动生成---*/ userName = "1234"; /*--uexESurfingRtc.login函数需要传入的参数是一个json字符串，所以需要调用JSON.stringify方法将json对象转换为字符串--*/ jsonDtr = JSON.stringify(jsonViewConfig); uexESurfingRtc.login(jsonDtr, userName);&#125;/** * 退出登录 * @return &#123;[type]&#125; [description] */function logout() &#123; uexESurfingRtc.logout();&#125;function call()&#123; uexESurfingRtc.call("3", "4321");&#125;function accept()&#123; uexESurfingRtc.acceptCall("3");&#125;/** *登陆按钮 *点击之后直接视频登陆 */appcan.button("#login", "ani-act", function() &#123; var btnName = $("#login").attr('name'); if (btnName == "login") &#123; $("#login").text("登陆中，请稍候..."); login(); &#125; else if (btnName = "logout") &#123; $("#login").text("退出中，请稍候..."); logout(); &#125;&#125;);/** * 呼叫按钮 */appcan.button("#call", "ani-act", function() &#123; var btnName = $("#call").attr('name'); if (btnName == "call") &#123; $("#call").text("呼叫中，请稍候..."); call(); &#125; else if (btnName = "accept") &#123; $("#call").text("接听中，请稍候..."); accept(); &#125;&#125;);推荐文章（由hexo文章推荐插件驱动）NDK开发中无法访问android.support.v7.app.AppCompatActivity解决办法使用MITAPPInventor2web客户端组件保存数据至云端如何使用MITAPPInventor2快速创建一个蓝牙串口app利用Fusion App实现Web2App功能]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>app</tag>
        <tag>appcan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中字符串相等的判断]]></title>
    <url>%2Fpost%2Fnotes%2Fjava%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89%E7%9A%84%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[今天需要写一个Java的小程序需要判断一下从控制台输入的字符串是否相等，在使用的过程中发现直接使用“==”来判断是没有办法判断出来的，Google&amp;百度了一下，找到一个解决办法 1. 用“==”运算符，该运算符表示指向字符串的引用是否相同比如说：123String a="abc";String b="abc";a==b;//将返回true。/*这是因为在java中字符串的值是不可改变的，相同的字符串在内存中只会存一份，所以a和b指向的是同一个对象*/ 再比如：123String a=new String("abc");String b=new String("abc");//那么a==b将返回false，因为a和b指向不同的对象。 用scanner类获取字符串来比较的时候：1234567Scanner input=new Scanner(System.in);//新建input对象，用于实现输入功能String a="exit";//定义一个字符串System.out.println("请输入您想输入的字符串：");String get=input.nextLine();//获取输入得的字符串的值if(get==a)&#123; System.out.println(a);&#125;//这个时候没有输出值 2. 用equals方法，该方法比较的是字符串的内容是否相同比如：123String a=new String("abc");String b=new String("abc");a.equals(b);//将返回true。 所以通常情况下，为了避免出现上述问题，判断字符串是否相等使用equals方法。 推荐文章（由hexo文章推荐插件驱动）java笔记1Spring-Boot启动类SpringApplication解析]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[office2016激活工具]]></title>
    <url>%2Fpost%2Fnotes%2Foffice2016%E6%BF%80%E6%B4%BB%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[可以用于激活 windows office2010/2013/2016 全系列版本 以管理员身份运行该软件即可30S 不到，你会发现你的 office 或者 windows 已经激活了，没有安装界面 软件下载 ps:本软件收集于网络，这里仅作分享，请下载之后 24 小时之内删除，并且不得用于商业用途推荐文章（由hexo文章推荐插件驱动）四川大学锐捷windows解除多网卡限制phpstrom10激活方法（JetBrains系列软件激活）phpstrom9可用注册码一枚WPS专业版序列号与激活]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>破解</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用MITAPPInventor2web客户端组件保存数据至云端]]></title>
    <url>%2Fpost%2Fnotes%2F%E4%BD%BF%E7%94%A8MIT-APP-Inventor2-web%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%84%E4%BB%B6%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E8%87%B3%E4%BA%91%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[接着前面的说，蓝牙接收到数据之后需要将数据处理分析然后保存下来，但是AI2并没有直接写代码来的方便快捷，并且我们的现在处于云计算的时代，数据无价，所以我们需要想办法将数据保存到云端。 数据保存到云端的方法： 使用自带的网络微数据库 使用web客户端调用写好的后端接口上传数据 由于自带的网络微数据库是Python写的，而且对于数据库的接口有着严格限制，所以这里我才用我自己用php+mysql写的一个api来进行上传 准备工作 先看看用到的组件：主要是web客户端 组件的代码块: 用于设置web客户端的网址 执行get请求 请求成功后返回操作 注意：这一个的话如果你设置了保存响应信息为ture就选择获得文件这个控制块，否则的话选择获得文字的控制块，我们使用获得文字的控制块 逻辑控制图我做的接口的返回值为json格式所以采用了json的解析，我暂时不需要判断返回值得内容【里面包含了上传是否成功之类的】，如果需要的话请参考有关json解析的相关内容 推荐参考手册 感谢@老巫婆翻译的参考手册，这里分享给大家：AI2中文参考手册 @老巫婆的json解析教程 AI2视频教程不得不吐槽这个教程的清晰度 推荐文章（由hexo文章推荐插件驱动）NDK开发中无法访问android.support.v7.app.AppCompatActivity解决办法appcan利用天翼rtc实现视频通话功能如何使用MITAPPInventor2快速创建一个蓝牙串口app利用Fusion App实现Web2App功能]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstrom9可用注册码一枚]]></title>
    <url>%2Fpost%2Fphp%2Fphpstrom9-%E5%8F%AF%E7%94%A8%E6%B3%A8%E5%86%8C%E7%A0%81%E4%B8%80%E6%9E%9A%2F</url>
    <content type="text"><![CDATA[phpstrom9 可用注册码一枚username EMBRACE key123456===== LICENSE BEGIN =====43136-1204201000002UsvSON704l&quot;dILe1PVx3y4&quot;B349AU6oSDJrsjE8nMOQh&quot;8HTDJHIUUhgd1BebYc5U&quot;6OxDbVsALB4Eb10PW8&quot;===== LICENSE END ===== 推荐文章（由hexo文章推荐插件驱动）office2016激活工具四川大学锐捷windows解除多网卡限制phpstrom10激活方法（JetBrains系列软件激活）一键迁移typecho到hexo四川大学评教开源代码PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>破解</tag>
        <tag>php</tag>
        <tag>注册码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php如何实现整除]]></title>
    <url>%2Fpost%2Fphp%2Fphp%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B4%E9%99%A4%2F</url>
    <content type="text"><![CDATA[php如何实现整除 以前在用C/C++的时候，整除就是’/‘，还要特别注意这个问题，今天用到php调试的时候出错了，最后发现：在php中’/‘除法是默认带有小数部分的，php自带有几个函数可以对小数进行处理 1. round()函数，四舍五入&lt;?php echo round(7/3); //2 ?&gt; 2. ceil()函数，进一法也就是取比该数大的最小整数 &lt;?php echo ceil(7/3); //3 ?&gt; 3. floor()函数，舍一法也就是取比该数小的最大整数 &lt;?php echo floor(7/3); //2?&gt; 推荐文章（由hexo文章推荐插件驱动）一键迁移typecho到hexo四川大学评教开源代码Composer上线前的优化CoreThink图片轮播插件【ImageSlider】Corethink瀑布流插件PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【福利】至善网媒体素材一键评价]]></title>
    <url>%2Fpost%2Fnotes%2F%E3%80%90%E7%A6%8F%E5%88%A9%E3%80%91%E8%87%B3%E5%96%84%E7%BD%91%E5%AA%92%E4%BD%93%E7%B4%A0%E6%9D%90%E4%B8%80%E9%94%AE%E8%AF%84%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[最近做至善网上面的题时候，发现媒体素材需要一个一个的评价实在是有点烦；所以开挂写了一个JS的小插件，直接一次性搞定 方法一：直接将下面这个链接拖入书签栏，然后在你需要一件评价媒体素材的地方点击就好ps:毛概测试成功，其他的请自测 至善网媒体素材一键评价 有什么问题直接在评论问就好 更新，附赠一个毛概的答案 毛概答案补充：中间有一个问号，那道题的答案是：一个中心，两个基本的注：这是毛概上的答案 推荐文章（由hexo文章推荐插件驱动）js编码解码URL如何批量改名的方法及教程]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreThink图片轮播插件【ImageSlider】]]></title>
    <url>%2Fpost%2Fphp%2FCoreThink%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD%E6%8F%92%E4%BB%B6%E3%80%90ImageSlider%E3%80%91%2F</url>
    <content type="text"><![CDATA[移植于OT插件，原文地址http://www.topthink.com/topic/6244.html 1、支持unslider\flexslider切换选择 2、支持推荐位选择 3、支持多图 4、切换时间&amp;方向选择 5、自定义容器宽度&amp;高度 *使用说明***1、请先将下面这段代码复制到Application\common\controller\addon.class.php /* 获取件所需的钩子是否存在，没有则新增 * @param string $str 钩子名称 * @param string $addons 插件名称 * @param string $addons 件简介 */ public function existHook($str, $addons, $msg=&apos;&apos;){ $hook_mod = M(&apos;addon_hook&apos;); $where[&apos;name&apos;] = $str; $gethook = $hook_mod-&gt;where($where)-&gt;find(); if(!$gethook || empty($gethook) || !is_array($gethook)){ $data[&apos;name&apos;] = $str; $data[&apos;description&apos;] = $msg; $data[&apos;type&apos;] = 1; $data[&apos;update_time&apos;] = NOW_TIME; $data[&apos;addons&apos;] = $addons; if( false !== $hook_mod-&gt;create($data) ){ $hook_mod-&gt;add(); } } } /** * delete钩子 * @param string $hook 钩子名称 */ public function deleteHook($hook){ $model = M(&apos;addon_hook&apos;); $condition = array( &apos;name&apos; =&gt; $hook, ); $model-&gt;where($condition)-&gt;delete(); } 2、调用方法 1&#123;:hook(&apos;ImageSlider&apos;)&#125; 3、如果出现显示不出图片，路径错误的情况 请改一下那个unslider\flexslider.html的图片路径，因为安装的路径不同可能出现意外 推荐文章（由hexo文章推荐插件驱动）一键迁移typecho到hexo四川大学评教开源代码Composer上线前的优化Corethink瀑布流插件nginx-php报502错误PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>corethink</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用MITAPPInventor2快速创建一个蓝牙串口app]]></title>
    <url>%2Fpost%2Fnotes%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MIT-APP-Inventor2-%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%93%9D%E7%89%99%E4%B8%B2%E5%8F%A3app%2F</url>
    <content type="text"><![CDATA[如何使用 MIT APP Inventor2 快速创建一个蓝牙串口 app 最近做学校的一个比赛，我是平时是学习做 web 后端的，有时候捎带一些前端的东西，但是最近这个比赛需要做一个 app，问题来了，没有学过 Java 没有学过 OC 所以 ios 和安卓都是无从下手，然后最后找了很多混合开发的工具，比如说 APPCAN，apicloud，hbuilder，wex5 等等，最后不是没有蓝牙串口的插件，就是没有办法使用.最终在一次搜索中无意的发现了这个 AI2. 前言 1. 使用 AI2 的前提条件： 不要求界面的美观性，需要实用性 不会原生代码的编程 2. 使用 AI2 好处： 不要求你会写代码，图形化编程，简单易用 提供了很多模块一般做一个常用的 app 完全没有问题 有中文版，所以说语言障碍也不存在了 3. 使用 AI2 的几种方式： 离线安装，离线调试 在线使用，AI 伴侣调试（模拟器调试）个人推荐第二种，在线使用，AI 伴侣调试 4. AI2 的中文网址： 最新的中文服务器：http://app.gzjkw.net/ 中文教程网站：http://www.17coding.net/ 教程 PS:仅仅是自己的一些经验观点，有什么错误大家交流啊 1. 点击进入 http://app.gzjkw.net/， 注册帐号之后，进入以下页面 2. 选择上面的帮助下载AI 伴侣apk，之后用于在线调试 或者直接点击 AI 伴侣 下载 3. 简单的功能介绍 其中我们需要用到的几个组件： 名称 作用 蓝牙客户端 1 用于接收蓝牙串口设备的消息 按钮 一般的 button 水平布局 用于布局整个界面 对话框 用于发出提示消息 activity 控制器 用于打开蓝牙 web 客户端 用于链接网络相关的东西（这个下一次用到） 计时器 用于定时接收蓝牙串口发送出来的消息 具体的常用组件的介绍，请大家点击网站查看http://www.17coding.net/ 4. 逻辑设置 首先完成界面的一个界面的布局工作 组件的逻辑设置【点击右上角的逻辑设计即可】 其中将 activity 启动器 1 的 action 值设置为android.bluetooth.adapter.action.REQUEST_ENABLE ，这样可以达到开启蓝牙的效果 下一篇讲如何将数据保存到服务器（不使用自带的网络数据库的情况下）推荐文章（由hexo文章推荐插件驱动）NDK开发中无法访问android.support.v7.app.AppCompatActivity解决办法appcan利用天翼rtc实现视频通话功能使用MITAPPInventor2web客户端组件保存数据至云端利用Fusion App实现Web2App功能]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Corethink瀑布流插件]]></title>
    <url>%2Fpost%2Fphp%2FCorethink%E7%80%91%E5%B8%83%E6%B5%81%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[【原创插件】瀑布流1、前台界面 2、前台大图预览 3、后台设置支持容器宽度自定义，高度随宽度按比例改变 4、后台管理界面作者，内容为选填项，其余为必填项 5、新增界面 ***使用说明**1、前台调用 钩子{:hook(&apos;WaterFall&apos;)} 2、安装说明 如果默认表前缀不是ct_，请在插件目录下WaterFallAddon.class.php中的ct_改为你的表前缀 -&gt;where(&apos;ct_addon_waterfall.status=1&apos;) 3、安装说明2如果不能安装是不存在钩子原因，解决办法请看我上一个OT移植插件ImageSlider中的使用方法 ImageSlider ps： 感谢三生石上的前端瀑布流教程 推荐文章（由hexo文章推荐插件驱动）一键迁移typecho到hexo四川大学评教开源代码Composer上线前的优化CoreThink图片轮播插件【ImageSlider】nginx-php报502错误PHP函数setcookie写入重名cookie]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>corethink</tag>
        <tag>插件</tag>
      </tags>
  </entry>
</search>
